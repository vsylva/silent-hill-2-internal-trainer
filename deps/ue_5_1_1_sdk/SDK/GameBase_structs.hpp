#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameBase

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "LevelStreaming_structs.hpp"


namespace SDK
{

// Enum GameBase.EAudioProfile
// NumValues: 0x0005
enum class EAudioProfile : uint8
{
	NighMode                                 = 0,
	Speakers                                 = 1,
	TVSpeakers                               = 2,
	Headset                                  = 3,
	EAudioProfile_MAX                        = 4,
};

// Enum GameBase.EAudioProfileOption
// NumValues: 0x0004
enum class EAudioProfileOption : uint8
{
	Speakers                                 = 0,
	TVSpeakers                               = 1,
	Headset                                  = 2,
	EAudioProfileOption_MAX                  = 3,
};

// Enum GameBase.EGameBaseInputDevice
// NumValues: 0x0003
enum class EGameBaseInputDevice : uint8
{
	MouseOrKeyboard                          = 0,
	Gamepad                                  = 1,
	EGameBaseInputDevice_MAX                 = 2,
};

// Enum GameBase.EStateWidgetFlags
// NumValues: 0x0006
enum class EStateWidgetFlags : uint8
{
	DoNotShowOnStateChange                   = 0,
	DoNotHideOnStateChange                   = 1,
	DoNotDeleteAfterHide                     = 2,
	AutoRemoveFromViewPort                   = 3,
	EventCatcher                             = 4,
	EStateWidgetFlags_MAX                    = 5,
};

// Enum GameBase.GFXQuality
// NumValues: 0x0007
enum class EGFXQuality : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Epic                                     = 3,
	Advanced                                 = 4,
	MAX                                      = 5,
	Autodetect                               = 5,
};

// Enum GameBase.SpecialGFXQuality
// NumValues: 0x0003
enum class ESpecialGFXQuality : uint8
{
	Quality                                  = 0,
	Performance                              = 1,
	SpecialGFXQuality_MAX                    = 2,
};

// Enum GameBase.EFpsCap
// NumValues: 0x0004
enum class EFpsCap : uint8
{
	Unlimited                                = 0,
	Fps30                                    = 1,
	Fps60                                    = 2,
	EFpsCap_MAX                              = 3,
};

// Enum GameBase.EAntiAliasing
// NumValues: 0x0005
enum class EAntiAliasing : uint8
{
	None                                     = 0,
	FXAA                                     = 1,
	TXAA                                     = 2,
	DLSS                                     = 3,
	EAntiAliasing_MAX                        = 4,
};

// Enum GameBase.ERaytracing
// NumValues: 0x0004
enum class ERaytracing : uint8
{
	Off                                      = 0,
	On                                       = 1,
	ForceOn                                  = 2,
	ERaytracing_MAX                          = 3,
};

// Enum GameBase.EDynamicResolution
// NumValues: 0x0004
enum class EDynamicResolution : uint8
{
	Off                                      = 0,
	LockOn30                                 = 1,
	LockOn60                                 = 2,
	EDynamicResolution_MAX                   = 3,
};

// Enum GameBase.EFrameGeneration
// NumValues: 0x0003
enum class EFrameGeneration : uint8
{
	Off                                      = 0,
	On                                       = 1,
	EFrameGeneration_MAX                     = 2,
};

// Enum GameBase.ESuperResolution
// NumValues: 0x0007
enum class ESuperResolution : uint8
{
	None                                     = 0,
	DLSS                                     = 1,
	FSR1                                     = 2,
	FSR3                                     = 3,
	TSR                                      = 4,
	XeSS                                     = 5,
	ESuperResolution_MAX                     = 6,
};

// Enum GameBase.EScreenWideMode
// NumValues: 0x0005
enum class EScreenWideMode : uint8
{
	Undefined                                = 255,
	Normal                                   = 0,
	UltraWide                                = 1,
	SuperUltraWide                           = 2,
	EScreenWideMode_MAX                      = 256,
};

// Enum GameBase.EPanini
// NumValues: 0x0004
enum class EPanini : uint8
{
	Off                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	EPanini_MAX                              = 3,
};

// Enum GameBase.EScreenMode
// NumValues: 0x0004
enum class EScreenMode : uint8
{
	Fullscreen                               = 0,
	Borderless                               = 1,
	Windowed                                 = 2,
	EScreenMode_MAX                          = 3,
};

// Enum GameBase.EGsaOptionConditionAction
// NumValues: 0x0008
enum class EGsaOptionConditionAction : uint8
{
	Enable                                   = 0,
	Disable                                  = 1,
	Visible                                  = 2,
	Hidden                                   = 3,
	Active                                   = 4,
	Inative                                  = 5,
	Custom                                   = 6,
	EGsaOptionConditionAction_MAX            = 7,
};

// Enum GameBase.EGsaOptionFlags
// NumValues: 0x0008
enum class EGsaOptionFlags : uint8
{
	PCOnly                                   = 0,
	ConsoleOnly                              = 1,
	CustomType                               = 2,
	NonEditable                              = 3,
	Advanced                                 = 4,
	PostApply                                = 5,
	Preset                                   = 6,
	EGsaOptionFlags_MAX                      = 7,
};

// Enum GameBase.ESubtitleBackground
// NumValues: 0x0004
enum class ESubtitleBackground : uint8
{
	None                                     = 0,
	Transparent                              = 1,
	Solid                                    = 2,
	ESubtitleBackground_MAX                  = 3,
};

// Enum GameBase.ETextSize
// NumValues: 0x0006
enum class ETextSize : uint8
{
	Tiny                                     = 0,
	Small                                    = 1,
	Medium                                   = 2,
	Big                                      = 3,
	Huge                                     = 4,
	ETextSize_MAX                            = 5,
};

// Enum GameBase.ESubtitleColor
// NumValues: 0x0004
enum class ESubtitleColor : uint8
{
	Off                                      = 0,
	On                                       = 1,
	ColorOnlyNames                           = 2,
	ESubtitleColor_MAX                       = 3,
};

// Enum GameBase.ETextFont
// NumValues: 0x0004
enum class ETextFont : uint8
{
	Default                                  = 0,
	Bold                                     = 1,
	Dyslexic                                 = 2,
	ETextFont_MAX                            = 3,
};

// Enum GameBase.ETooltipsVisibilityEffects
// NumValues: 0x0003
enum class ETooltipsVisibilityEffects : uint8
{
	None                                     = 0,
	Fadingout                                = 1,
	ETooltipsVisibilityEffects_MAX           = 2,
};

// Enum GameBase.EForceFeedback
// NumValues: 0x0005
enum class EForceFeedback : uint8
{
	Off                                      = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	EForceFeedback_MAX                       = 4,
};

// Enum GameBase.EControllerIcons
// NumValues: 0x0004
enum class EControllerIcons : uint8
{
	Microsoft                                = 0,
	Sony                                     = 1,
	Nintendo                                 = 2,
	EControllerIcons_MAX                     = 3,
};

// Enum GameBase.EStartGamePanelPlatform
// NumValues: 0x0006
enum class EStartGamePanelPlatform : uint8
{
	All                                      = 0,
	PcOnly                                   = 1,
	ConsoleOnly                              = 2,
	Ps5Only                                  = 3,
	XboxOnly                                 = 4,
	EStartGamePanelPlatform_MAX              = 5,
};

// ScriptStruct GameBase.GsaOptionCondition
// 0x0010 (0x0010 - 0x0000)
struct FGsaOptionCondition final
{
public:
	class FName                                   Property;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGsaOptionConditionAction                     Action;                                            // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGsaOptionCondition) == 0x000004, "Wrong alignment on FGsaOptionCondition");
static_assert(sizeof(FGsaOptionCondition) == 0x000010, "Wrong size on FGsaOptionCondition");
static_assert(offsetof(FGsaOptionCondition, Property) == 0x000000, "Member 'FGsaOptionCondition::Property' has a wrong offset!");
static_assert(offsetof(FGsaOptionCondition, Value) == 0x000008, "Member 'FGsaOptionCondition::Value' has a wrong offset!");
static_assert(offsetof(FGsaOptionCondition, Action) == 0x00000C, "Member 'FGsaOptionCondition::Action' has a wrong offset!");

// ScriptStruct GameBase.GsaNamedOption
// 0x0058 (0x0058 - 0x0000)
struct FGsaNamedOption final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Default;                                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValueMin;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValueMax;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSteps;                                          // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Values;                                            // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 QualityValues;                                     // 0x0030(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGsaOptionCondition                    Condition;                                         // 0x0040(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Flags;                                             // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGsaNamedOption) == 0x000008, "Wrong alignment on FGsaNamedOption");
static_assert(sizeof(FGsaNamedOption) == 0x000058, "Wrong size on FGsaNamedOption");
static_assert(offsetof(FGsaNamedOption, Name) == 0x000000, "Member 'FGsaNamedOption::Name' has a wrong offset!");
static_assert(offsetof(FGsaNamedOption, Default) == 0x000010, "Member 'FGsaNamedOption::Default' has a wrong offset!");
static_assert(offsetof(FGsaNamedOption, ValueMin) == 0x000014, "Member 'FGsaNamedOption::ValueMin' has a wrong offset!");
static_assert(offsetof(FGsaNamedOption, ValueMax) == 0x000018, "Member 'FGsaNamedOption::ValueMax' has a wrong offset!");
static_assert(offsetof(FGsaNamedOption, NumSteps) == 0x00001C, "Member 'FGsaNamedOption::NumSteps' has a wrong offset!");
static_assert(offsetof(FGsaNamedOption, Values) == 0x000020, "Member 'FGsaNamedOption::Values' has a wrong offset!");
static_assert(offsetof(FGsaNamedOption, QualityValues) == 0x000030, "Member 'FGsaNamedOption::QualityValues' has a wrong offset!");
static_assert(offsetof(FGsaNamedOption, Condition) == 0x000040, "Member 'FGsaNamedOption::Condition' has a wrong offset!");
static_assert(offsetof(FGsaNamedOption, Flags) == 0x000050, "Member 'FGsaNamedOption::Flags' has a wrong offset!");

// ScriptStruct GameBase.SaveSlotInfo
// 0x0038 (0x0038 - 0x0000)
struct FSaveSlotInfo
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UserIndex;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ProfileName;                                       // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              DateTime;                                          // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ScreenShot;                                        // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              PlayTime;                                          // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsEmpty : 1;                                       // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IsAuto : 1;                                        // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IsLastPlayedGame : 1;                              // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IsDisabled : 1;                                    // 0x0030(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IsVisible : 1;                                     // 0x0030(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveSlotInfo) == 0x000008, "Wrong alignment on FSaveSlotInfo");
static_assert(sizeof(FSaveSlotInfo) == 0x000038, "Wrong size on FSaveSlotInfo");
static_assert(offsetof(FSaveSlotInfo, SlotIndex) == 0x000000, "Member 'FSaveSlotInfo::SlotIndex' has a wrong offset!");
static_assert(offsetof(FSaveSlotInfo, UserIndex) == 0x000004, "Member 'FSaveSlotInfo::UserIndex' has a wrong offset!");
static_assert(offsetof(FSaveSlotInfo, ProfileName) == 0x000008, "Member 'FSaveSlotInfo::ProfileName' has a wrong offset!");
static_assert(offsetof(FSaveSlotInfo, DateTime) == 0x000018, "Member 'FSaveSlotInfo::DateTime' has a wrong offset!");
static_assert(offsetof(FSaveSlotInfo, ScreenShot) == 0x000020, "Member 'FSaveSlotInfo::ScreenShot' has a wrong offset!");
static_assert(offsetof(FSaveSlotInfo, PlayTime) == 0x000028, "Member 'FSaveSlotInfo::PlayTime' has a wrong offset!");

// ScriptStruct GameBase.AudioSettingsManager
// 0x0001 (0x0001 - 0x0000)
struct FAudioSettingsManager final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAudioSettingsManager) == 0x000001, "Wrong alignment on FAudioSettingsManager");
static_assert(sizeof(FAudioSettingsManager) == 0x000001, "Wrong size on FAudioSettingsManager");

// ScriptStruct GameBase.BinaryBlob
// 0x0010 (0x0010 - 0x0000)
struct FBinaryBlob final
{
public:
	TArray<uint8>                                 Data;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBinaryBlob) == 0x000008, "Wrong alignment on FBinaryBlob");
static_assert(sizeof(FBinaryBlob) == 0x000010, "Wrong size on FBinaryBlob");
static_assert(offsetof(FBinaryBlob, Data) == 0x000000, "Member 'FBinaryBlob::Data' has a wrong offset!");

// ScriptStruct GameBase.StateWidget
// 0x0040 (0x0040 - 0x0000)
struct FStateWidget final
{
public:
	TSoftClassPtr<class UClass>                   WidgetClass;                                       // 0x0000(0x0030)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            Widget;                                            // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateWidget) == 0x000008, "Wrong alignment on FStateWidget");
static_assert(sizeof(FStateWidget) == 0x000040, "Wrong size on FStateWidget");
static_assert(offsetof(FStateWidget, WidgetClass) == 0x000000, "Member 'FStateWidget::WidgetClass' has a wrong offset!");
static_assert(offsetof(FStateWidget, Widget) == 0x000038, "Member 'FStateWidget::Widget' has a wrong offset!");

// ScriptStruct GameBase.GenericSpawnPointData
// 0x0110 (0x0110 - 0x0000)
struct FGenericSpawnPointData final
{
public:
	struct FGuid                                  Guid;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStreamableLevelHandle                 PersistentLevel;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FStreamableLevel                       Level;                                             // 0x0018(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Position;                                          // 0x0090(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLevelStreamingRequestHandle>   InitialStreamingRequests;                          // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FDataLayerStatus>               InitialDataLayerRequests;                          // 0x0100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGenericSpawnPointData) == 0x000010, "Wrong alignment on FGenericSpawnPointData");
static_assert(sizeof(FGenericSpawnPointData) == 0x000110, "Wrong size on FGenericSpawnPointData");
static_assert(offsetof(FGenericSpawnPointData, Guid) == 0x000000, "Member 'FGenericSpawnPointData::Guid' has a wrong offset!");
static_assert(offsetof(FGenericSpawnPointData, PersistentLevel) == 0x000010, "Member 'FGenericSpawnPointData::PersistentLevel' has a wrong offset!");
static_assert(offsetof(FGenericSpawnPointData, Level) == 0x000018, "Member 'FGenericSpawnPointData::Level' has a wrong offset!");
static_assert(offsetof(FGenericSpawnPointData, Position) == 0x000090, "Member 'FGenericSpawnPointData::Position' has a wrong offset!");
static_assert(offsetof(FGenericSpawnPointData, InitialStreamingRequests) == 0x0000F0, "Member 'FGenericSpawnPointData::InitialStreamingRequests' has a wrong offset!");
static_assert(offsetof(FGenericSpawnPointData, InitialDataLayerRequests) == 0x000100, "Member 'FGenericSpawnPointData::InitialDataLayerRequests' has a wrong offset!");

// ScriptStruct GameBase.GFXSettings
// 0x0090 (0x0090 - 0x0000)
struct FGFXSettings final
{
public:
	TMap<class FName, int32>                      GsaOptions;                                        // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	float                                         GammaValue;                                        // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VSync;                                             // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScreenMode                                   ScreenMode;                                        // 0x0055(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MonitorIndex;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              Resolution;                                        // 0x005C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HDR;                                               // 0x0064(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HDRMinLuminance;                                   // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HDRMidLuminance;                                   // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HDRMaxLuminance;                                   // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HDRBrightness;                                     // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HDRUIBrightness;                                   // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HDRUIContrast;                                     // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGFXQuality                                   Quality;                                           // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AdvQualityIsCustom;                                // 0x0081(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpecialGFXQuality                            SpecialQuality;                                    // 0x0082(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFpsCap                                       FpsCap;                                            // 0x0083(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERaytracing                                   Raytracing;                                        // 0x0084(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicResolution                            DynRes;                                            // 0x0085(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFrameGeneration                              FrameGen;                                          // 0x0086(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPanini                                       Panini;                                            // 0x0087(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IngameMotionBlur;                                  // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFXSettings) == 0x000008, "Wrong alignment on FGFXSettings");
static_assert(sizeof(FGFXSettings) == 0x000090, "Wrong size on FGFXSettings");
static_assert(offsetof(FGFXSettings, GsaOptions) == 0x000000, "Member 'FGFXSettings::GsaOptions' has a wrong offset!");
static_assert(offsetof(FGFXSettings, GammaValue) == 0x000050, "Member 'FGFXSettings::GammaValue' has a wrong offset!");
static_assert(offsetof(FGFXSettings, VSync) == 0x000054, "Member 'FGFXSettings::VSync' has a wrong offset!");
static_assert(offsetof(FGFXSettings, ScreenMode) == 0x000055, "Member 'FGFXSettings::ScreenMode' has a wrong offset!");
static_assert(offsetof(FGFXSettings, MonitorIndex) == 0x000058, "Member 'FGFXSettings::MonitorIndex' has a wrong offset!");
static_assert(offsetof(FGFXSettings, Resolution) == 0x00005C, "Member 'FGFXSettings::Resolution' has a wrong offset!");
static_assert(offsetof(FGFXSettings, HDR) == 0x000064, "Member 'FGFXSettings::HDR' has a wrong offset!");
static_assert(offsetof(FGFXSettings, HDRMinLuminance) == 0x000068, "Member 'FGFXSettings::HDRMinLuminance' has a wrong offset!");
static_assert(offsetof(FGFXSettings, HDRMidLuminance) == 0x00006C, "Member 'FGFXSettings::HDRMidLuminance' has a wrong offset!");
static_assert(offsetof(FGFXSettings, HDRMaxLuminance) == 0x000070, "Member 'FGFXSettings::HDRMaxLuminance' has a wrong offset!");
static_assert(offsetof(FGFXSettings, HDRBrightness) == 0x000074, "Member 'FGFXSettings::HDRBrightness' has a wrong offset!");
static_assert(offsetof(FGFXSettings, HDRUIBrightness) == 0x000078, "Member 'FGFXSettings::HDRUIBrightness' has a wrong offset!");
static_assert(offsetof(FGFXSettings, HDRUIContrast) == 0x00007C, "Member 'FGFXSettings::HDRUIContrast' has a wrong offset!");
static_assert(offsetof(FGFXSettings, Quality) == 0x000080, "Member 'FGFXSettings::Quality' has a wrong offset!");
static_assert(offsetof(FGFXSettings, AdvQualityIsCustom) == 0x000081, "Member 'FGFXSettings::AdvQualityIsCustom' has a wrong offset!");
static_assert(offsetof(FGFXSettings, SpecialQuality) == 0x000082, "Member 'FGFXSettings::SpecialQuality' has a wrong offset!");
static_assert(offsetof(FGFXSettings, FpsCap) == 0x000083, "Member 'FGFXSettings::FpsCap' has a wrong offset!");
static_assert(offsetof(FGFXSettings, Raytracing) == 0x000084, "Member 'FGFXSettings::Raytracing' has a wrong offset!");
static_assert(offsetof(FGFXSettings, DynRes) == 0x000085, "Member 'FGFXSettings::DynRes' has a wrong offset!");
static_assert(offsetof(FGFXSettings, FrameGen) == 0x000086, "Member 'FGFXSettings::FrameGen' has a wrong offset!");
static_assert(offsetof(FGFXSettings, Panini) == 0x000087, "Member 'FGFXSettings::Panini' has a wrong offset!");
static_assert(offsetof(FGFXSettings, IngameMotionBlur) == 0x000088, "Member 'FGFXSettings::IngameMotionBlur' has a wrong offset!");

// ScriptStruct GameBase.VolumeData
// 0x0008 (0x0008 - 0x0000)
struct FVolumeData final
{
public:
	float                                         Volume;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMuted;                                           // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVolumeData) == 0x000004, "Wrong alignment on FVolumeData");
static_assert(sizeof(FVolumeData) == 0x000008, "Wrong size on FVolumeData");
static_assert(offsetof(FVolumeData, Volume) == 0x000000, "Member 'FVolumeData::Volume' has a wrong offset!");
static_assert(offsetof(FVolumeData, IsMuted) == 0x000004, "Member 'FVolumeData::IsMuted' has a wrong offset!");

// ScriptStruct GameBase.SaveData
// 0x0010 (0x0010 - 0x0000)
struct FSaveData
{
public:
	bool                                          HasData;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              PlayTime;                                          // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSaveData) == 0x000008, "Wrong alignment on FSaveData");
static_assert(sizeof(FSaveData) == 0x000010, "Wrong size on FSaveData");
static_assert(offsetof(FSaveData, HasData) == 0x000000, "Member 'FSaveData::HasData' has a wrong offset!");
static_assert(offsetof(FSaveData, PlayTime) == 0x000008, "Member 'FSaveData::PlayTime' has a wrong offset!");

// ScriptStruct GameBase.LevelStatus
// 0x0070 (0x0070 - 0x0000)
struct FLevelStatus final
{
public:
	struct FStreamableLevelHandle                 Handle;                                            // 0x0000(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	EStreamableLevelStatus                        Status;                                            // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelStatus) == 0x000010, "Wrong alignment on FLevelStatus");
static_assert(sizeof(FLevelStatus) == 0x000070, "Wrong size on FLevelStatus");
static_assert(offsetof(FLevelStatus, Handle) == 0x000000, "Member 'FLevelStatus::Handle' has a wrong offset!");
static_assert(offsetof(FLevelStatus, Status) == 0x000008, "Member 'FLevelStatus::Status' has a wrong offset!");
static_assert(offsetof(FLevelStatus, Transform) == 0x000010, "Member 'FLevelStatus::Transform' has a wrong offset!");

// ScriptStruct GameBase.SaveDataStreaming
// 0x00D0 (0x00D0 - 0x0000)
struct FSaveDataStreaming final
{
public:
	bool                                          HasPlayerLocation;                                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PlayerLocation;                                    // 0x0010(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  SpawnpointGuid;                                    // 0x0070(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLevelStreamingSaveData                LevelStreaming;                                    // 0x0080(0x0038)(NativeAccessSpecifierPublic)
	TArray<struct FLevelStatus>                   TargetLevelsStates;                                // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FStreamableLevelHandle                 PersistentLevelHandle;                             // 0x00C8(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSaveDataStreaming) == 0x000010, "Wrong alignment on FSaveDataStreaming");
static_assert(sizeof(FSaveDataStreaming) == 0x0000D0, "Wrong size on FSaveDataStreaming");
static_assert(offsetof(FSaveDataStreaming, HasPlayerLocation) == 0x000000, "Member 'FSaveDataStreaming::HasPlayerLocation' has a wrong offset!");
static_assert(offsetof(FSaveDataStreaming, PlayerLocation) == 0x000010, "Member 'FSaveDataStreaming::PlayerLocation' has a wrong offset!");
static_assert(offsetof(FSaveDataStreaming, SpawnpointGuid) == 0x000070, "Member 'FSaveDataStreaming::SpawnpointGuid' has a wrong offset!");
static_assert(offsetof(FSaveDataStreaming, LevelStreaming) == 0x000080, "Member 'FSaveDataStreaming::LevelStreaming' has a wrong offset!");
static_assert(offsetof(FSaveDataStreaming, TargetLevelsStates) == 0x0000B8, "Member 'FSaveDataStreaming::TargetLevelsStates' has a wrong offset!");
static_assert(offsetof(FSaveDataStreaming, PersistentLevelHandle) == 0x0000C8, "Member 'FSaveDataStreaming::PersistentLevelHandle' has a wrong offset!");

// ScriptStruct GameBase.ScreenResolutionRHIBP
// 0x000C (0x000C - 0x0000)
struct FScreenResolutionRHIBP final
{
public:
	int32                                         Width;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RefreshRate;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenResolutionRHIBP) == 0x000004, "Wrong alignment on FScreenResolutionRHIBP");
static_assert(sizeof(FScreenResolutionRHIBP) == 0x00000C, "Wrong size on FScreenResolutionRHIBP");
static_assert(offsetof(FScreenResolutionRHIBP, Width) == 0x000000, "Member 'FScreenResolutionRHIBP::Width' has a wrong offset!");
static_assert(offsetof(FScreenResolutionRHIBP, Height) == 0x000004, "Member 'FScreenResolutionRHIBP::Height' has a wrong offset!");
static_assert(offsetof(FScreenResolutionRHIBP, RefreshRate) == 0x000008, "Member 'FScreenResolutionRHIBP::RefreshRate' has a wrong offset!");

// ScriptStruct GameBase.SpecialEvent
// 0x0020 (0x0020 - 0x0000)
struct FSpecialEvent final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              FromDate;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ToDate;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UTCDate;                                           // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreYear;                                        // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecialEvent) == 0x000008, "Wrong alignment on FSpecialEvent");
static_assert(sizeof(FSpecialEvent) == 0x000020, "Wrong size on FSpecialEvent");
static_assert(offsetof(FSpecialEvent, Name) == 0x000000, "Member 'FSpecialEvent::Name' has a wrong offset!");
static_assert(offsetof(FSpecialEvent, FromDate) == 0x000008, "Member 'FSpecialEvent::FromDate' has a wrong offset!");
static_assert(offsetof(FSpecialEvent, ToDate) == 0x000010, "Member 'FSpecialEvent::ToDate' has a wrong offset!");
static_assert(offsetof(FSpecialEvent, UTCDate) == 0x000018, "Member 'FSpecialEvent::UTCDate' has a wrong offset!");
static_assert(offsetof(FSpecialEvent, IgnoreYear) == 0x000019, "Member 'FSpecialEvent::IgnoreYear' has a wrong offset!");

}

