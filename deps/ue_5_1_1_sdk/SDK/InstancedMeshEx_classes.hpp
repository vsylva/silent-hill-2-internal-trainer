#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: InstancedMeshEx

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "InstancedMeshEx_structs.hpp"
#include "ProceduralMeshComponent_classes.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Class InstancedMeshEx.AnimatedProceduralMeshActor
// 0x0008 (0x02B8 - 0x02B0)
class AAnimatedProceduralMeshActor final : public AActor
{
public:
	class UAnimatedProceduralMeshComponent*       AnimatedProceduralMesh;                            // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ImportMeshes();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimatedProceduralMeshActor">();
	}
	static class AAnimatedProceduralMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAnimatedProceduralMeshActor>();
	}
};
static_assert(alignof(AAnimatedProceduralMeshActor) == 0x000008, "Wrong alignment on AAnimatedProceduralMeshActor");
static_assert(sizeof(AAnimatedProceduralMeshActor) == 0x0002B8, "Wrong size on AAnimatedProceduralMeshActor");
static_assert(offsetof(AAnimatedProceduralMeshActor, AnimatedProceduralMesh) == 0x0002B0, "Member 'AAnimatedProceduralMeshActor::AnimatedProceduralMesh' has a wrong offset!");

// Class InstancedMeshEx.PaintableStaticMeshActor
// 0x0000 (0x02C0 - 0x02C0)
class APaintableStaticMeshActor final : public AStaticMeshActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaintableStaticMeshActor">();
	}
	static class APaintableStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APaintableStaticMeshActor>();
	}
};
static_assert(alignof(APaintableStaticMeshActor) == 0x000008, "Wrong alignment on APaintableStaticMeshActor");
static_assert(sizeof(APaintableStaticMeshActor) == 0x0002C0, "Wrong size on APaintableStaticMeshActor");

// Class InstancedMeshEx.AnimatedProceduralMeshComponent
// 0x0040 (0x0640 - 0x0600)
class UAnimatedProceduralMeshComponent final : public UProceduralMeshComponent
{
public:
	uint8                                         Pad_5F8[0x8];                                      // 0x05F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAnimProcMeshSectionsIDs>       SectionsAndFrames;                                 // 0x0600(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     MaterialOverride;                                  // 0x0610(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    Shapes;                                            // 0x0618(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          AutoFrame;                                         // 0x0628(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_629[0x3];                                      // 0x0629(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoFrameFPS;                                      // 0x062C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationFrame;                                    // 0x0630(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_634[0xC];                                      // 0x0634(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* GetDynamicMaterial();
	void ImportMeshes();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimatedProceduralMeshComponent">();
	}
	static class UAnimatedProceduralMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimatedProceduralMeshComponent>();
	}
};
static_assert(alignof(UAnimatedProceduralMeshComponent) == 0x000010, "Wrong alignment on UAnimatedProceduralMeshComponent");
static_assert(sizeof(UAnimatedProceduralMeshComponent) == 0x000640, "Wrong size on UAnimatedProceduralMeshComponent");
static_assert(offsetof(UAnimatedProceduralMeshComponent, SectionsAndFrames) == 0x000600, "Member 'UAnimatedProceduralMeshComponent::SectionsAndFrames' has a wrong offset!");
static_assert(offsetof(UAnimatedProceduralMeshComponent, MaterialOverride) == 0x000610, "Member 'UAnimatedProceduralMeshComponent::MaterialOverride' has a wrong offset!");
static_assert(offsetof(UAnimatedProceduralMeshComponent, Shapes) == 0x000618, "Member 'UAnimatedProceduralMeshComponent::Shapes' has a wrong offset!");
static_assert(offsetof(UAnimatedProceduralMeshComponent, AutoFrame) == 0x000628, "Member 'UAnimatedProceduralMeshComponent::AutoFrame' has a wrong offset!");
static_assert(offsetof(UAnimatedProceduralMeshComponent, AutoFrameFPS) == 0x00062C, "Member 'UAnimatedProceduralMeshComponent::AutoFrameFPS' has a wrong offset!");
static_assert(offsetof(UAnimatedProceduralMeshComponent, AnimationFrame) == 0x000630, "Member 'UAnimatedProceduralMeshComponent::AnimationFrame' has a wrong offset!");

// Class InstancedMeshEx.InstancedMeshExActor
// 0x0010 (0x02C0 - 0x02B0)
class AInstancedMeshExActor final : public AActor
{
public:
	class UInstancedMeshExComponent*              InstancedMeshExComponent;                          // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ReloadMeshes;                                      // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InstancedMeshExActor">();
	}
	static class AInstancedMeshExActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInstancedMeshExActor>();
	}
};
static_assert(alignof(AInstancedMeshExActor) == 0x000008, "Wrong alignment on AInstancedMeshExActor");
static_assert(sizeof(AInstancedMeshExActor) == 0x0002C0, "Wrong size on AInstancedMeshExActor");
static_assert(offsetof(AInstancedMeshExActor, InstancedMeshExComponent) == 0x0002B0, "Member 'AInstancedMeshExActor::InstancedMeshExComponent' has a wrong offset!");
static_assert(offsetof(AInstancedMeshExActor, ReloadMeshes) == 0x0002B8, "Member 'AInstancedMeshExActor::ReloadMeshes' has a wrong offset!");

// Class InstancedMeshEx.PaintableStaticMeshComponent
// 0x0030 (0x0630 - 0x0600)
class UPaintableStaticMeshComponent final : public UStaticMeshComponent
{
public:
	uint8                                         Pad_5F8[0x24];                                     // 0x05F8(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 ClearColor;                                        // 0x061C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClearAtBeginPlay;                                  // 0x0620(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_621[0xF];                                      // 0x0621(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearPainting(const struct FColor& PaintColor, float AlphaMultiplier);
	void PaintSphere(const struct FVector& SphereCenter, float SphereRadius, const struct FColor& PaintColor, float AlphaMultiplier, float FalloffExponent, bool AdditivePainting);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaintableStaticMeshComponent">();
	}
	static class UPaintableStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaintableStaticMeshComponent>();
	}
};
static_assert(alignof(UPaintableStaticMeshComponent) == 0x000010, "Wrong alignment on UPaintableStaticMeshComponent");
static_assert(sizeof(UPaintableStaticMeshComponent) == 0x000630, "Wrong size on UPaintableStaticMeshComponent");
static_assert(offsetof(UPaintableStaticMeshComponent, ClearColor) == 0x00061C, "Member 'UPaintableStaticMeshComponent::ClearColor' has a wrong offset!");
static_assert(offsetof(UPaintableStaticMeshComponent, ClearAtBeginPlay) == 0x000620, "Member 'UPaintableStaticMeshComponent::ClearAtBeginPlay' has a wrong offset!");

// Class InstancedMeshEx.InstancedMeshExComponent
// 0x0020 (0x0620 - 0x0600)
class UInstancedMeshExComponent final : public UProceduralMeshComponent
{
public:
	uint8                                         Pad_5F8[0x8];                                      // 0x05F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     MaterialOverride;                                  // 0x0600(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Shape;                                             // 0x0608(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfInstances;                                 // 0x0610(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_614[0xC];                                      // 0x0614(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* GetDynamicMaterial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InstancedMeshExComponent">();
	}
	static class UInstancedMeshExComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInstancedMeshExComponent>();
	}
};
static_assert(alignof(UInstancedMeshExComponent) == 0x000010, "Wrong alignment on UInstancedMeshExComponent");
static_assert(sizeof(UInstancedMeshExComponent) == 0x000620, "Wrong size on UInstancedMeshExComponent");
static_assert(offsetof(UInstancedMeshExComponent, MaterialOverride) == 0x000600, "Member 'UInstancedMeshExComponent::MaterialOverride' has a wrong offset!");
static_assert(offsetof(UInstancedMeshExComponent, Shape) == 0x000608, "Member 'UInstancedMeshExComponent::Shape' has a wrong offset!");
static_assert(offsetof(UInstancedMeshExComponent, NumberOfInstances) == 0x000610, "Member 'UInstancedMeshExComponent::NumberOfInstances' has a wrong offset!");

// Class InstancedMeshEx.SkeletalMeshExActor
// 0x0008 (0x02B8 - 0x02B0)
class ASkeletalMeshExActor final : public AActor
{
public:
	class USkeletalMeshExComponent*               SkeletalMeshExComponent;                           // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletalMeshExActor">();
	}
	static class ASkeletalMeshExActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASkeletalMeshExActor>();
	}
};
static_assert(alignof(ASkeletalMeshExActor) == 0x000008, "Wrong alignment on ASkeletalMeshExActor");
static_assert(sizeof(ASkeletalMeshExActor) == 0x0002B8, "Wrong size on ASkeletalMeshExActor");
static_assert(offsetof(ASkeletalMeshExActor, SkeletalMeshExComponent) == 0x0002B0, "Member 'ASkeletalMeshExActor::SkeletalMeshExComponent' has a wrong offset!");

// Class InstancedMeshEx.SkeletalMeshExComponent
// 0x0010 (0x0FA0 - 0x0F90)
class USkeletalMeshExComponent final : public USkeletalMeshComponent
{
public:
	TArray<struct FPerMaterialInfo>               ShellsCounts;                                      // 0x0F90(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletalMeshExComponent">();
	}
	static class USkeletalMeshExComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkeletalMeshExComponent>();
	}
};
static_assert(alignof(USkeletalMeshExComponent) == 0x000010, "Wrong alignment on USkeletalMeshExComponent");
static_assert(sizeof(USkeletalMeshExComponent) == 0x000FA0, "Wrong size on USkeletalMeshExComponent");
static_assert(offsetof(USkeletalMeshExComponent, ShellsCounts) == 0x000F90, "Member 'USkeletalMeshExComponent::ShellsCounts' has a wrong offset!");

// Class InstancedMeshEx.StaticMeshActorWithNaniteFallbackShadows
// 0x0000 (0x02C0 - 0x02C0)
class AStaticMeshActorWithNaniteFallbackShadows final : public AStaticMeshActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMeshActorWithNaniteFallbackShadows">();
	}
	static class AStaticMeshActorWithNaniteFallbackShadows* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticMeshActorWithNaniteFallbackShadows>();
	}
};
static_assert(alignof(AStaticMeshActorWithNaniteFallbackShadows) == 0x000008, "Wrong alignment on AStaticMeshActorWithNaniteFallbackShadows");
static_assert(sizeof(AStaticMeshActorWithNaniteFallbackShadows) == 0x0002C0, "Wrong size on AStaticMeshActorWithNaniteFallbackShadows");

// Class InstancedMeshEx.StaticMeshComponentNaniteFallbackShadows
// 0x0000 (0x0600 - 0x0600)
class UStaticMeshComponentNaniteFallbackShadows final : public UStaticMeshComponent
{
public:
	class UStaticMeshComponentWithNaniteFallbackShadows* ProxyParent;                                       // 0x05F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMeshComponentNaniteFallbackShadows">();
	}
	static class UStaticMeshComponentNaniteFallbackShadows* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaticMeshComponentNaniteFallbackShadows>();
	}
};
static_assert(alignof(UStaticMeshComponentNaniteFallbackShadows) == 0x000010, "Wrong alignment on UStaticMeshComponentNaniteFallbackShadows");
static_assert(sizeof(UStaticMeshComponentNaniteFallbackShadows) == 0x000600, "Wrong size on UStaticMeshComponentNaniteFallbackShadows");
static_assert(offsetof(UStaticMeshComponentNaniteFallbackShadows, ProxyParent) == 0x0005F8, "Member 'UStaticMeshComponentNaniteFallbackShadows::ProxyParent' has a wrong offset!");

// Class InstancedMeshEx.StaticMeshComponentWithNaniteFallbackShadows
// 0x0000 (0x0600 - 0x0600)
class UStaticMeshComponentWithNaniteFallbackShadows final : public UStaticMeshComponent
{
public:
	class UStaticMeshComponentNaniteFallbackShadows* Fallback;                                          // 0x05F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMeshComponentWithNaniteFallbackShadows">();
	}
	static class UStaticMeshComponentWithNaniteFallbackShadows* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaticMeshComponentWithNaniteFallbackShadows>();
	}
};
static_assert(alignof(UStaticMeshComponentWithNaniteFallbackShadows) == 0x000010, "Wrong alignment on UStaticMeshComponentWithNaniteFallbackShadows");
static_assert(sizeof(UStaticMeshComponentWithNaniteFallbackShadows) == 0x000600, "Wrong size on UStaticMeshComponentWithNaniteFallbackShadows");
static_assert(offsetof(UStaticMeshComponentWithNaniteFallbackShadows, Fallback) == 0x0005F8, "Member 'UStaticMeshComponentWithNaniteFallbackShadows::Fallback' has a wrong offset!");

}

