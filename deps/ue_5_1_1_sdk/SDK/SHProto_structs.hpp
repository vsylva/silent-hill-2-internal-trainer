#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SHProto

#include "Basic.hpp"

#include "InputRebinding_structs.hpp"
#include "Mai_structs.hpp"
#include "Engine_structs.hpp"
#include "UCSW_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Detection_structs.hpp"
#include "GameBase_structs.hpp"
#include "InputCore_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Commons_structs.hpp"
#include "Dialog_structs.hpp"
#include "LevelStreaming_structs.hpp"
#include "SlateCore_structs.hpp"


namespace SDK
{

// Enum SHProto.ESHSecondaryTargetType
// NumValues: 0x0004
enum class ESHSecondaryTargetType : uint8
{
	Undefined                                = 0,
	Glass                                    = 1,
	Wall                                     = 2,
	ESHSecondaryTargetType_MAX               = 3,
};

// Enum SHProto.ESHAnimEndType
// NumValues: 0x0005
enum class ESHAnimEndType : uint8
{
	Undefined                                = 0,
	Error                                    = 1,
	Success                                  = 2,
	Stop                                     = 3,
	ESHAnimEndType_MAX                       = 4,
};

// Enum SHProto.ESHFocusableInputActionTypeEnum
// NumValues: 0x000D
enum class ESHFocusableInputActionTypeEnum : uint8
{
	Invalid                                  = 0,
	NavigateUp                               = 1,
	NavigateDown                             = 2,
	NavigateRight                            = 3,
	NavigateLeft                             = 4,
	NavigateLeftAnalogVertical               = 5,
	NavigateLeftAnalogHorizontal             = 6,
	PickUpPlace                              = 7,
	Transcription                            = 8,
	Rotate                                   = 9,
	ToggleMiniInv                            = 10,
	Quit                                     = 11,
	ESHFocusableInputActionTypeEnum_MAX      = 12,
};

// Enum SHProto.ESHDetectionSide
// NumValues: 0x0003
enum class ESHDetectionSide : uint8
{
	Above                                    = 0,
	Below                                    = 1,
	ESHDetectionSide_MAX                     = 2,
};

// Enum SHProto.ESHCombatInputModeEnum
// NumValues: 0x0016
enum class ESHCombatInputModeEnum : uint8
{
	None                                     = 0,
	AnyAllowOverride                         = 1,
	EquipWeapon                              = 2,
	UnequipWeapon                            = 3,
	ChangeWeapon                             = 4,
	ReceiveDamage                            = 5,
	ReceiveDamageAllowOverride               = 6,
	ReceiveSoftDamage                        = 7,
	ReceiveContinuousDamage                  = 8,
	ReceiveStunDamage                        = 9,
	MeleeAttack                              = 10,
	MeleeAttackComboReady                    = 11,
	RangedAim                                = 12,
	RangedFire                               = 13,
	RangedReload                             = 14,
	Dodge                                    = 15,
	SynchedAction                            = 16,
	Struggle                                 = 17,
	FallToFloorTransition                    = 18,
	UseItem                                  = 19,
	QuickTurn                                = 20,
	ESHCombatInputModeEnum_MAX               = 21,
};

// Enum SHProto.ESHCombatPoseType
// NumValues: 0x0006
enum class ESHCombatPoseType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Injured                                  = 2,
	InDanger                                 = 5,
	InWater                                  = 6,
	ESHCombatPoseType_MAX                    = 7,
};

// Enum SHProto.ESHHealthStateEnum
// NumValues: 0x0006
enum class ESHHealthStateEnum : uint8
{
	Default                                  = 0,
	LowInjury                                = 1,
	HeavyInjury                              = 2,
	Criticalnjury                            = 3,
	Death                                    = 4,
	ESHHealthStateEnum_MAX                   = 5,
};

// Enum SHProto.ESHMaterialPropertyControlType
// NumValues: 0x0007
enum class ESHMaterialPropertyControlType : uint8
{
	ScalarValueDriven                        = 0,
	ScalarCurveDriven                        = 1,
	VectorValueDriven                        = 2,
	VectorCurveDriven                        = 3,
	TextureValueDriven                       = 4,
	TextureCurveDriven                       = 5,
	ESHMaterialPropertyControlType_MAX       = 6,
};

// Enum SHProto.ESHInteriorExteriorStateEnum
// NumValues: 0x0003
enum class ESHInteriorExteriorStateEnum : uint8
{
	Exterior                                 = 0,
	Interior                                 = 1,
	ESHInteriorExteriorStateEnum_MAX         = 2,
};

// Enum SHProto.ESHDoorStateEnum
// NumValues: 0x0005
enum class ESHDoorStateEnum : uint8
{
	Undefined                                = 0,
	Close                                    = 1,
	Middle                                   = 2,
	Open                                     = 3,
	ESHDoorStateEnum_MAX                     = 4,
};

// Enum SHProto.ESHItemTypeEnum
// NumValues: 0x000D
enum class ESHItemTypeEnum : uint8
{
	None                                     = 0,
	Other                                    = 1,
	MeleeWeapon                              = 2,
	RangedWeapon                             = 3,
	Ammunition                               = 4,
	MiscEquipment                            = 5,
	KeyObject                                = 6,
	Consumable                               = 7,
	Map                                      = 8,
	Memo                                     = 9,
	Personal                                 = 10,
	Reflection                               = 11,
	ESHItemTypeEnum_MAX                      = 12,
};

// Enum SHProto.ESHNavigationLoopOption
// NumValues: 0x0005
enum class ESHNavigationLoopOption : uint8
{
	NoLoop                                   = 0,
	LoopBothAxis                             = 1,
	LoopOnlyHorizontal                       = 2,
	LoopOnlyVertical                         = 3,
	ESHNavigationLoopOption_MAX              = 4,
};

// Enum SHProto.ESHFocusableTypeEnum
// NumValues: 0x0004
enum class ESHFocusableTypeEnum : uint8
{
	None                                     = 0,
	Input                                    = 1,
	SingleItem                               = 2,
	ESHFocusableTypeEnum_MAX                 = 3,
};

// Enum SHProto.EGameOverCause
// NumValues: 0x0003
enum class EGameOverCause : uint8
{
	CharacterDeath                           = 0,
	MariaDeath                               = 1,
	EGameOverCause_MAX                       = 2,
};

// Enum SHProto.ESHInteractionGenericBehaviour
// NumValues: 0x0003
enum class ESHInteractionGenericBehaviour : uint8
{
	Clickable                                = 0,
	Holdable                                 = 1,
	ESHInteractionGenericBehaviour_MAX       = 2,
};

// Enum SHProto.ESHInteractionInputAxis
// NumValues: 0x0004
enum class ESHInteractionInputAxis : uint8
{
	Horizontal                               = 0,
	Vertical                                 = 1,
	Both                                     = 2,
	ESHInteractionInputAxis_MAX              = 3,
};

// Enum SHProto.ESHTraversalType
// NumValues: 0x0006
enum class ESHTraversalType : uint8
{
	Undefined                                = 0,
	Crawl                                    = 1,
	Squeeze                                  = 2,
	Vault                                    = 3,
	Climb                                    = 4,
	ESHTraversalType_MAX                     = 5,
};

// Enum SHProto.ESHTraversalObstacleExtendedStage
// NumValues: 0x0006
enum class ESHTraversalObstacleExtendedStage : uint8
{
	None                                     = 0,
	Start                                    = 1,
	Fail                                     = 2,
	Success                                  = 3,
	End                                      = 4,
	ESHTraversalObstacleExtendedStage_MAX    = 5,
};

// Enum SHProto.ESHAnalyticsGameplayEventType
// NumValues: 0x0008
enum class ESHAnalyticsGameplayEventType : uint8
{
	Undefined                                = 0,
	GameFlow                                 = 1,
	ItemCollected                            = 2,
	RangedFire                               = 3,
	MeleeAttack                              = 4,
	PlayerReceivedDamage                     = 5,
	AICharacterDied                          = 6,
	ESHAnalyticsGameplayEventType_MAX        = 7,
};

// Enum SHProto.EMergeSamplesAction
// NumValues: 0x0004
enum class EMergeSamplesAction : uint8
{
	Average                                  = 0,
	TakeMin                                  = 1,
	TakeMax                                  = 2,
	EMergeSamplesAction_MAX                  = 3,
};

// Enum SHProto.EGameOptions
// NumValues: 0x0008
enum class EGameOptions : uint8
{
	None                                     = 0,
	NewGameMode                              = 1,
	CombatDifficulty                         = 2,
	PuzzlesDifficulty                        = 3,
	GameplayPreset                           = 4,
	PlayerSkin                               = 5,
	VisualMode                               = 6,
	EGameOptions_MAX                         = 7,
};

// Enum SHProto.ESHAudioCubatureEnum
// NumValues: 0x0006
enum class ESHAudioCubatureEnum : uint8
{
	Indoor_Small                             = 0,
	Indoor_Medium                            = 1,
	Indoor_Large                             = 2,
	Outdoor                                  = 3,
	NotSet                                   = 4,
	ESHAudioCubatureEnum_MAX                 = 5,
};

// Enum SHProto.ESHAudioWorldEnum
// NumValues: 0x0004
enum class ESHAudioWorldEnum : uint8
{
	World_FW                                 = 0,
	World_OW                                 = 1,
	NotSet                                   = 2,
	ESHAudioWorldEnum_MAX                    = 3,
};

// Enum SHProto.ESHAnimNotifyEnableBonePhysicsForceApplicationTarget
// NumValues: 0x0006
enum class ESHAnimNotifyEnableBonePhysicsForceApplicationTarget : uint8
{
	SpecifiedBone                            = 0,
	SpecifiedBoneAndAllChildren              = 1,
	SpecifiedBoneAndDirectChildren           = 2,
	OnlyAllChildren                          = 3,
	OnlyDirectChildren                       = 4,
	ESHAnimNotifyEnableBonePhysicsForceApplicationTarget_MAX = 5,
};

// Enum SHProto.ESHModifyCombatInputModeAction
// NumValues: 0x0008
enum class ESHModifyCombatInputModeAction : uint8
{
	None                                     = 0,
	MeleeAttack                              = 1,
	Dodge                                    = 2,
	RangedAim                                = 3,
	UseHealItem                              = 4,
	RangedReload                             = 5,
	ChangeWeapon                             = 6,
	ESHModifyCombatInputModeAction_MAX       = 7,
};

// Enum SHProto.ESHModifyCombatInputModeOperation
// NumValues: 0x0004
enum class ESHModifyCombatInputModeOperation : uint8
{
	None                                     = 0,
	Block                                    = 1,
	Unblock                                  = 2,
	ESHModifyCombatInputModeOperation_MAX    = 3,
};

// Enum SHProto.ECollisionShapePropertyType
// NumValues: 0x0005
enum class ECollisionShapePropertyType : uint8
{
	Line                                     = 0,
	Box                                      = 1,
	Sphere                                   = 2,
	Capsule                                  = 3,
	ECollisionShapePropertyType_MAX          = 4,
};

// Enum SHProto.EPhysicalAnimationProfile
// NumValues: 0x000E
enum class EPhysicalAnimationProfile : uint8
{
	Invalid                                  = 0,
	Disabled                                 = 1,
	Default                                  = 2,
	Death                                    = 3,
	TakeHit                                  = 4,
	LostBalance                              = 5,
	ReturnFromHit                            = 6,
	Walk                                     = 7,
	PistolAim                                = 8,
	GunRecoil                                = 9,
	Melee1HAim                               = 10,
	Melee1HAttack                            = 11,
	MeleeHitSth                              = 12,
	EPhysicalAnimationProfile_MAX            = 13,
};

// Enum SHProto.ESHDetectionPlaneType
// NumValues: 0x0004
enum class ESHDetectionPlaneType : uint8
{
	Up                                       = 0,
	Right                                    = 1,
	Forward                                  = 2,
	ESHDetectionPlaneType_MAX                = 3,
};

// Enum SHProto.ESHAbstractDaddyAnimInstanceStandingLocomotionState
// NumValues: 0x0005
enum class ESHAbstractDaddyAnimInstanceStandingLocomotionState : uint8
{
	Idle                                     = 0,
	IdleRotation                             = 1,
	MovementStrafing                         = 2,
	MovementCharging                         = 3,
	ESHAbstractDaddyAnimInstanceStandingLocomotionState_MAX = 4,
};

// Enum SHProto.ESHAbstractDaddyAnimInstanceLocomotionState
// NumValues: 0x0005
enum class ESHAbstractDaddyAnimInstanceLocomotionState : uint8
{
	Idle                                     = 0,
	IdleRotation                             = 1,
	Movement                                 = 2,
	MovementRotation                         = 3,
	ESHAbstractDaddyAnimInstanceLocomotionState_MAX = 4,
};

// Enum SHProto.ESHAIBehaviors
// NumValues: 0x000D
enum class ESHAIBehaviors : uint8
{
	Unknown                                  = 0,
	Default                                  = 1,
	WalksOnGraph                             = 2,
	KeepsClose                               = 3,
	GoesTo                                   = 4,
	Leads                                    = 5,
	Interested                               = 6,
	Waits                                    = 7,
	InDanger                                 = 8,
	InCombat                                 = 9,
	PassiveAction                            = 10,
	CustomBehaviour                          = 11,
	ESHAIBehaviors_MAX                       = 12,
};

// Enum SHProto.ESHAnimActionExeStatus
// NumValues: 0x0005
enum class ESHAnimActionExeStatus : uint8
{
	Invalid                                  = 0,
	Initialized                              = 1,
	Pending                                  = 2,
	Finished                                 = 3,
	ESHAnimActionExeStatus_MAX               = 4,
};

// Enum SHProto.EItemInvestigationType
// NumValues: 0x0005
enum class EItemInvestigationType : uint8
{
	InputRotation                            = 0,
	InputWithFlip                            = 1,
	NoInputIdle                              = 2,
	NoInputFlipOnly                          = 3,
	EItemInvestigationType_MAX               = 4,
};

// Enum SHProto.EItemInteractionType
// NumValues: 0x0004
enum class EItemInteractionType : uint8
{
	None                                     = 0,
	Investigation                            = 1,
	TakeItem                                 = 2,
	EItemInteractionType_MAX                 = 3,
};

// Enum SHProto.EKnockDownState
// NumValues: 0x0006
enum class EKnockDownState : uint8
{
	NotKnockDown                             = 0,
	FallingDown                              = 1,
	LayingDown                               = 2,
	GettingUp                                = 3,
	StandAfterKnockDown                      = 4,
	EKnockDownState_MAX                      = 5,
};

// Enum SHProto.ESHObstaclesDetectType
// NumValues: 0x0007
enum class ESHObstaclesDetectType : uint8
{
	None                                     = 0,
	AllBlock                                 = 1,
	CenterOnlyBlock                          = 2,
	SidesOnlyBlock                           = 3,
	LeftOnlyBlock                            = 4,
	RightOnlyBlock                           = 5,
	ESHObstaclesDetectType_MAX               = 6,
};

// Enum SHProto.ESHAspectAwareFrameType
// NumValues: 0x0004
enum class ESHAspectAwareFrameType : uint8
{
	Full                                     = 0,
	Half                                     = 1,
	Quater                                   = 2,
	ESHAspectAwareFrameType_MAX              = 3,
};

// Enum SHProto.ESHBonePhysicsControllerSettingsBodyPhysicsPermission
// NumValues: 0x0008
enum class ESHBonePhysicsControllerSettingsBodyPhysicsPermission : uint32
{
	Allow                                    = 0,
	DontInheritSelf                          = 1,
	DontInheritSelfAndChildren               = 2,
	AllowSelfOnlyWithRoot                    = 3,
	AllowSelfAndChildrenOnlyWithRoot         = 4,
	NeverAllowSelf                           = 5,
	NeverAllowSelfOrChildren                 = 6,
	ESHBonePhysicsControllerSettingsBodyPhysicsPermission_MAX = 7,
};

// Enum SHProto.ESHBoolEndingFactorValues
// NumValues: 0x0004
enum class ESHBoolEndingFactorValues : uint8
{
	Undefined                                = 0,
	SetTrue                                  = 1,
	SetFalse                                 = 2,
	ESHBoolEndingFactorValues_MAX            = 3,
};

// Enum SHProto.ESHCameraProfile
// NumValues: 0x0007
enum class ESHCameraProfile : uint8
{
	Invalid                                  = 0,
	Exterior                                 = 1,
	Interior                                 = 2,
	MaxCollision                             = 3,
	ExteriorSprint                           = 4,
	InteriorSprint                           = 5,
	ESHCameraProfile_MAX                     = 6,
};

// Enum SHProto.EMovementLegOnGround
// NumValues: 0x0005
enum class EMovementLegOnGround : uint8
{
	LeftOnGround                             = 0,
	LeftClosing                              = 1,
	RightClosing                             = 2,
	RightOnGround                            = 3,
	EMovementLegOnGround_MAX                 = 4,
};

// Enum SHProto.EMovementDirection
// NumValues: 0x0006
enum class EMovementDirection : uint8
{
	Forward                                  = 0,
	Back                                     = 1,
	Left                                     = 2,
	Right                                    = 3,
	Zero                                     = 4,
	EMovementDirection_MAX                   = 5,
};

// Enum SHProto.EHipsDirection
// NumValues: 0x0007
enum class EHipsDirection : uint8
{
	Forward                                  = 0,
	ForwardLeft                              = 1,
	ForwardRight                             = 2,
	Back                                     = 3,
	BackLeft                                 = 4,
	BackRight                                = 5,
	EHipsDirection_MAX                       = 6,
};

// Enum SHProto.ESHAudioDangerStateEnum
// NumValues: 0x0005
enum class ESHAudioDangerStateEnum : uint8
{
	NotSet                                   = 0,
	Calm                                     = 1,
	Danger                                   = 2,
	Combat                                   = 3,
	ESHAudioDangerStateEnum_MAX              = 4,
};

// Enum SHProto.ESHCreeperAnimInstanceLocomotionState
// NumValues: 0x0004
enum class ESHCreeperAnimInstanceLocomotionState : uint8
{
	Idle                                     = 0,
	IdleRotation                             = 1,
	Movement                                 = 2,
	ESHCreeperAnimInstanceLocomotionState_MAX = 3,
};

// Enum SHProto.ESHDoorUnlockModeEnum
// NumValues: 0x0004
enum class ESHDoorUnlockModeEnum : uint8
{
	None                                     = 0,
	ItemUnlock                               = 1,
	InteractToggle                           = 2,
	ESHDoorUnlockModeEnum_MAX                = 3,
};

// Enum SHProto.ESHCustomStencilDynamicObject
// NumValues: 0x000A
enum class ESHCustomStencilDynamicObject : uint8
{
	None                                     = 0,
	MiscMoveable                             = 1,
	SingleDoor                               = 2,
	DoubleDoor_LeftWing                      = 3,
	DoubleDoor_RightWing                     = 4,
	Pushable                                 = 5,
	RTVAGD                                   = 6,
	Savepoint                                = 7,
	InvestigatedMapItem                      = 8,
	ESHCustomStencilDynamicObject_MAX        = 9,
};

// Enum SHProto.ESHEddieAnimInstanceMovementState
// NumValues: 0x0003
enum class ESHEddieAnimInstanceMovementState : uint8
{
	Walking                                  = 0,
	Limping                                  = 1,
	ESHEddieAnimInstanceMovementState_MAX    = 2,
};

// Enum SHProto.ESHEddieWalkingAnimInstanceLocomotionState
// NumValues: 0x0004
enum class ESHEddieWalkingAnimInstanceLocomotionState : uint8
{
	Idle                                     = 0,
	IdleRotation                             = 1,
	MovementStrafing                         = 2,
	ESHEddieWalkingAnimInstanceLocomotionState_MAX = 3,
};

// Enum SHProto.ESHEddieLimpingAnimInstanceLocomotionState
// NumValues: 0x0005
enum class ESHEddieLimpingAnimInstanceLocomotionState : uint8
{
	Idle                                     = 0,
	IdleRotation                             = 1,
	Movement                                 = 2,
	MovementRotation                         = 3,
	ESHEddieLimpingAnimInstanceLocomotionState_MAX = 4,
};

// Enum SHProto.ESHEddieFaceExpression
// NumValues: 0x000A
enum class ESHEddieFaceExpression : uint8
{
	Exhale                                   = 0,
	Frustrated                               = 1,
	Hurt                                     = 2,
	Scared                                   = 3,
	Scream                                   = 4,
	Smile_Sneer                              = 5,
	Smirk                                    = 6,
	Angry                                    = 7,
	Normal                                   = 8,
	ESHEddieFaceExpression_MAX               = 9,
};

// Enum SHProto.ESHEndingType
// NumValues: 0x000A
enum class ESHEndingType : uint8
{
	Invalid                                  = 0,
	Leave                                    = 1,
	InWater                                  = 2,
	Maria                                    = 3,
	TrueLeave                                = 11,
	TrueInWater                              = 12,
	Rebirth                                  = 13,
	DogEnding                                = 14,
	UFOEnding                                = 15,
	ESHEndingType_MAX                        = 16,
};

// Enum SHProto.ESHEndingFactorType
// NumValues: 0x0019
enum class ESHEndingFactorType : uint8
{
	Invalid                                  = 0,
	WoodsideCoinPuzzle                       = 1,
	CityOWNeelysBarMessage                   = 2,
	MaryItemsInvestigation                   = 3,
	AngelasKnifeInvestigation                = 4,
	PrisonGallowPuzzle                       = 5,
	HotelOWMirrorPuzzle                      = 6,
	HotelFWPyramidHeadBossAftermath          = 7,
	HotelFWListenedSickbedConversation       = 8,
	WestCityFWInteractedAllAtHeavensNight    = 9,
	WestCityFWMariaRedirectionsComments      = 10,
	WestCityFWMariaInteractions              = 11,
	HospitalFWLyingMariaInteractions         = 12,
	LabyrinthMariaRooms                      = 13,
	PyramidHeadBossFightOutcome              = 14,
	HotelFWKilledAllDefenselessEnemies       = 15,
	PlaythroughKilledEnemies                 = 16,
	PlaythroughStompedDeadEnemies            = 17,
	PlaythroughMariaReceivedDamage           = 18,
	PlaythroughHealingExcess                 = 19,
	PlaythroughBadHealth                     = 20,
	AlreadySeenEndings                       = 21,
	UFOEnding                                = 100,
	BlissEnding                              = 101,
	ESHEndingFactorType_MAX                  = 102,
};

// Enum SHProto.ESHHitReactionSelectionHitResponseType
// NumValues: 0x0007
enum class ESHHitReactionSelectionHitResponseType : uint8
{
	Unknown                                  = 0,
	Twitch                                   = 1,
	Normal                                   = 2,
	Stagger                                  = 3,
	Falter                                   = 4,
	Knockdown                                = 5,
	MAX                                      = 6,
};

// Enum SHProto.ESHExtraSettingsType
// NumValues: 0x0003
enum class ESHExtraSettingsType : uint8
{
	None                                     = 0,
	Controls                                 = 1,
	ESHExtraSettingsType_MAX                 = 2,
};

// Enum SHProto.ESHFleshLipAnimInstanceTransformationState
// NumValues: 0x0005
enum class ESHFleshLipAnimInstanceTransformationState : uint8
{
	Flying                                   = 0,
	Hanging                                  = 1,
	Fallen                                   = 2,
	Standing                                 = 3,
	ESHFleshLipAnimInstanceTransformationState_MAX = 4,
};

// Enum SHProto.ESHFleshLipFlyingAnimInstanceLocomotionState
// NumValues: 0x0004
enum class ESHFleshLipFlyingAnimInstanceLocomotionState : uint8
{
	Idle                                     = 0,
	IdleRotation                             = 1,
	MovementStrafing                         = 2,
	ESHFleshLipFlyingAnimInstanceLocomotionState_MAX = 3,
};

// Enum SHProto.ESHFleshLipHangingAnimInstanceLocomotionState
// NumValues: 0x0003
enum class ESHFleshLipHangingAnimInstanceLocomotionState : uint8
{
	Idle                                     = 0,
	IdleRotation                             = 1,
	ESHFleshLipHangingAnimInstanceLocomotionState_MAX = 2,
};

// Enum SHProto.ESHFleshLipFallenAnimInstanceLocomotionState
// NumValues: 0x0003
enum class ESHFleshLipFallenAnimInstanceLocomotionState : uint8
{
	Idle                                     = 0,
	IdleRotation                             = 1,
	ESHFleshLipFallenAnimInstanceLocomotionState_MAX = 2,
};

// Enum SHProto.ESHFleshLipStandingAnimInstanceLocomotionState
// NumValues: 0x0005
enum class ESHFleshLipStandingAnimInstanceLocomotionState : uint8
{
	Idle                                     = 0,
	IdleRotation                             = 1,
	MovementStrafing                         = 2,
	MovementChargeStrafing                   = 3,
	ESHFleshLipStandingAnimInstanceLocomotionState_MAX = 4,
};

// Enum SHProto.ESHFleshLipTransformationState
// NumValues: 0x0005
enum class ESHFleshLipTransformationState : uint8
{
	Flying                                   = 0,
	Hanging                                  = 1,
	Fallen                                   = 2,
	Standing                                 = 3,
	ESHFleshLipTransformationState_MAX       = 4,
};

// Enum SHProto.ESHFlickerGroupState
// NumValues: 0x0004
enum class ESHFlickerGroupState : uint8
{
	Enabled                                  = 0,
	Mixed                                    = 1,
	Disabled                                 = 2,
	ESHFlickerGroupState_MAX                 = 3,
};

// Enum SHProto.ESHFloatOperationType
// NumValues: 0x0008
enum class ESHFloatOperationType : uint8
{
	Undefined                                = 0,
	Equals                                   = 1,
	NotEquals                                = 2,
	Lower                                    = 3,
	LowerOrEquals                            = 4,
	Greater                                  = 5,
	GreaterOrEquals                          = 6,
	ESHFloatOperationType_MAX                = 7,
};

// Enum SHProto.ESHFriendAnimInstanceLocomotionState
// NumValues: 0x0004
enum class ESHFriendAnimInstanceLocomotionState : uint8
{
	Idle                                     = 0,
	IdleRotation                             = 1,
	Movement                                 = 2,
	ESHFriendAnimInstanceLocomotionState_MAX = 3,
};

// Enum SHProto.ESHFXDirtState
// NumValues: 0x0006
enum class ESHFXDirtState : uint8
{
	Clean                                    = 0,
	Dirty                                    = 1,
	Dirtiest                                 = 2,
	DirtyArm                                 = 3,
	GooeyHand                                = 4,
	ESHFXDirtState_MAX                       = 5,
};

// Enum SHProto.ESHQueuedSpawnRequestPriority
// NumValues: 0x0007
enum class ESHQueuedSpawnRequestPriority : uint8
{
	None                                     = 0,
	Low                                      = 50,
	Medium                                   = 100,
	High                                     = 150,
	VeryHigh                                 = 200,
	Must                                     = 250,
	ESHQueuedSpawnRequestPriority_MAX        = 251,
};

// Enum SHProto.ESHControllerLightColorGameplayFeature
// NumValues: 0x0002
enum class ESHControllerLightColorGameplayFeature : uint8
{
	Health                                   = 0,
	ESHControllerLightColorGameplayFeature_MAX = 1,
};

// Enum SHProto.ESHSimpleDirectionType
// NumValues: 0x0006
enum class ESHSimpleDirectionType : uint8
{
	Undefined                                = 0,
	Front                                    = 1,
	Right                                    = 2,
	Left                                     = 3,
	Back                                     = 4,
	ESHSimpleDirectionType_MAX               = 5,
};

// Enum SHProto.ESHGameplayInputModeEnum
// NumValues: 0x0006
enum class ESHGameplayInputModeEnum : uint8
{
	Default                                  = 0,
	Disabled                                 = 1,
	Combat                                   = 2,
	AnimAction                               = 3,
	GameMenu                                 = 4,
	ESHGameplayInputModeEnum_MAX             = 5,
};

// Enum SHProto.ESHGameplayItemNotificationType
// NumValues: 0x0004
enum class ESHGameplayItemNotificationType : uint8
{
	Consumed                                 = 0,
	Collected                                = 1,
	Custom                                   = 2,
	ESHGameplayItemNotificationType_MAX      = 3,
};

// Enum SHProto.ESHMapObjectTypeEnum
// NumValues: 0x000D
enum class ESHMapObjectTypeEnum : uint8
{
	None                                     = 0,
	Objective                                = 1,
	Puzzle                                   = 2,
	Door                                     = 3,
	DoorAttachment                           = 4,
	Collectable                              = 5,
	Obstacle                                 = 6,
	Ladder                                   = 7,
	SavePoint                                = 8,
	Pushable                                 = 9,
	TextHint                                 = 10,
	HintSign                                 = 11,
	ESHMapObjectTypeEnum_MAX                 = 12,
};

// Enum SHProto.ESHGameplayMapDoorMode
// NumValues: 0x0003
enum class ESHGameplayMapDoorMode : uint8
{
	NeverLocked                              = 0,
	WasLocked                                = 1,
	ESHGameplayMapDoorMode_MAX               = 2,
};

// Enum SHProto.ESHGameplayMenuSectionEnum
// NumValues: 0x0004
enum class ESHGameplayMenuSectionEnum : uint8
{
	None                                     = 0,
	Inventory                                = 1,
	Combine                                  = 2,
	ESHGameplayMenuSectionEnum_MAX           = 3,
};

// Enum SHProto.ESHGameplayTutorialEnum
// NumValues: 0x001F
enum class ESHGameplayTutorialEnum : uint8
{
	Invalid                                  = 0,
	CombatMelee                              = 10,
	HealQuick                                = 11,
	HealHold                                 = 12,
	CombatRanged                             = 13,
	RangedReload                             = 14,
	SwitchWeaponPistol                       = 15,
	SwitchWeaponShotgun                      = 16,
	SwitchWeaponRifle                        = 17,
	StruggleWithMashInput                    = 18,
	StruggleWithHoldInput                    = 20,
	Interaction                              = 100,
	Inventory                                = 101,
	Map                                      = 102,
	Flashlight                               = 104,
	Sprint                                   = 105,
	BreakGlass                               = 106,
	ItemsCombine                             = 107,
	BreakWall                                = 109,
	ScribbleEvent                            = 110,
	TraversalCrawl                           = 111,
	TraversalSqueeze                         = 112,
	TraversalVault                           = 113,
	TraversalClimb                           = 114,
	TraversalJumpDown                        = 115,
	BoatNavigation_Keyboard                  = 120,
	BoatNavigation_Gamepad                   = 121,
	Scripted_PreTraversal                    = 200,
	Scripted_BreakWall                       = 201,
	Scripted_BreakGlass                      = 202,
	ESHGameplayTutorialEnum_MAX              = 203,
};

// Enum SHProto.ESHHitReactionResponseType
// NumValues: 0x0008
enum class ESHHitReactionResponseType : uint8
{
	Unknown                                  = 0,
	Twitch                                   = 1,
	Normal                                   = 2,
	Stagger                                  = 3,
	Falter                                   = 4,
	Knockdown                                = 5,
	Death                                    = 6,
	MAX                                      = 7,
};

// Enum SHProto.ESHHitReactionRotation
// NumValues: 0x0006
enum class ESHHitReactionRotation : uint8
{
	None                                     = 0,
	FromCurrent                              = 1,
	RotateTowardsAttacker                    = 2,
	RotateTowardsHitLocation                 = 3,
	RotateTowardsForce                       = 4,
	ESHHitReactionRotation_MAX               = 5,
};

// Enum SHProto.ESHHitReactionHitType
// NumValues: 0x0004
enum class ESHHitReactionHitType : uint8
{
	Directional                              = 0,
	Surface                                  = 1,
	Radial                                   = 2,
	ESHHitReactionHitType_MAX                = 3,
};

// Enum SHProto.ESHHotelFWPyramidHeadBossAftermathEndingFactorValue
// NumValues: 0x0004
enum class ESHHotelFWPyramidHeadBossAftermathEndingFactorValue : uint8
{
	Undefined                                = 0,
	RustEgg                                  = 1,
	ScarletEgg                               = 2,
	ESHHotelFWPyramidHeadBossAftermathEndingFactorValue_MAX = 3,
};

// Enum SHProto.ESHHotelOWMirrorPuzzleEndingFactorValue
// NumValues: 0x0004
enum class ESHHotelOWMirrorPuzzleEndingFactorValue : uint8
{
	Undefined                                = 0,
	FreshApple                               = 1,
	RottenApple                              = 2,
	ESHHotelOWMirrorPuzzleEndingFactorValue_MAX = 3,
};

// Enum SHProto.EInGameQuitTarget
// NumValues: 0x0003
enum class EInGameQuitTarget : uint8
{
	ToMainMenu                               = 0,
	QuitGame                                 = 1,
	EInGameQuitTarget_MAX                    = 2,
};

// Enum SHProto.ESHInputBufferAction
// NumValues: 0x0008
enum class ESHInputBufferAction : uint8
{
	None                                     = 0,
	MeleeAttack                              = 1,
	Dodge                                    = 2,
	RangedFire                               = 3,
	RangedReload                             = 4,
	ChangeWeapon                             = 5,
	UseHealItem                              = 6,
	ESHInputBufferAction_MAX                 = 7,
};

// Enum SHProto.ESHIntOperationType
// NumValues: 0x0008
enum class ESHIntOperationType : uint8
{
	Undefined                                = 0,
	Equals                                   = 1,
	NotEquals                                = 2,
	Lower                                    = 3,
	LowerOrEquals                            = 4,
	Greater                                  = 5,
	GreaterOrEquals                          = 6,
	ESHIntOperationType_MAX                  = 7,
};

// Enum SHProto.ESHInteractionIconOpacityState
// NumValues: 0x0005
enum class ESHInteractionIconOpacityState : uint8
{
	Hidden                                   = 0,
	Covered                                  = 1,
	Visible                                  = 2,
	Hovered                                  = 3,
	ESHInteractionIconOpacityState_MAX       = 4,
};

// Enum SHProto.ESHInteractionIconState
// NumValues: 0x0005
enum class ESHInteractionIconState : uint8
{
	Hidden                                   = 0,
	Visible                                  = 1,
	Focused                                  = 2,
	Used                                     = 3,
	ESHInteractionIconState_MAX              = 4,
};

// Enum SHProto.ESHInteractionIconType
// NumValues: 0x0004
enum class ESHInteractionIconType : uint8
{
	Invalid                                  = 0,
	Default                                  = 1,
	Traversal                                = 2,
	ESHInteractionIconType_MAX               = 3,
};

// Enum SHProto.ESHInteractionStopReason
// NumValues: 0x0004
enum class ESHInteractionStopReason : uint8
{
	Finished                                 = 0,
	NotVisible                               = 1,
	Interrupted                              = 2,
	ESHInteractionStopReason_MAX             = 3,
};

// Enum SHProto.ESHGameplaySection
// NumValues: 0x000A
enum class ESHGameplaySection : uint8
{
	None                                     = 0,
	Section1                                 = 1,
	Section2                                 = 2,
	Section3                                 = 3,
	Section4                                 = 4,
	Section5                                 = 5,
	Section6                                 = 6,
	Section7                                 = 7,
	Section8                                 = 8,
	ESHGameplaySection_MAX                   = 9,
};

// Enum SHProto.ESHItemAttachSlotType
// NumValues: 0x0004
enum class ESHItemAttachSlotType : uint8
{
	None                                     = 0,
	RightHand                                = 1,
	LeftHand                                 = 2,
	ESHItemAttachSlotType_MAX                = 3,
};

// Enum SHProto.ESHMapsFamily
// NumValues: 0x000A
enum class ESHMapsFamily : uint8
{
	None                                     = 0,
	Woodside                                 = 1,
	Hospital_FW                              = 2,
	Hospital_OW                              = 3,
	LakeviewHotel                            = 4,
	BlueCreek                                = 5,
	City                                     = 6,
	Toluca_Prison_OW                         = 7,
	Labyrinth                                = 8,
	ESHMapsFamily_MAX                        = 9,
};

// Enum SHProto.ESHMapsEnum
// NumValues: 0x0030
enum class ESHMapsEnum : uint8
{
	None                                     = 0,
	FogTest                                  = 1,
	RoadToCity                               = 9,
	CityEast                                 = 10,
	CityWest                                 = 11,
	CityEastOW                               = 12,
	CityWestOW                               = 13,
	Woodside_1F                              = 20,
	Woodside_2F                              = 21,
	Woodside_3F                              = 22,
	Hospital_FW_1F                           = 30,
	Hospital_FW_2F                           = 31,
	Hospital_FW_3F                           = 32,
	Hospital_FW_BF                           = 33,
	Hospital_FW_RF                           = 34,
	LakeviewHotel_OW_1F                      = 40,
	LakeviewHotel_OW_2F                      = 41,
	LakeviewHotel_OW_3F                      = 42,
	LakeviewHotel_OW_EF                      = 43,
	LakeviewHotel_OW_BF                      = 44,
	LakeviewHotel_OW_GF                      = 45,
	LakeviewHotel_OW_VF                      = 46,
	Hospital_OW_1F                           = 50,
	Hospital_OW_2F                           = 51,
	Hospital_OW_3F                           = 52,
	Hospital_OW_BF                           = 53,
	Hospital_OW_RF                           = 54,
	BlueCreek_1F                             = 60,
	BlueCreek_2F                             = 61,
	BlueCreek_3F                             = 62,
	BlueCreek_4F                             = 63,
	Toluca_Prison_OW_BF                      = 70,
	Toluca_Prison_OW_2F                      = 72,
	Toluca_Prison_OW_3F                      = 73,
	Toluca_Prison_OW_1F_Main                 = 74,
	Toluca_Prison_OW_1F_Boar                 = 75,
	Toluca_Prison_OW_1F_Serpent              = 76,
	LakeviewHotel_FW_BF                      = 80,
	LakeviewHotel_FW_EF                      = 81,
	LakeviewHotel_FW_1F                      = 82,
	LakeviewHotel_FW_2F                      = 83,
	LakeviewHotel_FW_3F                      = 84,
	Labyrinth_MainArea                       = 90,
	Labyrinth_DisgustPath                    = 91,
	Labyrinth_FearPathUp                     = 92,
	Labyrinth_FearPathDown                   = 93,
	Labyrinth_AngerPath                      = 94,
	ESHMapsEnum_MAX                          = 95,
};

// Enum SHProto.ESHUseFinishType
// NumValues: 0x0005
enum class ESHUseFinishType : uint8
{
	None                                     = 0,
	Success                                  = 1,
	Abort                                    = 2,
	Error                                    = 3,
	ESHUseFinishType_MAX                     = 4,
};

// Enum SHProto.ESHWeaponTypeEnum
// NumValues: 0x0004
enum class ESHWeaponTypeEnum : uint8
{
	Other                                    = 0,
	Shooting                                 = 1,
	Melee                                    = 2,
	ESHWeaponTypeEnum_MAX                    = 3,
};

// Enum SHProto.ESHLightingChannelsProfile
// NumValues: 0x0007
enum class ESHLightingChannelsProfile : uint8
{
	None                                     = 0,
	Everything                               = 1,
	AllButCharacterPlay                      = 2,
	OnlyCharacterPlay                        = 3,
	AllButMaria                              = 4,
	OnlyMaria                                = 5,
	ESHLightingChannelsProfile_MAX           = 6,
};

// Enum SHProto.ELocomotionState
// NumValues: 0x0003
enum class ELocomotionState : uint8
{
	Idle                                     = 0,
	Move                                     = 1,
	ELocomotionState_MAX                     = 2,
};

// Enum SHProto.EMovementType
// NumValues: 0x0005
enum class EMovementType : uint8
{
	Stand                                    = 0,
	Walk                                     = 1,
	Jog                                      = 2,
	Run                                      = 3,
	EMovementType_MAX                        = 4,
};

// Enum SHProto.ESHLyingFigureAnimInstanceStandingLocomotionState
// NumValues: 0x0004
enum class ESHLyingFigureAnimInstanceStandingLocomotionState : uint8
{
	Idle                                     = 0,
	IdleRotation                             = 1,
	MovementStrafing                         = 2,
	ESHLyingFigureAnimInstanceStandingLocomotionState_MAX = 3,
};

// Enum SHProto.ESHLyingFigureAnimInstanceCrawlingLocomotionState
// NumValues: 0x0003
enum class ESHLyingFigureAnimInstanceCrawlingLocomotionState : uint8
{
	Idle                                     = 0,
	Movement                                 = 1,
	ESHLyingFigureAnimInstanceCrawlingLocomotionState_MAX = 2,
};

// Enum SHProto.ESHMandarinAnimInstanceLocomotionState
// NumValues: 0x0004
enum class ESHMandarinAnimInstanceLocomotionState : uint8
{
	Idle                                     = 0,
	IdleRotation                             = 1,
	Movement                                 = 2,
	ESHMandarinAnimInstanceLocomotionState_MAX = 3,
};

// Enum SHProto.ESHMandarinTransformationState
// NumValues: 0x0006
enum class ESHMandarinTransformationState : uint8
{
	Hanging                                  = 0,
	Fallen                                   = 1,
	Climbing                                 = 2,
	Jumping                                  = 3,
	Dead                                     = 4,
	ESHMandarinTransformationState_MAX       = 5,
};

// Enum SHProto.ESHMannequinAnimInstanceStandingLocomotionState
// NumValues: 0x0004
enum class ESHMannequinAnimInstanceStandingLocomotionState : uint8
{
	Idle                                     = 0,
	IdleRotation                             = 1,
	MovementStrafing                         = 2,
	ESHMannequinAnimInstanceStandingLocomotionState_MAX = 3,
};

// Enum SHProto.ESHMaryAnimInstanceMovementState
// NumValues: 0x0007
enum class ESHMaryAnimInstanceMovementState : uint8
{
	Flying                                   = 0,
	Spider                                   = 1,
	Caged                                    = 2,
	Hanging                                  = 3,
	Fallen                                   = 4,
	WallMount                                = 5,
	ESHMaryAnimInstanceMovementState_MAX     = 6,
};

// Enum SHProto.ESHMaryAnimInstanceLocomotionState
// NumValues: 0x0005
enum class ESHMaryAnimInstanceLocomotionState : uint8
{
	Idle                                     = 0,
	IdleRotation                             = 1,
	Movement                                 = 2,
	MovementRotation                         = 3,
	ESHMaryAnimInstanceLocomotionState_MAX   = 4,
};

// Enum SHProto.ESHMariaBossFaceExpression
// NumValues: 0x000A
enum class ESHMariaBossFaceExpression : uint8
{
	Angry                                    = 0,
	Desperate                                = 1,
	Enraged                                  = 2,
	Hurt                                     = 3,
	Scared                                   = 4,
	Scream                                   = 5,
	Sinister                                 = 6,
	Determined                               = 7,
	Normal                                   = 8,
	ESHMariaBossFaceExpression_MAX           = 9,
};

// Enum SHProto.ESHMaryTransformationState
// NumValues: 0x0007
enum class ESHMaryTransformationState : uint8
{
	Flying                                   = 0,
	Hanging                                  = 1,
	Caged                                    = 2,
	CagedLow                                 = 3,
	Fallen                                   = 4,
	WallMount                                = 5,
	ESHMaryTransformationState_MAX           = 6,
};

// Enum SHProto.ESHMenuTutorialEnum
// NumValues: 0x0009
enum class ESHMenuTutorialEnum : uint8
{
	HealQuick                                = 0,
	HealingAmount                            = 1,
	TraversalVault                           = 2,
	BreakGlass                               = 3,
	CombatMelee                              = 4,
	CombatRanged                             = 5,
	Radio                                    = 6,
	Map                                      = 7,
	ESHMenuTutorialEnum_MAX                  = 8,
};

// Enum SHProto.ESHMovementProfile
// NumValues: 0x000C
enum class ESHMovementProfile : uint8
{
	Invalid                                  = 0,
	Weapon                                   = 1,
	WeaponLowHealth                          = 2,
	Exterior                                 = 3,
	ExteriorInDanger                         = 4,
	ExteriorLowHealth                        = 5,
	ExteriorSprint                           = 6,
	Interior                                 = 7,
	InteriorInDanger                         = 8,
	InteriorLowHealth                        = 9,
	InteriorSprint                           = 10,
	ESHMovementProfile_MAX                   = 11,
};

// Enum SHProto.ESHMovementSprintCameraFOVProfile
// NumValues: 0x0004
enum class ESHMovementSprintCameraFOVProfile : uint8
{
	None                                     = 0,
	SprintInterior                           = 1,
	SprintExterior                           = 2,
	ESHMovementSprintCameraFOVProfile_MAX    = 3,
};

// Enum SHProto.ESHMQSpiderAnimInstanceLocomotionState
// NumValues: 0x0004
enum class ESHMQSpiderAnimInstanceLocomotionState : uint8
{
	Idle                                     = 0,
	IdleRotation                             = 1,
	Movement                                 = 2,
	ESHMQSpiderAnimInstanceLocomotionState_MAX = 3,
};

// Enum SHProto.ESHNewGamePlusControllerBehaviourType
// NumValues: 0x0004
enum class ESHNewGamePlusControllerBehaviourType : uint8
{
	DefaultGameOnly                          = 0,
	NewGamePlusOnly                          = 1,
	SeenInWaterEndingOnly                    = 2,
	ESHNewGamePlusControllerBehaviourType_MAX = 3,
};

// Enum SHProto.ESHNurseAnimInstanceLocomotionState
// NumValues: 0x0005
enum class ESHNurseAnimInstanceLocomotionState : uint8
{
	Idle                                     = 0,
	IdleRotation                             = 1,
	Movement                                 = 2,
	MovementRotation                         = 3,
	ESHNurseAnimInstanceLocomotionState_MAX  = 4,
};

// Enum SHProto.ENurseWalkingProfile
// NumValues: 0x0004
enum class ENurseWalkingProfile : uint8
{
	SleepWalking                             = 0,
	Attacking                                = 1,
	Aggressive                               = 2,
	ENurseWalkingProfile_MAX                 = 3,
};

// Enum SHProto.ESHPHAnimInstanceLocomotionState
// NumValues: 0x0004
enum class ESHPHAnimInstanceLocomotionState : uint8
{
	Idle                                     = 0,
	Movement                                 = 1,
	TurnInPlace                              = 2,
	ESHPHAnimInstanceLocomotionState_MAX     = 3,
};

// Enum SHProto.ESHInputModeEnum
// NumValues: 0x0003
enum class ESHInputModeEnum : uint8
{
	Hold                                     = 0,
	Toggle                                   = 1,
	ESHInputModeEnum_MAX                     = 2,
};

// Enum SHProto.EReticleVisibility
// NumValues: 0x0004
enum class EReticleVisibility : uint8
{
	Off                                      = 0,
	Minimal                                  = 1,
	Dynamic                                  = 2,
	EReticleVisibility_MAX                   = 3,
};

// Enum SHProto.EReticleThickness
// NumValues: 0x0004
enum class EReticleThickness : uint8
{
	Thin                                     = 0,
	Normal                                   = 1,
	Thick                                    = 2,
	EReticleThickness_MAX                    = 3,
};

// Enum SHProto.EReticleColor
// NumValues: 0x0008
enum class EReticleColor : uint8
{
	White                                    = 0,
	Cyan                                     = 1,
	Magenta                                  = 2,
	Yellow                                   = 3,
	Red                                      = 4,
	Green                                    = 5,
	Blue                                     = 6,
	EReticleColor_MAX                        = 7,
};

// Enum SHProto.EInteractionIconVisibility
// NumValues: 0x0004
enum class EInteractionIconVisibility : uint8
{
	Off                                      = 0,
	Icon                                     = 1,
	ActionKey                                = 2,
	EInteractionIconVisibility_MAX           = 3,
};

// Enum SHProto.EInteractionIconSize
// NumValues: 0x0006
enum class EInteractionIconSize : uint8
{
	Tiny                                     = 0,
	Small                                    = 1,
	Default                                  = 2,
	Big                                      = 3,
	Huge                                     = 4,
	EInteractionIconSize_MAX                 = 5,
};

// Enum SHProto.EHighContrastColor
// NumValues: 0x0008
enum class EHighContrastColor : uint8
{
	White                                    = 0,
	Cyan                                     = 1,
	Magenta                                  = 2,
	Yellow                                   = 3,
	Red                                      = 4,
	Green                                    = 5,
	Blue                                     = 6,
	EHighContrastColor_MAX                   = 7,
};

// Enum SHProto.EAmmoWidgetVisibility
// NumValues: 0x0004
enum class EAmmoWidgetVisibility : uint8
{
	Off                                      = 0,
	On                                       = 1,
	Dynamic                                  = 2,
	EAmmoWidgetVisibility_MAX                = 3,
};

// Enum SHProto.EVisualMode
// NumValues: 0x0010
enum class EVisualMode : uint8
{
	Default                                  = 0,
	Mode0                                    = 1,
	Mode1                                    = 2,
	Mode2                                    = 3,
	Mode3                                    = 4,
	Mode4                                    = 5,
	Mode5                                    = 6,
	Mode6                                    = 7,
	Mode7                                    = 8,
	Mode8                                    = 9,
	Mode9                                    = 10,
	Mode10                                   = 11,
	Mode11                                   = 12,
	Mode12                                   = 13,
	Mode13                                   = 14,
	EVisualMode_MAX                          = 15,
};

// Enum SHProto.EPlayerSkin
// NumValues: 0x0005
enum class EPlayerSkin : uint8
{
	Default                                  = 0,
	PyramidHead                              = 1,
	RobbieHead                               = 2,
	ShibaInu                                 = 3,
	EPlayerSkin_MAX                          = 4,
};

// Enum SHProto.ECombatDifficulty
// NumValues: 0x0004
enum class ECombatDifficulty : uint8
{
	Easy                                     = 0,
	Medium                                   = 1,
	Hard                                     = 2,
	ECombatDifficulty_MAX                    = 3,
};

// Enum SHProto.EAimAssistMagnetismMode
// NumValues: 0x0005
enum class EAimAssistMagnetismMode : uint8
{
	Off                                      = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	EAimAssistMagnetismMode_MAX              = 4,
};

// Enum SHProto.EStruggleInputVisibility
// NumValues: 0x0003
enum class EStruggleInputVisibility : uint8
{
	Off                                      = 0,
	On                                       = 1,
	EStruggleInputVisibility_MAX             = 2,
};

// Enum SHProto.EStruggleInputSize
// NumValues: 0x0006
enum class EStruggleInputSize : uint8
{
	Tiny                                     = 0,
	Small                                    = 1,
	Default                                  = 2,
	Big                                      = 3,
	Huge                                     = 4,
	EStruggleInputSize_MAX                   = 5,
};

// Enum SHProto.ESettingsPresets
// NumValues: 0x0005
enum class ESettingsPresets : uint8
{
	Custom                                   = 0,
	Modern                                   = 1,
	Default                                  = 2,
	Retro                                    = 3,
	ESettingsPresets_MAX                     = 4,
};

// Enum SHProto.ESHInputTriggerMode
// NumValues: 0x0004
enum class ESHInputTriggerMode : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	ESHInputTriggerMode_MAX                  = 3,
};

// Enum SHProto.ESHPrisonGallowPuzzleEndingFactorValue
// NumValues: 0x0004
enum class ESHPrisonGallowPuzzleEndingFactorValue : uint8
{
	Undefined                                = 0,
	EddieOrAngelaRepresentation              = 1,
	JamesRepresentation                      = 2,
	ESHPrisonGallowPuzzleEndingFactorValue_MAX = 3,
};

// Enum SHProto.ESHLadyJusticeTraceEnum
// NumValues: 0x0004
enum class ESHLadyJusticeTraceEnum : uint8
{
	Unassigned                               = 0,
	Left_tray                                = 1,
	Right_tray                               = 2,
	ESHLadyJusticeTraceEnum_MAX              = 3,
};

// Enum SHProto.ESHPyramidHeadBossFightOutcomeEndingFactorValue
// NumValues: 0x0005
enum class ESHPyramidHeadBossFightOutcomeEndingFactorValue : uint8
{
	Undefined                                = 0,
	Default                                  = 1,
	Denied                                   = 2,
	Forced                                   = 3,
	ESHPyramidHeadBossFightOutcomeEndingFactorValue_MAX = 4,
};

// Enum SHProto.ESHRadioStance
// NumValues: 0x0005
enum class ESHRadioStance : uint8
{
	Invalid                                  = 0,
	Calm                                     = 1,
	Danger                                   = 2,
	Aggressive                               = 3,
	ESHRadioStance_MAX                       = 4,
};

// Enum SHProto.ESHReceivedDamageGrade
// NumValues: 0x0006
enum class ESHReceivedDamageGrade : uint8
{
	Undefined                                = 0,
	Normal                                   = 1,
	Stun                                     = 2,
	Continous                                = 3,
	Soft                                     = 4,
	ESHReceivedDamageGrade_MAX               = 5,
};

// Enum SHProto.ERevivePose
// NumValues: 0x0007
enum class ERevivePose : uint8
{
	Back                                     = 0,
	Front                                    = 1,
	SideLeft                                 = 2,
	SideRight                                = 3,
	Knee                                     = 4,
	Sit                                      = 5,
	ERevivePose_MAX                          = 6,
};

// Enum SHProto.EPuzzlesDifficulty
// NumValues: 0x0004
enum class EPuzzlesDifficulty : uint8
{
	Easy                                     = 0,
	Medium                                   = 1,
	Hard                                     = 2,
	EPuzzlesDifficulty_MAX                   = 3,
};

// Enum SHProto.ESavePointFilterId
// NumValues: 0x0006
enum class ESavePointFilterId : uint8
{
	All                                      = 0,
	Hospital                                 = 1,
	Labyrinth                                = 2,
	Prison                                   = 3,
	Hotel                                    = 4,
	ESavePointFilterId_MAX                   = 5,
};

// Enum SHProto.ESHCombatStressLevel
// NumValues: 0x0006
enum class ESHCombatStressLevel : uint8
{
	Undefined                                = 0,
	None                                     = 1,
	Light                                    = 2,
	Medium                                   = 3,
	High                                     = 4,
	ESHCombatStressLevel_MAX                 = 5,
};

// Enum SHProto.ESHSuccessFailureEnum
// NumValues: 0x0003
enum class ESHSuccessFailureEnum : uint8
{
	Success                                  = 0,
	Failure                                  = 1,
	ESHSuccessFailureEnum_MAX                = 2,
};

// Enum SHProto.ESwarmFollowType
// NumValues: 0x0007
enum class ESwarmFollowType : uint8
{
	CHOOSE_ONLY_CLOSEST                      = 0,
	CHOOSE_ONLY_RANDOM                       = 1,
	START_CLOSEST_FOLLOW_INDEX_ORDER         = 2,
	START_RANDOM_FOLLOW_INDEX_ORDER          = 3,
	START_CLOSEST_FOLLOW_INDEX_ORDER_REPEAT  = 4,
	START_RANDOM_FOLLOW_INDEX_ORDER_REPEAT   = 5,
	ESwarmFollowType_MAX                     = 6,
};

// Enum SHProto.ESwarmCreeperState
// NumValues: 0x0006
enum class ESwarmCreeperState : uint8
{
	MOVE                                     = 0,
	IDLE                                     = 1,
	RUNOUT                                   = 2,
	DISTURBANCE                              = 3,
	FOLLOWING                                = 4,
	ESwarmCreeperState_MAX                   = 5,
};

// Enum SHProto.ESwarmRegionType
// NumValues: 0x0003
enum class ESwarmRegionType : uint8
{
	Sphere                                   = 0,
	Box                                      = 1,
	ESwarmRegionType_MAX                     = 2,
};

// Enum SHProto.ESHUfoEndingInteraction
// NumValues: 0x0006
enum class ESHUfoEndingInteraction : uint8
{
	Undefined                                = 0,
	SaulStRoof                               = 1,
	RosewaterPark                            = 2,
	HotelPier                                = 3,
	HotelRoom                                = 4,
	ESHUfoEndingInteraction_MAX              = 5,
};

// Enum SHProto.ESimulatedWaterEffectType
// NumValues: 0x0004
enum class ESimulatedWaterEffectType : uint8
{
	DEFAULT                                  = 0,
	BLOOD                                    = 1,
	PUKE_ACID                                = 2,
	ESimulatedWaterEffectType_MAX            = 3,
};

// Enum SHProto.ESHWoodsideCoinPuzzleEndingFactorValue
// NumValues: 0x0005
enum class ESHWoodsideCoinPuzzleEndingFactorValue : uint8
{
	Undefined                                = 0,
	SnakeCoin                                = 1,
	ManCoin                                  = 2,
	WomanCoin                                = 3,
	ESHWoodsideCoinPuzzleEndingFactorValue_MAX = 4,
};

// Enum SHProto.EBoneHierarchySort
// NumValues: 0x0004
enum class EBoneHierarchySort : uint8
{
	None                                     = 0,
	ParentLevel                              = 1,
	WeightFromRoot                           = 2,
	EBoneHierarchySort_MAX                   = 3,
};

// Enum SHProto.EBones
// NumValues: 0x0018
enum class EBones : uint8
{
	Root                                     = 0,
	Pelvis                                   = 1,
	Spine_01                                 = 2,
	Spine_02                                 = 3,
	Spine_04                                 = 4,
	Chest                                    = 5,
	ThighL                                   = 6,
	ShinL                                    = 7,
	FootL                                    = 8,
	ThighR                                   = 9,
	ShinR                                    = 10,
	FootR                                    = 11,
	ClavicleL                                = 12,
	UpperArmL                                = 13,
	ForearmL                                 = 14,
	HandL                                    = 15,
	ClavicleR                                = 16,
	UpperArmR                                = 17,
	ForearmR                                 = 18,
	HandR                                    = 19,
	Neck_01                                  = 20,
	Neck_02                                  = 21,
	Head                                     = 22,
	EBones_MAX                               = 23,
};

// Enum SHProto.ESkeletonSockets
// NumValues: 0x0003
enum class ESkeletonSockets : uint8
{
	WeaponHandR                              = 0,
	WeaponHandL                              = 1,
	ESkeletonSockets_MAX                     = 2,
};

// Enum SHProto.ERagdollProfileName
// NumValues: 0x0003
enum class ERagdollProfileName : uint32
{
	Test                                     = 0,
	HitNormal                                = 1,
	ERagdollProfileName_MAX                  = 2,
};

// Enum SHProto.ESkeletonRagdollProfileTickResult
// NumValues: 0x0005
enum class ESkeletonRagdollProfileTickResult : uint8
{
	Work                                     = 0,
	End                                      = 1,
	Paused                                   = 2,
	Inactive                                 = 3,
	ESkeletonRagdollProfileTickResult_MAX    = 4,
};

// ScriptStruct SHProto.SHItemAndQuantityHandle
// 0x0018 (0x0018 - 0x0000)
struct FSHItemAndQuantityHandle final
{
public:
	struct FDataTableRowHandle                    DataRowHandle;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHItemAndQuantityHandle) == 0x000008, "Wrong alignment on FSHItemAndQuantityHandle");
static_assert(sizeof(FSHItemAndQuantityHandle) == 0x000018, "Wrong size on FSHItemAndQuantityHandle");
static_assert(offsetof(FSHItemAndQuantityHandle, DataRowHandle) == 0x000000, "Member 'FSHItemAndQuantityHandle::DataRowHandle' has a wrong offset!");
static_assert(offsetof(FSHItemAndQuantityHandle, Quantity) == 0x000010, "Member 'FSHItemAndQuantityHandle::Quantity' has a wrong offset!");

// ScriptStruct SHProto.SHMovementDataStruct
// 0x0028 (0x0028 - 0x0000)
struct FSHMovementDataStruct final
{
public:
	float                                         SpeedForward;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedSideway;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedBackward;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlRotationInterpSpeed;                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AccelerationCurve;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DecelerationCurve;                                 // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         SprintCameraShake;                                 // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHMovementDataStruct) == 0x000008, "Wrong alignment on FSHMovementDataStruct");
static_assert(sizeof(FSHMovementDataStruct) == 0x000028, "Wrong size on FSHMovementDataStruct");
static_assert(offsetof(FSHMovementDataStruct, SpeedForward) == 0x000000, "Member 'FSHMovementDataStruct::SpeedForward' has a wrong offset!");
static_assert(offsetof(FSHMovementDataStruct, SpeedSideway) == 0x000004, "Member 'FSHMovementDataStruct::SpeedSideway' has a wrong offset!");
static_assert(offsetof(FSHMovementDataStruct, SpeedBackward) == 0x000008, "Member 'FSHMovementDataStruct::SpeedBackward' has a wrong offset!");
static_assert(offsetof(FSHMovementDataStruct, ControlRotationInterpSpeed) == 0x00000C, "Member 'FSHMovementDataStruct::ControlRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(FSHMovementDataStruct, AccelerationCurve) == 0x000010, "Member 'FSHMovementDataStruct::AccelerationCurve' has a wrong offset!");
static_assert(offsetof(FSHMovementDataStruct, DecelerationCurve) == 0x000018, "Member 'FSHMovementDataStruct::DecelerationCurve' has a wrong offset!");
static_assert(offsetof(FSHMovementDataStruct, SprintCameraShake) == 0x000020, "Member 'FSHMovementDataStruct::SprintCameraShake' has a wrong offset!");

// ScriptStruct SHProto.SHBonePhysicsPhysicsBlendInput
// 0x0014 (0x0014 - 0x0000)
struct FSHBonePhysicsPhysicsBlendInput final
{
public:
	float                                         PhysicsBlendWeight;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsDuration;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsFadeOutCurveBend;                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PhysicsProfileOverride;                            // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHBonePhysicsPhysicsBlendInput) == 0x000004, "Wrong alignment on FSHBonePhysicsPhysicsBlendInput");
static_assert(sizeof(FSHBonePhysicsPhysicsBlendInput) == 0x000014, "Wrong size on FSHBonePhysicsPhysicsBlendInput");
static_assert(offsetof(FSHBonePhysicsPhysicsBlendInput, PhysicsBlendWeight) == 0x000000, "Member 'FSHBonePhysicsPhysicsBlendInput::PhysicsBlendWeight' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsPhysicsBlendInput, PhysicsDuration) == 0x000004, "Member 'FSHBonePhysicsPhysicsBlendInput::PhysicsDuration' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsPhysicsBlendInput, PhysicsFadeOutCurveBend) == 0x000008, "Member 'FSHBonePhysicsPhysicsBlendInput::PhysicsFadeOutCurveBend' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsPhysicsBlendInput, PhysicsProfileOverride) == 0x00000C, "Member 'FSHBonePhysicsPhysicsBlendInput::PhysicsProfileOverride' has a wrong offset!");

// ScriptStruct SHProto.SHMakeNoiseData
// 0x0018 (0x0018 - 0x0000)
struct FSHMakeNoiseData final
{
public:
	class FName                                   NoiseTag;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aggro;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseRange;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Loudness;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHMakeNoiseData) == 0x000004, "Wrong alignment on FSHMakeNoiseData");
static_assert(sizeof(FSHMakeNoiseData) == 0x000018, "Wrong size on FSHMakeNoiseData");
static_assert(offsetof(FSHMakeNoiseData, NoiseTag) == 0x000000, "Member 'FSHMakeNoiseData::NoiseTag' has a wrong offset!");
static_assert(offsetof(FSHMakeNoiseData, Aggro) == 0x000008, "Member 'FSHMakeNoiseData::Aggro' has a wrong offset!");
static_assert(offsetof(FSHMakeNoiseData, NoiseRange) == 0x00000C, "Member 'FSHMakeNoiseData::NoiseRange' has a wrong offset!");
static_assert(offsetof(FSHMakeNoiseData, MaxRange) == 0x000010, "Member 'FSHMakeNoiseData::MaxRange' has a wrong offset!");
static_assert(offsetof(FSHMakeNoiseData, Loudness) == 0x000014, "Member 'FSHMakeNoiseData::Loudness' has a wrong offset!");

// ScriptStruct SHProto.SHMakeNoiseConfig
// 0x001C (0x001C - 0x0000)
struct FSHMakeNoiseConfig final
{
public:
	bool                                          bShouldMakeNoise;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHMakeNoiseData                       NoiseData;                                         // 0x0004(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHMakeNoiseConfig) == 0x000004, "Wrong alignment on FSHMakeNoiseConfig");
static_assert(sizeof(FSHMakeNoiseConfig) == 0x00001C, "Wrong size on FSHMakeNoiseConfig");
static_assert(offsetof(FSHMakeNoiseConfig, bShouldMakeNoise) == 0x000000, "Member 'FSHMakeNoiseConfig::bShouldMakeNoise' has a wrong offset!");
static_assert(offsetof(FSHMakeNoiseConfig, NoiseData) == 0x000004, "Member 'FSHMakeNoiseConfig::NoiseData' has a wrong offset!");

// ScriptStruct SHProto.SHFlickerLight
// 0x0018 (0x0018 - 0x0000)
struct FSHFlickerLight final
{
public:
	class ULightComponent*                        Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseIntensity;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseTemperature;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasOffTag;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHFlickerLight) == 0x000008, "Wrong alignment on FSHFlickerLight");
static_assert(sizeof(FSHFlickerLight) == 0x000018, "Wrong size on FSHFlickerLight");
static_assert(offsetof(FSHFlickerLight, Component) == 0x000000, "Member 'FSHFlickerLight::Component' has a wrong offset!");
static_assert(offsetof(FSHFlickerLight, BaseIntensity) == 0x000008, "Member 'FSHFlickerLight::BaseIntensity' has a wrong offset!");
static_assert(offsetof(FSHFlickerLight, BaseTemperature) == 0x00000C, "Member 'FSHFlickerLight::BaseTemperature' has a wrong offset!");
static_assert(offsetof(FSHFlickerLight, HasOffTag) == 0x000010, "Member 'FSHFlickerLight::HasOffTag' has a wrong offset!");

// ScriptStruct SHProto.SHAnalyticsGameFlowDetail
// 0x0020 (0x0020 - 0x0000)
struct FSHAnalyticsGameFlowDetail final
{
public:
	class FString                                 Description;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ObjectName;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHAnalyticsGameFlowDetail) == 0x000008, "Wrong alignment on FSHAnalyticsGameFlowDetail");
static_assert(sizeof(FSHAnalyticsGameFlowDetail) == 0x000020, "Wrong size on FSHAnalyticsGameFlowDetail");
static_assert(offsetof(FSHAnalyticsGameFlowDetail, Description) == 0x000000, "Member 'FSHAnalyticsGameFlowDetail::Description' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsGameFlowDetail, ObjectName) == 0x000010, "Member 'FSHAnalyticsGameFlowDetail::ObjectName' has a wrong offset!");

// ScriptStruct SHProto.SHElevatorFloorConfig
// 0x0008 (0x0008 - 0x0000)
struct FSHElevatorFloorConfig final
{
public:
	float                                         FloorOffset;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OpenFrontInsideDoor;                               // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OpenBackInsideDoor;                                // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHElevatorFloorConfig) == 0x000004, "Wrong alignment on FSHElevatorFloorConfig");
static_assert(sizeof(FSHElevatorFloorConfig) == 0x000008, "Wrong size on FSHElevatorFloorConfig");
static_assert(offsetof(FSHElevatorFloorConfig, FloorOffset) == 0x000000, "Member 'FSHElevatorFloorConfig::FloorOffset' has a wrong offset!");
static_assert(offsetof(FSHElevatorFloorConfig, OpenFrontInsideDoor) == 0x000004, "Member 'FSHElevatorFloorConfig::OpenFrontInsideDoor' has a wrong offset!");
static_assert(offsetof(FSHElevatorFloorConfig, OpenBackInsideDoor) == 0x000005, "Member 'FSHElevatorFloorConfig::OpenBackInsideDoor' has a wrong offset!");

// ScriptStruct SHProto.SHTraceData
// 0x0030 (0x0030 - 0x0000)
struct FSHTraceData final
{
public:
	struct FVector                                TraceStart;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceEnd;                                          // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHTraceData) == 0x000008, "Wrong alignment on FSHTraceData");
static_assert(sizeof(FSHTraceData) == 0x000030, "Wrong size on FSHTraceData");
static_assert(offsetof(FSHTraceData, TraceStart) == 0x000000, "Member 'FSHTraceData::TraceStart' has a wrong offset!");
static_assert(offsetof(FSHTraceData, TraceEnd) == 0x000018, "Member 'FSHTraceData::TraceEnd' has a wrong offset!");

// ScriptStruct SHProto.MandarinIKSettings
// 0x0028 (0x0028 - 0x0000)
struct FMandarinIKSettings final
{
public:
	class FName                                   LeftHandName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSpeed_IK;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSpeed_Handlock;                                // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultOffset;                                     // 0x0010(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMandarinIKSettings) == 0x000008, "Wrong alignment on FMandarinIKSettings");
static_assert(sizeof(FMandarinIKSettings) == 0x000028, "Wrong size on FMandarinIKSettings");
static_assert(offsetof(FMandarinIKSettings, LeftHandName) == 0x000000, "Member 'FMandarinIKSettings::LeftHandName' has a wrong offset!");
static_assert(offsetof(FMandarinIKSettings, LerpSpeed_IK) == 0x000008, "Member 'FMandarinIKSettings::LerpSpeed_IK' has a wrong offset!");
static_assert(offsetof(FMandarinIKSettings, LerpSpeed_Handlock) == 0x00000C, "Member 'FMandarinIKSettings::LerpSpeed_Handlock' has a wrong offset!");
static_assert(offsetof(FMandarinIKSettings, DefaultOffset) == 0x000010, "Member 'FMandarinIKSettings::DefaultOffset' has a wrong offset!");

// ScriptStruct SHProto.SHAnalyticsGameplayEvent
// 0x0010 (0x0010 - 0x0000)
struct FSHAnalyticsGameplayEvent final
{
public:
	double                                        PlayTime;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHAnalyticsGameplayEventType                 Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DetailIndex;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHAnalyticsGameplayEvent) == 0x000008, "Wrong alignment on FSHAnalyticsGameplayEvent");
static_assert(sizeof(FSHAnalyticsGameplayEvent) == 0x000010, "Wrong size on FSHAnalyticsGameplayEvent");
static_assert(offsetof(FSHAnalyticsGameplayEvent, PlayTime) == 0x000000, "Member 'FSHAnalyticsGameplayEvent::PlayTime' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsGameplayEvent, Type) == 0x000008, "Member 'FSHAnalyticsGameplayEvent::Type' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsGameplayEvent, DetailIndex) == 0x00000C, "Member 'FSHAnalyticsGameplayEvent::DetailIndex' has a wrong offset!");

// ScriptStruct SHProto.SHAnalyticsItemCollectedDetail
// 0x0028 (0x0028 - 0x0000)
struct FSHAnalyticsItemCollectedDetail final
{
public:
	class FString                                 ItemName;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ObjectName;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHAnalyticsItemCollectedDetail) == 0x000008, "Wrong alignment on FSHAnalyticsItemCollectedDetail");
static_assert(sizeof(FSHAnalyticsItemCollectedDetail) == 0x000028, "Wrong size on FSHAnalyticsItemCollectedDetail");
static_assert(offsetof(FSHAnalyticsItemCollectedDetail, ItemName) == 0x000000, "Member 'FSHAnalyticsItemCollectedDetail::ItemName' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsItemCollectedDetail, Quantity) == 0x000010, "Member 'FSHAnalyticsItemCollectedDetail::Quantity' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsItemCollectedDetail, ObjectName) == 0x000018, "Member 'FSHAnalyticsItemCollectedDetail::ObjectName' has a wrong offset!");

// ScriptStruct SHProto.SHAnalyticsRangedFireTraceDetail
// 0x0030 (0x0030 - 0x0000)
struct FSHAnalyticsRangedFireTraceDetail final
{
public:
	float                                         TraceDistance;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitEnemy;                                         // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ObjectName;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPenetrating;                                    // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ComponentName;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHAnalyticsRangedFireTraceDetail) == 0x000008, "Wrong alignment on FSHAnalyticsRangedFireTraceDetail");
static_assert(sizeof(FSHAnalyticsRangedFireTraceDetail) == 0x000030, "Wrong size on FSHAnalyticsRangedFireTraceDetail");
static_assert(offsetof(FSHAnalyticsRangedFireTraceDetail, TraceDistance) == 0x000000, "Member 'FSHAnalyticsRangedFireTraceDetail::TraceDistance' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsRangedFireTraceDetail, bHitEnemy) == 0x000004, "Member 'FSHAnalyticsRangedFireTraceDetail::bHitEnemy' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsRangedFireTraceDetail, ObjectName) == 0x000008, "Member 'FSHAnalyticsRangedFireTraceDetail::ObjectName' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsRangedFireTraceDetail, bIsPenetrating) == 0x000018, "Member 'FSHAnalyticsRangedFireTraceDetail::bIsPenetrating' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsRangedFireTraceDetail, ComponentName) == 0x000020, "Member 'FSHAnalyticsRangedFireTraceDetail::ComponentName' has a wrong offset!");

// ScriptStruct SHProto.SHAnalyticsRangedFireDetail
// 0x0028 (0x0028 - 0x0000)
struct FSHAnalyticsRangedFireDetail final
{
public:
	class FString                                 WeaponName;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoAfter;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHAnalyticsRangedFireTraceDetail> Traces;                                            // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHAnalyticsRangedFireDetail) == 0x000008, "Wrong alignment on FSHAnalyticsRangedFireDetail");
static_assert(sizeof(FSHAnalyticsRangedFireDetail) == 0x000028, "Wrong size on FSHAnalyticsRangedFireDetail");
static_assert(offsetof(FSHAnalyticsRangedFireDetail, WeaponName) == 0x000000, "Member 'FSHAnalyticsRangedFireDetail::WeaponName' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsRangedFireDetail, AmmoAfter) == 0x000010, "Member 'FSHAnalyticsRangedFireDetail::AmmoAfter' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsRangedFireDetail, Traces) == 0x000018, "Member 'FSHAnalyticsRangedFireDetail::Traces' has a wrong offset!");

// ScriptStruct SHProto.SHAnalyticsMeleeAttackDetail
// 0x0060 (0x0060 - 0x0000)
struct FSHAnalyticsMeleeAttackDetail final
{
public:
	class FString                                 WeaponName;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttackRowName;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHadTarget;                                        // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSecondaryTarget;                                // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TargetObjectName;                                  // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitEnemy;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HitEnemyResult;                                    // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HitObjectName;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HitComponentName;                                  // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHAnalyticsMeleeAttackDetail) == 0x000008, "Wrong alignment on FSHAnalyticsMeleeAttackDetail");
static_assert(sizeof(FSHAnalyticsMeleeAttackDetail) == 0x000060, "Wrong size on FSHAnalyticsMeleeAttackDetail");
static_assert(offsetof(FSHAnalyticsMeleeAttackDetail, WeaponName) == 0x000000, "Member 'FSHAnalyticsMeleeAttackDetail::WeaponName' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsMeleeAttackDetail, AttackRowName) == 0x000010, "Member 'FSHAnalyticsMeleeAttackDetail::AttackRowName' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsMeleeAttackDetail, bHadTarget) == 0x000020, "Member 'FSHAnalyticsMeleeAttackDetail::bHadTarget' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsMeleeAttackDetail, bIsSecondaryTarget) == 0x000021, "Member 'FSHAnalyticsMeleeAttackDetail::bIsSecondaryTarget' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsMeleeAttackDetail, TargetObjectName) == 0x000028, "Member 'FSHAnalyticsMeleeAttackDetail::TargetObjectName' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsMeleeAttackDetail, bHitEnemy) == 0x000038, "Member 'FSHAnalyticsMeleeAttackDetail::bHitEnemy' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsMeleeAttackDetail, HitEnemyResult) == 0x00003C, "Member 'FSHAnalyticsMeleeAttackDetail::HitEnemyResult' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsMeleeAttackDetail, HitObjectName) == 0x000040, "Member 'FSHAnalyticsMeleeAttackDetail::HitObjectName' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsMeleeAttackDetail, HitComponentName) == 0x000050, "Member 'FSHAnalyticsMeleeAttackDetail::HitComponentName' has a wrong offset!");

// ScriptStruct SHProto.SHAnalyticsPlayerReceivedDamageDetail
// 0x0028 (0x0028 - 0x0000)
struct FSHAnalyticsPlayerReceivedDamageDetail final
{
public:
	class FString                                 Causer;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DamageType;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageValue;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHAnalyticsPlayerReceivedDamageDetail) == 0x000008, "Wrong alignment on FSHAnalyticsPlayerReceivedDamageDetail");
static_assert(sizeof(FSHAnalyticsPlayerReceivedDamageDetail) == 0x000028, "Wrong size on FSHAnalyticsPlayerReceivedDamageDetail");
static_assert(offsetof(FSHAnalyticsPlayerReceivedDamageDetail, Causer) == 0x000000, "Member 'FSHAnalyticsPlayerReceivedDamageDetail::Causer' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsPlayerReceivedDamageDetail, DamageType) == 0x000010, "Member 'FSHAnalyticsPlayerReceivedDamageDetail::DamageType' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsPlayerReceivedDamageDetail, DamageValue) == 0x000020, "Member 'FSHAnalyticsPlayerReceivedDamageDetail::DamageValue' has a wrong offset!");

// ScriptStruct SHProto.SHAnalyticsAICharacterDiedDetail
// 0x0020 (0x0020 - 0x0000)
struct FSHAnalyticsAICharacterDiedDetail final
{
public:
	class FString                                 SpawnerObject;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterClass;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHAnalyticsAICharacterDiedDetail) == 0x000008, "Wrong alignment on FSHAnalyticsAICharacterDiedDetail");
static_assert(sizeof(FSHAnalyticsAICharacterDiedDetail) == 0x000020, "Wrong size on FSHAnalyticsAICharacterDiedDetail");
static_assert(offsetof(FSHAnalyticsAICharacterDiedDetail, SpawnerObject) == 0x000000, "Member 'FSHAnalyticsAICharacterDiedDetail::SpawnerObject' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsAICharacterDiedDetail, CharacterClass) == 0x000010, "Member 'FSHAnalyticsAICharacterDiedDetail::CharacterClass' has a wrong offset!");

// ScriptStruct SHProto.SHAnalyticsGameplayEventsDetails
// 0x0060 (0x0060 - 0x0000)
struct FSHAnalyticsGameplayEventsDetails final
{
public:
	TArray<struct FSHAnalyticsGameFlowDetail>     GameFlowDetails;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSHAnalyticsItemCollectedDetail> ItemCollectedDetails;                              // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSHAnalyticsRangedFireDetail>   RangedFireDetails;                                 // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSHAnalyticsMeleeAttackDetail>  MeleeAttackDetails;                                // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSHAnalyticsPlayerReceivedDamageDetail> PlayerReceivedDamageDetails;                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSHAnalyticsAICharacterDiedDetail> AICharacterDiedDetails;                            // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHAnalyticsGameplayEventsDetails) == 0x000008, "Wrong alignment on FSHAnalyticsGameplayEventsDetails");
static_assert(sizeof(FSHAnalyticsGameplayEventsDetails) == 0x000060, "Wrong size on FSHAnalyticsGameplayEventsDetails");
static_assert(offsetof(FSHAnalyticsGameplayEventsDetails, GameFlowDetails) == 0x000000, "Member 'FSHAnalyticsGameplayEventsDetails::GameFlowDetails' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsGameplayEventsDetails, ItemCollectedDetails) == 0x000010, "Member 'FSHAnalyticsGameplayEventsDetails::ItemCollectedDetails' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsGameplayEventsDetails, RangedFireDetails) == 0x000020, "Member 'FSHAnalyticsGameplayEventsDetails::RangedFireDetails' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsGameplayEventsDetails, MeleeAttackDetails) == 0x000030, "Member 'FSHAnalyticsGameplayEventsDetails::MeleeAttackDetails' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsGameplayEventsDetails, PlayerReceivedDamageDetails) == 0x000040, "Member 'FSHAnalyticsGameplayEventsDetails::PlayerReceivedDamageDetails' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsGameplayEventsDetails, AICharacterDiedDetails) == 0x000050, "Member 'FSHAnalyticsGameplayEventsDetails::AICharacterDiedDetails' has a wrong offset!");

// ScriptStruct SHProto.SHAnalyticsGameplayRecordsDatabase
// 0x00A0 (0x00A0 - 0x0000)
struct FSHAnalyticsGameplayRecordsDatabase final
{
public:
	class FString                                 SessionStartTimeString;                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionRestoreTimeString;                          // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionEndTimeString;                              // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSHAnalyticsGameplayEvent>      Events;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FSHAnalyticsGameplayEventsDetails      Details;                                           // 0x0040(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHAnalyticsGameplayRecordsDatabase) == 0x000008, "Wrong alignment on FSHAnalyticsGameplayRecordsDatabase");
static_assert(sizeof(FSHAnalyticsGameplayRecordsDatabase) == 0x0000A0, "Wrong size on FSHAnalyticsGameplayRecordsDatabase");
static_assert(offsetof(FSHAnalyticsGameplayRecordsDatabase, SessionStartTimeString) == 0x000000, "Member 'FSHAnalyticsGameplayRecordsDatabase::SessionStartTimeString' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsGameplayRecordsDatabase, SessionRestoreTimeString) == 0x000010, "Member 'FSHAnalyticsGameplayRecordsDatabase::SessionRestoreTimeString' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsGameplayRecordsDatabase, SessionEndTimeString) == 0x000020, "Member 'FSHAnalyticsGameplayRecordsDatabase::SessionEndTimeString' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsGameplayRecordsDatabase, Events) == 0x000030, "Member 'FSHAnalyticsGameplayRecordsDatabase::Events' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsGameplayRecordsDatabase, Details) == 0x000040, "Member 'FSHAnalyticsGameplayRecordsDatabase::Details' has a wrong offset!");

// ScriptStruct SHProto.SHMapObjectDataStruct
// 0x0010 (0x0010 - 0x0000)
struct FSHMapObjectDataStruct
{
public:
	class FName                                   ObjectID;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHMapsEnum                                   Map;                                               // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHMapObjectTypeEnum                          Type;                                              // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHMapObjectDataStruct) == 0x000004, "Wrong alignment on FSHMapObjectDataStruct");
static_assert(sizeof(FSHMapObjectDataStruct) == 0x000010, "Wrong size on FSHMapObjectDataStruct");
static_assert(offsetof(FSHMapObjectDataStruct, ObjectID) == 0x000000, "Member 'FSHMapObjectDataStruct::ObjectID' has a wrong offset!");
static_assert(offsetof(FSHMapObjectDataStruct, Map) == 0x000008, "Member 'FSHMapObjectDataStruct::Map' has a wrong offset!");
static_assert(offsetof(FSHMapObjectDataStruct, Type) == 0x000009, "Member 'FSHMapObjectDataStruct::Type' has a wrong offset!");
static_assert(offsetof(FSHMapObjectDataStruct, Value) == 0x00000C, "Member 'FSHMapObjectDataStruct::Value' has a wrong offset!");

// ScriptStruct SHProto.SHElevatorOrderData
// 0x000C (0x000C - 0x0000)
struct FSHElevatorOrderData final
{
public:
	int32                                         BeginFloor;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetFloor;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrderFloorAlpha;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHElevatorOrderData) == 0x000004, "Wrong alignment on FSHElevatorOrderData");
static_assert(sizeof(FSHElevatorOrderData) == 0x00000C, "Wrong size on FSHElevatorOrderData");
static_assert(offsetof(FSHElevatorOrderData, BeginFloor) == 0x000000, "Member 'FSHElevatorOrderData::BeginFloor' has a wrong offset!");
static_assert(offsetof(FSHElevatorOrderData, TargetFloor) == 0x000004, "Member 'FSHElevatorOrderData::TargetFloor' has a wrong offset!");
static_assert(offsetof(FSHElevatorOrderData, OrderFloorAlpha) == 0x000008, "Member 'FSHElevatorOrderData::OrderFloorAlpha' has a wrong offset!");

// ScriptStruct SHProto.2DPingPongRTBinding
// 0x000C (0x000C - 0x0000)
struct FTwoDPingPongRTBinding final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RTIndex;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTwoDPingPongRTBinding) == 0x000004, "Wrong alignment on FTwoDPingPongRTBinding");
static_assert(sizeof(FTwoDPingPongRTBinding) == 0x00000C, "Wrong size on FTwoDPingPongRTBinding");
static_assert(offsetof(FTwoDPingPongRTBinding, ParameterName) == 0x000000, "Member 'FTwoDPingPongRTBinding::ParameterName' has a wrong offset!");
static_assert(offsetof(FTwoDPingPongRTBinding, RTIndex) == 0x000008, "Member 'FTwoDPingPongRTBinding::RTIndex' has a wrong offset!");

// ScriptStruct SHProto.SHWeaponMovementSet
// 0x0050 (0x0050 - 0x0000)
struct FSHWeaponMovementSet final
{
public:
	struct FSHMovementDataStruct                  EquipedMovementData;                               // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FSHMovementDataStruct                  EquipedLowHealthMovementData;                      // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHWeaponMovementSet) == 0x000008, "Wrong alignment on FSHWeaponMovementSet");
static_assert(sizeof(FSHWeaponMovementSet) == 0x000050, "Wrong size on FSHWeaponMovementSet");
static_assert(offsetof(FSHWeaponMovementSet, EquipedMovementData) == 0x000000, "Member 'FSHWeaponMovementSet::EquipedMovementData' has a wrong offset!");
static_assert(offsetof(FSHWeaponMovementSet, EquipedLowHealthMovementData) == 0x000028, "Member 'FSHWeaponMovementSet::EquipedLowHealthMovementData' has a wrong offset!");

// ScriptStruct SHProto.SHAnimBlendProfile
// 0x0030 (0x0030 - 0x0000)
struct FSHAnimBlendProfile final
{
public:
	TSoftObjectPtr<class UBlendProfile>           BlendProfile;                                      // 0x0000(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSHAnimBlendProfile) == 0x000008, "Wrong alignment on FSHAnimBlendProfile");
static_assert(sizeof(FSHAnimBlendProfile) == 0x000030, "Wrong size on FSHAnimBlendProfile");
static_assert(offsetof(FSHAnimBlendProfile, BlendProfile) == 0x000000, "Member 'FSHAnimBlendProfile::BlendProfile' has a wrong offset!");

// ScriptStruct SHProto.PlayAnimationData
// 0x00B0 (0x00B0 - 0x0000)
struct FPlayAnimationData final
{
public:
	TSoftObjectPtr<class UAnimationAsset>         Animation;                                         // 0x0000(0x0030)(Edit, BlueprintVisible, SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHAnimBlendProfile                    BlendInProfile;                                    // 0x0040(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHAnimBlendProfile                    BlendOutProfile;                                   // 0x0078(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          UseRootMotion;                                     // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RootMotionTranslationScale;                        // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayAnimationData) == 0x000008, "Wrong alignment on FPlayAnimationData");
static_assert(sizeof(FPlayAnimationData) == 0x0000B0, "Wrong size on FPlayAnimationData");
static_assert(offsetof(FPlayAnimationData, Animation) == 0x000000, "Member 'FPlayAnimationData::Animation' has a wrong offset!");
static_assert(offsetof(FPlayAnimationData, SlotName) == 0x000030, "Member 'FPlayAnimationData::SlotName' has a wrong offset!");
static_assert(offsetof(FPlayAnimationData, BlendInTime) == 0x000038, "Member 'FPlayAnimationData::BlendInTime' has a wrong offset!");
static_assert(offsetof(FPlayAnimationData, BlendInProfile) == 0x000040, "Member 'FPlayAnimationData::BlendInProfile' has a wrong offset!");
static_assert(offsetof(FPlayAnimationData, BlendOutTime) == 0x000070, "Member 'FPlayAnimationData::BlendOutTime' has a wrong offset!");
static_assert(offsetof(FPlayAnimationData, BlendOutProfile) == 0x000078, "Member 'FPlayAnimationData::BlendOutProfile' has a wrong offset!");
static_assert(offsetof(FPlayAnimationData, UseRootMotion) == 0x0000A8, "Member 'FPlayAnimationData::UseRootMotion' has a wrong offset!");
static_assert(offsetof(FPlayAnimationData, RootMotionTranslationScale) == 0x0000AC, "Member 'FPlayAnimationData::RootMotionTranslationScale' has a wrong offset!");

// ScriptStruct SHProto.SHOverrideFXData
// 0x0070 (0x0070 - 0x0000)
struct FSHOverrideFXData final
{
public:
	bool                                          bUseOverrideTraceHitFXMappings;                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USHSystemFXDataMappings> OverrideTraceHitFXMappings;                        // 0x0008(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOverrideHitFXSpawnerAkAudioEvent;              // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAkAudioEvent>           OverrideHitFXSpawnerAkAudioEvent;                  // 0x0040(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHOverrideFXData) == 0x000008, "Wrong alignment on FSHOverrideFXData");
static_assert(sizeof(FSHOverrideFXData) == 0x000070, "Wrong size on FSHOverrideFXData");
static_assert(offsetof(FSHOverrideFXData, bUseOverrideTraceHitFXMappings) == 0x000000, "Member 'FSHOverrideFXData::bUseOverrideTraceHitFXMappings' has a wrong offset!");
static_assert(offsetof(FSHOverrideFXData, OverrideTraceHitFXMappings) == 0x000008, "Member 'FSHOverrideFXData::OverrideTraceHitFXMappings' has a wrong offset!");
static_assert(offsetof(FSHOverrideFXData, bUseOverrideHitFXSpawnerAkAudioEvent) == 0x000038, "Member 'FSHOverrideFXData::bUseOverrideHitFXSpawnerAkAudioEvent' has a wrong offset!");
static_assert(offsetof(FSHOverrideFXData, OverrideHitFXSpawnerAkAudioEvent) == 0x000040, "Member 'FSHOverrideFXData::OverrideHitFXSpawnerAkAudioEvent' has a wrong offset!");

// ScriptStruct SHProto.SHCharacterPlayAttackBaseData
// 0x0188 (0x0190 - 0x0008)
struct FSHCharacterPlayAttackBaseData : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DamageTypeClass;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitCheckRadius;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitCheckAngle;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnvTraceOnlyFirstHit;                             // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnvTraceManualLocations;                          // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceEnvTrace;                                    // 0x0022(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHTraceData>                   EnvTraceLocalManualLocations;                      // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEnvTraceFromWeapon;                               // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnvTracePitch;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnvTraceLength;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayAnimationData                     AnimationData;                                     // 0x0048(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bUseSectionSwitching;                              // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraShakeBase>           HitCameraShakeClass;                               // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitCameraShakeScale;                               // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraShakeBase>           EnvHitCameraShakeClass;                            // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnvHitCameraShakeScale;                            // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHOverrideFXData                      OverrideFXData;                                    // 0x0120(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHCharacterPlayAttackBaseData) == 0x000008, "Wrong alignment on FSHCharacterPlayAttackBaseData");
static_assert(sizeof(FSHCharacterPlayAttackBaseData) == 0x000190, "Wrong size on FSHCharacterPlayAttackBaseData");
static_assert(offsetof(FSHCharacterPlayAttackBaseData, Name) == 0x000008, "Member 'FSHCharacterPlayAttackBaseData::Name' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackBaseData, DamageTypeClass) == 0x000010, "Member 'FSHCharacterPlayAttackBaseData::DamageTypeClass' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackBaseData, HitCheckRadius) == 0x000018, "Member 'FSHCharacterPlayAttackBaseData::HitCheckRadius' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackBaseData, HitCheckAngle) == 0x00001C, "Member 'FSHCharacterPlayAttackBaseData::HitCheckAngle' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackBaseData, bEnvTraceOnlyFirstHit) == 0x000020, "Member 'FSHCharacterPlayAttackBaseData::bEnvTraceOnlyFirstHit' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackBaseData, bEnvTraceManualLocations) == 0x000021, "Member 'FSHCharacterPlayAttackBaseData::bEnvTraceManualLocations' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackBaseData, bForceEnvTrace) == 0x000022, "Member 'FSHCharacterPlayAttackBaseData::bForceEnvTrace' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackBaseData, EnvTraceLocalManualLocations) == 0x000028, "Member 'FSHCharacterPlayAttackBaseData::EnvTraceLocalManualLocations' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackBaseData, bEnvTraceFromWeapon) == 0x000038, "Member 'FSHCharacterPlayAttackBaseData::bEnvTraceFromWeapon' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackBaseData, EnvTracePitch) == 0x00003C, "Member 'FSHCharacterPlayAttackBaseData::EnvTracePitch' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackBaseData, EnvTraceLength) == 0x000040, "Member 'FSHCharacterPlayAttackBaseData::EnvTraceLength' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackBaseData, AnimationData) == 0x000048, "Member 'FSHCharacterPlayAttackBaseData::AnimationData' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackBaseData, bUseSectionSwitching) == 0x0000F8, "Member 'FSHCharacterPlayAttackBaseData::bUseSectionSwitching' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackBaseData, HitCameraShakeClass) == 0x000100, "Member 'FSHCharacterPlayAttackBaseData::HitCameraShakeClass' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackBaseData, HitCameraShakeScale) == 0x000108, "Member 'FSHCharacterPlayAttackBaseData::HitCameraShakeScale' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackBaseData, EnvHitCameraShakeClass) == 0x000110, "Member 'FSHCharacterPlayAttackBaseData::EnvHitCameraShakeClass' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackBaseData, EnvHitCameraShakeScale) == 0x000118, "Member 'FSHCharacterPlayAttackBaseData::EnvHitCameraShakeScale' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackBaseData, OverrideFXData) == 0x000120, "Member 'FSHCharacterPlayAttackBaseData::OverrideFXData' has a wrong offset!");

// ScriptStruct SHProto.SHSwitchesPrioritiesMusicData
// 0x0058 (0x0058 - 0x0000)
struct FSHSwitchesPrioritiesMusicData final
{
public:
	class FName                                   SwitchesCategoryName;                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UAkSwitchValue>, int32> SwitchesPrioritiesValues;                          // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHSwitchesPrioritiesMusicData) == 0x000008, "Wrong alignment on FSHSwitchesPrioritiesMusicData");
static_assert(sizeof(FSHSwitchesPrioritiesMusicData) == 0x000058, "Wrong size on FSHSwitchesPrioritiesMusicData");
static_assert(offsetof(FSHSwitchesPrioritiesMusicData, SwitchesCategoryName) == 0x000000, "Member 'FSHSwitchesPrioritiesMusicData::SwitchesCategoryName' has a wrong offset!");
static_assert(offsetof(FSHSwitchesPrioritiesMusicData, SwitchesPrioritiesValues) == 0x000008, "Member 'FSHSwitchesPrioritiesMusicData::SwitchesPrioritiesValues' has a wrong offset!");

// ScriptStruct SHProto.SHMaterialPropertyControlHandler
// 0x00A8 (0x00A8 - 0x0000)
struct FSHMaterialPropertyControlHandler final
{
public:
	class UMaterialInstanceDynamic*               DynamicMaterial;                                   // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8[0xA0];                                       // 0x0008(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHMaterialPropertyControlHandler) == 0x000008, "Wrong alignment on FSHMaterialPropertyControlHandler");
static_assert(sizeof(FSHMaterialPropertyControlHandler) == 0x0000A8, "Wrong size on FSHMaterialPropertyControlHandler");
static_assert(offsetof(FSHMaterialPropertyControlHandler, DynamicMaterial) == 0x000000, "Member 'FSHMaterialPropertyControlHandler::DynamicMaterial' has a wrong offset!");

// ScriptStruct SHProto.SHMaterialPropertyControlData
// 0x0100 (0x0100 - 0x0000)
struct FSHMaterialPropertyControlData final
{
public:
	bool                                          bIsLayerParameter;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialParameterAssociation                 Association;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LayerIndex;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContextValueType;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeSpeed;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHMaterialPropertyControlType                Type;                                              // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             ControlFloatCurve;                                 // 0x0020(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveVector>            ControlVectorCurve;                                // 0x0050(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, TSoftObjectPtr<class UTexture>>   AssignedTexures;                                   // 0x0080(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             ControlTexureCurve;                                // 0x00D0(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHMaterialPropertyControlData) == 0x000008, "Wrong alignment on FSHMaterialPropertyControlData");
static_assert(sizeof(FSHMaterialPropertyControlData) == 0x000100, "Wrong size on FSHMaterialPropertyControlData");
static_assert(offsetof(FSHMaterialPropertyControlData, bIsLayerParameter) == 0x000000, "Member 'FSHMaterialPropertyControlData::bIsLayerParameter' has a wrong offset!");
static_assert(offsetof(FSHMaterialPropertyControlData, Association) == 0x000001, "Member 'FSHMaterialPropertyControlData::Association' has a wrong offset!");
static_assert(offsetof(FSHMaterialPropertyControlData, LayerIndex) == 0x000004, "Member 'FSHMaterialPropertyControlData::LayerIndex' has a wrong offset!");
static_assert(offsetof(FSHMaterialPropertyControlData, PropertyName) == 0x000008, "Member 'FSHMaterialPropertyControlData::PropertyName' has a wrong offset!");
static_assert(offsetof(FSHMaterialPropertyControlData, ContextValueType) == 0x000010, "Member 'FSHMaterialPropertyControlData::ContextValueType' has a wrong offset!");
static_assert(offsetof(FSHMaterialPropertyControlData, ChangeSpeed) == 0x000014, "Member 'FSHMaterialPropertyControlData::ChangeSpeed' has a wrong offset!");
static_assert(offsetof(FSHMaterialPropertyControlData, Type) == 0x000018, "Member 'FSHMaterialPropertyControlData::Type' has a wrong offset!");
static_assert(offsetof(FSHMaterialPropertyControlData, ControlFloatCurve) == 0x000020, "Member 'FSHMaterialPropertyControlData::ControlFloatCurve' has a wrong offset!");
static_assert(offsetof(FSHMaterialPropertyControlData, ControlVectorCurve) == 0x000050, "Member 'FSHMaterialPropertyControlData::ControlVectorCurve' has a wrong offset!");
static_assert(offsetof(FSHMaterialPropertyControlData, AssignedTexures) == 0x000080, "Member 'FSHMaterialPropertyControlData::AssignedTexures' has a wrong offset!");
static_assert(offsetof(FSHMaterialPropertyControlData, ControlTexureCurve) == 0x0000D0, "Member 'FSHMaterialPropertyControlData::ControlTexureCurve' has a wrong offset!");

// ScriptStruct SHProto.SHReceiveDamagePostProcessConfig
// 0x0050 (0x0050 - 0x0000)
struct FSHReceiveDamagePostProcessConfig
{
public:
	TSoftObjectPtr<class UMaterialInterface>      Material;                                          // 0x0000(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepTime;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHMaterialPropertyControlData> MaterialPropertyControlConfigs;                    // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHReceiveDamagePostProcessConfig) == 0x000008, "Wrong alignment on FSHReceiveDamagePostProcessConfig");
static_assert(sizeof(FSHReceiveDamagePostProcessConfig) == 0x000050, "Wrong size on FSHReceiveDamagePostProcessConfig");
static_assert(offsetof(FSHReceiveDamagePostProcessConfig, Material) == 0x000000, "Member 'FSHReceiveDamagePostProcessConfig::Material' has a wrong offset!");
static_assert(offsetof(FSHReceiveDamagePostProcessConfig, BlendInTime) == 0x000030, "Member 'FSHReceiveDamagePostProcessConfig::BlendInTime' has a wrong offset!");
static_assert(offsetof(FSHReceiveDamagePostProcessConfig, KeepTime) == 0x000034, "Member 'FSHReceiveDamagePostProcessConfig::KeepTime' has a wrong offset!");
static_assert(offsetof(FSHReceiveDamagePostProcessConfig, BlendOutTime) == 0x000038, "Member 'FSHReceiveDamagePostProcessConfig::BlendOutTime' has a wrong offset!");
static_assert(offsetof(FSHReceiveDamagePostProcessConfig, MaterialPropertyControlConfigs) == 0x000040, "Member 'FSHReceiveDamagePostProcessConfig::MaterialPropertyControlConfigs' has a wrong offset!");

// ScriptStruct SHProto.SHDynamicPostProcessHandler
// 0x0020 (0x0070 - 0x0050)
struct FSHDynamicPostProcessHandler final : public FSHReceiveDamagePostProcessConfig
{
public:
	class UMaterialInstanceDynamic*               MaterialDynamic;                                   // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSHMaterialPropertyControlHandler> MaterialPropertyControlHandlers;                   // 0x0058(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHDynamicPostProcessHandler) == 0x000008, "Wrong alignment on FSHDynamicPostProcessHandler");
static_assert(sizeof(FSHDynamicPostProcessHandler) == 0x000070, "Wrong size on FSHDynamicPostProcessHandler");
static_assert(offsetof(FSHDynamicPostProcessHandler, MaterialDynamic) == 0x000050, "Member 'FSHDynamicPostProcessHandler::MaterialDynamic' has a wrong offset!");
static_assert(offsetof(FSHDynamicPostProcessHandler, MaterialPropertyControlHandlers) == 0x000058, "Member 'FSHDynamicPostProcessHandler::MaterialPropertyControlHandlers' has a wrong offset!");

// ScriptStruct SHProto.SHAnimSubcompSettings
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FSHAnimSubcompSettings
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHAnimSubcompSettings) == 0x000008, "Wrong alignment on FSHAnimSubcompSettings");
static_assert(sizeof(FSHAnimSubcompSettings) == 0x000008, "Wrong size on FSHAnimSubcompSettings");

// ScriptStruct SHProto.EnviroHitReactionSettings
// 0x0028 (0x0028 - 0x0000)
struct FEnviroHitReactionSettings
{
public:
	struct FVector2D                              HitAngleThresholdMinMax;                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowedWhenWalking;                                // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowedWhenRunning;                                // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          Audio;                                             // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtBlendOutSpeed;                               // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtBlendInSpeed;                                // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnviroHitReactionSettings) == 0x000008, "Wrong alignment on FEnviroHitReactionSettings");
static_assert(sizeof(FEnviroHitReactionSettings) == 0x000028, "Wrong size on FEnviroHitReactionSettings");
static_assert(offsetof(FEnviroHitReactionSettings, HitAngleThresholdMinMax) == 0x000000, "Member 'FEnviroHitReactionSettings::HitAngleThresholdMinMax' has a wrong offset!");
static_assert(offsetof(FEnviroHitReactionSettings, AllowedWhenWalking) == 0x000010, "Member 'FEnviroHitReactionSettings::AllowedWhenWalking' has a wrong offset!");
static_assert(offsetof(FEnviroHitReactionSettings, AllowedWhenRunning) == 0x000011, "Member 'FEnviroHitReactionSettings::AllowedWhenRunning' has a wrong offset!");
static_assert(offsetof(FEnviroHitReactionSettings, Audio) == 0x000018, "Member 'FEnviroHitReactionSettings::Audio' has a wrong offset!");
static_assert(offsetof(FEnviroHitReactionSettings, LookAtBlendOutSpeed) == 0x000020, "Member 'FEnviroHitReactionSettings::LookAtBlendOutSpeed' has a wrong offset!");
static_assert(offsetof(FEnviroHitReactionSettings, LookAtBlendInSpeed) == 0x000024, "Member 'FEnviroHitReactionSettings::LookAtBlendInSpeed' has a wrong offset!");

// ScriptStruct SHProto.SHCharacterPlayAttackStruct
// 0x0038 (0x01C8 - 0x0190)
struct FSHCharacterPlayAttackStruct final : public FSHCharacterPlayAttackBaseData
{
public:
	float                                         DesiredDistanceFromEnemy;                          // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSlideDistance;                                  // 0x0194(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideDuration;                                     // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideBackDuration;                                 // 0x019C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SlideCurve;                                        // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationDuration;                                  // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RotationCurve;                                     // 0x01B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHCharacterPlayAttackCameraDataAsset*  HasTargetCameraWorkData;                           // 0x01B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHCharacterPlayAttackCameraDataAsset*  NoTargetCameraWorkData;                            // 0x01C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHCharacterPlayAttackStruct) == 0x000008, "Wrong alignment on FSHCharacterPlayAttackStruct");
static_assert(sizeof(FSHCharacterPlayAttackStruct) == 0x0001C8, "Wrong size on FSHCharacterPlayAttackStruct");
static_assert(offsetof(FSHCharacterPlayAttackStruct, DesiredDistanceFromEnemy) == 0x000190, "Member 'FSHCharacterPlayAttackStruct::DesiredDistanceFromEnemy' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackStruct, MaxSlideDistance) == 0x000194, "Member 'FSHCharacterPlayAttackStruct::MaxSlideDistance' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackStruct, SlideDuration) == 0x000198, "Member 'FSHCharacterPlayAttackStruct::SlideDuration' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackStruct, SlideBackDuration) == 0x00019C, "Member 'FSHCharacterPlayAttackStruct::SlideBackDuration' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackStruct, SlideCurve) == 0x0001A0, "Member 'FSHCharacterPlayAttackStruct::SlideCurve' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackStruct, RotationDuration) == 0x0001A8, "Member 'FSHCharacterPlayAttackStruct::RotationDuration' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackStruct, RotationCurve) == 0x0001B0, "Member 'FSHCharacterPlayAttackStruct::RotationCurve' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackStruct, HasTargetCameraWorkData) == 0x0001B8, "Member 'FSHCharacterPlayAttackStruct::HasTargetCameraWorkData' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayAttackStruct, NoTargetCameraWorkData) == 0x0001C0, "Member 'FSHCharacterPlayAttackStruct::NoTargetCameraWorkData' has a wrong offset!");

// ScriptStruct SHProto.SHCameraAnimationBlending
// 0x0020 (0x0020 - 0x0000)
struct FSHCameraAnimationBlending final
{
public:
	struct FViewTargetTransitionParams            BlendInParams;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FViewTargetTransitionParams            BlendOutParams;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHCameraAnimationBlending) == 0x000004, "Wrong alignment on FSHCameraAnimationBlending");
static_assert(sizeof(FSHCameraAnimationBlending) == 0x000020, "Wrong size on FSHCameraAnimationBlending");
static_assert(offsetof(FSHCameraAnimationBlending, BlendInParams) == 0x000000, "Member 'FSHCameraAnimationBlending::BlendInParams' has a wrong offset!");
static_assert(offsetof(FSHCameraAnimationBlending, BlendOutParams) == 0x000010, "Member 'FSHCameraAnimationBlending::BlendOutParams' has a wrong offset!");

// ScriptStruct SHProto.SHCameraAnimationData
// 0x0080 (0x0080 - 0x0000)
struct FSHCameraAnimationData final
{
public:
	TSoftClassPtr<class UClass>                   CameraAnimationExeClass;                           // 0x0000(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULevelSequence>          CameraAnimationAsset;                              // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSHCameraAnimationBlending             CameraAnimationBlending;                           // 0x0060(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHCameraAnimationData) == 0x000008, "Wrong alignment on FSHCameraAnimationData");
static_assert(sizeof(FSHCameraAnimationData) == 0x000080, "Wrong size on FSHCameraAnimationData");
static_assert(offsetof(FSHCameraAnimationData, CameraAnimationExeClass) == 0x000000, "Member 'FSHCameraAnimationData::CameraAnimationExeClass' has a wrong offset!");
static_assert(offsetof(FSHCameraAnimationData, CameraAnimationAsset) == 0x000030, "Member 'FSHCameraAnimationData::CameraAnimationAsset' has a wrong offset!");
static_assert(offsetof(FSHCameraAnimationData, CameraAnimationBlending) == 0x000060, "Member 'FSHCameraAnimationData::CameraAnimationBlending' has a wrong offset!");

// ScriptStruct SHProto.SHBreakableMeshBreakStepData
// 0x0018 (0x0018 - 0x0000)
struct FSHBreakableMeshBreakStepData final
{
public:
	bool                                          bHideWeaponHitDecal;                               // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveAttachedFXSystems;                          // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UStaticMesh>>     Meshes;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHBreakableMeshBreakStepData) == 0x000008, "Wrong alignment on FSHBreakableMeshBreakStepData");
static_assert(sizeof(FSHBreakableMeshBreakStepData) == 0x000018, "Wrong size on FSHBreakableMeshBreakStepData");
static_assert(offsetof(FSHBreakableMeshBreakStepData, bHideWeaponHitDecal) == 0x000000, "Member 'FSHBreakableMeshBreakStepData::bHideWeaponHitDecal' has a wrong offset!");
static_assert(offsetof(FSHBreakableMeshBreakStepData, bRemoveAttachedFXSystems) == 0x000001, "Member 'FSHBreakableMeshBreakStepData::bRemoveAttachedFXSystems' has a wrong offset!");
static_assert(offsetof(FSHBreakableMeshBreakStepData, Meshes) == 0x000008, "Member 'FSHBreakableMeshBreakStepData::Meshes' has a wrong offset!");

// ScriptStruct SHProto.GameOptionValueData
// 0x0060 (0x0060 - 0x0000)
struct FGameOptionValueData final
{
public:
	class FText                                   Value;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameOptionValueData) == 0x000008, "Wrong alignment on FGameOptionValueData");
static_assert(sizeof(FGameOptionValueData) == 0x000060, "Wrong size on FGameOptionValueData");
static_assert(offsetof(FGameOptionValueData, Value) == 0x000000, "Member 'FGameOptionValueData::Value' has a wrong offset!");
static_assert(offsetof(FGameOptionValueData, Description) == 0x000018, "Member 'FGameOptionValueData::Description' has a wrong offset!");
static_assert(offsetof(FGameOptionValueData, Image) == 0x000030, "Member 'FGameOptionValueData::Image' has a wrong offset!");

// ScriptStruct SHProto.SHControllerLightsSettings
// 0x0028 (0x0028 - 0x0000)
struct FSHControllerLightsSettings final
{
public:
	bool                                          bControlValueWithCurve;                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           DesiredColor;                                      // 0x0004(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           ValueCurve;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoopCurve;                                        // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHControllerLightsSettings) == 0x000008, "Wrong alignment on FSHControllerLightsSettings");
static_assert(sizeof(FSHControllerLightsSettings) == 0x000028, "Wrong size on FSHControllerLightsSettings");
static_assert(offsetof(FSHControllerLightsSettings, bControlValueWithCurve) == 0x000000, "Member 'FSHControllerLightsSettings::bControlValueWithCurve' has a wrong offset!");
static_assert(offsetof(FSHControllerLightsSettings, DesiredColor) == 0x000004, "Member 'FSHControllerLightsSettings::DesiredColor' has a wrong offset!");
static_assert(offsetof(FSHControllerLightsSettings, ValueCurve) == 0x000018, "Member 'FSHControllerLightsSettings::ValueCurve' has a wrong offset!");
static_assert(offsetof(FSHControllerLightsSettings, bLoopCurve) == 0x000020, "Member 'FSHControllerLightsSettings::bLoopCurve' has a wrong offset!");

// ScriptStruct SHProto.GameplayPresetItem
// 0x0014 (0x0014 - 0x0000)
struct FGameplayPresetItem final
{
public:
	struct FSettingOptionHandle                   Name;                                              // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESettingsPropertyType                         Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDefaultOptionValue                    Value;                                             // 0x000C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayPresetItem) == 0x000004, "Wrong alignment on FGameplayPresetItem");
static_assert(sizeof(FGameplayPresetItem) == 0x000014, "Wrong size on FGameplayPresetItem");
static_assert(offsetof(FGameplayPresetItem, Name) == 0x000000, "Member 'FGameplayPresetItem::Name' has a wrong offset!");
static_assert(offsetof(FGameplayPresetItem, Type) == 0x000008, "Member 'FGameplayPresetItem::Type' has a wrong offset!");
static_assert(offsetof(FGameplayPresetItem, Value) == 0x00000C, "Member 'FGameplayPresetItem::Value' has a wrong offset!");

// ScriptStruct SHProto.GameplayPreset
// 0x0028 (0x0028 - 0x0000)
struct FGameplayPreset final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FGameplayPresetItem>            Values;                                            // 0x0018(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayPreset) == 0x000008, "Wrong alignment on FGameplayPreset");
static_assert(sizeof(FGameplayPreset) == 0x000028, "Wrong size on FGameplayPreset");
static_assert(offsetof(FGameplayPreset, Name) == 0x000000, "Member 'FGameplayPreset::Name' has a wrong offset!");
static_assert(offsetof(FGameplayPreset, Values) == 0x000018, "Member 'FGameplayPreset::Values' has a wrong offset!");

// ScriptStruct SHProto.AngleToAnimationRangeMap
// 0x0014 (0x0014 - 0x0000)
struct FAngleToAnimationRangeMap final
{
public:
	float                                         AngleA;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleB;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAnimationTimeRange;                             // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimationTimeA;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationTimeB;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAngleToAnimationRangeMap) == 0x000004, "Wrong alignment on FAngleToAnimationRangeMap");
static_assert(sizeof(FAngleToAnimationRangeMap) == 0x000014, "Wrong size on FAngleToAnimationRangeMap");
static_assert(offsetof(FAngleToAnimationRangeMap, AngleA) == 0x000000, "Member 'FAngleToAnimationRangeMap::AngleA' has a wrong offset!");
static_assert(offsetof(FAngleToAnimationRangeMap, AngleB) == 0x000004, "Member 'FAngleToAnimationRangeMap::AngleB' has a wrong offset!");
static_assert(offsetof(FAngleToAnimationRangeMap, UseAnimationTimeRange) == 0x000008, "Member 'FAngleToAnimationRangeMap::UseAnimationTimeRange' has a wrong offset!");
static_assert(offsetof(FAngleToAnimationRangeMap, AnimationTimeA) == 0x00000C, "Member 'FAngleToAnimationRangeMap::AnimationTimeA' has a wrong offset!");
static_assert(offsetof(FAngleToAnimationRangeMap, AnimationTimeB) == 0x000010, "Member 'FAngleToAnimationRangeMap::AnimationTimeB' has a wrong offset!");

// ScriptStruct SHProto.SHTraversalObstacleHandler
// 0x01A0 (0x01A0 - 0x0000)
struct alignas(0x10) FSHTraversalObstacleHandler final
{
public:
	uint8                                         Pad_0[0x1A0];                                      // 0x0000(0x01A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHTraversalObstacleHandler) == 0x000010, "Wrong alignment on FSHTraversalObstacleHandler");
static_assert(sizeof(FSHTraversalObstacleHandler) == 0x0001A0, "Wrong size on FSHTraversalObstacleHandler");

// ScriptStruct SHProto.SHInteractionConfig
// 0x001C (0x001C - 0x0000)
struct FSHInteractionConfig
{
public:
	float                                         MouseRotationInputScale;                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PadRotationInputScale;                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementInputScale;                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseCharacterRotationScale;                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PadCharacterRotationScale;                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterMovementScale;                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHInteractionInputAxis                       InputAxis;                                         // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHInteractionConfig) == 0x000004, "Wrong alignment on FSHInteractionConfig");
static_assert(sizeof(FSHInteractionConfig) == 0x00001C, "Wrong size on FSHInteractionConfig");
static_assert(offsetof(FSHInteractionConfig, MouseRotationInputScale) == 0x000000, "Member 'FSHInteractionConfig::MouseRotationInputScale' has a wrong offset!");
static_assert(offsetof(FSHInteractionConfig, PadRotationInputScale) == 0x000004, "Member 'FSHInteractionConfig::PadRotationInputScale' has a wrong offset!");
static_assert(offsetof(FSHInteractionConfig, MovementInputScale) == 0x000008, "Member 'FSHInteractionConfig::MovementInputScale' has a wrong offset!");
static_assert(offsetof(FSHInteractionConfig, MouseCharacterRotationScale) == 0x00000C, "Member 'FSHInteractionConfig::MouseCharacterRotationScale' has a wrong offset!");
static_assert(offsetof(FSHInteractionConfig, PadCharacterRotationScale) == 0x000010, "Member 'FSHInteractionConfig::PadCharacterRotationScale' has a wrong offset!");
static_assert(offsetof(FSHInteractionConfig, CharacterMovementScale) == 0x000014, "Member 'FSHInteractionConfig::CharacterMovementScale' has a wrong offset!");
static_assert(offsetof(FSHInteractionConfig, InputAxis) == 0x000018, "Member 'FSHInteractionConfig::InputAxis' has a wrong offset!");

// ScriptStruct SHProto.SHMeatHealthValues
// 0x0010 (0x0010 - 0x0000)
struct FSHMeatHealthValues final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChunkHealth;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentHealth;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHMeatHealthValues) == 0x000004, "Wrong alignment on FSHMeatHealthValues");
static_assert(sizeof(FSHMeatHealthValues) == 0x000010, "Wrong size on FSHMeatHealthValues");
static_assert(offsetof(FSHMeatHealthValues, BoneName) == 0x000000, "Member 'FSHMeatHealthValues::BoneName' has a wrong offset!");
static_assert(offsetof(FSHMeatHealthValues, ChunkHealth) == 0x000008, "Member 'FSHMeatHealthValues::ChunkHealth' has a wrong offset!");
static_assert(offsetof(FSHMeatHealthValues, CurrentHealth) == 0x00000C, "Member 'FSHMeatHealthValues::CurrentHealth' has a wrong offset!");

// ScriptStruct SHProto.SHObstacleAnimationSet
// 0x0200 (0x0200 - 0x0000)
struct FSHObstacleAnimationSet final
{
public:
	struct FPlayAnimationData                     DefaultAnimationAbove;                             // 0x0000(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPlayAnimationData                     DefaultAnimationBelow;                             // 0x00B0(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, struct FPlayAnimationData>  WeaponsAnimationsAbove;                            // 0x0160(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, struct FPlayAnimationData>  WeaponsAnimationsBelow;                            // 0x01B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHObstacleAnimationSet) == 0x000008, "Wrong alignment on FSHObstacleAnimationSet");
static_assert(sizeof(FSHObstacleAnimationSet) == 0x000200, "Wrong size on FSHObstacleAnimationSet");
static_assert(offsetof(FSHObstacleAnimationSet, DefaultAnimationAbove) == 0x000000, "Member 'FSHObstacleAnimationSet::DefaultAnimationAbove' has a wrong offset!");
static_assert(offsetof(FSHObstacleAnimationSet, DefaultAnimationBelow) == 0x0000B0, "Member 'FSHObstacleAnimationSet::DefaultAnimationBelow' has a wrong offset!");
static_assert(offsetof(FSHObstacleAnimationSet, WeaponsAnimationsAbove) == 0x000160, "Member 'FSHObstacleAnimationSet::WeaponsAnimationsAbove' has a wrong offset!");
static_assert(offsetof(FSHObstacleAnimationSet, WeaponsAnimationsBelow) == 0x0001B0, "Member 'FSHObstacleAnimationSet::WeaponsAnimationsBelow' has a wrong offset!");

// ScriptStruct SHProto.SHCollectedItemData
// 0x000C (0x000C - 0x0000)
struct FSHCollectedItemData final
{
public:
	class FName                                   ItemRowName;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHCollectedItemData) == 0x000004, "Wrong alignment on FSHCollectedItemData");
static_assert(sizeof(FSHCollectedItemData) == 0x00000C, "Wrong size on FSHCollectedItemData");
static_assert(offsetof(FSHCollectedItemData, ItemRowName) == 0x000000, "Member 'FSHCollectedItemData::ItemRowName' has a wrong offset!");
static_assert(offsetof(FSHCollectedItemData, Quantity) == 0x000008, "Member 'FSHCollectedItemData::Quantity' has a wrong offset!");

// ScriptStruct SHProto.SHCustomMovementStruct
// 0x0040 (0x0040 - 0x0000)
struct FSHCustomMovementStruct final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Requester;                                         // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSHMovementDataStruct                  Data;                                              // 0x0018(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHCustomMovementStruct) == 0x000008, "Wrong alignment on FSHCustomMovementStruct");
static_assert(sizeof(FSHCustomMovementStruct) == 0x000040, "Wrong size on FSHCustomMovementStruct");
static_assert(offsetof(FSHCustomMovementStruct, Requester) == 0x000010, "Member 'FSHCustomMovementStruct::Requester' has a wrong offset!");
static_assert(offsetof(FSHCustomMovementStruct, Data) == 0x000018, "Member 'FSHCustomMovementStruct::Data' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionRotationConfiguration
// 0x0014 (0x0014 - 0x0000)
struct FSHHitReactionRotationConfiguration final
{
public:
	ESHHitReactionRotation                        ApplyRotation;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationDuration;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMinMaxVector2D                        YawOffset;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bReplaceCurrentRotation;                           // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHHitReactionRotationConfiguration) == 0x000004, "Wrong alignment on FSHHitReactionRotationConfiguration");
static_assert(sizeof(FSHHitReactionRotationConfiguration) == 0x000014, "Wrong size on FSHHitReactionRotationConfiguration");
static_assert(offsetof(FSHHitReactionRotationConfiguration, ApplyRotation) == 0x000000, "Member 'FSHHitReactionRotationConfiguration::ApplyRotation' has a wrong offset!");
static_assert(offsetof(FSHHitReactionRotationConfiguration, RotationDuration) == 0x000004, "Member 'FSHHitReactionRotationConfiguration::RotationDuration' has a wrong offset!");
static_assert(offsetof(FSHHitReactionRotationConfiguration, YawOffset) == 0x000008, "Member 'FSHHitReactionRotationConfiguration::YawOffset' has a wrong offset!");
static_assert(offsetof(FSHHitReactionRotationConfiguration, bReplaceCurrentRotation) == 0x000010, "Member 'FSHHitReactionRotationConfiguration::bReplaceCurrentRotation' has a wrong offset!");

// ScriptStruct SHProto.CurveWithScale
// 0x0010 (0x0010 - 0x0000)
struct FCurveWithScale
{
public:
	class UCurveFloat*                            LeanInTimeCurve;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeCurveScale;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCurveWithScale) == 0x000008, "Wrong alignment on FCurveWithScale");
static_assert(sizeof(FCurveWithScale) == 0x000010, "Wrong size on FCurveWithScale");
static_assert(offsetof(FCurveWithScale, LeanInTimeCurve) == 0x000000, "Member 'FCurveWithScale::LeanInTimeCurve' has a wrong offset!");
static_assert(offsetof(FCurveWithScale, TimeCurveScale) == 0x000008, "Member 'FCurveWithScale::TimeCurveScale' has a wrong offset!");

// ScriptStruct SHProto.EnviroFrontHitEventSettings
// 0x0058 (0x0080 - 0x0028)
struct FEnviroFrontHitEventSettings final : public FEnviroHitReactionSettings
{
public:
	float                                         ForwardLeanMaxAngle;                               // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveWithScale                        ForwardLeanAngleBlendCurve;                        // 0x0030(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BackwardLeanMaxAngle;                              // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveWithScale                        BackwardLeanAngleBlendCurve;                       // 0x0048(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          EnableCharacterPushBack;                           // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PushBackDistance;                                  // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PushBackSpeed;                                     // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x1C];                                      // 0x0064(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnviroFrontHitEventSettings) == 0x000008, "Wrong alignment on FEnviroFrontHitEventSettings");
static_assert(sizeof(FEnviroFrontHitEventSettings) == 0x000080, "Wrong size on FEnviroFrontHitEventSettings");
static_assert(offsetof(FEnviroFrontHitEventSettings, ForwardLeanMaxAngle) == 0x000028, "Member 'FEnviroFrontHitEventSettings::ForwardLeanMaxAngle' has a wrong offset!");
static_assert(offsetof(FEnviroFrontHitEventSettings, ForwardLeanAngleBlendCurve) == 0x000030, "Member 'FEnviroFrontHitEventSettings::ForwardLeanAngleBlendCurve' has a wrong offset!");
static_assert(offsetof(FEnviroFrontHitEventSettings, BackwardLeanMaxAngle) == 0x000040, "Member 'FEnviroFrontHitEventSettings::BackwardLeanMaxAngle' has a wrong offset!");
static_assert(offsetof(FEnviroFrontHitEventSettings, BackwardLeanAngleBlendCurve) == 0x000048, "Member 'FEnviroFrontHitEventSettings::BackwardLeanAngleBlendCurve' has a wrong offset!");
static_assert(offsetof(FEnviroFrontHitEventSettings, EnableCharacterPushBack) == 0x000058, "Member 'FEnviroFrontHitEventSettings::EnableCharacterPushBack' has a wrong offset!");
static_assert(offsetof(FEnviroFrontHitEventSettings, PushBackDistance) == 0x00005C, "Member 'FEnviroFrontHitEventSettings::PushBackDistance' has a wrong offset!");
static_assert(offsetof(FEnviroFrontHitEventSettings, PushBackSpeed) == 0x000060, "Member 'FEnviroFrontHitEventSettings::PushBackSpeed' has a wrong offset!");

// ScriptStruct SHProto.EnviroSideHitEventSettings
// 0x0018 (0x0040 - 0x0028)
struct FEnviroSideHitEventSettings final : public FEnviroHitReactionSettings
{
public:
	float                                         RightYawMaxAngle;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftYawMaxAngle;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCurveWithScale                        AngleBlendCurve;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnviroSideHitEventSettings) == 0x000008, "Wrong alignment on FEnviroSideHitEventSettings");
static_assert(sizeof(FEnviroSideHitEventSettings) == 0x000040, "Wrong size on FEnviroSideHitEventSettings");
static_assert(offsetof(FEnviroSideHitEventSettings, RightYawMaxAngle) == 0x000028, "Member 'FEnviroSideHitEventSettings::RightYawMaxAngle' has a wrong offset!");
static_assert(offsetof(FEnviroSideHitEventSettings, LeftYawMaxAngle) == 0x00002C, "Member 'FEnviroSideHitEventSettings::LeftYawMaxAngle' has a wrong offset!");
static_assert(offsetof(FEnviroSideHitEventSettings, AngleBlendCurve) == 0x000030, "Member 'FEnviroSideHitEventSettings::AngleBlendCurve' has a wrong offset!");

// ScriptStruct SHProto.SHAnimEnviroHitReactionsSubcompSettings
// 0x00D8 (0x00E0 - 0x0008)
struct FSHAnimEnviroHitReactionsSubcompSettings final : public FSHAnimSubcompSettings
{
public:
	class FName                                   IgnoreActorsWithTag;                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           IgnoredActorClasses;                               // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FEnviroFrontHitEventSettings           EnviroFrontHitEventSettings;                       // 0x0020(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FEnviroSideHitEventSettings            EnviroSideHitEventSettings;                        // 0x00A0(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHAnimEnviroHitReactionsSubcompSettings) == 0x000008, "Wrong alignment on FSHAnimEnviroHitReactionsSubcompSettings");
static_assert(sizeof(FSHAnimEnviroHitReactionsSubcompSettings) == 0x0000E0, "Wrong size on FSHAnimEnviroHitReactionsSubcompSettings");
static_assert(offsetof(FSHAnimEnviroHitReactionsSubcompSettings, IgnoreActorsWithTag) == 0x000008, "Member 'FSHAnimEnviroHitReactionsSubcompSettings::IgnoreActorsWithTag' has a wrong offset!");
static_assert(offsetof(FSHAnimEnviroHitReactionsSubcompSettings, IgnoredActorClasses) == 0x000010, "Member 'FSHAnimEnviroHitReactionsSubcompSettings::IgnoredActorClasses' has a wrong offset!");
static_assert(offsetof(FSHAnimEnviroHitReactionsSubcompSettings, EnviroFrontHitEventSettings) == 0x000020, "Member 'FSHAnimEnviroHitReactionsSubcompSettings::EnviroFrontHitEventSettings' has a wrong offset!");
static_assert(offsetof(FSHAnimEnviroHitReactionsSubcompSettings, EnviroSideHitEventSettings) == 0x0000A0, "Member 'FSHAnimEnviroHitReactionsSubcompSettings::EnviroSideHitEventSettings' has a wrong offset!");

// ScriptStruct SHProto.SavePointInfo
// 0x0068 (0x0070 - 0x0008)
struct FSavePointInfo final : public FTableRowBase
{
public:
	ESavePointFilterId                            Filter;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayTitle;                                      // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   MinorDisplayTitle;                                 // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0040(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavePointInfo) == 0x000008, "Wrong alignment on FSavePointInfo");
static_assert(sizeof(FSavePointInfo) == 0x000070, "Wrong size on FSavePointInfo");
static_assert(offsetof(FSavePointInfo, Filter) == 0x000008, "Member 'FSavePointInfo::Filter' has a wrong offset!");
static_assert(offsetof(FSavePointInfo, DisplayTitle) == 0x000010, "Member 'FSavePointInfo::DisplayTitle' has a wrong offset!");
static_assert(offsetof(FSavePointInfo, MinorDisplayTitle) == 0x000028, "Member 'FSavePointInfo::MinorDisplayTitle' has a wrong offset!");
static_assert(offsetof(FSavePointInfo, Image) == 0x000040, "Member 'FSavePointInfo::Image' has a wrong offset!");

// ScriptStruct SHProto.SHMovementSnapConfig
// 0x0008 (0x0008 - 0x0000)
struct FSHMovementSnapConfig final
{
public:
	float                                         RequiredDist2DToComplete;                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantStopMovementImmediatelyOnEnd;                 // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHMovementSnapConfig) == 0x000004, "Wrong alignment on FSHMovementSnapConfig");
static_assert(sizeof(FSHMovementSnapConfig) == 0x000008, "Wrong size on FSHMovementSnapConfig");
static_assert(offsetof(FSHMovementSnapConfig, RequiredDist2DToComplete) == 0x000000, "Member 'FSHMovementSnapConfig::RequiredDist2DToComplete' has a wrong offset!");
static_assert(offsetof(FSHMovementSnapConfig, bWantStopMovementImmediatelyOnEnd) == 0x000004, "Member 'FSHMovementSnapConfig::bWantStopMovementImmediatelyOnEnd' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionResultState
// 0x0018 (0x0018 - 0x0000)
struct FSHHitReactionResultState final
{
public:
	ESHHitReactionResponseType                    HitReactionType;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HitReactionVariant;                                // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StateDuration;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkipToDuration;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableAI;                                        // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableControllerRotation;                        // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHHitReactionResultState) == 0x000004, "Wrong alignment on FSHHitReactionResultState");
static_assert(sizeof(FSHHitReactionResultState) == 0x000018, "Wrong size on FSHHitReactionResultState");
static_assert(offsetof(FSHHitReactionResultState, HitReactionType) == 0x000000, "Member 'FSHHitReactionResultState::HitReactionType' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResultState, HitReactionVariant) == 0x000004, "Member 'FSHHitReactionResultState::HitReactionVariant' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResultState, StateDuration) == 0x00000C, "Member 'FSHHitReactionResultState::StateDuration' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResultState, SkipToDuration) == 0x000010, "Member 'FSHHitReactionResultState::SkipToDuration' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResultState, bDisableAI) == 0x000014, "Member 'FSHHitReactionResultState::bDisableAI' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResultState, bDisableControllerRotation) == 0x000015, "Member 'FSHHitReactionResultState::bDisableControllerRotation' has a wrong offset!");

// ScriptStruct SHProto.SHPushableHandleData
// 0x0048 (0x0048 - 0x0000)
struct FSHPushableHandleData final
{
public:
	bool                                          bIsEnabled;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RelativeLocation;                                  // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelativeDirectionAngle;                            // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IconOffset;                                        // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimSpotSecureFrontTraceDistance;                  // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHPushableHandleData) == 0x000008, "Wrong alignment on FSHPushableHandleData");
static_assert(sizeof(FSHPushableHandleData) == 0x000048, "Wrong size on FSHPushableHandleData");
static_assert(offsetof(FSHPushableHandleData, bIsEnabled) == 0x000000, "Member 'FSHPushableHandleData::bIsEnabled' has a wrong offset!");
static_assert(offsetof(FSHPushableHandleData, RelativeLocation) == 0x000008, "Member 'FSHPushableHandleData::RelativeLocation' has a wrong offset!");
static_assert(offsetof(FSHPushableHandleData, RelativeDirectionAngle) == 0x000020, "Member 'FSHPushableHandleData::RelativeDirectionAngle' has a wrong offset!");
static_assert(offsetof(FSHPushableHandleData, Width) == 0x000024, "Member 'FSHPushableHandleData::Width' has a wrong offset!");
static_assert(offsetof(FSHPushableHandleData, IconOffset) == 0x000028, "Member 'FSHPushableHandleData::IconOffset' has a wrong offset!");
static_assert(offsetof(FSHPushableHandleData, AnimSpotSecureFrontTraceDistance) == 0x000040, "Member 'FSHPushableHandleData::AnimSpotSecureFrontTraceDistance' has a wrong offset!");

// ScriptStruct SHProto.SHManagedInteractionSlotCleanupConfig
// 0x0014 (0x0014 - 0x0000)
struct FSHManagedInteractionSlotCleanupConfig final
{
public:
	float                                         SimpleCleanupDelay;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CleanupTargetRotationScale;                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CleanupMaxRotationAngleDifference;                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CleanupTargetMovementScale;                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CleanupMaxMovementAngleDifference;                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHManagedInteractionSlotCleanupConfig) == 0x000004, "Wrong alignment on FSHManagedInteractionSlotCleanupConfig");
static_assert(sizeof(FSHManagedInteractionSlotCleanupConfig) == 0x000014, "Wrong size on FSHManagedInteractionSlotCleanupConfig");
static_assert(offsetof(FSHManagedInteractionSlotCleanupConfig, SimpleCleanupDelay) == 0x000000, "Member 'FSHManagedInteractionSlotCleanupConfig::SimpleCleanupDelay' has a wrong offset!");
static_assert(offsetof(FSHManagedInteractionSlotCleanupConfig, CleanupTargetRotationScale) == 0x000004, "Member 'FSHManagedInteractionSlotCleanupConfig::CleanupTargetRotationScale' has a wrong offset!");
static_assert(offsetof(FSHManagedInteractionSlotCleanupConfig, CleanupMaxRotationAngleDifference) == 0x000008, "Member 'FSHManagedInteractionSlotCleanupConfig::CleanupMaxRotationAngleDifference' has a wrong offset!");
static_assert(offsetof(FSHManagedInteractionSlotCleanupConfig, CleanupTargetMovementScale) == 0x00000C, "Member 'FSHManagedInteractionSlotCleanupConfig::CleanupTargetMovementScale' has a wrong offset!");
static_assert(offsetof(FSHManagedInteractionSlotCleanupConfig, CleanupMaxMovementAngleDifference) == 0x000010, "Member 'FSHManagedInteractionSlotCleanupConfig::CleanupMaxMovementAngleDifference' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionStateConfiguration
// 0x000C (0x000C - 0x0000)
struct FSHHitReactionStateConfiguration final
{
public:
	struct FMinMaxVector2D                        StateDuration;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDisableAI;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableControllerRotation;                        // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHHitReactionStateConfiguration) == 0x000004, "Wrong alignment on FSHHitReactionStateConfiguration");
static_assert(sizeof(FSHHitReactionStateConfiguration) == 0x00000C, "Wrong size on FSHHitReactionStateConfiguration");
static_assert(offsetof(FSHHitReactionStateConfiguration, StateDuration) == 0x000000, "Member 'FSHHitReactionStateConfiguration::StateDuration' has a wrong offset!");
static_assert(offsetof(FSHHitReactionStateConfiguration, bDisableAI) == 0x000008, "Member 'FSHHitReactionStateConfiguration::bDisableAI' has a wrong offset!");
static_assert(offsetof(FSHHitReactionStateConfiguration, bDisableControllerRotation) == 0x000009, "Member 'FSHHitReactionStateConfiguration::bDisableControllerRotation' has a wrong offset!");

// ScriptStruct SHProto.2DPingPongPass
// 0x00B0 (0x00B0 - 0x0000)
struct FTwoDPingPongPass final
{
public:
	int32                                         TargetIndex;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Clear;                                             // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClearAtBeginPlay;                                  // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0xA];                                        // 0x0006(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               ClearColor;                                        // 0x0010(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_DTParameterName : 1;                     // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DTParameterName;                                   // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_TimeParameterName : 1;                   // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TimeParameterName;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_FrameIndexName : 1;                      // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FrameIndexNameName;                                // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     Material;                                          // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               DynamicMaterial;                                   // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTwoDPingPongRTBinding>         RTBindings;                                        // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCanvasUVTri>                   Triangles;                                         // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UCanvas*                                Canvas[0x2];                                       // 0x0088(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x18];                                      // 0x0098(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTwoDPingPongPass) == 0x000010, "Wrong alignment on FTwoDPingPongPass");
static_assert(sizeof(FTwoDPingPongPass) == 0x0000B0, "Wrong size on FTwoDPingPongPass");
static_assert(offsetof(FTwoDPingPongPass, TargetIndex) == 0x000000, "Member 'FTwoDPingPongPass::TargetIndex' has a wrong offset!");
static_assert(offsetof(FTwoDPingPongPass, Clear) == 0x000004, "Member 'FTwoDPingPongPass::Clear' has a wrong offset!");
static_assert(offsetof(FTwoDPingPongPass, ClearAtBeginPlay) == 0x000005, "Member 'FTwoDPingPongPass::ClearAtBeginPlay' has a wrong offset!");
static_assert(offsetof(FTwoDPingPongPass, ClearColor) == 0x000010, "Member 'FTwoDPingPongPass::ClearColor' has a wrong offset!");
static_assert(offsetof(FTwoDPingPongPass, DTParameterName) == 0x000034, "Member 'FTwoDPingPongPass::DTParameterName' has a wrong offset!");
static_assert(offsetof(FTwoDPingPongPass, TimeParameterName) == 0x000040, "Member 'FTwoDPingPongPass::TimeParameterName' has a wrong offset!");
static_assert(offsetof(FTwoDPingPongPass, FrameIndexNameName) == 0x00004C, "Member 'FTwoDPingPongPass::FrameIndexNameName' has a wrong offset!");
static_assert(offsetof(FTwoDPingPongPass, Material) == 0x000058, "Member 'FTwoDPingPongPass::Material' has a wrong offset!");
static_assert(offsetof(FTwoDPingPongPass, DynamicMaterial) == 0x000060, "Member 'FTwoDPingPongPass::DynamicMaterial' has a wrong offset!");
static_assert(offsetof(FTwoDPingPongPass, RTBindings) == 0x000068, "Member 'FTwoDPingPongPass::RTBindings' has a wrong offset!");
static_assert(offsetof(FTwoDPingPongPass, Triangles) == 0x000078, "Member 'FTwoDPingPongPass::Triangles' has a wrong offset!");
static_assert(offsetof(FTwoDPingPongPass, Canvas) == 0x000088, "Member 'FTwoDPingPongPass::Canvas' has a wrong offset!");

// ScriptStruct SHProto.SHInteractionGenericConfig
// 0x0034 (0x0050 - 0x001C)
struct FSHInteractionGenericConfig final : public FSHInteractionConfig
{
public:
	bool                                          EnableCharacterLookAt;                             // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   LookAtTypeID;                                      // 0x0020(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHInteractionGenericConfig) == 0x000008, "Wrong alignment on FSHInteractionGenericConfig");
static_assert(sizeof(FSHInteractionGenericConfig) == 0x000050, "Wrong size on FSHInteractionGenericConfig");
static_assert(offsetof(FSHInteractionGenericConfig, EnableCharacterLookAt) == 0x00001C, "Member 'FSHInteractionGenericConfig::EnableCharacterLookAt' has a wrong offset!");
static_assert(offsetof(FSHInteractionGenericConfig, LookAtTypeID) == 0x000020, "Member 'FSHInteractionGenericConfig::LookAtTypeID' has a wrong offset!");

// ScriptStruct SHProto.SHMaterialPropertyDirtSet
// 0x0020 (0x0020 - 0x0000)
struct FSHMaterialPropertyDirtSet final
{
public:
	ESHFXDirtState                                CurrentDirtState;                                  // 0x0000(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               MaterialDynamic;                                   // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSHMaterialPropertyControlHandler> MaterialPropertyHandlers;                          // 0x0010(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSHMaterialPropertyDirtSet) == 0x000008, "Wrong alignment on FSHMaterialPropertyDirtSet");
static_assert(sizeof(FSHMaterialPropertyDirtSet) == 0x000020, "Wrong size on FSHMaterialPropertyDirtSet");
static_assert(offsetof(FSHMaterialPropertyDirtSet, CurrentDirtState) == 0x000000, "Member 'FSHMaterialPropertyDirtSet::CurrentDirtState' has a wrong offset!");
static_assert(offsetof(FSHMaterialPropertyDirtSet, MaterialDynamic) == 0x000008, "Member 'FSHMaterialPropertyDirtSet::MaterialDynamic' has a wrong offset!");
static_assert(offsetof(FSHMaterialPropertyDirtSet, MaterialPropertyHandlers) == 0x000010, "Member 'FSHMaterialPropertyDirtSet::MaterialPropertyHandlers' has a wrong offset!");

// ScriptStruct SHProto.SHPOVDetectorProximityPoints
// 0x0010 (0x0010 - 0x0000)
struct FSHPOVDetectorProximityPoints final
{
public:
	TArray<class USceneComponent*>                Points;                                            // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHPOVDetectorProximityPoints) == 0x000008, "Wrong alignment on FSHPOVDetectorProximityPoints");
static_assert(sizeof(FSHPOVDetectorProximityPoints) == 0x000010, "Wrong size on FSHPOVDetectorProximityPoints");
static_assert(offsetof(FSHPOVDetectorProximityPoints, Points) == 0x000000, "Member 'FSHPOVDetectorProximityPoints::Points' has a wrong offset!");

// ScriptStruct SHProto.SHTraversalObstacleExtendedAnimationSet
// 0x02C0 (0x02C0 - 0x0000)
struct FSHTraversalObstacleExtendedAnimationSet final
{
public:
	struct FPlayAnimationData                     StartAnimation;                                    // 0x0000(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPlayAnimationData                     FailAnimation;                                     // 0x00B0(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPlayAnimationData                     SuccessAnimation;                                  // 0x0160(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPlayAnimationData                     EndAnimation;                                      // 0x0210(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHTraversalObstacleExtendedAnimationSet) == 0x000008, "Wrong alignment on FSHTraversalObstacleExtendedAnimationSet");
static_assert(sizeof(FSHTraversalObstacleExtendedAnimationSet) == 0x0002C0, "Wrong size on FSHTraversalObstacleExtendedAnimationSet");
static_assert(offsetof(FSHTraversalObstacleExtendedAnimationSet, StartAnimation) == 0x000000, "Member 'FSHTraversalObstacleExtendedAnimationSet::StartAnimation' has a wrong offset!");
static_assert(offsetof(FSHTraversalObstacleExtendedAnimationSet, FailAnimation) == 0x0000B0, "Member 'FSHTraversalObstacleExtendedAnimationSet::FailAnimation' has a wrong offset!");
static_assert(offsetof(FSHTraversalObstacleExtendedAnimationSet, SuccessAnimation) == 0x000160, "Member 'FSHTraversalObstacleExtendedAnimationSet::SuccessAnimation' has a wrong offset!");
static_assert(offsetof(FSHTraversalObstacleExtendedAnimationSet, EndAnimation) == 0x000210, "Member 'FSHTraversalObstacleExtendedAnimationSet::EndAnimation' has a wrong offset!");

// ScriptStruct SHProto.SHFleshLipCeilingActorHangingTileDropChances
// 0x0010 (0x0010 - 0x0000)
struct FSHFleshLipCeilingActorHangingTileDropChances final
{
public:
	float                                         FourSideChance;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThreeSideChance;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OppositeTwoSideChance;                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiagonalTwoSideChance;                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSHFleshLipCeilingActorHangingTileDropChances) == 0x000004, "Wrong alignment on FSHFleshLipCeilingActorHangingTileDropChances");
static_assert(sizeof(FSHFleshLipCeilingActorHangingTileDropChances) == 0x000010, "Wrong size on FSHFleshLipCeilingActorHangingTileDropChances");
static_assert(offsetof(FSHFleshLipCeilingActorHangingTileDropChances, FourSideChance) == 0x000000, "Member 'FSHFleshLipCeilingActorHangingTileDropChances::FourSideChance' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingActorHangingTileDropChances, ThreeSideChance) == 0x000004, "Member 'FSHFleshLipCeilingActorHangingTileDropChances::ThreeSideChance' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingActorHangingTileDropChances, OppositeTwoSideChance) == 0x000008, "Member 'FSHFleshLipCeilingActorHangingTileDropChances::OppositeTwoSideChance' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingActorHangingTileDropChances, DiagonalTwoSideChance) == 0x00000C, "Member 'FSHFleshLipCeilingActorHangingTileDropChances::DiagonalTwoSideChance' has a wrong offset!");

// ScriptStruct SHProto.SHFleshLipCeilingActorHangingTileDropChancesPerType
// 0x0030 (0x0030 - 0x0000)
struct FSHFleshLipCeilingActorHangingTileDropChancesPerType final
{
public:
	struct FSHFleshLipCeilingActorHangingTileDropChances MiddleTileDropChances;                             // 0x0000(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSHFleshLipCeilingActorHangingTileDropChances EdgeTileDropChances;                               // 0x0010(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSHFleshLipCeilingActorHangingTileDropChances CornerTileDropChances;                             // 0x0020(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSHFleshLipCeilingActorHangingTileDropChancesPerType) == 0x000004, "Wrong alignment on FSHFleshLipCeilingActorHangingTileDropChancesPerType");
static_assert(sizeof(FSHFleshLipCeilingActorHangingTileDropChancesPerType) == 0x000030, "Wrong size on FSHFleshLipCeilingActorHangingTileDropChancesPerType");
static_assert(offsetof(FSHFleshLipCeilingActorHangingTileDropChancesPerType, MiddleTileDropChances) == 0x000000, "Member 'FSHFleshLipCeilingActorHangingTileDropChancesPerType::MiddleTileDropChances' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingActorHangingTileDropChancesPerType, EdgeTileDropChances) == 0x000010, "Member 'FSHFleshLipCeilingActorHangingTileDropChancesPerType::EdgeTileDropChances' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingActorHangingTileDropChancesPerType, CornerTileDropChances) == 0x000020, "Member 'FSHFleshLipCeilingActorHangingTileDropChancesPerType::CornerTileDropChances' has a wrong offset!");

// ScriptStruct SHProto.SHAnalyticsPerormanceData
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x04) FSHAnalyticsPerormanceData final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHAnalyticsPerormanceData) == 0x000004, "Wrong alignment on FSHAnalyticsPerormanceData");
static_assert(sizeof(FSHAnalyticsPerormanceData) == 0x000028, "Wrong size on FSHAnalyticsPerormanceData");

// ScriptStruct SHProto.SHNamedMaterialParameter
// 0x0030 (0x0030 - 0x0000)
struct FSHNamedMaterialParameter final
{
public:
	bool                                          Valid;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x000C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LastKnownValue;                                    // 0x001C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHNamedMaterialParameter) == 0x000004, "Wrong alignment on FSHNamedMaterialParameter");
static_assert(sizeof(FSHNamedMaterialParameter) == 0x000030, "Wrong size on FSHNamedMaterialParameter");
static_assert(offsetof(FSHNamedMaterialParameter, Valid) == 0x000000, "Member 'FSHNamedMaterialParameter::Valid' has a wrong offset!");
static_assert(offsetof(FSHNamedMaterialParameter, Name) == 0x000004, "Member 'FSHNamedMaterialParameter::Name' has a wrong offset!");
static_assert(offsetof(FSHNamedMaterialParameter, Value) == 0x00000C, "Member 'FSHNamedMaterialParameter::Value' has a wrong offset!");
static_assert(offsetof(FSHNamedMaterialParameter, LastKnownValue) == 0x00001C, "Member 'FSHNamedMaterialParameter::LastKnownValue' has a wrong offset!");
static_assert(offsetof(FSHNamedMaterialParameter, Index) == 0x00002C, "Member 'FSHNamedMaterialParameter::Index' has a wrong offset!");

// ScriptStruct SHProto.SHFlickerMaterial
// 0x00C8 (0x00C8 - 0x0000)
struct FSHFlickerMaterial final
{
public:
	class UMaterialInstanceDynamic*               Mid;                                               // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSHNamedMaterialParameter              TintEmission0;                                     // 0x0008(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FSHNamedMaterialParameter              VertexColorEmissiveTint;                           // 0x0038(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FSHNamedMaterialParameter              VertexColorEmissiveIntensity;                      // 0x0068(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FSHNamedMaterialParameter              AOFactor;                                          // 0x0098(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHFlickerMaterial) == 0x000008, "Wrong alignment on FSHFlickerMaterial");
static_assert(sizeof(FSHFlickerMaterial) == 0x0000C8, "Wrong size on FSHFlickerMaterial");
static_assert(offsetof(FSHFlickerMaterial, Mid) == 0x000000, "Member 'FSHFlickerMaterial::Mid' has a wrong offset!");
static_assert(offsetof(FSHFlickerMaterial, TintEmission0) == 0x000008, "Member 'FSHFlickerMaterial::TintEmission0' has a wrong offset!");
static_assert(offsetof(FSHFlickerMaterial, VertexColorEmissiveTint) == 0x000038, "Member 'FSHFlickerMaterial::VertexColorEmissiveTint' has a wrong offset!");
static_assert(offsetof(FSHFlickerMaterial, VertexColorEmissiveIntensity) == 0x000068, "Member 'FSHFlickerMaterial::VertexColorEmissiveIntensity' has a wrong offset!");
static_assert(offsetof(FSHFlickerMaterial, AOFactor) == 0x000098, "Member 'FSHFlickerMaterial::AOFactor' has a wrong offset!");

// ScriptStruct SHProto.SHAnalyticsPerformanceRecordsDatabase
// 0x0070 (0x0070 - 0x0000)
struct FSHAnalyticsPerformanceRecordsDatabase final
{
public:
	class FString                                 SessionStartTimeString;                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              SessionStartTime;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionEndTimeString;                              // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlatformString;                                    // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              Resolution;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERaytracing                                   Raytracing;                                        // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicResolution                            DynRes;                                            // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGFXQuality                                   Quality;                                           // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         LevelNames;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	int32                                         BuildVersion;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHAnalyticsPerormanceData>     Data;                                              // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHAnalyticsPerformanceRecordsDatabase) == 0x000008, "Wrong alignment on FSHAnalyticsPerformanceRecordsDatabase");
static_assert(sizeof(FSHAnalyticsPerformanceRecordsDatabase) == 0x000070, "Wrong size on FSHAnalyticsPerformanceRecordsDatabase");
static_assert(offsetof(FSHAnalyticsPerformanceRecordsDatabase, SessionStartTimeString) == 0x000000, "Member 'FSHAnalyticsPerformanceRecordsDatabase::SessionStartTimeString' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsPerformanceRecordsDatabase, SessionStartTime) == 0x000010, "Member 'FSHAnalyticsPerformanceRecordsDatabase::SessionStartTime' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsPerformanceRecordsDatabase, SessionEndTimeString) == 0x000018, "Member 'FSHAnalyticsPerformanceRecordsDatabase::SessionEndTimeString' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsPerformanceRecordsDatabase, PlatformString) == 0x000028, "Member 'FSHAnalyticsPerformanceRecordsDatabase::PlatformString' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsPerformanceRecordsDatabase, Resolution) == 0x000038, "Member 'FSHAnalyticsPerformanceRecordsDatabase::Resolution' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsPerformanceRecordsDatabase, Raytracing) == 0x000040, "Member 'FSHAnalyticsPerformanceRecordsDatabase::Raytracing' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsPerformanceRecordsDatabase, DynRes) == 0x000041, "Member 'FSHAnalyticsPerformanceRecordsDatabase::DynRes' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsPerformanceRecordsDatabase, Quality) == 0x000042, "Member 'FSHAnalyticsPerformanceRecordsDatabase::Quality' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsPerformanceRecordsDatabase, LevelNames) == 0x000048, "Member 'FSHAnalyticsPerformanceRecordsDatabase::LevelNames' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsPerformanceRecordsDatabase, BuildVersion) == 0x000058, "Member 'FSHAnalyticsPerformanceRecordsDatabase::BuildVersion' has a wrong offset!");
static_assert(offsetof(FSHAnalyticsPerformanceRecordsDatabase, Data) == 0x000060, "Member 'FSHAnalyticsPerformanceRecordsDatabase::Data' has a wrong offset!");

// ScriptStruct SHProto.SkeletonHierarchy
// 0x0108 (0x0108 - 0x0000)
struct alignas(0x08) FSkeletonHierarchy
{
public:
	uint8                                         Pad_0[0x108];                                      // 0x0000(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkeletonHierarchy) == 0x000008, "Wrong alignment on FSkeletonHierarchy");
static_assert(sizeof(FSkeletonHierarchy) == 0x000108, "Wrong size on FSkeletonHierarchy");

// ScriptStruct SHProto.SHMariaSkeletonHierarchy
// 0x0000 (0x0108 - 0x0108)
struct FSHMariaSkeletonHierarchy final : public FSkeletonHierarchy
{
};
static_assert(alignof(FSHMariaSkeletonHierarchy) == 0x000008, "Wrong alignment on FSHMariaSkeletonHierarchy");
static_assert(sizeof(FSHMariaSkeletonHierarchy) == 0x000108, "Wrong size on FSHMariaSkeletonHierarchy");

// ScriptStruct SHProto.GameOptionsData
// 0x00A0 (0x00A0 - 0x0000)
struct FGameOptionsData final
{
public:
	EGameOptions                                  Name;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FText                                   InactiveDescription;                               // 0x0038(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FGameOptionValueData>           Values;                                            // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 RemapValues;                                       // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0070(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameOptionsData) == 0x000008, "Wrong alignment on FGameOptionsData");
static_assert(sizeof(FGameOptionsData) == 0x0000A0, "Wrong size on FGameOptionsData");
static_assert(offsetof(FGameOptionsData, Name) == 0x000000, "Member 'FGameOptionsData::Name' has a wrong offset!");
static_assert(offsetof(FGameOptionsData, DisplayName) == 0x000008, "Member 'FGameOptionsData::DisplayName' has a wrong offset!");
static_assert(offsetof(FGameOptionsData, Description) == 0x000020, "Member 'FGameOptionsData::Description' has a wrong offset!");
static_assert(offsetof(FGameOptionsData, InactiveDescription) == 0x000038, "Member 'FGameOptionsData::InactiveDescription' has a wrong offset!");
static_assert(offsetof(FGameOptionsData, Values) == 0x000050, "Member 'FGameOptionsData::Values' has a wrong offset!");
static_assert(offsetof(FGameOptionsData, RemapValues) == 0x000060, "Member 'FGameOptionsData::RemapValues' has a wrong offset!");
static_assert(offsetof(FGameOptionsData, Image) == 0x000070, "Member 'FGameOptionsData::Image' has a wrong offset!");

// ScriptStruct SHProto.SHAsyncLoadingObjectCache
// 0x00B8 (0x00B8 - 0x0000)
struct alignas(0x08) FSHAsyncLoadingObjectCache final
{
public:
	uint8                                         Pad_0[0xB8];                                       // 0x0000(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHAsyncLoadingObjectCache) == 0x000008, "Wrong alignment on FSHAsyncLoadingObjectCache");
static_assert(sizeof(FSHAsyncLoadingObjectCache) == 0x0000B8, "Wrong size on FSHAsyncLoadingObjectCache");

// ScriptStruct SHProto.SHBlendData
// 0x0020 (0x0020 - 0x0000)
struct FSHBlendData final
{
public:
	float                                         BlendInTime;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BlendInAlphaCurve;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BlendOutAlphaCurve;                                // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHBlendData) == 0x000008, "Wrong alignment on FSHBlendData");
static_assert(sizeof(FSHBlendData) == 0x000020, "Wrong size on FSHBlendData");
static_assert(offsetof(FSHBlendData, BlendInTime) == 0x000000, "Member 'FSHBlendData::BlendInTime' has a wrong offset!");
static_assert(offsetof(FSHBlendData, BlendInAlphaCurve) == 0x000008, "Member 'FSHBlendData::BlendInAlphaCurve' has a wrong offset!");
static_assert(offsetof(FSHBlendData, BlendOutTime) == 0x000010, "Member 'FSHBlendData::BlendOutTime' has a wrong offset!");
static_assert(offsetof(FSHBlendData, BlendOutAlphaCurve) == 0x000018, "Member 'FSHBlendData::BlendOutAlphaCurve' has a wrong offset!");

// ScriptStruct SHProto.SHFlashlightMainLightOffsetBlendData
// 0x0038 (0x0038 - 0x0000)
struct FSHFlashlightMainLightOffsetBlendData final
{
public:
	struct FSHBlendData                           BlendData;                                         // 0x0000(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                MainLightOffsetValue;                              // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHFlashlightMainLightOffsetBlendData) == 0x000008, "Wrong alignment on FSHFlashlightMainLightOffsetBlendData");
static_assert(sizeof(FSHFlashlightMainLightOffsetBlendData) == 0x000038, "Wrong size on FSHFlashlightMainLightOffsetBlendData");
static_assert(offsetof(FSHFlashlightMainLightOffsetBlendData, BlendData) == 0x000000, "Member 'FSHFlashlightMainLightOffsetBlendData::BlendData' has a wrong offset!");
static_assert(offsetof(FSHFlashlightMainLightOffsetBlendData, MainLightOffsetValue) == 0x000020, "Member 'FSHFlashlightMainLightOffsetBlendData::MainLightOffsetValue' has a wrong offset!");

// ScriptStruct SHProto.SHAsyncLoadedObjectCache
// 0x0048 (0x0048 - 0x0000)
struct FSHAsyncLoadedObjectCache final
{
public:
	class UObject*                                StrongObject;                                      // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x40];                                       // 0x0008(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHAsyncLoadedObjectCache) == 0x000008, "Wrong alignment on FSHAsyncLoadedObjectCache");
static_assert(sizeof(FSHAsyncLoadedObjectCache) == 0x000048, "Wrong size on FSHAsyncLoadedObjectCache");
static_assert(offsetof(FSHAsyncLoadedObjectCache, StrongObject) == 0x000000, "Member 'FSHAsyncLoadedObjectCache::StrongObject' has a wrong offset!");

// ScriptStruct SHProto.CollisionShapeProperty
// 0x0010 (0x0010 - 0x0000)
struct FCollisionShapeProperty final
{
public:
	ECollisionShapePropertyType                   CollisionShapeType;                                // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Parameter1;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Parameter2;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Parameter3;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollisionShapeProperty) == 0x000004, "Wrong alignment on FCollisionShapeProperty");
static_assert(sizeof(FCollisionShapeProperty) == 0x000010, "Wrong size on FCollisionShapeProperty");
static_assert(offsetof(FCollisionShapeProperty, CollisionShapeType) == 0x000000, "Member 'FCollisionShapeProperty::CollisionShapeType' has a wrong offset!");
static_assert(offsetof(FCollisionShapeProperty, Parameter1) == 0x000004, "Member 'FCollisionShapeProperty::Parameter1' has a wrong offset!");
static_assert(offsetof(FCollisionShapeProperty, Parameter2) == 0x000008, "Member 'FCollisionShapeProperty::Parameter2' has a wrong offset!");
static_assert(offsetof(FCollisionShapeProperty, Parameter3) == 0x00000C, "Member 'FCollisionShapeProperty::Parameter3' has a wrong offset!");

// ScriptStruct SHProto.SHMovementSnapOperation
// 0x00C0 (0x00C0 - 0x0000)
struct alignas(0x08) FSHMovementSnapOperation final
{
public:
	uint8                                         Pad_0[0xC0];                                       // 0x0000(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHMovementSnapOperation) == 0x000008, "Wrong alignment on FSHMovementSnapOperation");
static_assert(sizeof(FSHMovementSnapOperation) == 0x0000C0, "Wrong size on FSHMovementSnapOperation");

// ScriptStruct SHProto.ConstraintMotorBlender
// 0x0028 (0x0028 - 0x0000)
struct FConstraintMotorBlender final
{
public:
	bool                                          bIsActive;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Constraints;                                       // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         StrengthOnStart;                                   // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeMultiplier;                                    // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeNormal;                                        // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConstraintMotorBlender) == 0x000008, "Wrong alignment on FConstraintMotorBlender");
static_assert(sizeof(FConstraintMotorBlender) == 0x000028, "Wrong size on FConstraintMotorBlender");
static_assert(offsetof(FConstraintMotorBlender, bIsActive) == 0x000000, "Member 'FConstraintMotorBlender::bIsActive' has a wrong offset!");
static_assert(offsetof(FConstraintMotorBlender, Constraints) == 0x000008, "Member 'FConstraintMotorBlender::Constraints' has a wrong offset!");
static_assert(offsetof(FConstraintMotorBlender, StrengthOnStart) == 0x000018, "Member 'FConstraintMotorBlender::StrengthOnStart' has a wrong offset!");
static_assert(offsetof(FConstraintMotorBlender, Strength) == 0x00001C, "Member 'FConstraintMotorBlender::Strength' has a wrong offset!");
static_assert(offsetof(FConstraintMotorBlender, TimeMultiplier) == 0x000020, "Member 'FConstraintMotorBlender::TimeMultiplier' has a wrong offset!");
static_assert(offsetof(FConstraintMotorBlender, TimeNormal) == 0x000024, "Member 'FConstraintMotorBlender::TimeNormal' has a wrong offset!");

// ScriptStruct SHProto.UE4KeyRichText
// 0x0030 (0x0030 - 0x0000)
struct FUE4KeyRichText final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   RichText;                                          // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUE4KeyRichText) == 0x000008, "Wrong alignment on FUE4KeyRichText");
static_assert(sizeof(FUE4KeyRichText) == 0x000030, "Wrong size on FUE4KeyRichText");
static_assert(offsetof(FUE4KeyRichText, Key) == 0x000000, "Member 'FUE4KeyRichText::Key' has a wrong offset!");
static_assert(offsetof(FUE4KeyRichText, RichText) == 0x000018, "Member 'FUE4KeyRichText::RichText' has a wrong offset!");

// ScriptStruct SHProto.SHNurseSkeletonHierarchy
// 0x0000 (0x0108 - 0x0108)
struct FSHNurseSkeletonHierarchy final : public FSkeletonHierarchy
{
};
static_assert(alignof(FSHNurseSkeletonHierarchy) == 0x000008, "Wrong alignment on FSHNurseSkeletonHierarchy");
static_assert(sizeof(FSHNurseSkeletonHierarchy) == 0x000108, "Wrong size on FSHNurseSkeletonHierarchy");

// ScriptStruct SHProto.LoadingHint
// 0x0038 (0x0038 - 0x0000)
struct FLoadingHint final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FUE4InputHandle>                Actions;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           AllowedSavePoints;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingHint) == 0x000008, "Wrong alignment on FLoadingHint");
static_assert(sizeof(FLoadingHint) == 0x000038, "Wrong size on FLoadingHint");
static_assert(offsetof(FLoadingHint, Text) == 0x000000, "Member 'FLoadingHint::Text' has a wrong offset!");
static_assert(offsetof(FLoadingHint, Actions) == 0x000018, "Member 'FLoadingHint::Actions' has a wrong offset!");
static_assert(offsetof(FLoadingHint, AllowedSavePoints) == 0x000028, "Member 'FLoadingHint::AllowedSavePoints' has a wrong offset!");

// ScriptStruct SHProto.PhysicalAnimationProfileData
// 0x0038 (0x0038 - 0x0000)
struct FPhysicalAnimationProfileData final
{
public:
	class FName                                   PhysicalAnimationProfile;                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConstraintProfile;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGravity;                                    // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PhysicWeightAtStart;                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicWeight;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BlendCurve;                                        // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EBones>                                Bones;                                             // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhysicalAnimationProfileData) == 0x000008, "Wrong alignment on FPhysicalAnimationProfileData");
static_assert(sizeof(FPhysicalAnimationProfileData) == 0x000038, "Wrong size on FPhysicalAnimationProfileData");
static_assert(offsetof(FPhysicalAnimationProfileData, PhysicalAnimationProfile) == 0x000000, "Member 'FPhysicalAnimationProfileData::PhysicalAnimationProfile' has a wrong offset!");
static_assert(offsetof(FPhysicalAnimationProfileData, ConstraintProfile) == 0x000008, "Member 'FPhysicalAnimationProfileData::ConstraintProfile' has a wrong offset!");
static_assert(offsetof(FPhysicalAnimationProfileData, bEnableGravity) == 0x000010, "Member 'FPhysicalAnimationProfileData::bEnableGravity' has a wrong offset!");
static_assert(offsetof(FPhysicalAnimationProfileData, PhysicWeightAtStart) == 0x000014, "Member 'FPhysicalAnimationProfileData::PhysicWeightAtStart' has a wrong offset!");
static_assert(offsetof(FPhysicalAnimationProfileData, PhysicWeight) == 0x000018, "Member 'FPhysicalAnimationProfileData::PhysicWeight' has a wrong offset!");
static_assert(offsetof(FPhysicalAnimationProfileData, BlendCurve) == 0x000020, "Member 'FPhysicalAnimationProfileData::BlendCurve' has a wrong offset!");
static_assert(offsetof(FPhysicalAnimationProfileData, Bones) == 0x000028, "Member 'FPhysicalAnimationProfileData::Bones' has a wrong offset!");

// ScriptStruct SHProto.SHFleshLipSkeletonHierarchy
// 0x0000 (0x0108 - 0x0108)
struct FSHFleshLipSkeletonHierarchy final : public FSkeletonHierarchy
{
};
static_assert(alignof(FSHFleshLipSkeletonHierarchy) == 0x000008, "Wrong alignment on FSHFleshLipSkeletonHierarchy");
static_assert(sizeof(FSHFleshLipSkeletonHierarchy) == 0x000108, "Wrong size on FSHFleshLipSkeletonHierarchy");

// ScriptStruct SHProto.PhysicalAnimationBlender
// 0x0050 (0x0050 - 0x0000)
struct FPhysicalAnimationBlender final
{
public:
	struct FPhysicalAnimationProfileData          CurrentProfileData;                                // 0x0000(0x0038)(NativeAccessSpecifierPublic)
	float                                         PhysicWeightCurrent;                               // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicWeightTarget;                                // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicWeightSpeed;                                 // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveTime;                                         // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendToCurve;                                      // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendToCurveSpeed;                                 // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhysicalAnimationBlender) == 0x000008, "Wrong alignment on FPhysicalAnimationBlender");
static_assert(sizeof(FPhysicalAnimationBlender) == 0x000050, "Wrong size on FPhysicalAnimationBlender");
static_assert(offsetof(FPhysicalAnimationBlender, CurrentProfileData) == 0x000000, "Member 'FPhysicalAnimationBlender::CurrentProfileData' has a wrong offset!");
static_assert(offsetof(FPhysicalAnimationBlender, PhysicWeightCurrent) == 0x000038, "Member 'FPhysicalAnimationBlender::PhysicWeightCurrent' has a wrong offset!");
static_assert(offsetof(FPhysicalAnimationBlender, PhysicWeightTarget) == 0x00003C, "Member 'FPhysicalAnimationBlender::PhysicWeightTarget' has a wrong offset!");
static_assert(offsetof(FPhysicalAnimationBlender, PhysicWeightSpeed) == 0x000040, "Member 'FPhysicalAnimationBlender::PhysicWeightSpeed' has a wrong offset!");
static_assert(offsetof(FPhysicalAnimationBlender, CurveTime) == 0x000044, "Member 'FPhysicalAnimationBlender::CurveTime' has a wrong offset!");
static_assert(offsetof(FPhysicalAnimationBlender, BlendToCurve) == 0x000048, "Member 'FPhysicalAnimationBlender::BlendToCurve' has a wrong offset!");
static_assert(offsetof(FPhysicalAnimationBlender, BlendToCurveSpeed) == 0x00004C, "Member 'FPhysicalAnimationBlender::BlendToCurveSpeed' has a wrong offset!");

// ScriptStruct SHProto.SHMapFogRevealObjectData
// 0x000C (0x000C - 0x0000)
struct FSHMapFogRevealObjectData final
{
public:
	class FName                                   ObjectID;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHMapsEnum                                   Map;                                               // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHMapFogRevealObjectData) == 0x000004, "Wrong alignment on FSHMapFogRevealObjectData");
static_assert(sizeof(FSHMapFogRevealObjectData) == 0x00000C, "Wrong size on FSHMapFogRevealObjectData");
static_assert(offsetof(FSHMapFogRevealObjectData, ObjectID) == 0x000000, "Member 'FSHMapFogRevealObjectData::ObjectID' has a wrong offset!");
static_assert(offsetof(FSHMapFogRevealObjectData, Map) == 0x000008, "Member 'FSHMapFogRevealObjectData::Map' has a wrong offset!");

// ScriptStruct SHProto.SHMapFogRevealObjectsContainer
// 0x0010 (0x0010 - 0x0000)
struct FSHMapFogRevealObjectsContainer final
{
public:
	TArray<struct FSHMapFogRevealObjectData>      Objects;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHMapFogRevealObjectsContainer) == 0x000008, "Wrong alignment on FSHMapFogRevealObjectsContainer");
static_assert(sizeof(FSHMapFogRevealObjectsContainer) == 0x000010, "Wrong size on FSHMapFogRevealObjectsContainer");
static_assert(offsetof(FSHMapFogRevealObjectsContainer, Objects) == 0x000000, "Member 'FSHMapFogRevealObjectsContainer::Objects' has a wrong offset!");

// ScriptStruct SHProto.SHAbstractDaddySkeletonHierarchy
// 0x0000 (0x0108 - 0x0108)
struct FSHAbstractDaddySkeletonHierarchy final : public FSkeletonHierarchy
{
};
static_assert(alignof(FSHAbstractDaddySkeletonHierarchy) == 0x000008, "Wrong alignment on FSHAbstractDaddySkeletonHierarchy");
static_assert(sizeof(FSHAbstractDaddySkeletonHierarchy) == 0x000108, "Wrong size on FSHAbstractDaddySkeletonHierarchy");

// ScriptStruct SHProto.SHHitReactionCollisionConditionConfiguration
// 0x002C (0x002C - 0x0000)
struct FSHHitReactionCollisionConditionConfiguration final
{
public:
	float                                         TraceRadiusScale;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollisionProfileName;                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRespectIgnoredCollisions;                         // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinMaxVector2D                        TraceCapsuleHeights;                               // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TraceDirection;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMinMaxVector2D                        RequiredCollisionDistance;                         // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DebugDrawDuration;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHHitReactionCollisionConditionConfiguration) == 0x000004, "Wrong alignment on FSHHitReactionCollisionConditionConfiguration");
static_assert(sizeof(FSHHitReactionCollisionConditionConfiguration) == 0x00002C, "Wrong size on FSHHitReactionCollisionConditionConfiguration");
static_assert(offsetof(FSHHitReactionCollisionConditionConfiguration, TraceRadiusScale) == 0x000000, "Member 'FSHHitReactionCollisionConditionConfiguration::TraceRadiusScale' has a wrong offset!");
static_assert(offsetof(FSHHitReactionCollisionConditionConfiguration, bTraceComplex) == 0x000004, "Member 'FSHHitReactionCollisionConditionConfiguration::bTraceComplex' has a wrong offset!");
static_assert(offsetof(FSHHitReactionCollisionConditionConfiguration, CollisionProfileName) == 0x000008, "Member 'FSHHitReactionCollisionConditionConfiguration::CollisionProfileName' has a wrong offset!");
static_assert(offsetof(FSHHitReactionCollisionConditionConfiguration, bRespectIgnoredCollisions) == 0x000010, "Member 'FSHHitReactionCollisionConditionConfiguration::bRespectIgnoredCollisions' has a wrong offset!");
static_assert(offsetof(FSHHitReactionCollisionConditionConfiguration, TraceCapsuleHeights) == 0x000014, "Member 'FSHHitReactionCollisionConditionConfiguration::TraceCapsuleHeights' has a wrong offset!");
static_assert(offsetof(FSHHitReactionCollisionConditionConfiguration, TraceDirection) == 0x00001C, "Member 'FSHHitReactionCollisionConditionConfiguration::TraceDirection' has a wrong offset!");
static_assert(offsetof(FSHHitReactionCollisionConditionConfiguration, RequiredCollisionDistance) == 0x000020, "Member 'FSHHitReactionCollisionConditionConfiguration::RequiredCollisionDistance' has a wrong offset!");
static_assert(offsetof(FSHHitReactionCollisionConditionConfiguration, DebugDrawDuration) == 0x000028, "Member 'FSHHitReactionCollisionConditionConfiguration::DebugDrawDuration' has a wrong offset!");

// ScriptStruct SHProto.SHAIFinisherParams
// 0x00B8 (0x00C0 - 0x0008)
struct FSHAIFinisherParams final : public FTableRowBase
{
public:
	TArray<struct FGameplayTag>                   _RequiredTags;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   _OptionalTags;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           _SlayerAnimTag;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           _VictimAnimTag;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class USHAIAction_Finisher>       _SyncAction;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSHCameraAnimationData                 _CameraAnimationData;                              // 0x0040(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHAIFinisherParams) == 0x000008, "Wrong alignment on FSHAIFinisherParams");
static_assert(sizeof(FSHAIFinisherParams) == 0x0000C0, "Wrong size on FSHAIFinisherParams");
static_assert(offsetof(FSHAIFinisherParams, _RequiredTags) == 0x000008, "Member 'FSHAIFinisherParams::_RequiredTags' has a wrong offset!");
static_assert(offsetof(FSHAIFinisherParams, _OptionalTags) == 0x000018, "Member 'FSHAIFinisherParams::_OptionalTags' has a wrong offset!");
static_assert(offsetof(FSHAIFinisherParams, _SlayerAnimTag) == 0x000028, "Member 'FSHAIFinisherParams::_SlayerAnimTag' has a wrong offset!");
static_assert(offsetof(FSHAIFinisherParams, _VictimAnimTag) == 0x000030, "Member 'FSHAIFinisherParams::_VictimAnimTag' has a wrong offset!");
static_assert(offsetof(FSHAIFinisherParams, _SyncAction) == 0x000038, "Member 'FSHAIFinisherParams::_SyncAction' has a wrong offset!");
static_assert(offsetof(FSHAIFinisherParams, _CameraAnimationData) == 0x000040, "Member 'FSHAIFinisherParams::_CameraAnimationData' has a wrong offset!");

// ScriptStruct SHProto.SHCreeperSkeletonHierarchy
// 0x0000 (0x0108 - 0x0108)
struct FSHCreeperSkeletonHierarchy final : public FSkeletonHierarchy
{
};
static_assert(alignof(FSHCreeperSkeletonHierarchy) == 0x000008, "Wrong alignment on FSHCreeperSkeletonHierarchy");
static_assert(sizeof(FSHCreeperSkeletonHierarchy) == 0x000108, "Wrong size on FSHCreeperSkeletonHierarchy");

// ScriptStruct SHProto.SHAngelaSkeletonHierarchy
// 0x0000 (0x0108 - 0x0108)
struct FSHAngelaSkeletonHierarchy final : public FSkeletonHierarchy
{
};
static_assert(alignof(FSHAngelaSkeletonHierarchy) == 0x000008, "Wrong alignment on FSHAngelaSkeletonHierarchy");
static_assert(sizeof(FSHAngelaSkeletonHierarchy) == 0x000108, "Wrong size on FSHAngelaSkeletonHierarchy");

// ScriptStruct SHProto.SHHitReactionAnimationConfiguration
// 0x00B0 (0x00B0 - 0x0000)
struct FSHHitReactionAnimationConfiguration final
{
public:
	struct FPlayAnimationData                     Animation;                                         // 0x0000(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHHitReactionAnimationConfiguration) == 0x000008, "Wrong alignment on FSHHitReactionAnimationConfiguration");
static_assert(sizeof(FSHHitReactionAnimationConfiguration) == 0x0000B0, "Wrong size on FSHHitReactionAnimationConfiguration");
static_assert(offsetof(FSHHitReactionAnimationConfiguration, Animation) == 0x000000, "Member 'FSHHitReactionAnimationConfiguration::Animation' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionArtificialHitConfiguration
// 0x0078 (0x0078 - 0x0000)
struct FSHHitReactionArtificialHitConfiguration final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DebugReactionName;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHHitReactionResponseType                    HitReactionType;                                   // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HitReactionVariant;                                // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USHEnemyTransformationState*            TransformationState;                               // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitReactionStartTime;                              // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSHHitReactionStateConfiguration       HitReactionState;                                  // 0x003C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FSHHitReactionAnimationConfiguration> Animations;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSHHitReactionAnimationConfiguration> FinishingAnimations;                               // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSHHitReactionAnimationConfiguration> TwitchAnimations;                                  // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHHitReactionArtificialHitConfiguration) == 0x000008, "Wrong alignment on FSHHitReactionArtificialHitConfiguration");
static_assert(sizeof(FSHHitReactionArtificialHitConfiguration) == 0x000078, "Wrong size on FSHHitReactionArtificialHitConfiguration");
static_assert(offsetof(FSHHitReactionArtificialHitConfiguration, DebugReactionName) == 0x000010, "Member 'FSHHitReactionArtificialHitConfiguration::DebugReactionName' has a wrong offset!");
static_assert(offsetof(FSHHitReactionArtificialHitConfiguration, HitReactionType) == 0x000020, "Member 'FSHHitReactionArtificialHitConfiguration::HitReactionType' has a wrong offset!");
static_assert(offsetof(FSHHitReactionArtificialHitConfiguration, HitReactionVariant) == 0x000024, "Member 'FSHHitReactionArtificialHitConfiguration::HitReactionVariant' has a wrong offset!");
static_assert(offsetof(FSHHitReactionArtificialHitConfiguration, TransformationState) == 0x000030, "Member 'FSHHitReactionArtificialHitConfiguration::TransformationState' has a wrong offset!");
static_assert(offsetof(FSHHitReactionArtificialHitConfiguration, HitReactionStartTime) == 0x000038, "Member 'FSHHitReactionArtificialHitConfiguration::HitReactionStartTime' has a wrong offset!");
static_assert(offsetof(FSHHitReactionArtificialHitConfiguration, HitReactionState) == 0x00003C, "Member 'FSHHitReactionArtificialHitConfiguration::HitReactionState' has a wrong offset!");
static_assert(offsetof(FSHHitReactionArtificialHitConfiguration, Animations) == 0x000048, "Member 'FSHHitReactionArtificialHitConfiguration::Animations' has a wrong offset!");
static_assert(offsetof(FSHHitReactionArtificialHitConfiguration, FinishingAnimations) == 0x000058, "Member 'FSHHitReactionArtificialHitConfiguration::FinishingAnimations' has a wrong offset!");
static_assert(offsetof(FSHHitReactionArtificialHitConfiguration, TwitchAnimations) == 0x000068, "Member 'FSHHitReactionArtificialHitConfiguration::TwitchAnimations' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionVariantDamageReactionConfig
// 0x0010 (0x0010 - 0x0000)
struct FSHHitReactionVariantDamageReactionConfig final
{
public:
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHHitReactionsBodyMap*                 HitReactionBodyMap;                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHHitReactionVariantDamageReactionConfig) == 0x000008, "Wrong alignment on FSHHitReactionVariantDamageReactionConfig");
static_assert(sizeof(FSHHitReactionVariantDamageReactionConfig) == 0x000010, "Wrong size on FSHHitReactionVariantDamageReactionConfig");
static_assert(offsetof(FSHHitReactionVariantDamageReactionConfig, DamageType) == 0x000000, "Member 'FSHHitReactionVariantDamageReactionConfig::DamageType' has a wrong offset!");
static_assert(offsetof(FSHHitReactionVariantDamageReactionConfig, HitReactionBodyMap) == 0x000008, "Member 'FSHHitReactionVariantDamageReactionConfig::HitReactionBodyMap' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionVariantConfig
// 0x0018 (0x0018 - 0x0000)
struct FSHHitReactionVariantConfig final
{
public:
	class FName                                   HitReactionVariant;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSHHitReactionVariantDamageReactionConfig> DamageHitReactions;                                // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHHitReactionVariantConfig) == 0x000008, "Wrong alignment on FSHHitReactionVariantConfig");
static_assert(sizeof(FSHHitReactionVariantConfig) == 0x000018, "Wrong size on FSHHitReactionVariantConfig");
static_assert(offsetof(FSHHitReactionVariantConfig, HitReactionVariant) == 0x000000, "Member 'FSHHitReactionVariantConfig::HitReactionVariant' has a wrong offset!");
static_assert(offsetof(FSHHitReactionVariantConfig, DamageHitReactions) == 0x000008, "Member 'FSHHitReactionVariantConfig::DamageHitReactions' has a wrong offset!");

// ScriptStruct SHProto.FootIKNames
// 0x0028 (0x0028 - 0x0000)
struct FFootIKNames final
{
public:
	class FName                                   BoneIKName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneFootName;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ChildrenBonesNames;                                // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   FootLockCurveName;                                 // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootIKNames) == 0x000008, "Wrong alignment on FFootIKNames");
static_assert(sizeof(FFootIKNames) == 0x000028, "Wrong size on FFootIKNames");
static_assert(offsetof(FFootIKNames, BoneIKName) == 0x000000, "Member 'FFootIKNames::BoneIKName' has a wrong offset!");
static_assert(offsetof(FFootIKNames, BoneFootName) == 0x000008, "Member 'FFootIKNames::BoneFootName' has a wrong offset!");
static_assert(offsetof(FFootIKNames, ChildrenBonesNames) == 0x000010, "Member 'FFootIKNames::ChildrenBonesNames' has a wrong offset!");
static_assert(offsetof(FFootIKNames, FootLockCurveName) == 0x000020, "Member 'FFootIKNames::FootLockCurveName' has a wrong offset!");

// ScriptStruct SHProto.SHMapDynamicObjectDataStruct
// 0x0010 (0x0020 - 0x0010)
struct FSHMapDynamicObjectDataStruct final : public FSHMapObjectDataStruct
{
public:
	struct FVector2D                              WorldLocation2D;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHMapDynamicObjectDataStruct) == 0x000008, "Wrong alignment on FSHMapDynamicObjectDataStruct");
static_assert(sizeof(FSHMapDynamicObjectDataStruct) == 0x000020, "Wrong size on FSHMapDynamicObjectDataStruct");
static_assert(offsetof(FSHMapDynamicObjectDataStruct, WorldLocation2D) == 0x000010, "Member 'FSHMapDynamicObjectDataStruct::WorldLocation2D' has a wrong offset!");

// ScriptStruct SHProto.FootIKData
// 0x0088 (0x0088 - 0x0000)
struct FFootIKData final
{
public:
	float                                         IKAlpha;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FootOffset;                                        // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FootRotation;                                      // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FootOffsetAlpha;                                   // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FootLockLocation;                                  // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FootLockRotation;                                  // 0x0058(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FootLockAlpha;                                     // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRotator>                       ChildrenBonesLockRotation;                         // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootIKData) == 0x000008, "Wrong alignment on FFootIKData");
static_assert(sizeof(FFootIKData) == 0x000088, "Wrong size on FFootIKData");
static_assert(offsetof(FFootIKData, IKAlpha) == 0x000000, "Member 'FFootIKData::IKAlpha' has a wrong offset!");
static_assert(offsetof(FFootIKData, FootOffset) == 0x000008, "Member 'FFootIKData::FootOffset' has a wrong offset!");
static_assert(offsetof(FFootIKData, FootRotation) == 0x000020, "Member 'FFootIKData::FootRotation' has a wrong offset!");
static_assert(offsetof(FFootIKData, FootOffsetAlpha) == 0x000038, "Member 'FFootIKData::FootOffsetAlpha' has a wrong offset!");
static_assert(offsetof(FFootIKData, FootLockLocation) == 0x000040, "Member 'FFootIKData::FootLockLocation' has a wrong offset!");
static_assert(offsetof(FFootIKData, FootLockRotation) == 0x000058, "Member 'FFootIKData::FootLockRotation' has a wrong offset!");
static_assert(offsetof(FFootIKData, FootLockAlpha) == 0x000070, "Member 'FFootIKData::FootLockAlpha' has a wrong offset!");
static_assert(offsetof(FFootIKData, ChildrenBonesLockRotation) == 0x000078, "Member 'FFootIKData::ChildrenBonesLockRotation' has a wrong offset!");

// ScriptStruct SHProto.IgnoredActorClass
// 0x0038 (0x0038 - 0x0000)
struct FIgnoredActorClass final
{
public:
	bool                                          AlsoIgnoreChildren;                                // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ActorClass;                                        // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIgnoredActorClass) == 0x000008, "Wrong alignment on FIgnoredActorClass");
static_assert(sizeof(FIgnoredActorClass) == 0x000038, "Wrong size on FIgnoredActorClass");
static_assert(offsetof(FIgnoredActorClass, AlsoIgnoreChildren) == 0x000000, "Member 'FIgnoredActorClass::AlsoIgnoreChildren' has a wrong offset!");
static_assert(offsetof(FIgnoredActorClass, ActorClass) == 0x000008, "Member 'FIgnoredActorClass::ActorClass' has a wrong offset!");

// ScriptStruct SHProto.SHExtraHitAudioData
// 0x0010 (0x0010 - 0x0000)
struct FSHExtraHitAudioData final
{
public:
	class UAkAudioEvent*                          AudioEvent;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkSwitchValue*                         SwitchValue;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHExtraHitAudioData) == 0x000008, "Wrong alignment on FSHExtraHitAudioData");
static_assert(sizeof(FSHExtraHitAudioData) == 0x000010, "Wrong size on FSHExtraHitAudioData");
static_assert(offsetof(FSHExtraHitAudioData, AudioEvent) == 0x000000, "Member 'FSHExtraHitAudioData::AudioEvent' has a wrong offset!");
static_assert(offsetof(FSHExtraHitAudioData, SwitchValue) == 0x000008, "Member 'FSHExtraHitAudioData::SwitchValue' has a wrong offset!");

// ScriptStruct SHProto.SHAnimFootIKSubcompSettings
// 0x0068 (0x0070 - 0x0008)
struct FSHAnimFootIKSubcompSettings final : public FSHAnimSubcompSettings
{
public:
	TArray<struct FFootIKNames>                   FeetIKNames;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         FeetIKHeight;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MoveFeetOnlyInZAxis;                               // 0x001C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSweepInsteadOfLineTrace;                        // 0x001D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCollisionShapeProperty                SweepCollisionShape;                               // 0x0020(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          UseSingleTraceLogic;                               // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceHalfDistance;                                 // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FootRotationTargetLimit;                           // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FootRootIKBoneName;                                // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootLocationOffsetLimit;                           // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FIgnoredActorClass>             IgnoredActorClassess;                              // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bDisableUpdatesThrottling;                         // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHAnimFootIKSubcompSettings) == 0x000008, "Wrong alignment on FSHAnimFootIKSubcompSettings");
static_assert(sizeof(FSHAnimFootIKSubcompSettings) == 0x000070, "Wrong size on FSHAnimFootIKSubcompSettings");
static_assert(offsetof(FSHAnimFootIKSubcompSettings, FeetIKNames) == 0x000008, "Member 'FSHAnimFootIKSubcompSettings::FeetIKNames' has a wrong offset!");
static_assert(offsetof(FSHAnimFootIKSubcompSettings, FeetIKHeight) == 0x000018, "Member 'FSHAnimFootIKSubcompSettings::FeetIKHeight' has a wrong offset!");
static_assert(offsetof(FSHAnimFootIKSubcompSettings, MoveFeetOnlyInZAxis) == 0x00001C, "Member 'FSHAnimFootIKSubcompSettings::MoveFeetOnlyInZAxis' has a wrong offset!");
static_assert(offsetof(FSHAnimFootIKSubcompSettings, UseSweepInsteadOfLineTrace) == 0x00001D, "Member 'FSHAnimFootIKSubcompSettings::UseSweepInsteadOfLineTrace' has a wrong offset!");
static_assert(offsetof(FSHAnimFootIKSubcompSettings, SweepCollisionShape) == 0x000020, "Member 'FSHAnimFootIKSubcompSettings::SweepCollisionShape' has a wrong offset!");
static_assert(offsetof(FSHAnimFootIKSubcompSettings, UseSingleTraceLogic) == 0x000030, "Member 'FSHAnimFootIKSubcompSettings::UseSingleTraceLogic' has a wrong offset!");
static_assert(offsetof(FSHAnimFootIKSubcompSettings, TraceHalfDistance) == 0x000034, "Member 'FSHAnimFootIKSubcompSettings::TraceHalfDistance' has a wrong offset!");
static_assert(offsetof(FSHAnimFootIKSubcompSettings, FootRotationTargetLimit) == 0x000038, "Member 'FSHAnimFootIKSubcompSettings::FootRotationTargetLimit' has a wrong offset!");
static_assert(offsetof(FSHAnimFootIKSubcompSettings, FootRootIKBoneName) == 0x000048, "Member 'FSHAnimFootIKSubcompSettings::FootRootIKBoneName' has a wrong offset!");
static_assert(offsetof(FSHAnimFootIKSubcompSettings, FootLocationOffsetLimit) == 0x000050, "Member 'FSHAnimFootIKSubcompSettings::FootLocationOffsetLimit' has a wrong offset!");
static_assert(offsetof(FSHAnimFootIKSubcompSettings, IgnoredActorClassess) == 0x000058, "Member 'FSHAnimFootIKSubcompSettings::IgnoredActorClassess' has a wrong offset!");
static_assert(offsetof(FSHAnimFootIKSubcompSettings, bDisableUpdatesThrottling) == 0x000068, "Member 'FSHAnimFootIKSubcompSettings::bDisableUpdatesThrottling' has a wrong offset!");

// ScriptStruct SHProto.SHAnimHeadRotationBaseSubcompSettings
// 0x0040 (0x0048 - 0x0008)
struct FSHAnimHeadRotationBaseSubcompSettings : public FSHAnimSubcompSettings
{
public:
	class FName                                   AimOffsetLinkedAnimGraphTag;                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOffsetHeadInterpSpeed;                          // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOffsetHeadLookAtTargetInterpSpeed;              // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOffsetBackToDefaultHeadInterpSpeed;             // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              HeadRotationVerticalLimit;                         // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HeadRotationHorizontalLimit;                       // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultLookAtBlendOutAlphaSpeed;                   // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHAnimHeadRotationBaseSubcompSettings) == 0x000008, "Wrong alignment on FSHAnimHeadRotationBaseSubcompSettings");
static_assert(sizeof(FSHAnimHeadRotationBaseSubcompSettings) == 0x000048, "Wrong size on FSHAnimHeadRotationBaseSubcompSettings");
static_assert(offsetof(FSHAnimHeadRotationBaseSubcompSettings, AimOffsetLinkedAnimGraphTag) == 0x000008, "Member 'FSHAnimHeadRotationBaseSubcompSettings::AimOffsetLinkedAnimGraphTag' has a wrong offset!");
static_assert(offsetof(FSHAnimHeadRotationBaseSubcompSettings, AimOffsetHeadInterpSpeed) == 0x000010, "Member 'FSHAnimHeadRotationBaseSubcompSettings::AimOffsetHeadInterpSpeed' has a wrong offset!");
static_assert(offsetof(FSHAnimHeadRotationBaseSubcompSettings, AimOffsetHeadLookAtTargetInterpSpeed) == 0x000014, "Member 'FSHAnimHeadRotationBaseSubcompSettings::AimOffsetHeadLookAtTargetInterpSpeed' has a wrong offset!");
static_assert(offsetof(FSHAnimHeadRotationBaseSubcompSettings, AimOffsetBackToDefaultHeadInterpSpeed) == 0x000018, "Member 'FSHAnimHeadRotationBaseSubcompSettings::AimOffsetBackToDefaultHeadInterpSpeed' has a wrong offset!");
static_assert(offsetof(FSHAnimHeadRotationBaseSubcompSettings, HeadRotationVerticalLimit) == 0x000020, "Member 'FSHAnimHeadRotationBaseSubcompSettings::HeadRotationVerticalLimit' has a wrong offset!");
static_assert(offsetof(FSHAnimHeadRotationBaseSubcompSettings, HeadRotationHorizontalLimit) == 0x000030, "Member 'FSHAnimHeadRotationBaseSubcompSettings::HeadRotationHorizontalLimit' has a wrong offset!");
static_assert(offsetof(FSHAnimHeadRotationBaseSubcompSettings, DefaultLookAtBlendOutAlphaSpeed) == 0x000040, "Member 'FSHAnimHeadRotationBaseSubcompSettings::DefaultLookAtBlendOutAlphaSpeed' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionBonePhysicsConfiguration
// 0x0080 (0x0080 - 0x0000)
struct FSHHitReactionBonePhysicsConfiguration final
{
public:
	struct FVector                                AdditionalActorSpaceForce;                         // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActorSpaceForceMultiplier;                         // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoneSpaceForceMultiplier;                          // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyForceAtBoneLocation;                         // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChildBodiesForceMultiplier;                        // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyApplyForceToDirectChildren;                   // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyForceAtChildLocation;                        // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomForceDirectionOffsetAngle;                   // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMinMaxVector2D                        RandomForceMultiplier;                             // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FMinMaxVector2D                        ForceLimit;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ActivatePhysicsForParentBoneLevelAbove;            // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BonePhysicsBlend;                                  // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BonePhysicsDuration;                               // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BonePhysicsCurve;                                  // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowRootBonePhysics;                             // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHHitReactionBonePhysicsConfiguration) == 0x000008, "Wrong alignment on FSHHitReactionBonePhysicsConfiguration");
static_assert(sizeof(FSHHitReactionBonePhysicsConfiguration) == 0x000080, "Wrong size on FSHHitReactionBonePhysicsConfiguration");
static_assert(offsetof(FSHHitReactionBonePhysicsConfiguration, AdditionalActorSpaceForce) == 0x000000, "Member 'FSHHitReactionBonePhysicsConfiguration::AdditionalActorSpaceForce' has a wrong offset!");
static_assert(offsetof(FSHHitReactionBonePhysicsConfiguration, ActorSpaceForceMultiplier) == 0x000018, "Member 'FSHHitReactionBonePhysicsConfiguration::ActorSpaceForceMultiplier' has a wrong offset!");
static_assert(offsetof(FSHHitReactionBonePhysicsConfiguration, BoneSpaceForceMultiplier) == 0x000030, "Member 'FSHHitReactionBonePhysicsConfiguration::BoneSpaceForceMultiplier' has a wrong offset!");
static_assert(offsetof(FSHHitReactionBonePhysicsConfiguration, bApplyForceAtBoneLocation) == 0x000048, "Member 'FSHHitReactionBonePhysicsConfiguration::bApplyForceAtBoneLocation' has a wrong offset!");
static_assert(offsetof(FSHHitReactionBonePhysicsConfiguration, ChildBodiesForceMultiplier) == 0x00004C, "Member 'FSHHitReactionBonePhysicsConfiguration::ChildBodiesForceMultiplier' has a wrong offset!");
static_assert(offsetof(FSHHitReactionBonePhysicsConfiguration, bOnlyApplyForceToDirectChildren) == 0x000050, "Member 'FSHHitReactionBonePhysicsConfiguration::bOnlyApplyForceToDirectChildren' has a wrong offset!");
static_assert(offsetof(FSHHitReactionBonePhysicsConfiguration, bApplyForceAtChildLocation) == 0x000051, "Member 'FSHHitReactionBonePhysicsConfiguration::bApplyForceAtChildLocation' has a wrong offset!");
static_assert(offsetof(FSHHitReactionBonePhysicsConfiguration, RandomForceDirectionOffsetAngle) == 0x000054, "Member 'FSHHitReactionBonePhysicsConfiguration::RandomForceDirectionOffsetAngle' has a wrong offset!");
static_assert(offsetof(FSHHitReactionBonePhysicsConfiguration, RandomForceMultiplier) == 0x000058, "Member 'FSHHitReactionBonePhysicsConfiguration::RandomForceMultiplier' has a wrong offset!");
static_assert(offsetof(FSHHitReactionBonePhysicsConfiguration, ForceLimit) == 0x000060, "Member 'FSHHitReactionBonePhysicsConfiguration::ForceLimit' has a wrong offset!");
static_assert(offsetof(FSHHitReactionBonePhysicsConfiguration, ActivatePhysicsForParentBoneLevelAbove) == 0x000068, "Member 'FSHHitReactionBonePhysicsConfiguration::ActivatePhysicsForParentBoneLevelAbove' has a wrong offset!");
static_assert(offsetof(FSHHitReactionBonePhysicsConfiguration, BonePhysicsBlend) == 0x00006C, "Member 'FSHHitReactionBonePhysicsConfiguration::BonePhysicsBlend' has a wrong offset!");
static_assert(offsetof(FSHHitReactionBonePhysicsConfiguration, BonePhysicsDuration) == 0x000070, "Member 'FSHHitReactionBonePhysicsConfiguration::BonePhysicsDuration' has a wrong offset!");
static_assert(offsetof(FSHHitReactionBonePhysicsConfiguration, BonePhysicsCurve) == 0x000074, "Member 'FSHHitReactionBonePhysicsConfiguration::BonePhysicsCurve' has a wrong offset!");
static_assert(offsetof(FSHHitReactionBonePhysicsConfiguration, bAllowRootBonePhysics) == 0x000078, "Member 'FSHHitReactionBonePhysicsConfiguration::bAllowRootBonePhysics' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionPhysicsConfiguration
// 0x00D8 (0x00D8 - 0x0000)
struct FSHHitReactionPhysicsConfiguration final
{
public:
	float                                         ForceMultiplier;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHHitReactionBonePhysicsConfiguration HitBonePhysics;                                    // 0x0008(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FSHHitReactionBonePhysicsConfiguration> AdditionalBonePhysics;                             // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHHitReactionPhysicsConfiguration) == 0x000008, "Wrong alignment on FSHHitReactionPhysicsConfiguration");
static_assert(sizeof(FSHHitReactionPhysicsConfiguration) == 0x0000D8, "Wrong size on FSHHitReactionPhysicsConfiguration");
static_assert(offsetof(FSHHitReactionPhysicsConfiguration, ForceMultiplier) == 0x000000, "Member 'FSHHitReactionPhysicsConfiguration::ForceMultiplier' has a wrong offset!");
static_assert(offsetof(FSHHitReactionPhysicsConfiguration, HitBonePhysics) == 0x000008, "Member 'FSHHitReactionPhysicsConfiguration::HitBonePhysics' has a wrong offset!");
static_assert(offsetof(FSHHitReactionPhysicsConfiguration, AdditionalBonePhysics) == 0x000088, "Member 'FSHHitReactionPhysicsConfiguration::AdditionalBonePhysics' has a wrong offset!");

// ScriptStruct SHProto.SHAnimHeadRotationSubcompSettings
// 0x0028 (0x0070 - 0x0048)
struct FSHAnimHeadRotationSubcompSettings final : public FSHAnimHeadRotationBaseSubcompSettings
{
public:
	float                                         AimOffsetOnIdleHeadInterpSpeed;                    // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOffsetBackToDefaultHeadWaitTimer;               // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HeadOnAimTargetVerticalLimit;                      // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HeadOnAimTargetHorizontalLimit;                    // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHAnimHeadRotationSubcompSettings) == 0x000008, "Wrong alignment on FSHAnimHeadRotationSubcompSettings");
static_assert(sizeof(FSHAnimHeadRotationSubcompSettings) == 0x000070, "Wrong size on FSHAnimHeadRotationSubcompSettings");
static_assert(offsetof(FSHAnimHeadRotationSubcompSettings, AimOffsetOnIdleHeadInterpSpeed) == 0x000048, "Member 'FSHAnimHeadRotationSubcompSettings::AimOffsetOnIdleHeadInterpSpeed' has a wrong offset!");
static_assert(offsetof(FSHAnimHeadRotationSubcompSettings, AimOffsetBackToDefaultHeadWaitTimer) == 0x00004C, "Member 'FSHAnimHeadRotationSubcompSettings::AimOffsetBackToDefaultHeadWaitTimer' has a wrong offset!");
static_assert(offsetof(FSHAnimHeadRotationSubcompSettings, HeadOnAimTargetVerticalLimit) == 0x000050, "Member 'FSHAnimHeadRotationSubcompSettings::HeadOnAimTargetVerticalLimit' has a wrong offset!");
static_assert(offsetof(FSHAnimHeadRotationSubcompSettings, HeadOnAimTargetHorizontalLimit) == 0x000060, "Member 'FSHAnimHeadRotationSubcompSettings::HeadOnAimTargetHorizontalLimit' has a wrong offset!");

// ScriptStruct SHProto.ItemInvestigationAnimationData
// 0x0100 (0x0100 - 0x0000)
struct FItemInvestigationAnimationData final
{
public:
	TSoftObjectPtr<class UAnimSequence>           SetupAnimation;                                    // 0x0000(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           InvestigationAnimation;                            // 0x0030(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           FinishAnimation;                                   // 0x0060(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           TakeAnimation;                                     // 0x0090(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           FingersPose;                                       // 0x00C0(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemInvestigationType                        InvestigationType;                                 // 0x00F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationSpeedKeys;                                 // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpeedMouse;                                // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemInvestigationAnimationData) == 0x000008, "Wrong alignment on FItemInvestigationAnimationData");
static_assert(sizeof(FItemInvestigationAnimationData) == 0x000100, "Wrong size on FItemInvestigationAnimationData");
static_assert(offsetof(FItemInvestigationAnimationData, SetupAnimation) == 0x000000, "Member 'FItemInvestigationAnimationData::SetupAnimation' has a wrong offset!");
static_assert(offsetof(FItemInvestigationAnimationData, InvestigationAnimation) == 0x000030, "Member 'FItemInvestigationAnimationData::InvestigationAnimation' has a wrong offset!");
static_assert(offsetof(FItemInvestigationAnimationData, FinishAnimation) == 0x000060, "Member 'FItemInvestigationAnimationData::FinishAnimation' has a wrong offset!");
static_assert(offsetof(FItemInvestigationAnimationData, TakeAnimation) == 0x000090, "Member 'FItemInvestigationAnimationData::TakeAnimation' has a wrong offset!");
static_assert(offsetof(FItemInvestigationAnimationData, FingersPose) == 0x0000C0, "Member 'FItemInvestigationAnimationData::FingersPose' has a wrong offset!");
static_assert(offsetof(FItemInvestigationAnimationData, InvestigationType) == 0x0000F0, "Member 'FItemInvestigationAnimationData::InvestigationType' has a wrong offset!");
static_assert(offsetof(FItemInvestigationAnimationData, RotationSpeedKeys) == 0x0000F4, "Member 'FItemInvestigationAnimationData::RotationSpeedKeys' has a wrong offset!");
static_assert(offsetof(FItemInvestigationAnimationData, RotationSpeedMouse) == 0x0000F8, "Member 'FItemInvestigationAnimationData::RotationSpeedMouse' has a wrong offset!");

// ScriptStruct SHProto.SHFlashlightDefaultDataContainer
// 0x0020 (0x0020 - 0x0000)
struct FSHFlashlightDefaultDataContainer final
{
public:
	class UTextureLightProfile*                   MainLightIESTexture;                               // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHFlashlightDefaultDataContainer) == 0x000008, "Wrong alignment on FSHFlashlightDefaultDataContainer");
static_assert(sizeof(FSHFlashlightDefaultDataContainer) == 0x000020, "Wrong size on FSHFlashlightDefaultDataContainer");
static_assert(offsetof(FSHFlashlightDefaultDataContainer, MainLightIESTexture) == 0x000000, "Member 'FSHFlashlightDefaultDataContainer::MainLightIESTexture' has a wrong offset!");

// ScriptStruct SHProto.ItemQuickGrabAnimationData
// 0x0060 (0x0060 - 0x0000)
struct FItemQuickGrabAnimationData final
{
public:
	TSoftObjectPtr<class UBlendSpace>             GrabItemBlendspace;                                // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           WeaponHandPoseOverride;                            // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemQuickGrabAnimationData) == 0x000008, "Wrong alignment on FItemQuickGrabAnimationData");
static_assert(sizeof(FItemQuickGrabAnimationData) == 0x000060, "Wrong size on FItemQuickGrabAnimationData");
static_assert(offsetof(FItemQuickGrabAnimationData, GrabItemBlendspace) == 0x000000, "Member 'FItemQuickGrabAnimationData::GrabItemBlendspace' has a wrong offset!");
static_assert(offsetof(FItemQuickGrabAnimationData, WeaponHandPoseOverride) == 0x000030, "Member 'FItemQuickGrabAnimationData::WeaponHandPoseOverride' has a wrong offset!");

// ScriptStruct SHProto.SHAnimMovementSubcompSettings
// 0x0008 (0x0010 - 0x0008)
struct FSHAnimMovementSubcompSettings final : public FSHAnimSubcompSettings
{
public:
	bool                                          DelayedStopLogicEnabled;                           // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayedStopTimeWindow;                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHAnimMovementSubcompSettings) == 0x000008, "Wrong alignment on FSHAnimMovementSubcompSettings");
static_assert(sizeof(FSHAnimMovementSubcompSettings) == 0x000010, "Wrong size on FSHAnimMovementSubcompSettings");
static_assert(offsetof(FSHAnimMovementSubcompSettings, DelayedStopLogicEnabled) == 0x000008, "Member 'FSHAnimMovementSubcompSettings::DelayedStopLogicEnabled' has a wrong offset!");
static_assert(offsetof(FSHAnimMovementSubcompSettings, DelayedStopTimeWindow) == 0x00000C, "Member 'FSHAnimMovementSubcompSettings::DelayedStopTimeWindow' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionStateAnimationSerializedData
// 0x00B8 (0x00B8 - 0x0000)
struct FSHHitReactionStateAnimationSerializedData final
{
public:
	struct FPlayAnimationData                     AnimationData;                                     // 0x0000(0x00B0)(SaveGame, NativeAccessSpecifierPublic)
	float                                         AnimationPosition;                                 // 0x00B0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHHitReactionStateAnimationSerializedData) == 0x000008, "Wrong alignment on FSHHitReactionStateAnimationSerializedData");
static_assert(sizeof(FSHHitReactionStateAnimationSerializedData) == 0x0000B8, "Wrong size on FSHHitReactionStateAnimationSerializedData");
static_assert(offsetof(FSHHitReactionStateAnimationSerializedData, AnimationData) == 0x000000, "Member 'FSHHitReactionStateAnimationSerializedData::AnimationData' has a wrong offset!");
static_assert(offsetof(FSHHitReactionStateAnimationSerializedData, AnimationPosition) == 0x0000B0, "Member 'FSHHitReactionStateAnimationSerializedData::AnimationPosition' has a wrong offset!");

// ScriptStruct SHProto.SHObstacleDetectCylindricalCoordinates
// 0x000C (0x000C - 0x0000)
struct FSHObstacleDetectCylindricalCoordinates final
{
public:
	float                                         Angle;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHObstacleDetectCylindricalCoordinates) == 0x000004, "Wrong alignment on FSHObstacleDetectCylindricalCoordinates");
static_assert(sizeof(FSHObstacleDetectCylindricalCoordinates) == 0x00000C, "Wrong size on FSHObstacleDetectCylindricalCoordinates");
static_assert(offsetof(FSHObstacleDetectCylindricalCoordinates, Angle) == 0x000000, "Member 'FSHObstacleDetectCylindricalCoordinates::Angle' has a wrong offset!");
static_assert(offsetof(FSHObstacleDetectCylindricalCoordinates, Distance) == 0x000004, "Member 'FSHObstacleDetectCylindricalCoordinates::Distance' has a wrong offset!");
static_assert(offsetof(FSHObstacleDetectCylindricalCoordinates, Height) == 0x000008, "Member 'FSHObstacleDetectCylindricalCoordinates::Height' has a wrong offset!");

// ScriptStruct SHProto.SHObstacleDetectSocketData
// 0x00C0 (0x00C0 - 0x0000)
struct FSHObstacleDetectSocketData final
{
public:
	class FName                                   IKBoneName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneOffsetName;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CheckVector;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckRadius;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x94];                                      // 0x002C(0x0094)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHObstacleDetectSocketData) == 0x000008, "Wrong alignment on FSHObstacleDetectSocketData");
static_assert(sizeof(FSHObstacleDetectSocketData) == 0x0000C0, "Wrong size on FSHObstacleDetectSocketData");
static_assert(offsetof(FSHObstacleDetectSocketData, IKBoneName) == 0x000000, "Member 'FSHObstacleDetectSocketData::IKBoneName' has a wrong offset!");
static_assert(offsetof(FSHObstacleDetectSocketData, BoneOffsetName) == 0x000008, "Member 'FSHObstacleDetectSocketData::BoneOffsetName' has a wrong offset!");
static_assert(offsetof(FSHObstacleDetectSocketData, CheckVector) == 0x000010, "Member 'FSHObstacleDetectSocketData::CheckVector' has a wrong offset!");
static_assert(offsetof(FSHObstacleDetectSocketData, CheckRadius) == 0x000028, "Member 'FSHObstacleDetectSocketData::CheckRadius' has a wrong offset!");

// ScriptStruct SHProto.SHMariaLightingControlData
// 0x0008 (0x0008 - 0x0000)
struct FSHMariaLightingControlData final
{
public:
	bool                                          bOverrideIntensityValue;                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntensityValue;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHMariaLightingControlData) == 0x000004, "Wrong alignment on FSHMariaLightingControlData");
static_assert(sizeof(FSHMariaLightingControlData) == 0x000008, "Wrong size on FSHMariaLightingControlData");
static_assert(offsetof(FSHMariaLightingControlData, bOverrideIntensityValue) == 0x000000, "Member 'FSHMariaLightingControlData::bOverrideIntensityValue' has a wrong offset!");
static_assert(offsetof(FSHMariaLightingControlData, IntensityValue) == 0x000004, "Member 'FSHMariaLightingControlData::IntensityValue' has a wrong offset!");

// ScriptStruct SHProto.SHObstacleDetectMovementData
// 0x0018 (0x0018 - 0x0000)
struct FSHObstacleDetectMovementData final
{
public:
	float                                         SideCheckDistanceAdd;                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightCheck;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalRotation;                                // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x8];                                        // 0x000C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ESHObstaclesDetectType                        BlockMovementType;                                 // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHObstacleDetectMovementData) == 0x000004, "Wrong alignment on FSHObstacleDetectMovementData");
static_assert(sizeof(FSHObstacleDetectMovementData) == 0x000018, "Wrong size on FSHObstacleDetectMovementData");
static_assert(offsetof(FSHObstacleDetectMovementData, SideCheckDistanceAdd) == 0x000000, "Member 'FSHObstacleDetectMovementData::SideCheckDistanceAdd' has a wrong offset!");
static_assert(offsetof(FSHObstacleDetectMovementData, HeightCheck) == 0x000004, "Member 'FSHObstacleDetectMovementData::HeightCheck' has a wrong offset!");
static_assert(offsetof(FSHObstacleDetectMovementData, AdditionalRotation) == 0x000008, "Member 'FSHObstacleDetectMovementData::AdditionalRotation' has a wrong offset!");
static_assert(offsetof(FSHObstacleDetectMovementData, BlockMovementType) == 0x000014, "Member 'FSHObstacleDetectMovementData::BlockMovementType' has a wrong offset!");

// ScriptStruct SHProto.ForceOverTime
// 0x0030 (0x0030 - 0x0000)
struct FForceOverTime final
{
public:
	EBones                                        bone;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Force;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDamp;                                             // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Damp;                                              // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FForceOverTime) == 0x000008, "Wrong alignment on FForceOverTime");
static_assert(sizeof(FForceOverTime) == 0x000030, "Wrong size on FForceOverTime");
static_assert(offsetof(FForceOverTime, bone) == 0x000000, "Member 'FForceOverTime::bone' has a wrong offset!");
static_assert(offsetof(FForceOverTime, Force) == 0x000008, "Member 'FForceOverTime::Force' has a wrong offset!");
static_assert(offsetof(FForceOverTime, Duration) == 0x000020, "Member 'FForceOverTime::Duration' has a wrong offset!");
static_assert(offsetof(FForceOverTime, Time) == 0x000024, "Member 'FForceOverTime::Time' has a wrong offset!");
static_assert(offsetof(FForceOverTime, bDamp) == 0x000028, "Member 'FForceOverTime::bDamp' has a wrong offset!");
static_assert(offsetof(FForceOverTime, Damp) == 0x00002C, "Member 'FForceOverTime::Damp' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionResultBonePhysics
// 0x0058 (0x0058 - 0x0000)
struct FSHHitReactionResultBonePhysics final
{
public:
	struct FVector                                ForceLocation;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Force;                                             // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActivatePhysicsForParentBoneLevelAbove;            // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChildBodiesForceMultiplier;                        // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyApplyForceToDirectChildren;                   // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyForceAtChildLocation;                        // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BonePhysicsBlend;                                  // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BonePhysicsDuration;                               // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BonePhysicsCurve;                                  // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowRootBonePhysics;                             // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHHitReactionResultBonePhysics) == 0x000008, "Wrong alignment on FSHHitReactionResultBonePhysics");
static_assert(sizeof(FSHHitReactionResultBonePhysics) == 0x000058, "Wrong size on FSHHitReactionResultBonePhysics");
static_assert(offsetof(FSHHitReactionResultBonePhysics, ForceLocation) == 0x000000, "Member 'FSHHitReactionResultBonePhysics::ForceLocation' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResultBonePhysics, Force) == 0x000018, "Member 'FSHHitReactionResultBonePhysics::Force' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResultBonePhysics, BoneName) == 0x000030, "Member 'FSHHitReactionResultBonePhysics::BoneName' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResultBonePhysics, ActivatePhysicsForParentBoneLevelAbove) == 0x000038, "Member 'FSHHitReactionResultBonePhysics::ActivatePhysicsForParentBoneLevelAbove' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResultBonePhysics, ChildBodiesForceMultiplier) == 0x00003C, "Member 'FSHHitReactionResultBonePhysics::ChildBodiesForceMultiplier' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResultBonePhysics, bOnlyApplyForceToDirectChildren) == 0x000040, "Member 'FSHHitReactionResultBonePhysics::bOnlyApplyForceToDirectChildren' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResultBonePhysics, bApplyForceAtChildLocation) == 0x000041, "Member 'FSHHitReactionResultBonePhysics::bApplyForceAtChildLocation' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResultBonePhysics, BonePhysicsBlend) == 0x000044, "Member 'FSHHitReactionResultBonePhysics::BonePhysicsBlend' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResultBonePhysics, BonePhysicsDuration) == 0x000048, "Member 'FSHHitReactionResultBonePhysics::BonePhysicsDuration' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResultBonePhysics, BonePhysicsCurve) == 0x00004C, "Member 'FSHHitReactionResultBonePhysics::BonePhysicsCurve' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResultBonePhysics, bAllowRootBonePhysics) == 0x000050, "Member 'FSHHitReactionResultBonePhysics::bAllowRootBonePhysics' has a wrong offset!");

// ScriptStruct SHProto.WholeBodyTranslation
// 0x0048 (0x0048 - 0x0000)
struct FWholeBodyTranslation final
{
public:
	struct FVector                                Translation;                                       // 0x0000(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                VectorUp;                                          // 0x0030(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWholeBodyTranslation) == 0x000008, "Wrong alignment on FWholeBodyTranslation");
static_assert(sizeof(FWholeBodyTranslation) == 0x000048, "Wrong size on FWholeBodyTranslation");
static_assert(offsetof(FWholeBodyTranslation, Translation) == 0x000000, "Member 'FWholeBodyTranslation::Translation' has a wrong offset!");
static_assert(offsetof(FWholeBodyTranslation, Rotation) == 0x000018, "Member 'FWholeBodyTranslation::Rotation' has a wrong offset!");
static_assert(offsetof(FWholeBodyTranslation, VectorUp) == 0x000030, "Member 'FWholeBodyTranslation::VectorUp' has a wrong offset!");

// ScriptStruct SHProto.SHFleshLipCeilingCustomTileConfiguration
// 0x0010 (0x0010 - 0x0000)
struct FSHFleshLipCeilingCustomTileConfiguration final
{
public:
	int32                                         TileX;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TileY;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASHFleshLipCeilingTileActor> CeilingTileActor;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHFleshLipCeilingCustomTileConfiguration) == 0x000008, "Wrong alignment on FSHFleshLipCeilingCustomTileConfiguration");
static_assert(sizeof(FSHFleshLipCeilingCustomTileConfiguration) == 0x000010, "Wrong size on FSHFleshLipCeilingCustomTileConfiguration");
static_assert(offsetof(FSHFleshLipCeilingCustomTileConfiguration, TileX) == 0x000000, "Member 'FSHFleshLipCeilingCustomTileConfiguration::TileX' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingCustomTileConfiguration, TileY) == 0x000004, "Member 'FSHFleshLipCeilingCustomTileConfiguration::TileY' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingCustomTileConfiguration, CeilingTileActor) == 0x000008, "Member 'FSHFleshLipCeilingCustomTileConfiguration::CeilingTileActor' has a wrong offset!");

// ScriptStruct SHProto.SHBonePhysicsControllerSettingsBodyPhysicsOverride
// 0x002C (0x002C - 0x0000)
struct FSHBonePhysicsControllerSettingsBodyPhysicsOverride final
{
public:
	bool                                          bTreatBoneAsRoot;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESHBonePhysicsControllerSettingsBodyPhysicsPermission AllowPhysics;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InactivePhysicsProfileOverride;                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivePhysicsProfileOverride;                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumBlendWeight;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumVelocity;                                   // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumAngularVelocity;                            // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyForceMultiplier;                             // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaximumForceMultiplier;                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHBonePhysicsControllerSettingsBodyPhysicsOverride) == 0x000004, "Wrong alignment on FSHBonePhysicsControllerSettingsBodyPhysicsOverride");
static_assert(sizeof(FSHBonePhysicsControllerSettingsBodyPhysicsOverride) == 0x00002C, "Wrong size on FSHBonePhysicsControllerSettingsBodyPhysicsOverride");
static_assert(offsetof(FSHBonePhysicsControllerSettingsBodyPhysicsOverride, bTreatBoneAsRoot) == 0x000000, "Member 'FSHBonePhysicsControllerSettingsBodyPhysicsOverride::bTreatBoneAsRoot' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerSettingsBodyPhysicsOverride, AllowPhysics) == 0x000004, "Member 'FSHBonePhysicsControllerSettingsBodyPhysicsOverride::AllowPhysics' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerSettingsBodyPhysicsOverride, InactivePhysicsProfileOverride) == 0x000008, "Member 'FSHBonePhysicsControllerSettingsBodyPhysicsOverride::InactivePhysicsProfileOverride' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerSettingsBodyPhysicsOverride, ActivePhysicsProfileOverride) == 0x000010, "Member 'FSHBonePhysicsControllerSettingsBodyPhysicsOverride::ActivePhysicsProfileOverride' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerSettingsBodyPhysicsOverride, MaximumBlendWeight) == 0x000018, "Member 'FSHBonePhysicsControllerSettingsBodyPhysicsOverride::MaximumBlendWeight' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerSettingsBodyPhysicsOverride, MaximumVelocity) == 0x00001C, "Member 'FSHBonePhysicsControllerSettingsBodyPhysicsOverride::MaximumVelocity' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerSettingsBodyPhysicsOverride, MaximumAngularVelocity) == 0x000020, "Member 'FSHBonePhysicsControllerSettingsBodyPhysicsOverride::MaximumAngularVelocity' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerSettingsBodyPhysicsOverride, bApplyForceMultiplier) == 0x000024, "Member 'FSHBonePhysicsControllerSettingsBodyPhysicsOverride::bApplyForceMultiplier' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerSettingsBodyPhysicsOverride, MaximumForceMultiplier) == 0x000028, "Member 'FSHBonePhysicsControllerSettingsBodyPhysicsOverride::MaximumForceMultiplier' has a wrong offset!");

// ScriptStruct SHProto.SHBonePhysicsControllerSettingsProfile
// 0x0068 (0x0068 - 0x0000)
struct FSHBonePhysicsControllerSettingsProfile final
{
public:
	bool                                          bPreventPhysicsOfRootBody;                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeverManagePhysicsProfiles;                       // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefaultInactivePhysicsProfile;                     // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DefaultActivePhysicsProfile;                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FSHBonePhysicsControllerSettingsBodyPhysicsOverride> BodyPhysicsOverrides;                              // 0x0018(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSHBonePhysicsControllerSettingsProfile) == 0x000008, "Wrong alignment on FSHBonePhysicsControllerSettingsProfile");
static_assert(sizeof(FSHBonePhysicsControllerSettingsProfile) == 0x000068, "Wrong size on FSHBonePhysicsControllerSettingsProfile");
static_assert(offsetof(FSHBonePhysicsControllerSettingsProfile, bPreventPhysicsOfRootBody) == 0x000000, "Member 'FSHBonePhysicsControllerSettingsProfile::bPreventPhysicsOfRootBody' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerSettingsProfile, bNeverManagePhysicsProfiles) == 0x000001, "Member 'FSHBonePhysicsControllerSettingsProfile::bNeverManagePhysicsProfiles' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerSettingsProfile, DefaultInactivePhysicsProfile) == 0x000004, "Member 'FSHBonePhysicsControllerSettingsProfile::DefaultInactivePhysicsProfile' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerSettingsProfile, DefaultActivePhysicsProfile) == 0x00000C, "Member 'FSHBonePhysicsControllerSettingsProfile::DefaultActivePhysicsProfile' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerSettingsProfile, BodyPhysicsOverrides) == 0x000018, "Member 'FSHBonePhysicsControllerSettingsProfile::BodyPhysicsOverrides' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionIdentifier
// 0x000C (0x000C - 0x0000)
struct FSHHitReactionIdentifier final
{
public:
	ESHHitReactionResponseType                    ResponseType;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   VariantName;                                       // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHHitReactionIdentifier) == 0x000004, "Wrong alignment on FSHHitReactionIdentifier");
static_assert(sizeof(FSHHitReactionIdentifier) == 0x00000C, "Wrong size on FSHHitReactionIdentifier");
static_assert(offsetof(FSHHitReactionIdentifier, ResponseType) == 0x000000, "Member 'FSHHitReactionIdentifier::ResponseType' has a wrong offset!");
static_assert(offsetof(FSHHitReactionIdentifier, VariantName) == 0x000004, "Member 'FSHHitReactionIdentifier::VariantName' has a wrong offset!");

// ScriptStruct SHProto.SHBonePhysicsControllerBodyPhysicsBlendState
// 0x0024 (0x0024 - 0x0000)
struct FSHBonePhysicsControllerBodyPhysicsBlendState final
{
public:
	class FName                                   P_IdentifierName;                                  // 0x0000(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         P_MaximumPhysicsBlendWeight;                       // 0x0008(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         P_CurrentPhysicsBlendWeight;                       // 0x000C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         P_FadeOutTime;                                     // 0x0010(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         P_CurrentFadeOutProgess;                           // 0x0014(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         P_FadeOutCurveBend;                                // 0x0018(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   P_PhysicsProfileOverride;                          // 0x001C(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSHBonePhysicsControllerBodyPhysicsBlendState) == 0x000004, "Wrong alignment on FSHBonePhysicsControllerBodyPhysicsBlendState");
static_assert(sizeof(FSHBonePhysicsControllerBodyPhysicsBlendState) == 0x000024, "Wrong size on FSHBonePhysicsControllerBodyPhysicsBlendState");
static_assert(offsetof(FSHBonePhysicsControllerBodyPhysicsBlendState, P_IdentifierName) == 0x000000, "Member 'FSHBonePhysicsControllerBodyPhysicsBlendState::P_IdentifierName' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerBodyPhysicsBlendState, P_MaximumPhysicsBlendWeight) == 0x000008, "Member 'FSHBonePhysicsControllerBodyPhysicsBlendState::P_MaximumPhysicsBlendWeight' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerBodyPhysicsBlendState, P_CurrentPhysicsBlendWeight) == 0x00000C, "Member 'FSHBonePhysicsControllerBodyPhysicsBlendState::P_CurrentPhysicsBlendWeight' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerBodyPhysicsBlendState, P_FadeOutTime) == 0x000010, "Member 'FSHBonePhysicsControllerBodyPhysicsBlendState::P_FadeOutTime' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerBodyPhysicsBlendState, P_CurrentFadeOutProgess) == 0x000014, "Member 'FSHBonePhysicsControllerBodyPhysicsBlendState::P_CurrentFadeOutProgess' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerBodyPhysicsBlendState, P_FadeOutCurveBend) == 0x000018, "Member 'FSHBonePhysicsControllerBodyPhysicsBlendState::P_FadeOutCurveBend' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerBodyPhysicsBlendState, P_PhysicsProfileOverride) == 0x00001C, "Member 'FSHBonePhysicsControllerBodyPhysicsBlendState::P_PhysicsProfileOverride' has a wrong offset!");

// ScriptStruct SHProto.SHBonePhysicsControllerBodyPhysicsState
// 0x0030 (0x0030 - 0x0000)
struct FSHBonePhysicsControllerBodyPhysicsState final
{
public:
	class FName                                   P_CollisionBody;                                   // 0x0000(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         P_CurrentBlendWeight;                              // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         P_CachedCurrentBlendWeight;                        // 0x000C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   P_CachedCurrentPhysicsOverrideProfile;             // 0x0010(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          P_bNeedsPhysicsProfileOverrideUpdate;              // 0x0018(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHBonePhysicsControllerBodyPhysicsBlendState> P_PhysicsBlendStateStacks;                         // 0x0020(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSHBonePhysicsControllerBodyPhysicsState) == 0x000008, "Wrong alignment on FSHBonePhysicsControllerBodyPhysicsState");
static_assert(sizeof(FSHBonePhysicsControllerBodyPhysicsState) == 0x000030, "Wrong size on FSHBonePhysicsControllerBodyPhysicsState");
static_assert(offsetof(FSHBonePhysicsControllerBodyPhysicsState, P_CollisionBody) == 0x000000, "Member 'FSHBonePhysicsControllerBodyPhysicsState::P_CollisionBody' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerBodyPhysicsState, P_CurrentBlendWeight) == 0x000008, "Member 'FSHBonePhysicsControllerBodyPhysicsState::P_CurrentBlendWeight' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerBodyPhysicsState, P_CachedCurrentBlendWeight) == 0x00000C, "Member 'FSHBonePhysicsControllerBodyPhysicsState::P_CachedCurrentBlendWeight' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerBodyPhysicsState, P_CachedCurrentPhysicsOverrideProfile) == 0x000010, "Member 'FSHBonePhysicsControllerBodyPhysicsState::P_CachedCurrentPhysicsOverrideProfile' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerBodyPhysicsState, P_bNeedsPhysicsProfileOverrideUpdate) == 0x000018, "Member 'FSHBonePhysicsControllerBodyPhysicsState::P_bNeedsPhysicsProfileOverrideUpdate' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerBodyPhysicsState, P_PhysicsBlendStateStacks) == 0x000020, "Member 'FSHBonePhysicsControllerBodyPhysicsState::P_PhysicsBlendStateStacks' has a wrong offset!");

// ScriptStruct SHProto.SHBonePhysicsControllerPhysicsSerializedData
// 0x0020 (0x0020 - 0x0000)
struct FSHBonePhysicsControllerPhysicsSerializedData final
{
public:
	TArray<struct FSHBonePhysicsControllerBodyPhysicsState> P_BodyPhysicsStates;                               // 0x0000(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTransform>                     P_BoneTransforms;                                  // 0x0010(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSHBonePhysicsControllerPhysicsSerializedData) == 0x000008, "Wrong alignment on FSHBonePhysicsControllerPhysicsSerializedData");
static_assert(sizeof(FSHBonePhysicsControllerPhysicsSerializedData) == 0x000020, "Wrong size on FSHBonePhysicsControllerPhysicsSerializedData");
static_assert(offsetof(FSHBonePhysicsControllerPhysicsSerializedData, P_BodyPhysicsStates) == 0x000000, "Member 'FSHBonePhysicsControllerPhysicsSerializedData::P_BodyPhysicsStates' has a wrong offset!");
static_assert(offsetof(FSHBonePhysicsControllerPhysicsSerializedData, P_BoneTransforms) == 0x000010, "Member 'FSHBonePhysicsControllerPhysicsSerializedData::P_BoneTransforms' has a wrong offset!");

// ScriptStruct SHProto.SHBossfightItemsManagerPhaseSetup
// 0x0010 (0x0010 - 0x0000)
struct FSHBossfightItemsManagerPhaseSetup final
{
public:
	TArray<struct FSHItemAndQuantityHandle>       RequiredItemQuantities;                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHBossfightItemsManagerPhaseSetup) == 0x000008, "Wrong alignment on FSHBossfightItemsManagerPhaseSetup");
static_assert(sizeof(FSHBossfightItemsManagerPhaseSetup) == 0x000010, "Wrong size on FSHBossfightItemsManagerPhaseSetup");
static_assert(offsetof(FSHBossfightItemsManagerPhaseSetup, RequiredItemQuantities) == 0x000000, "Member 'FSHBossfightItemsManagerPhaseSetup::RequiredItemQuantities' has a wrong offset!");

// ScriptStruct SHProto.SHBreakableGlassSizeAudioData
// 0x0010 (0x0010 - 0x0000)
struct FSHBreakableGlassSizeAudioData final
{
public:
	float                                         MinGlassSurfaceArea;                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AkEventToPlayAtHit;                                // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHBreakableGlassSizeAudioData) == 0x000008, "Wrong alignment on FSHBreakableGlassSizeAudioData");
static_assert(sizeof(FSHBreakableGlassSizeAudioData) == 0x000010, "Wrong size on FSHBreakableGlassSizeAudioData");
static_assert(offsetof(FSHBreakableGlassSizeAudioData, MinGlassSurfaceArea) == 0x000000, "Member 'FSHBreakableGlassSizeAudioData::MinGlassSurfaceArea' has a wrong offset!");
static_assert(offsetof(FSHBreakableGlassSizeAudioData, AkEventToPlayAtHit) == 0x000008, "Member 'FSHBreakableGlassSizeAudioData::AkEventToPlayAtHit' has a wrong offset!");

// ScriptStruct SHProto.SHBreakableGlassNoiseConfig
// 0x0018 (0x0018 - 0x0000)
struct FSHBreakableGlassNoiseConfig final
{
public:
	float                                         Aggro;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Loudness;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHBreakableGlassNoiseConfig) == 0x000004, "Wrong alignment on FSHBreakableGlassNoiseConfig");
static_assert(sizeof(FSHBreakableGlassNoiseConfig) == 0x000018, "Wrong size on FSHBreakableGlassNoiseConfig");
static_assert(offsetof(FSHBreakableGlassNoiseConfig, Aggro) == 0x000000, "Member 'FSHBreakableGlassNoiseConfig::Aggro' has a wrong offset!");
static_assert(offsetof(FSHBreakableGlassNoiseConfig, Range) == 0x000004, "Member 'FSHBreakableGlassNoiseConfig::Range' has a wrong offset!");
static_assert(offsetof(FSHBreakableGlassNoiseConfig, MaxRange) == 0x000008, "Member 'FSHBreakableGlassNoiseConfig::MaxRange' has a wrong offset!");
static_assert(offsetof(FSHBreakableGlassNoiseConfig, Loudness) == 0x00000C, "Member 'FSHBreakableGlassNoiseConfig::Loudness' has a wrong offset!");
static_assert(offsetof(FSHBreakableGlassNoiseConfig, Tag) == 0x000010, "Member 'FSHBreakableGlassNoiseConfig::Tag' has a wrong offset!");

// ScriptStruct SHProto.SHBuoyancyMimicWave
// 0x0018 (0x0018 - 0x0000)
struct FSHBuoyancyMimicWave final
{
public:
	struct FVector2D                              Direction;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Steepness;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveLength;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHBuoyancyMimicWave) == 0x000008, "Wrong alignment on FSHBuoyancyMimicWave");
static_assert(sizeof(FSHBuoyancyMimicWave) == 0x000018, "Wrong size on FSHBuoyancyMimicWave");
static_assert(offsetof(FSHBuoyancyMimicWave, Direction) == 0x000000, "Member 'FSHBuoyancyMimicWave::Direction' has a wrong offset!");
static_assert(offsetof(FSHBuoyancyMimicWave, Steepness) == 0x000010, "Member 'FSHBuoyancyMimicWave::Steepness' has a wrong offset!");
static_assert(offsetof(FSHBuoyancyMimicWave, WaveLength) == 0x000014, "Member 'FSHBuoyancyMimicWave::WaveLength' has a wrong offset!");

// ScriptStruct SHProto.SHCameraBlendableEffect
// 0x0048 (0x0048 - 0x0000)
struct FSHCameraBlendableEffect final
{
public:
	class USHOperationEvents*                     OperationEvents;                                   // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            EaseCurve;                                         // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x38];                                      // 0x0010(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHCameraBlendableEffect) == 0x000008, "Wrong alignment on FSHCameraBlendableEffect");
static_assert(sizeof(FSHCameraBlendableEffect) == 0x000048, "Wrong size on FSHCameraBlendableEffect");
static_assert(offsetof(FSHCameraBlendableEffect, OperationEvents) == 0x000000, "Member 'FSHCameraBlendableEffect::OperationEvents' has a wrong offset!");
static_assert(offsetof(FSHCameraBlendableEffect, EaseCurve) == 0x000008, "Member 'FSHCameraBlendableEffect::EaseCurve' has a wrong offset!");

// ScriptStruct SHProto.SHCameraDataStruct
// 0x0058 (0x0058 - 0x0000)
struct FSHCameraDataStruct final
{
public:
	struct FSHBlendData                           BlendData;                                         // 0x0000(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ArmLengthFromPitchCurve;                           // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           SocketOffsetFromPitchCurve;                        // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetOffsetExtraHeightFromPitchScale;             // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementForwardCameraLag;                          // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementNonForwardCameraLag;                       // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationLag;                                       // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHCameraDataStruct) == 0x000008, "Wrong alignment on FSHCameraDataStruct");
static_assert(sizeof(FSHCameraDataStruct) == 0x000058, "Wrong size on FSHCameraDataStruct");
static_assert(offsetof(FSHCameraDataStruct, BlendData) == 0x000000, "Member 'FSHCameraDataStruct::BlendData' has a wrong offset!");
static_assert(offsetof(FSHCameraDataStruct, ArmLengthFromPitchCurve) == 0x000020, "Member 'FSHCameraDataStruct::ArmLengthFromPitchCurve' has a wrong offset!");
static_assert(offsetof(FSHCameraDataStruct, SocketOffsetFromPitchCurve) == 0x000028, "Member 'FSHCameraDataStruct::SocketOffsetFromPitchCurve' has a wrong offset!");
static_assert(offsetof(FSHCameraDataStruct, TargetOffset) == 0x000030, "Member 'FSHCameraDataStruct::TargetOffset' has a wrong offset!");
static_assert(offsetof(FSHCameraDataStruct, TargetOffsetExtraHeightFromPitchScale) == 0x000048, "Member 'FSHCameraDataStruct::TargetOffsetExtraHeightFromPitchScale' has a wrong offset!");
static_assert(offsetof(FSHCameraDataStruct, MovementForwardCameraLag) == 0x00004C, "Member 'FSHCameraDataStruct::MovementForwardCameraLag' has a wrong offset!");
static_assert(offsetof(FSHCameraDataStruct, MovementNonForwardCameraLag) == 0x000050, "Member 'FSHCameraDataStruct::MovementNonForwardCameraLag' has a wrong offset!");
static_assert(offsetof(FSHCameraDataStruct, RotationLag) == 0x000054, "Member 'FSHCameraDataStruct::RotationLag' has a wrong offset!");

// ScriptStruct SHProto.SHCameraDataFull
// 0x00B0 (0x00B0 - 0x0000)
struct FSHCameraDataFull final
{
public:
	struct FSHCameraDataStruct                    MainData;                                          // 0x0000(0x0058)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FSHCameraDataStruct                    MaxCollisionData;                                  // 0x0058(0x0058)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHCameraDataFull) == 0x000008, "Wrong alignment on FSHCameraDataFull");
static_assert(sizeof(FSHCameraDataFull) == 0x0000B0, "Wrong size on FSHCameraDataFull");
static_assert(offsetof(FSHCameraDataFull, MainData) == 0x000000, "Member 'FSHCameraDataFull::MainData' has a wrong offset!");
static_assert(offsetof(FSHCameraDataFull, MaxCollisionData) == 0x000058, "Member 'FSHCameraDataFull::MaxCollisionData' has a wrong offset!");

// ScriptStruct SHProto.SHCameraFOVBlendData
// 0x0028 (0x0028 - 0x0000)
struct FSHCameraFOVBlendData final
{
public:
	struct FSHBlendData                           BlendData;                                         // 0x0000(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FOVValue;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHCameraFOVBlendData) == 0x000008, "Wrong alignment on FSHCameraFOVBlendData");
static_assert(sizeof(FSHCameraFOVBlendData) == 0x000028, "Wrong size on FSHCameraFOVBlendData");
static_assert(offsetof(FSHCameraFOVBlendData, BlendData) == 0x000000, "Member 'FSHCameraFOVBlendData::BlendData' has a wrong offset!");
static_assert(offsetof(FSHCameraFOVBlendData, FOVValue) == 0x000020, "Member 'FSHCameraFOVBlendData::FOVValue' has a wrong offset!");

// ScriptStruct SHProto.SHCameraMAACRBlendData
// 0x0028 (0x0028 - 0x0000)
struct FSHCameraMAACRBlendData final
{
public:
	struct FSHBlendData                           BlendData;                                         // 0x0000(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MAACRScaleValue;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHCameraMAACRBlendData) == 0x000008, "Wrong alignment on FSHCameraMAACRBlendData");
static_assert(sizeof(FSHCameraMAACRBlendData) == 0x000028, "Wrong size on FSHCameraMAACRBlendData");
static_assert(offsetof(FSHCameraMAACRBlendData, BlendData) == 0x000000, "Member 'FSHCameraMAACRBlendData::BlendData' has a wrong offset!");
static_assert(offsetof(FSHCameraMAACRBlendData, MAACRScaleValue) == 0x000020, "Member 'FSHCameraMAACRBlendData::MAACRScaleValue' has a wrong offset!");

// ScriptStruct SHProto.SHCameraMAARLBlendData
// 0x0028 (0x0028 - 0x0000)
struct FSHCameraMAARLBlendData final
{
public:
	struct FSHBlendData                           BlendData;                                         // 0x0000(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MAARLScaleValue;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHCameraMAARLBlendData) == 0x000008, "Wrong alignment on FSHCameraMAARLBlendData");
static_assert(sizeof(FSHCameraMAARLBlendData) == 0x000028, "Wrong size on FSHCameraMAARLBlendData");
static_assert(offsetof(FSHCameraMAARLBlendData, BlendData) == 0x000000, "Member 'FSHCameraMAARLBlendData::BlendData' has a wrong offset!");
static_assert(offsetof(FSHCameraMAARLBlendData, MAARLScaleValue) == 0x000020, "Member 'FSHCameraMAARLBlendData::MAARLScaleValue' has a wrong offset!");

// ScriptStruct SHProto.SHLookAtTarget
// 0x0050 (0x0050 - 0x0000)
struct FSHLookAtTarget final
{
public:
	TWeakObjectPtr<class USceneComponent>         SceneComponent;                                    // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   LookAtTypeID;                                      // 0x0008(0x0030)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHLookAtTarget) == 0x000008, "Wrong alignment on FSHLookAtTarget");
static_assert(sizeof(FSHLookAtTarget) == 0x000050, "Wrong size on FSHLookAtTarget");
static_assert(offsetof(FSHLookAtTarget, SceneComponent) == 0x000000, "Member 'FSHLookAtTarget::SceneComponent' has a wrong offset!");
static_assert(offsetof(FSHLookAtTarget, LookAtTypeID) == 0x000008, "Member 'FSHLookAtTarget::LookAtTypeID' has a wrong offset!");

// ScriptStruct SHProto.SHAdaptiveTriggerWeaponData
// 0x0003 (0x0003 - 0x0000)
struct FSHAdaptiveTriggerWeaponData final
{
public:
	uint8                                         StartPosition;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EndPosition;                                       // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Strength;                                          // 0x0002(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHAdaptiveTriggerWeaponData) == 0x000001, "Wrong alignment on FSHAdaptiveTriggerWeaponData");
static_assert(sizeof(FSHAdaptiveTriggerWeaponData) == 0x000003, "Wrong size on FSHAdaptiveTriggerWeaponData");
static_assert(offsetof(FSHAdaptiveTriggerWeaponData, StartPosition) == 0x000000, "Member 'FSHAdaptiveTriggerWeaponData::StartPosition' has a wrong offset!");
static_assert(offsetof(FSHAdaptiveTriggerWeaponData, EndPosition) == 0x000001, "Member 'FSHAdaptiveTriggerWeaponData::EndPosition' has a wrong offset!");
static_assert(offsetof(FSHAdaptiveTriggerWeaponData, Strength) == 0x000002, "Member 'FSHAdaptiveTriggerWeaponData::Strength' has a wrong offset!");

// ScriptStruct SHProto.SHAdaptiveTriggerFeedbackData
// 0x0002 (0x0002 - 0x0000)
struct FSHAdaptiveTriggerFeedbackData final
{
public:
	uint8                                         Position;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Strength;                                          // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHAdaptiveTriggerFeedbackData) == 0x000001, "Wrong alignment on FSHAdaptiveTriggerFeedbackData");
static_assert(sizeof(FSHAdaptiveTriggerFeedbackData) == 0x000002, "Wrong size on FSHAdaptiveTriggerFeedbackData");
static_assert(offsetof(FSHAdaptiveTriggerFeedbackData, Position) == 0x000000, "Member 'FSHAdaptiveTriggerFeedbackData::Position' has a wrong offset!");
static_assert(offsetof(FSHAdaptiveTriggerFeedbackData, Strength) == 0x000001, "Member 'FSHAdaptiveTriggerFeedbackData::Strength' has a wrong offset!");

// ScriptStruct SHProto.AngleCurveWithScaleGetter
// 0x0008 (0x0018 - 0x0010)
struct FAngleCurveWithScaleGetter final : public FCurveWithScale
{
public:
	float                                         CurrentCurveTime;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxAngle;                                          // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAngleCurveWithScaleGetter) == 0x000008, "Wrong alignment on FAngleCurveWithScaleGetter");
static_assert(sizeof(FAngleCurveWithScaleGetter) == 0x000018, "Wrong size on FAngleCurveWithScaleGetter");
static_assert(offsetof(FAngleCurveWithScaleGetter, CurrentCurveTime) == 0x000010, "Member 'FAngleCurveWithScaleGetter::CurrentCurveTime' has a wrong offset!");
static_assert(offsetof(FAngleCurveWithScaleGetter, MaxAngle) == 0x000014, "Member 'FAngleCurveWithScaleGetter::MaxAngle' has a wrong offset!");

// ScriptStruct SHProto.SHHealingItemHandle
// 0x0018 (0x0018 - 0x0000)
struct FSHHealingItemHandle final
{
public:
	struct FDataTableRowHandle                    ItemHandle;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         HealingValue;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHHealingItemHandle) == 0x000008, "Wrong alignment on FSHHealingItemHandle");
static_assert(sizeof(FSHHealingItemHandle) == 0x000018, "Wrong size on FSHHealingItemHandle");
static_assert(offsetof(FSHHealingItemHandle, ItemHandle) == 0x000000, "Member 'FSHHealingItemHandle::ItemHandle' has a wrong offset!");
static_assert(offsetof(FSHHealingItemHandle, HealingValue) == 0x000010, "Member 'FSHHealingItemHandle::HealingValue' has a wrong offset!");

// ScriptStruct SHProto.SHReceiveDamageCustomPostProcessConfig
// 0x0008 (0x0058 - 0x0050)
struct FSHReceiveDamageCustomPostProcessConfig final : public FSHReceiveDamagePostProcessConfig
{
public:
	bool                                          bMarkAsSplatterVignette;                           // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHReceiveDamageCustomPostProcessConfig) == 0x000008, "Wrong alignment on FSHReceiveDamageCustomPostProcessConfig");
static_assert(sizeof(FSHReceiveDamageCustomPostProcessConfig) == 0x000058, "Wrong size on FSHReceiveDamageCustomPostProcessConfig");
static_assert(offsetof(FSHReceiveDamageCustomPostProcessConfig, bMarkAsSplatterVignette) == 0x000050, "Member 'FSHReceiveDamageCustomPostProcessConfig::bMarkAsSplatterVignette' has a wrong offset!");

// ScriptStruct SHProto.SHGenericDeathSequencesContainer
// 0x0010 (0x0010 - 0x0000)
struct FSHGenericDeathSequencesContainer final
{
public:
	TArray<TSoftClassPtr<class UClass>>           GenericDeathSequenceSoftClasses;                   // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHGenericDeathSequencesContainer) == 0x000008, "Wrong alignment on FSHGenericDeathSequencesContainer");
static_assert(sizeof(FSHGenericDeathSequencesContainer) == 0x000010, "Wrong size on FSHGenericDeathSequencesContainer");
static_assert(offsetof(FSHGenericDeathSequencesContainer, GenericDeathSequenceSoftClasses) == 0x000000, "Member 'FSHGenericDeathSequencesContainer::GenericDeathSequenceSoftClasses' has a wrong offset!");

// ScriptStruct SHProto.HitEvent
// 0x0118 (0x0118 - 0x0000)
struct FHitEvent final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00E8)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                CharacterVelocity;                                 // 0x00E8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CharacterLocation;                                 // 0x0100(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitEvent) == 0x000008, "Wrong alignment on FHitEvent");
static_assert(sizeof(FHitEvent) == 0x000118, "Wrong size on FHitEvent");
static_assert(offsetof(FHitEvent, HitResult) == 0x000000, "Member 'FHitEvent::HitResult' has a wrong offset!");
static_assert(offsetof(FHitEvent, CharacterVelocity) == 0x0000E8, "Member 'FHitEvent::CharacterVelocity' has a wrong offset!");
static_assert(offsetof(FHitEvent, CharacterLocation) == 0x000100, "Member 'FHitEvent::CharacterLocation' has a wrong offset!");

// ScriptStruct SHProto.SHRaycastDetectorTraceData
// 0x0008 (0x0128 - 0x0120)
struct FSHRaycastDetectorTraceData final : public FRaycastDetectorTraceData
{
public:
	float                                         Range;                                             // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHRaycastDetectorTraceData) == 0x000008, "Wrong alignment on FSHRaycastDetectorTraceData");
static_assert(sizeof(FSHRaycastDetectorTraceData) == 0x000128, "Wrong size on FSHRaycastDetectorTraceData");
static_assert(offsetof(FSHRaycastDetectorTraceData, Range) == 0x000120, "Member 'FSHRaycastDetectorTraceData::Range' has a wrong offset!");

// ScriptStruct SHProto.SHGameplayStatisticsData
// 0x0068 (0x0068 - 0x0000)
struct FSHGameplayStatisticsData final
{
public:
	ECombatDifficulty                             PlaythroughCombatDifficulty;                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPuzzlesDifficulty                            PlaythroughPuzzleDifficulty;                       // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHEndingType                                 PlaythroughEnding;                                 // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SeenUniqueEndings;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaytimeHours;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaytimeMinutes;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaytimeSeconds;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelledDistanceInKilometers;                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConsumableItemsPickedUp;                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MemosItemsPickedUp;                                // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LockedDoorAnimsPlayed;                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SeenMaps;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemiesKilledByRanged;                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemiesKilledByMelee;                              // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerReceivedDamage;                              // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   FavoriteWeaponDisplayName;                         // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         ShootsFired;                                       // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DestroyedGlass;                                    // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UsedHealingItems;                                  // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerDeathsCount;                                 // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerDodgesCount;                                 // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHGameplayStatisticsData) == 0x000008, "Wrong alignment on FSHGameplayStatisticsData");
static_assert(sizeof(FSHGameplayStatisticsData) == 0x000068, "Wrong size on FSHGameplayStatisticsData");
static_assert(offsetof(FSHGameplayStatisticsData, PlaythroughCombatDifficulty) == 0x000000, "Member 'FSHGameplayStatisticsData::PlaythroughCombatDifficulty' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, PlaythroughPuzzleDifficulty) == 0x000001, "Member 'FSHGameplayStatisticsData::PlaythroughPuzzleDifficulty' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, PlaythroughEnding) == 0x000002, "Member 'FSHGameplayStatisticsData::PlaythroughEnding' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, SeenUniqueEndings) == 0x000004, "Member 'FSHGameplayStatisticsData::SeenUniqueEndings' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, PlaytimeHours) == 0x000008, "Member 'FSHGameplayStatisticsData::PlaytimeHours' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, PlaytimeMinutes) == 0x00000C, "Member 'FSHGameplayStatisticsData::PlaytimeMinutes' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, PlaytimeSeconds) == 0x000010, "Member 'FSHGameplayStatisticsData::PlaytimeSeconds' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, TravelledDistanceInKilometers) == 0x000014, "Member 'FSHGameplayStatisticsData::TravelledDistanceInKilometers' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, ConsumableItemsPickedUp) == 0x000018, "Member 'FSHGameplayStatisticsData::ConsumableItemsPickedUp' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, MemosItemsPickedUp) == 0x00001C, "Member 'FSHGameplayStatisticsData::MemosItemsPickedUp' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, LockedDoorAnimsPlayed) == 0x000020, "Member 'FSHGameplayStatisticsData::LockedDoorAnimsPlayed' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, SeenMaps) == 0x000024, "Member 'FSHGameplayStatisticsData::SeenMaps' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, EnemiesKilledByRanged) == 0x000028, "Member 'FSHGameplayStatisticsData::EnemiesKilledByRanged' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, EnemiesKilledByMelee) == 0x00002C, "Member 'FSHGameplayStatisticsData::EnemiesKilledByMelee' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, PlayerReceivedDamage) == 0x000030, "Member 'FSHGameplayStatisticsData::PlayerReceivedDamage' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, FavoriteWeaponDisplayName) == 0x000038, "Member 'FSHGameplayStatisticsData::FavoriteWeaponDisplayName' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, ShootsFired) == 0x000050, "Member 'FSHGameplayStatisticsData::ShootsFired' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, DestroyedGlass) == 0x000054, "Member 'FSHGameplayStatisticsData::DestroyedGlass' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, UsedHealingItems) == 0x000058, "Member 'FSHGameplayStatisticsData::UsedHealingItems' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, PlayerDeathsCount) == 0x00005C, "Member 'FSHGameplayStatisticsData::PlayerDeathsCount' has a wrong offset!");
static_assert(offsetof(FSHGameplayStatisticsData, PlayerDodgesCount) == 0x000060, "Member 'FSHGameplayStatisticsData::PlayerDodgesCount' has a wrong offset!");

// ScriptStruct SHProto.SHSwitchesPrioritiesEnviromentData
// 0x0058 (0x0058 - 0x0000)
struct FSHSwitchesPrioritiesEnviromentData final
{
public:
	class FName                                   SwitchesCategoryName;                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UAkSwitchValue>, int32> SwitchesPrioritiesValues;                          // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHSwitchesPrioritiesEnviromentData) == 0x000008, "Wrong alignment on FSHSwitchesPrioritiesEnviromentData");
static_assert(sizeof(FSHSwitchesPrioritiesEnviromentData) == 0x000058, "Wrong size on FSHSwitchesPrioritiesEnviromentData");
static_assert(offsetof(FSHSwitchesPrioritiesEnviromentData, SwitchesCategoryName) == 0x000000, "Member 'FSHSwitchesPrioritiesEnviromentData::SwitchesCategoryName' has a wrong offset!");
static_assert(offsetof(FSHSwitchesPrioritiesEnviromentData, SwitchesPrioritiesValues) == 0x000008, "Member 'FSHSwitchesPrioritiesEnviromentData::SwitchesPrioritiesValues' has a wrong offset!");

// ScriptStruct SHProto.SHViewLookOperationSettings
// 0x0038 (0x0038 - 0x0000)
struct FSHViewLookOperationSettings final
{
public:
	bool                                          bIsSoftOperation;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SoftOperationBreakValue;                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDynamicRotation;                                // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YawAngleOffset;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSecuredOperation;                               // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            EaseCurve;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MaxUnsecuredDeltaRotator;                          // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHViewLookOperationSettings) == 0x000008, "Wrong alignment on FSHViewLookOperationSettings");
static_assert(sizeof(FSHViewLookOperationSettings) == 0x000038, "Wrong size on FSHViewLookOperationSettings");
static_assert(offsetof(FSHViewLookOperationSettings, bIsSoftOperation) == 0x000000, "Member 'FSHViewLookOperationSettings::bIsSoftOperation' has a wrong offset!");
static_assert(offsetof(FSHViewLookOperationSettings, SoftOperationBreakValue) == 0x000004, "Member 'FSHViewLookOperationSettings::SoftOperationBreakValue' has a wrong offset!");
static_assert(offsetof(FSHViewLookOperationSettings, bIsDynamicRotation) == 0x000008, "Member 'FSHViewLookOperationSettings::bIsDynamicRotation' has a wrong offset!");
static_assert(offsetof(FSHViewLookOperationSettings, YawAngleOffset) == 0x00000C, "Member 'FSHViewLookOperationSettings::YawAngleOffset' has a wrong offset!");
static_assert(offsetof(FSHViewLookOperationSettings, bIsSecuredOperation) == 0x000010, "Member 'FSHViewLookOperationSettings::bIsSecuredOperation' has a wrong offset!");
static_assert(offsetof(FSHViewLookOperationSettings, EaseCurve) == 0x000018, "Member 'FSHViewLookOperationSettings::EaseCurve' has a wrong offset!");
static_assert(offsetof(FSHViewLookOperationSettings, MaxUnsecuredDeltaRotator) == 0x000020, "Member 'FSHViewLookOperationSettings::MaxUnsecuredDeltaRotator' has a wrong offset!");

// ScriptStruct SHProto.SHCharacterPlaySecondaryAttackData
// 0x0060 (0x01F0 - 0x0190)
struct FSHCharacterPlaySecondaryAttackData final : public FSHCharacterPlayAttackBaseData
{
public:
	float                                         DesiredDistanceFromTarget;                         // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideDuration;                                     // 0x0194(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SlideCurve;                                        // 0x0198(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationDuration;                                  // 0x01A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RotationCurve;                                     // 0x01A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSecureCameraView;                                 // 0x01B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x3];                                      // 0x01B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ViewLookAtTargetDuration;                          // 0x01B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSHViewLookOperationSettings           ViewLookAtTargetSettings;                          // 0x01B8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHCharacterPlaySecondaryAttackData) == 0x000008, "Wrong alignment on FSHCharacterPlaySecondaryAttackData");
static_assert(sizeof(FSHCharacterPlaySecondaryAttackData) == 0x0001F0, "Wrong size on FSHCharacterPlaySecondaryAttackData");
static_assert(offsetof(FSHCharacterPlaySecondaryAttackData, DesiredDistanceFromTarget) == 0x000190, "Member 'FSHCharacterPlaySecondaryAttackData::DesiredDistanceFromTarget' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlaySecondaryAttackData, SlideDuration) == 0x000194, "Member 'FSHCharacterPlaySecondaryAttackData::SlideDuration' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlaySecondaryAttackData, SlideCurve) == 0x000198, "Member 'FSHCharacterPlaySecondaryAttackData::SlideCurve' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlaySecondaryAttackData, RotationDuration) == 0x0001A0, "Member 'FSHCharacterPlaySecondaryAttackData::RotationDuration' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlaySecondaryAttackData, RotationCurve) == 0x0001A8, "Member 'FSHCharacterPlaySecondaryAttackData::RotationCurve' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlaySecondaryAttackData, bSecureCameraView) == 0x0001B0, "Member 'FSHCharacterPlaySecondaryAttackData::bSecureCameraView' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlaySecondaryAttackData, ViewLookAtTargetDuration) == 0x0001B4, "Member 'FSHCharacterPlaySecondaryAttackData::ViewLookAtTargetDuration' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlaySecondaryAttackData, ViewLookAtTargetSettings) == 0x0001B8, "Member 'FSHCharacterPlaySecondaryAttackData::ViewLookAtTargetSettings' has a wrong offset!");

// ScriptStruct SHProto.SHSlideDataStruct
// 0x0010 (0x0010 - 0x0000)
struct FSHSlideDataStruct final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AlphaModCurve;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHSlideDataStruct) == 0x000008, "Wrong alignment on FSHSlideDataStruct");
static_assert(sizeof(FSHSlideDataStruct) == 0x000010, "Wrong size on FSHSlideDataStruct");
static_assert(offsetof(FSHSlideDataStruct, Distance) == 0x000000, "Member 'FSHSlideDataStruct::Distance' has a wrong offset!");
static_assert(offsetof(FSHSlideDataStruct, Duration) == 0x000004, "Member 'FSHSlideDataStruct::Duration' has a wrong offset!");
static_assert(offsetof(FSHSlideDataStruct, AlphaModCurve) == 0x000008, "Member 'FSHSlideDataStruct::AlphaModCurve' has a wrong offset!");

// ScriptStruct SHProto.SHSlideActionDataStruct
// 0x00C0 (0x00C0 - 0x0000)
struct FSHSlideActionDataStruct
{
public:
	struct FPlayAnimationData                     AnimationData;                                     // 0x0000(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSHSlideDataStruct                     SlideData;                                         // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHSlideActionDataStruct) == 0x000008, "Wrong alignment on FSHSlideActionDataStruct");
static_assert(sizeof(FSHSlideActionDataStruct) == 0x0000C0, "Wrong size on FSHSlideActionDataStruct");
static_assert(offsetof(FSHSlideActionDataStruct, AnimationData) == 0x000000, "Member 'FSHSlideActionDataStruct::AnimationData' has a wrong offset!");
static_assert(offsetof(FSHSlideActionDataStruct, SlideData) == 0x0000B0, "Member 'FSHSlideActionDataStruct::SlideData' has a wrong offset!");

// ScriptStruct SHProto.ReticleTextureConfig
// 0x00A8 (0x00A8 - 0x0000)
struct FReticleTextureConfig final
{
public:
	TSoftObjectPtr<class UTexture2D>              Thin;                                              // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ThinAtlasSize;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              Normal;                                            // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NormalAtlasSize;                                   // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              Thick;                                             // 0x0070(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ThickAtlasSize;                                    // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReticleTextureConfig) == 0x000008, "Wrong alignment on FReticleTextureConfig");
static_assert(sizeof(FReticleTextureConfig) == 0x0000A8, "Wrong size on FReticleTextureConfig");
static_assert(offsetof(FReticleTextureConfig, Thin) == 0x000000, "Member 'FReticleTextureConfig::Thin' has a wrong offset!");
static_assert(offsetof(FReticleTextureConfig, ThinAtlasSize) == 0x000030, "Member 'FReticleTextureConfig::ThinAtlasSize' has a wrong offset!");
static_assert(offsetof(FReticleTextureConfig, Normal) == 0x000038, "Member 'FReticleTextureConfig::Normal' has a wrong offset!");
static_assert(offsetof(FReticleTextureConfig, NormalAtlasSize) == 0x000068, "Member 'FReticleTextureConfig::NormalAtlasSize' has a wrong offset!");
static_assert(offsetof(FReticleTextureConfig, Thick) == 0x000070, "Member 'FReticleTextureConfig::Thick' has a wrong offset!");
static_assert(offsetof(FReticleTextureConfig, ThickAtlasSize) == 0x0000A0, "Member 'FReticleTextureConfig::ThickAtlasSize' has a wrong offset!");

// ScriptStruct SHProto.CustomDecalHitData
// 0x0028 (0x0028 - 0x0000)
struct FCustomDecalHitData final
{
public:
	struct FVector                                ImpactPoint;                                       // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ALPHA;                                             // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FrameIndex;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomDecalHitData) == 0x000008, "Wrong alignment on FCustomDecalHitData");
static_assert(sizeof(FCustomDecalHitData) == 0x000028, "Wrong size on FCustomDecalHitData");
static_assert(offsetof(FCustomDecalHitData, ImpactPoint) == 0x000000, "Member 'FCustomDecalHitData::ImpactPoint' has a wrong offset!");
static_assert(offsetof(FCustomDecalHitData, Radius) == 0x000018, "Member 'FCustomDecalHitData::Radius' has a wrong offset!");
static_assert(offsetof(FCustomDecalHitData, ALPHA) == 0x00001C, "Member 'FCustomDecalHitData::ALPHA' has a wrong offset!");
static_assert(offsetof(FCustomDecalHitData, FrameIndex) == 0x000020, "Member 'FCustomDecalHitData::FrameIndex' has a wrong offset!");

// ScriptStruct SHProto.CustomDecalMeshHits
// 0x0010 (0x0010 - 0x0000)
struct FCustomDecalMeshHits final
{
public:
	TArray<struct FCustomDecalHitData>            DecalHits;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomDecalMeshHits) == 0x000008, "Wrong alignment on FCustomDecalMeshHits");
static_assert(sizeof(FCustomDecalMeshHits) == 0x000010, "Wrong size on FCustomDecalMeshHits");
static_assert(offsetof(FCustomDecalMeshHits, DecalHits) == 0x000000, "Member 'FCustomDecalMeshHits::DecalHits' has a wrong offset!");

// ScriptStruct SHProto.SHCustomPrimitiveDataHandler
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x04) FSHCustomPrimitiveDataHandler final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHCustomPrimitiveDataHandler) == 0x000004, "Wrong alignment on FSHCustomPrimitiveDataHandler");
static_assert(sizeof(FSHCustomPrimitiveDataHandler) == 0x000020, "Wrong size on FSHCustomPrimitiveDataHandler");

// ScriptStruct SHProto.SHDeathPlayerFinishPostProcessData
// 0x0028 (0x0028 - 0x0000)
struct FSHDeathPlayerFinishPostProcessData final
{
public:
	bool                                          bUseFinishPostProcess;                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PostProcessAnimationLength;                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostProcessAnimationHoldTime;                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     PostProcessMaterial;                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHMaterialPropertyControlSettings*     MaterialPropertyControlSettings;                   // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowGameOverScreenOnFinish;                       // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHDeathPlayerFinishPostProcessData) == 0x000008, "Wrong alignment on FSHDeathPlayerFinishPostProcessData");
static_assert(sizeof(FSHDeathPlayerFinishPostProcessData) == 0x000028, "Wrong size on FSHDeathPlayerFinishPostProcessData");
static_assert(offsetof(FSHDeathPlayerFinishPostProcessData, bUseFinishPostProcess) == 0x000000, "Member 'FSHDeathPlayerFinishPostProcessData::bUseFinishPostProcess' has a wrong offset!");
static_assert(offsetof(FSHDeathPlayerFinishPostProcessData, PostProcessAnimationLength) == 0x000004, "Member 'FSHDeathPlayerFinishPostProcessData::PostProcessAnimationLength' has a wrong offset!");
static_assert(offsetof(FSHDeathPlayerFinishPostProcessData, PostProcessAnimationHoldTime) == 0x000008, "Member 'FSHDeathPlayerFinishPostProcessData::PostProcessAnimationHoldTime' has a wrong offset!");
static_assert(offsetof(FSHDeathPlayerFinishPostProcessData, PostProcessMaterial) == 0x000010, "Member 'FSHDeathPlayerFinishPostProcessData::PostProcessMaterial' has a wrong offset!");
static_assert(offsetof(FSHDeathPlayerFinishPostProcessData, MaterialPropertyControlSettings) == 0x000018, "Member 'FSHDeathPlayerFinishPostProcessData::MaterialPropertyControlSettings' has a wrong offset!");
static_assert(offsetof(FSHDeathPlayerFinishPostProcessData, bShowGameOverScreenOnFinish) == 0x000020, "Member 'FSHDeathPlayerFinishPostProcessData::bShowGameOverScreenOnFinish' has a wrong offset!");

// ScriptStruct SHProto.SHDeathPlayerData
// 0x0090 (0x0090 - 0x0000)
struct FSHDeathPlayerData final
{
public:
	struct FGameplayTag                           PawnAnimationTag;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PlayerAnimationTag;                                // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSHCameraAnimationData                 CameraAnimation;                                   // 0x0010(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHDeathPlayerData) == 0x000008, "Wrong alignment on FSHDeathPlayerData");
static_assert(sizeof(FSHDeathPlayerData) == 0x000090, "Wrong size on FSHDeathPlayerData");
static_assert(offsetof(FSHDeathPlayerData, PawnAnimationTag) == 0x000000, "Member 'FSHDeathPlayerData::PawnAnimationTag' has a wrong offset!");
static_assert(offsetof(FSHDeathPlayerData, PlayerAnimationTag) == 0x000008, "Member 'FSHDeathPlayerData::PlayerAnimationTag' has a wrong offset!");
static_assert(offsetof(FSHDeathPlayerData, CameraAnimation) == 0x000010, "Member 'FSHDeathPlayerData::CameraAnimation' has a wrong offset!");

// ScriptStruct SHProto.SHLockedDoorCheckAnimationContextData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FSHLockedDoorCheckAnimationContextData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHLockedDoorCheckAnimationContextData) == 0x000008, "Wrong alignment on FSHLockedDoorCheckAnimationContextData");
static_assert(sizeof(FSHLockedDoorCheckAnimationContextData) == 0x000018, "Wrong size on FSHLockedDoorCheckAnimationContextData");

// ScriptStruct SHProto.SHKeyAttachmentDataStruct
// 0x0048 (0x0050 - 0x0008)
struct FSHKeyAttachmentDataStruct final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UStaticMesh>             Mesh;                                              // 0x0008(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MeshRelativeOffset;                                // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHKeyAttachmentDataStruct) == 0x000008, "Wrong alignment on FSHKeyAttachmentDataStruct");
static_assert(sizeof(FSHKeyAttachmentDataStruct) == 0x000050, "Wrong size on FSHKeyAttachmentDataStruct");
static_assert(offsetof(FSHKeyAttachmentDataStruct, Mesh) == 0x000008, "Member 'FSHKeyAttachmentDataStruct::Mesh' has a wrong offset!");
static_assert(offsetof(FSHKeyAttachmentDataStruct, MeshRelativeOffset) == 0x000038, "Member 'FSHKeyAttachmentDataStruct::MeshRelativeOffset' has a wrong offset!");

// ScriptStruct SHProto.SHDPSCounterElementData
// 0x0010 (0x0010 - 0x0000)
struct FSHDPSCounterElementData final
{
public:
	double                                        DamageTime;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageValue;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHDPSCounterElementData) == 0x000008, "Wrong alignment on FSHDPSCounterElementData");
static_assert(sizeof(FSHDPSCounterElementData) == 0x000010, "Wrong size on FSHDPSCounterElementData");
static_assert(offsetof(FSHDPSCounterElementData, DamageTime) == 0x000000, "Member 'FSHDPSCounterElementData::DamageTime' has a wrong offset!");
static_assert(offsetof(FSHDPSCounterElementData, DamageValue) == 0x000008, "Member 'FSHDPSCounterElementData::DamageValue' has a wrong offset!");

// ScriptStruct SHProto.HEddieSkeletonHierarchy
// 0x0000 (0x0108 - 0x0108)
struct FHEddieSkeletonHierarchy final : public FSkeletonHierarchy
{
};
static_assert(alignof(FHEddieSkeletonHierarchy) == 0x000008, "Wrong alignment on FHEddieSkeletonHierarchy");
static_assert(sizeof(FHEddieSkeletonHierarchy) == 0x000108, "Wrong size on FHEddieSkeletonHierarchy");

// ScriptStruct SHProto.SHEndingScoreChanger
// 0x0050 (0x0050 - 0x0000)
struct FSHEndingScoreChanger final
{
public:
	TMap<ESHEndingType, int32>                    EndingScoreChangeMap;                              // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEndingScoreChanger) == 0x000008, "Wrong alignment on FSHEndingScoreChanger");
static_assert(sizeof(FSHEndingScoreChanger) == 0x000050, "Wrong size on FSHEndingScoreChanger");
static_assert(offsetof(FSHEndingScoreChanger, EndingScoreChangeMap) == 0x000000, "Member 'FSHEndingScoreChanger::EndingScoreChangeMap' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionBoneGroupBone
// 0x000C (0x000C - 0x0000)
struct FSHEnemyHitReactionSelectionBoneGroupBone final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoneShapeIndex;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionBoneGroupBone) == 0x000004, "Wrong alignment on FSHEnemyHitReactionSelectionBoneGroupBone");
static_assert(sizeof(FSHEnemyHitReactionSelectionBoneGroupBone) == 0x00000C, "Wrong size on FSHEnemyHitReactionSelectionBoneGroupBone");
static_assert(offsetof(FSHEnemyHitReactionSelectionBoneGroupBone, BoneName) == 0x000000, "Member 'FSHEnemyHitReactionSelectionBoneGroupBone::BoneName' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionBoneGroupBone, BoneShapeIndex) == 0x000008, "Member 'FSHEnemyHitReactionSelectionBoneGroupBone::BoneShapeIndex' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionBoneGroup
// 0x0038 (0x0038 - 0x0000)
struct FSHEnemyHitReactionSelectionBoneGroup final
{
public:
	class FName                                   GroupName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           Bones;                                             // 0x0008(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSHEnemyHitReactionSelectionBoneGroupBone> GroupBones;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseIndividualConsecutiveHitsCounter;              // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomConsecutiveHitsCounter;                      // 0x002C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHEnemyHitReactionSelectionBoneGroup) == 0x000008, "Wrong alignment on FSHEnemyHitReactionSelectionBoneGroup");
static_assert(sizeof(FSHEnemyHitReactionSelectionBoneGroup) == 0x000038, "Wrong size on FSHEnemyHitReactionSelectionBoneGroup");
static_assert(offsetof(FSHEnemyHitReactionSelectionBoneGroup, GroupName) == 0x000000, "Member 'FSHEnemyHitReactionSelectionBoneGroup::GroupName' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionBoneGroup, Bones) == 0x000008, "Member 'FSHEnemyHitReactionSelectionBoneGroup::Bones' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionBoneGroup, GroupBones) == 0x000018, "Member 'FSHEnemyHitReactionSelectionBoneGroup::GroupBones' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionBoneGroup, bUseIndividualConsecutiveHitsCounter) == 0x000028, "Member 'FSHEnemyHitReactionSelectionBoneGroup::bUseIndividualConsecutiveHitsCounter' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionBoneGroup, CustomConsecutiveHitsCounter) == 0x00002C, "Member 'FSHEnemyHitReactionSelectionBoneGroup::CustomConsecutiveHitsCounter' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionAllowedHitReactionState
// 0x0018 (0x0018 - 0x0000)
struct FSHEnemyHitReactionSelectionAllowedHitReactionState final
{
public:
	bool                                          bAllow;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PreventVariants;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionAllowedHitReactionState) == 0x000008, "Wrong alignment on FSHEnemyHitReactionSelectionAllowedHitReactionState");
static_assert(sizeof(FSHEnemyHitReactionSelectionAllowedHitReactionState) == 0x000018, "Wrong size on FSHEnemyHitReactionSelectionAllowedHitReactionState");
static_assert(offsetof(FSHEnemyHitReactionSelectionAllowedHitReactionState, bAllow) == 0x000000, "Member 'FSHEnemyHitReactionSelectionAllowedHitReactionState::bAllow' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionAllowedHitReactionState, PreventVariants) == 0x000008, "Member 'FSHEnemyHitReactionSelectionAllowedHitReactionState::PreventVariants' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionAllowedStates
// 0x0060 (0x0060 - 0x0000)
struct FSHEnemyHitReactionSelectionAllowedStates final
{
public:
	struct FSHEnemyHitReactionSelectionAllowedHitReactionState Knockdown;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSHEnemyHitReactionSelectionAllowedHitReactionState Falter;                                            // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSHEnemyHitReactionSelectionAllowedHitReactionState Stagger;                                           // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSHEnemyHitReactionSelectionAllowedHitReactionState Normal;                                            // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionAllowedStates) == 0x000008, "Wrong alignment on FSHEnemyHitReactionSelectionAllowedStates");
static_assert(sizeof(FSHEnemyHitReactionSelectionAllowedStates) == 0x000060, "Wrong size on FSHEnemyHitReactionSelectionAllowedStates");
static_assert(offsetof(FSHEnemyHitReactionSelectionAllowedStates, Knockdown) == 0x000000, "Member 'FSHEnemyHitReactionSelectionAllowedStates::Knockdown' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionAllowedStates, Falter) == 0x000018, "Member 'FSHEnemyHitReactionSelectionAllowedStates::Falter' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionAllowedStates, Stagger) == 0x000030, "Member 'FSHEnemyHitReactionSelectionAllowedStates::Stagger' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionAllowedStates, Normal) == 0x000048, "Member 'FSHEnemyHitReactionSelectionAllowedStates::Normal' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionHitReactionRequiredAggression
// 0x0002 (0x0002 - 0x0000)
struct FSHEnemyHitReactionSelectionHitReactionRequiredAggression final
{
public:
	EMaiAggroStance                               MinimumAggressionLevel;                            // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaiAggroStance                               MaximumAggressionLevel;                            // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionHitReactionRequiredAggression) == 0x000001, "Wrong alignment on FSHEnemyHitReactionSelectionHitReactionRequiredAggression");
static_assert(sizeof(FSHEnemyHitReactionSelectionHitReactionRequiredAggression) == 0x000002, "Wrong size on FSHEnemyHitReactionSelectionHitReactionRequiredAggression");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionRequiredAggression, MinimumAggressionLevel) == 0x000000, "Member 'FSHEnemyHitReactionSelectionHitReactionRequiredAggression::MinimumAggressionLevel' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionRequiredAggression, MaximumAggressionLevel) == 0x000001, "Member 'FSHEnemyHitReactionSelectionHitReactionRequiredAggression::MaximumAggressionLevel' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionHitReactionRequiredActiveHitReaction
// 0x000C (0x000C - 0x0000)
struct FSHEnemyHitReactionSelectionHitReactionRequiredActiveHitReaction final
{
public:
	ESHHitReactionResponseType                    HitReactionType;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   VariantName;                                       // 0x0004(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionHitReactionRequiredActiveHitReaction) == 0x000004, "Wrong alignment on FSHEnemyHitReactionSelectionHitReactionRequiredActiveHitReaction");
static_assert(sizeof(FSHEnemyHitReactionSelectionHitReactionRequiredActiveHitReaction) == 0x00000C, "Wrong size on FSHEnemyHitReactionSelectionHitReactionRequiredActiveHitReaction");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionRequiredActiveHitReaction, HitReactionType) == 0x000000, "Member 'FSHEnemyHitReactionSelectionHitReactionRequiredActiveHitReaction::HitReactionType' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionRequiredActiveHitReaction, VariantName) == 0x000004, "Member 'FSHEnemyHitReactionSelectionHitReactionRequiredActiveHitReaction::VariantName' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionHitReactionRequiredActiveHitReactions
// 0x0010 (0x0010 - 0x0000)
struct FSHEnemyHitReactionSelectionHitReactionRequiredActiveHitReactions final
{
public:
	TArray<struct FSHEnemyHitReactionSelectionHitReactionRequiredActiveHitReaction> RequiredHitReactions;                              // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionHitReactionRequiredActiveHitReactions) == 0x000008, "Wrong alignment on FSHEnemyHitReactionSelectionHitReactionRequiredActiveHitReactions");
static_assert(sizeof(FSHEnemyHitReactionSelectionHitReactionRequiredActiveHitReactions) == 0x000010, "Wrong size on FSHEnemyHitReactionSelectionHitReactionRequiredActiveHitReactions");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionRequiredActiveHitReactions, RequiredHitReactions) == 0x000000, "Member 'FSHEnemyHitReactionSelectionHitReactionRequiredActiveHitReactions::RequiredHitReactions' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionHitReactionTypeVariantConfiguration
// 0x000C (0x000C - 0x0000)
struct FSHEnemyHitReactionSelectionHitReactionTypeVariantConfiguration final
{
public:
	class FName                                   VariantName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectionWeight;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionHitReactionTypeVariantConfiguration) == 0x000004, "Wrong alignment on FSHEnemyHitReactionSelectionHitReactionTypeVariantConfiguration");
static_assert(sizeof(FSHEnemyHitReactionSelectionHitReactionTypeVariantConfiguration) == 0x00000C, "Wrong size on FSHEnemyHitReactionSelectionHitReactionTypeVariantConfiguration");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionTypeVariantConfiguration, VariantName) == 0x000000, "Member 'FSHEnemyHitReactionSelectionHitReactionTypeVariantConfiguration::VariantName' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionTypeVariantConfiguration, SelectionWeight) == 0x000008, "Member 'FSHEnemyHitReactionSelectionHitReactionTypeVariantConfiguration::SelectionWeight' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionHitReactionTypeConfiguration
// 0x0018 (0x0018 - 0x0000)
struct FSHEnemyHitReactionSelectionHitReactionTypeConfiguration final
{
public:
	float                                         Chance;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHEnemyHitReactionSelectionHitReactionTypeVariantConfiguration> Variants;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionHitReactionTypeConfiguration) == 0x000008, "Wrong alignment on FSHEnemyHitReactionSelectionHitReactionTypeConfiguration");
static_assert(sizeof(FSHEnemyHitReactionSelectionHitReactionTypeConfiguration) == 0x000018, "Wrong size on FSHEnemyHitReactionSelectionHitReactionTypeConfiguration");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionTypeConfiguration, Chance) == 0x000000, "Member 'FSHEnemyHitReactionSelectionHitReactionTypeConfiguration::Chance' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionTypeConfiguration, Variants) == 0x000008, "Member 'FSHEnemyHitReactionSelectionHitReactionTypeConfiguration::Variants' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionHitCountersResetConfiguration
// 0x0018 (0x0018 - 0x0000)
struct FSHEnemyHitReactionSelectionHitCountersResetConfiguration final
{
public:
	bool                                          bResetHitBoneGroupCounter;                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ResetCountersOfBoneGroups;                         // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionHitCountersResetConfiguration) == 0x000008, "Wrong alignment on FSHEnemyHitReactionSelectionHitCountersResetConfiguration");
static_assert(sizeof(FSHEnemyHitReactionSelectionHitCountersResetConfiguration) == 0x000018, "Wrong size on FSHEnemyHitReactionSelectionHitCountersResetConfiguration");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitCountersResetConfiguration, bResetHitBoneGroupCounter) == 0x000000, "Member 'FSHEnemyHitReactionSelectionHitCountersResetConfiguration::bResetHitBoneGroupCounter' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitCountersResetConfiguration, ResetCountersOfBoneGroups) == 0x000008, "Member 'FSHEnemyHitReactionSelectionHitCountersResetConfiguration::ResetCountersOfBoneGroups' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionHitReactionOption
// 0x0100 (0x0100 - 0x0000)
struct FSHEnemyHitReactionSelectionHitReactionOption final
{
public:
	float                                         PassChance;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMinMaxVector2D                        RequiredHealth;                                    // 0x0004(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSHEnemyHitReactionSelectionHitReactionRequiredAggression RequiredAggression;                                // 0x000C(0x0002)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinMaxVector2D                        RequiredDistance;                                  // 0x0010(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDirectionCondition                    RequiredDirection;                                 // 0x0018(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FMinMaxVector2D                        RequiredTargetVelocity;                            // 0x002C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDirectionCondition                    RequiredTargetVelocityDirection;                   // 0x0034(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSHEnemyHitReactionSelectionHitReactionRequiredActiveHitReactions RequiredActiveHitReactions;                        // 0x0048(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         DamageMultiplier;                                  // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumRemainingHealthFraction;                    // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSHEnemyHitReactionSelectionHitReactionTypeConfiguration KnockdownHitReaction;                              // 0x0060(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSHEnemyHitReactionSelectionHitReactionTypeConfiguration StaggerHitReaction;                                // 0x0078(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSHEnemyHitReactionSelectionHitReactionTypeConfiguration FalterHitReaction;                                 // 0x0090(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSHEnemyHitReactionSelectionHitReactionTypeConfiguration NormalHitReaction;                                 // 0x00A8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSHEnemyHitReactionSelectionHitReactionTypeConfiguration TwitchHitReaction;                                 // 0x00C0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSHEnemyHitReactionSelectionHitReactionTypeVariantConfiguration> DeathVariants;                                     // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSHEnemyHitReactionSelectionHitCountersResetConfiguration ResetHitCounters;                                  // 0x00E8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionHitReactionOption) == 0x000008, "Wrong alignment on FSHEnemyHitReactionSelectionHitReactionOption");
static_assert(sizeof(FSHEnemyHitReactionSelectionHitReactionOption) == 0x000100, "Wrong size on FSHEnemyHitReactionSelectionHitReactionOption");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionOption, PassChance) == 0x000000, "Member 'FSHEnemyHitReactionSelectionHitReactionOption::PassChance' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionOption, RequiredHealth) == 0x000004, "Member 'FSHEnemyHitReactionSelectionHitReactionOption::RequiredHealth' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionOption, RequiredAggression) == 0x00000C, "Member 'FSHEnemyHitReactionSelectionHitReactionOption::RequiredAggression' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionOption, RequiredDistance) == 0x000010, "Member 'FSHEnemyHitReactionSelectionHitReactionOption::RequiredDistance' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionOption, RequiredDirection) == 0x000018, "Member 'FSHEnemyHitReactionSelectionHitReactionOption::RequiredDirection' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionOption, RequiredTargetVelocity) == 0x00002C, "Member 'FSHEnemyHitReactionSelectionHitReactionOption::RequiredTargetVelocity' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionOption, RequiredTargetVelocityDirection) == 0x000034, "Member 'FSHEnemyHitReactionSelectionHitReactionOption::RequiredTargetVelocityDirection' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionOption, RequiredActiveHitReactions) == 0x000048, "Member 'FSHEnemyHitReactionSelectionHitReactionOption::RequiredActiveHitReactions' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionOption, DamageMultiplier) == 0x000058, "Member 'FSHEnemyHitReactionSelectionHitReactionOption::DamageMultiplier' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionOption, MaximumRemainingHealthFraction) == 0x00005C, "Member 'FSHEnemyHitReactionSelectionHitReactionOption::MaximumRemainingHealthFraction' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionOption, KnockdownHitReaction) == 0x000060, "Member 'FSHEnemyHitReactionSelectionHitReactionOption::KnockdownHitReaction' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionOption, StaggerHitReaction) == 0x000078, "Member 'FSHEnemyHitReactionSelectionHitReactionOption::StaggerHitReaction' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionOption, FalterHitReaction) == 0x000090, "Member 'FSHEnemyHitReactionSelectionHitReactionOption::FalterHitReaction' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionOption, NormalHitReaction) == 0x0000A8, "Member 'FSHEnemyHitReactionSelectionHitReactionOption::NormalHitReaction' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionOption, TwitchHitReaction) == 0x0000C0, "Member 'FSHEnemyHitReactionSelectionHitReactionOption::TwitchHitReaction' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionOption, DeathVariants) == 0x0000D8, "Member 'FSHEnemyHitReactionSelectionHitReactionOption::DeathVariants' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitReactionOption, ResetHitCounters) == 0x0000E8, "Member 'FSHEnemyHitReactionSelectionHitReactionOption::ResetHitCounters' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionDefaultHitReactionVariants
// 0x0060 (0x0060 - 0x0000)
struct FSHEnemyHitReactionSelectionDefaultHitReactionVariants final
{
public:
	TArray<struct FSHEnemyHitReactionSelectionHitReactionTypeVariantConfiguration> KnockdownVariants;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSHEnemyHitReactionSelectionHitReactionTypeVariantConfiguration> StaggerVariants;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSHEnemyHitReactionSelectionHitReactionTypeVariantConfiguration> FalterVariants;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSHEnemyHitReactionSelectionHitReactionTypeVariantConfiguration> NormalVariants;                                    // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSHEnemyHitReactionSelectionHitReactionTypeVariantConfiguration> TwitchVariants;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSHEnemyHitReactionSelectionHitReactionTypeVariantConfiguration> DeathVariants;                                     // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionDefaultHitReactionVariants) == 0x000008, "Wrong alignment on FSHEnemyHitReactionSelectionDefaultHitReactionVariants");
static_assert(sizeof(FSHEnemyHitReactionSelectionDefaultHitReactionVariants) == 0x000060, "Wrong size on FSHEnemyHitReactionSelectionDefaultHitReactionVariants");
static_assert(offsetof(FSHEnemyHitReactionSelectionDefaultHitReactionVariants, KnockdownVariants) == 0x000000, "Member 'FSHEnemyHitReactionSelectionDefaultHitReactionVariants::KnockdownVariants' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionDefaultHitReactionVariants, StaggerVariants) == 0x000010, "Member 'FSHEnemyHitReactionSelectionDefaultHitReactionVariants::StaggerVariants' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionDefaultHitReactionVariants, FalterVariants) == 0x000020, "Member 'FSHEnemyHitReactionSelectionDefaultHitReactionVariants::FalterVariants' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionDefaultHitReactionVariants, NormalVariants) == 0x000030, "Member 'FSHEnemyHitReactionSelectionDefaultHitReactionVariants::NormalVariants' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionDefaultHitReactionVariants, TwitchVariants) == 0x000040, "Member 'FSHEnemyHitReactionSelectionDefaultHitReactionVariants::TwitchVariants' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionDefaultHitReactionVariants, DeathVariants) == 0x000050, "Member 'FSHEnemyHitReactionSelectionDefaultHitReactionVariants::DeathVariants' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionConsecutiveHitConfiguration
// 0x0010 (0x0010 - 0x0000)
struct FSHEnemyHitReactionSelectionConsecutiveHitConfiguration final
{
public:
	TArray<struct FSHEnemyHitReactionSelectionHitReactionOption> HitReactionOptions;                                // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionConsecutiveHitConfiguration) == 0x000008, "Wrong alignment on FSHEnemyHitReactionSelectionConsecutiveHitConfiguration");
static_assert(sizeof(FSHEnemyHitReactionSelectionConsecutiveHitConfiguration) == 0x000010, "Wrong size on FSHEnemyHitReactionSelectionConsecutiveHitConfiguration");
static_assert(offsetof(FSHEnemyHitReactionSelectionConsecutiveHitConfiguration, HitReactionOptions) == 0x000000, "Member 'FSHEnemyHitReactionSelectionConsecutiveHitConfiguration::HitReactionOptions' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionHitBonesConfiguration
// 0x0020 (0x0020 - 0x0000)
struct FSHEnemyHitReactionSelectionHitBonesConfiguration final
{
public:
	TArray<class FName>                           HitBoneNames;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSHEnemyHitReactionSelectionConsecutiveHitConfiguration> ConsecutiveHits;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionHitBonesConfiguration) == 0x000008, "Wrong alignment on FSHEnemyHitReactionSelectionHitBonesConfiguration");
static_assert(sizeof(FSHEnemyHitReactionSelectionHitBonesConfiguration) == 0x000020, "Wrong size on FSHEnemyHitReactionSelectionHitBonesConfiguration");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitBonesConfiguration, HitBoneNames) == 0x000000, "Member 'FSHEnemyHitReactionSelectionHitBonesConfiguration::HitBoneNames' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitBonesConfiguration, ConsecutiveHits) == 0x000010, "Member 'FSHEnemyHitReactionSelectionHitBonesConfiguration::ConsecutiveHits' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionDefaultHitBoneConfiguration
// 0x0010 (0x0010 - 0x0000)
struct FSHEnemyHitReactionSelectionDefaultHitBoneConfiguration final
{
public:
	TArray<struct FSHEnemyHitReactionSelectionConsecutiveHitConfiguration> ConsecutiveHits;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionDefaultHitBoneConfiguration) == 0x000008, "Wrong alignment on FSHEnemyHitReactionSelectionDefaultHitBoneConfiguration");
static_assert(sizeof(FSHEnemyHitReactionSelectionDefaultHitBoneConfiguration) == 0x000010, "Wrong size on FSHEnemyHitReactionSelectionDefaultHitBoneConfiguration");
static_assert(offsetof(FSHEnemyHitReactionSelectionDefaultHitBoneConfiguration, ConsecutiveHits) == 0x000000, "Member 'FSHEnemyHitReactionSelectionDefaultHitBoneConfiguration::ConsecutiveHits' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionDamageTypeConfiguration
// 0x0088 (0x0088 - 0x0000)
struct FSHEnemyHitReactionSelectionDamageTypeConfiguration final
{
public:
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSHEnemyHitReactionSelectionHitBonesConfiguration> SpecificBonesResponse;                             // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSHEnemyHitReactionSelectionDefaultHitBoneConfiguration DefaultResponse;                                   // 0x0018(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSHEnemyHitReactionSelectionDefaultHitReactionVariants DefaultHitReactionVariants;                        // 0x0028(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionDamageTypeConfiguration) == 0x000008, "Wrong alignment on FSHEnemyHitReactionSelectionDamageTypeConfiguration");
static_assert(sizeof(FSHEnemyHitReactionSelectionDamageTypeConfiguration) == 0x000088, "Wrong size on FSHEnemyHitReactionSelectionDamageTypeConfiguration");
static_assert(offsetof(FSHEnemyHitReactionSelectionDamageTypeConfiguration, DamageType) == 0x000000, "Member 'FSHEnemyHitReactionSelectionDamageTypeConfiguration::DamageType' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionDamageTypeConfiguration, SpecificBonesResponse) == 0x000008, "Member 'FSHEnemyHitReactionSelectionDamageTypeConfiguration::SpecificBonesResponse' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionDamageTypeConfiguration, DefaultResponse) == 0x000018, "Member 'FSHEnemyHitReactionSelectionDamageTypeConfiguration::DefaultResponse' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionDamageTypeConfiguration, DefaultHitReactionVariants) == 0x000028, "Member 'FSHEnemyHitReactionSelectionDamageTypeConfiguration::DefaultHitReactionVariants' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionConfiguration
// 0x0010 (0x0010 - 0x0000)
struct FSHEnemyHitReactionSelectionConfiguration final
{
public:
	TArray<struct FSHEnemyHitReactionSelectionDamageTypeConfiguration> DamageTypeConfigurations;                          // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionConfiguration) == 0x000008, "Wrong alignment on FSHEnemyHitReactionSelectionConfiguration");
static_assert(sizeof(FSHEnemyHitReactionSelectionConfiguration) == 0x000010, "Wrong size on FSHEnemyHitReactionSelectionConfiguration");
static_assert(offsetof(FSHEnemyHitReactionSelectionConfiguration, DamageTypeConfigurations) == 0x000000, "Member 'FSHEnemyHitReactionSelectionConfiguration::DamageTypeConfigurations' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionConsecutiveHitCountingDamageTypeConfiguration
// 0x0010 (0x0010 - 0x0000)
struct FSHEnemyHitReactionSelectionConsecutiveHitCountingDamageTypeConfiguration final
{
public:
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CountedHitTimeoutOverride;                         // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHEnemyHitReactionSelectionConsecutiveHitCountingDamageTypeConfiguration) == 0x000008, "Wrong alignment on FSHEnemyHitReactionSelectionConsecutiveHitCountingDamageTypeConfiguration");
static_assert(sizeof(FSHEnemyHitReactionSelectionConsecutiveHitCountingDamageTypeConfiguration) == 0x000010, "Wrong size on FSHEnemyHitReactionSelectionConsecutiveHitCountingDamageTypeConfiguration");
static_assert(offsetof(FSHEnemyHitReactionSelectionConsecutiveHitCountingDamageTypeConfiguration, DamageType) == 0x000000, "Member 'FSHEnemyHitReactionSelectionConsecutiveHitCountingDamageTypeConfiguration::DamageType' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionConsecutiveHitCountingDamageTypeConfiguration, CountedHitTimeoutOverride) == 0x000008, "Member 'FSHEnemyHitReactionSelectionConsecutiveHitCountingDamageTypeConfiguration::CountedHitTimeoutOverride' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionConsecutiveHitsCountingConfiguration
// 0x0018 (0x0018 - 0x0000)
struct FSHEnemyHitReactionSelectionConsecutiveHitsCountingConfiguration final
{
public:
	float                                         CountedHitTimeout;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHEnemyHitReactionSelectionConsecutiveHitCountingDamageTypeConfiguration> DamageTypeOverrides;                               // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionConsecutiveHitsCountingConfiguration) == 0x000008, "Wrong alignment on FSHEnemyHitReactionSelectionConsecutiveHitsCountingConfiguration");
static_assert(sizeof(FSHEnemyHitReactionSelectionConsecutiveHitsCountingConfiguration) == 0x000018, "Wrong size on FSHEnemyHitReactionSelectionConsecutiveHitsCountingConfiguration");
static_assert(offsetof(FSHEnemyHitReactionSelectionConsecutiveHitsCountingConfiguration, CountedHitTimeout) == 0x000000, "Member 'FSHEnemyHitReactionSelectionConsecutiveHitsCountingConfiguration::CountedHitTimeout' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionConsecutiveHitsCountingConfiguration, DamageTypeOverrides) == 0x000008, "Member 'FSHEnemyHitReactionSelectionConsecutiveHitsCountingConfiguration::DamageTypeOverrides' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionHitResponseVariantSettingsAppliedCooldown
// 0x000C (0x000C - 0x0000)
struct FSHEnemyHitReactionSelectionHitResponseVariantSettingsAppliedCooldown final
{
public:
	class FName                                   CooldownCounterName;                               // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownDuration;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionHitResponseVariantSettingsAppliedCooldown) == 0x000004, "Wrong alignment on FSHEnemyHitReactionSelectionHitResponseVariantSettingsAppliedCooldown");
static_assert(sizeof(FSHEnemyHitReactionSelectionHitResponseVariantSettingsAppliedCooldown) == 0x00000C, "Wrong size on FSHEnemyHitReactionSelectionHitResponseVariantSettingsAppliedCooldown");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitResponseVariantSettingsAppliedCooldown, CooldownCounterName) == 0x000000, "Member 'FSHEnemyHitReactionSelectionHitResponseVariantSettingsAppliedCooldown::CooldownCounterName' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitResponseVariantSettingsAppliedCooldown, CooldownDuration) == 0x000008, "Member 'FSHEnemyHitReactionSelectionHitResponseVariantSettingsAppliedCooldown::CooldownDuration' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionHitResponseVariantSettings
// 0x0028 (0x0028 - 0x0000)
struct FSHEnemyHitReactionSelectionHitResponseVariantSettings final
{
public:
	struct FMinMaxVector2D                        DurationLimit;                                     // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           BlockedByCooldowns;                                // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSHEnemyHitReactionSelectionHitResponseVariantSettingsAppliedCooldown> ApplyCooldowns;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionHitResponseVariantSettings) == 0x000008, "Wrong alignment on FSHEnemyHitReactionSelectionHitResponseVariantSettings");
static_assert(sizeof(FSHEnemyHitReactionSelectionHitResponseVariantSettings) == 0x000028, "Wrong size on FSHEnemyHitReactionSelectionHitResponseVariantSettings");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitResponseVariantSettings, DurationLimit) == 0x000000, "Member 'FSHEnemyHitReactionSelectionHitResponseVariantSettings::DurationLimit' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitResponseVariantSettings, BlockedByCooldowns) == 0x000008, "Member 'FSHEnemyHitReactionSelectionHitResponseVariantSettings::BlockedByCooldowns' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitResponseVariantSettings, ApplyCooldowns) == 0x000018, "Member 'FSHEnemyHitReactionSelectionHitResponseVariantSettings::ApplyCooldowns' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionHitResponsesConfiguration
// 0x0190 (0x0190 - 0x0000)
struct FSHEnemyHitReactionSelectionHitResponsesConfiguration final
{
public:
	TMap<class FName, struct FSHEnemyHitReactionSelectionHitResponseVariantSettings> KnockdownVariantsSettings;                         // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, struct FSHEnemyHitReactionSelectionHitResponseVariantSettings> StaggerVariantsSettings;                           // 0x0050(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, struct FSHEnemyHitReactionSelectionHitResponseVariantSettings> FalterVariantsSettings;                            // 0x00A0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, struct FSHEnemyHitReactionSelectionHitResponseVariantSettings> NormalVariantsSettings;                            // 0x00F0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, struct FSHEnemyHitReactionSelectionHitResponseVariantSettings> TwitchVariantsSettings;                            // 0x0140(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyHitReactionSelectionHitResponsesConfiguration) == 0x000008, "Wrong alignment on FSHEnemyHitReactionSelectionHitResponsesConfiguration");
static_assert(sizeof(FSHEnemyHitReactionSelectionHitResponsesConfiguration) == 0x000190, "Wrong size on FSHEnemyHitReactionSelectionHitResponsesConfiguration");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitResponsesConfiguration, KnockdownVariantsSettings) == 0x000000, "Member 'FSHEnemyHitReactionSelectionHitResponsesConfiguration::KnockdownVariantsSettings' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitResponsesConfiguration, StaggerVariantsSettings) == 0x000050, "Member 'FSHEnemyHitReactionSelectionHitResponsesConfiguration::StaggerVariantsSettings' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitResponsesConfiguration, FalterVariantsSettings) == 0x0000A0, "Member 'FSHEnemyHitReactionSelectionHitResponsesConfiguration::FalterVariantsSettings' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitResponsesConfiguration, NormalVariantsSettings) == 0x0000F0, "Member 'FSHEnemyHitReactionSelectionHitResponsesConfiguration::NormalVariantsSettings' has a wrong offset!");
static_assert(offsetof(FSHEnemyHitReactionSelectionHitResponsesConfiguration, TwitchVariantsSettings) == 0x000140, "Member 'FSHEnemyHitReactionSelectionHitResponsesConfiguration::TwitchVariantsSettings' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyHitReactionSelectionConsecutiveHitsCounter
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FSHEnemyHitReactionSelectionConsecutiveHitsCounter final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHEnemyHitReactionSelectionConsecutiveHitsCounter) == 0x000008, "Wrong alignment on FSHEnemyHitReactionSelectionConsecutiveHitsCounter");
static_assert(sizeof(FSHEnemyHitReactionSelectionConsecutiveHitsCounter) == 0x000020, "Wrong size on FSHEnemyHitReactionSelectionConsecutiveHitsCounter");

// ScriptStruct SHProto.SHEnemyTransformationStateVariantDifficultyOverrides
// 0x0018 (0x0018 - 0x0000)
struct FSHEnemyTransformationStateVariantDifficultyOverrides final
{
public:
	class USEnemyHitReactionSelection*            HitReactionSelectionConfigurationEasy;             // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USEnemyHitReactionSelection*            HitReactionSelectionConfigurationMedium;           // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USEnemyHitReactionSelection*            HitReactionSelectionConfigurationHard;             // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyTransformationStateVariantDifficultyOverrides) == 0x000008, "Wrong alignment on FSHEnemyTransformationStateVariantDifficultyOverrides");
static_assert(sizeof(FSHEnemyTransformationStateVariantDifficultyOverrides) == 0x000018, "Wrong size on FSHEnemyTransformationStateVariantDifficultyOverrides");
static_assert(offsetof(FSHEnemyTransformationStateVariantDifficultyOverrides, HitReactionSelectionConfigurationEasy) == 0x000000, "Member 'FSHEnemyTransformationStateVariantDifficultyOverrides::HitReactionSelectionConfigurationEasy' has a wrong offset!");
static_assert(offsetof(FSHEnemyTransformationStateVariantDifficultyOverrides, HitReactionSelectionConfigurationMedium) == 0x000008, "Member 'FSHEnemyTransformationStateVariantDifficultyOverrides::HitReactionSelectionConfigurationMedium' has a wrong offset!");
static_assert(offsetof(FSHEnemyTransformationStateVariantDifficultyOverrides, HitReactionSelectionConfigurationHard) == 0x000010, "Member 'FSHEnemyTransformationStateVariantDifficultyOverrides::HitReactionSelectionConfigurationHard' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyTransformationStateVariantSettings
// 0x0028 (0x0028 - 0x0000)
struct FSHEnemyTransformationStateVariantSettings final
{
public:
	class USEnemyHitReactionSelection*            HitReactionSelectionConfiguration;                 // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHHitReactionsSet*                     HitReactionsSet;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSHEnemyTransformationStateVariantDifficultyOverrides DifficultyOverrides;                               // 0x0010(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyTransformationStateVariantSettings) == 0x000008, "Wrong alignment on FSHEnemyTransformationStateVariantSettings");
static_assert(sizeof(FSHEnemyTransformationStateVariantSettings) == 0x000028, "Wrong size on FSHEnemyTransformationStateVariantSettings");
static_assert(offsetof(FSHEnemyTransformationStateVariantSettings, HitReactionSelectionConfiguration) == 0x000000, "Member 'FSHEnemyTransformationStateVariantSettings::HitReactionSelectionConfiguration' has a wrong offset!");
static_assert(offsetof(FSHEnemyTransformationStateVariantSettings, HitReactionsSet) == 0x000008, "Member 'FSHEnemyTransformationStateVariantSettings::HitReactionsSet' has a wrong offset!");
static_assert(offsetof(FSHEnemyTransformationStateVariantSettings, DifficultyOverrides) == 0x000010, "Member 'FSHEnemyTransformationStateVariantSettings::DifficultyOverrides' has a wrong offset!");

// ScriptStruct SHProto.SHEnemyTransformationStateVariant
// 0x0030 (0x0030 - 0x0000)
struct FSHEnemyTransformationStateVariant final
{
public:
	class FName                                   VariantName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSHEnemyTransformationStateVariantSettings VariantSettings;                                   // 0x0008(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHEnemyTransformationStateVariant) == 0x000008, "Wrong alignment on FSHEnemyTransformationStateVariant");
static_assert(sizeof(FSHEnemyTransformationStateVariant) == 0x000030, "Wrong size on FSHEnemyTransformationStateVariant");
static_assert(offsetof(FSHEnemyTransformationStateVariant, VariantName) == 0x000000, "Member 'FSHEnemyTransformationStateVariant::VariantName' has a wrong offset!");
static_assert(offsetof(FSHEnemyTransformationStateVariant, VariantSettings) == 0x000008, "Member 'FSHEnemyTransformationStateVariant::VariantSettings' has a wrong offset!");

// ScriptStruct SHProto.LongWeaponAimObstacleCheckPayload
// 0x0030 (0x0030 - 0x0000)
struct FLongWeaponAimObstacleCheckPayload final
{
public:
	class UCurveVector*                           WeaponStartSocketData;                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           WeaponEndSocketData;                               // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmsAimOffsetX;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmsAimOffsetXRangeMin;                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmsAimOffsetXRangeMax;                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SweepRadius;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowDebug;                                         // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ALPHA;                                             // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveTimeMin;                                      // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveTimeMax;                                      // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLongWeaponAimObstacleCheckPayload) == 0x000008, "Wrong alignment on FLongWeaponAimObstacleCheckPayload");
static_assert(sizeof(FLongWeaponAimObstacleCheckPayload) == 0x000030, "Wrong size on FLongWeaponAimObstacleCheckPayload");
static_assert(offsetof(FLongWeaponAimObstacleCheckPayload, WeaponStartSocketData) == 0x000000, "Member 'FLongWeaponAimObstacleCheckPayload::WeaponStartSocketData' has a wrong offset!");
static_assert(offsetof(FLongWeaponAimObstacleCheckPayload, WeaponEndSocketData) == 0x000008, "Member 'FLongWeaponAimObstacleCheckPayload::WeaponEndSocketData' has a wrong offset!");
static_assert(offsetof(FLongWeaponAimObstacleCheckPayload, ArmsAimOffsetX) == 0x000010, "Member 'FLongWeaponAimObstacleCheckPayload::ArmsAimOffsetX' has a wrong offset!");
static_assert(offsetof(FLongWeaponAimObstacleCheckPayload, ArmsAimOffsetXRangeMin) == 0x000014, "Member 'FLongWeaponAimObstacleCheckPayload::ArmsAimOffsetXRangeMin' has a wrong offset!");
static_assert(offsetof(FLongWeaponAimObstacleCheckPayload, ArmsAimOffsetXRangeMax) == 0x000018, "Member 'FLongWeaponAimObstacleCheckPayload::ArmsAimOffsetXRangeMax' has a wrong offset!");
static_assert(offsetof(FLongWeaponAimObstacleCheckPayload, SweepRadius) == 0x00001C, "Member 'FLongWeaponAimObstacleCheckPayload::SweepRadius' has a wrong offset!");
static_assert(offsetof(FLongWeaponAimObstacleCheckPayload, ShowDebug) == 0x000020, "Member 'FLongWeaponAimObstacleCheckPayload::ShowDebug' has a wrong offset!");
static_assert(offsetof(FLongWeaponAimObstacleCheckPayload, ALPHA) == 0x000024, "Member 'FLongWeaponAimObstacleCheckPayload::ALPHA' has a wrong offset!");
static_assert(offsetof(FLongWeaponAimObstacleCheckPayload, CurveTimeMin) == 0x000028, "Member 'FLongWeaponAimObstacleCheckPayload::CurveTimeMin' has a wrong offset!");
static_assert(offsetof(FLongWeaponAimObstacleCheckPayload, CurveTimeMax) == 0x00002C, "Member 'FLongWeaponAimObstacleCheckPayload::CurveTimeMax' has a wrong offset!");

// ScriptStruct SHProto.SHFlashlightDynamicDataContainer
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FSHFlashlightDynamicDataContainer final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHFlashlightDynamicDataContainer) == 0x000008, "Wrong alignment on FSHFlashlightDynamicDataContainer");
static_assert(sizeof(FSHFlashlightDynamicDataContainer) == 0x000070, "Wrong size on FSHFlashlightDynamicDataContainer");

// ScriptStruct SHProto.SHFlashlightControlData
// 0x00A0 (0x00A0 - 0x0000)
struct FSHFlashlightControlData final
{
public:
	bool                                          bOverrideLightsColor;                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 LightsColor;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMainLightAttenuationRadius;               // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MainLightAttenuationRadius;                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMainLightIntensityMul;                    // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MainLightIntensityMul;                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMainLightInnerConeAngle;                  // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MainLightInnerConeAngle;                           // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMainLightOuterConeAngle;                  // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MainLightOuterConeAngle;                           // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMainLightIndirectLightingIntensity;       // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MainLightIndirectLightingIntensity;                // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMainLightIESTexture;                      // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureLightProfile*                   MainLightIESTexture;                               // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCloseLightIntensityMul;                   // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloseLightIntensityMul;                            // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideBackLightIntensityMul;                    // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BackLightIntensityMul;                             // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideLightshaftMaterial0EdgeColor;             // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           LightshaftMaterial0EdgeColor;                      // 0x0054(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideLightshaftMaterial0TintEmission;          // 0x0064(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           LightshaftMaterial0TintEmission;                   // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideLightshaftMaterial1EdgeColor;             // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           LightshaftMaterial1EdgeColor;                      // 0x007C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideLightshaftMaterial1TintEmission;          // 0x008C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           LightshaftMaterial1TintEmission;                   // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHFlashlightControlData) == 0x000008, "Wrong alignment on FSHFlashlightControlData");
static_assert(sizeof(FSHFlashlightControlData) == 0x0000A0, "Wrong size on FSHFlashlightControlData");
static_assert(offsetof(FSHFlashlightControlData, bOverrideLightsColor) == 0x000000, "Member 'FSHFlashlightControlData::bOverrideLightsColor' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, LightsColor) == 0x000004, "Member 'FSHFlashlightControlData::LightsColor' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, bOverrideMainLightAttenuationRadius) == 0x000008, "Member 'FSHFlashlightControlData::bOverrideMainLightAttenuationRadius' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, MainLightAttenuationRadius) == 0x00000C, "Member 'FSHFlashlightControlData::MainLightAttenuationRadius' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, bOverrideMainLightIntensityMul) == 0x000010, "Member 'FSHFlashlightControlData::bOverrideMainLightIntensityMul' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, MainLightIntensityMul) == 0x000014, "Member 'FSHFlashlightControlData::MainLightIntensityMul' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, bOverrideMainLightInnerConeAngle) == 0x000018, "Member 'FSHFlashlightControlData::bOverrideMainLightInnerConeAngle' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, MainLightInnerConeAngle) == 0x00001C, "Member 'FSHFlashlightControlData::MainLightInnerConeAngle' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, bOverrideMainLightOuterConeAngle) == 0x000020, "Member 'FSHFlashlightControlData::bOverrideMainLightOuterConeAngle' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, MainLightOuterConeAngle) == 0x000024, "Member 'FSHFlashlightControlData::MainLightOuterConeAngle' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, bOverrideMainLightIndirectLightingIntensity) == 0x000028, "Member 'FSHFlashlightControlData::bOverrideMainLightIndirectLightingIntensity' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, MainLightIndirectLightingIntensity) == 0x00002C, "Member 'FSHFlashlightControlData::MainLightIndirectLightingIntensity' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, bOverrideMainLightIESTexture) == 0x000030, "Member 'FSHFlashlightControlData::bOverrideMainLightIESTexture' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, MainLightIESTexture) == 0x000038, "Member 'FSHFlashlightControlData::MainLightIESTexture' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, bOverrideCloseLightIntensityMul) == 0x000040, "Member 'FSHFlashlightControlData::bOverrideCloseLightIntensityMul' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, CloseLightIntensityMul) == 0x000044, "Member 'FSHFlashlightControlData::CloseLightIntensityMul' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, bOverrideBackLightIntensityMul) == 0x000048, "Member 'FSHFlashlightControlData::bOverrideBackLightIntensityMul' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, BackLightIntensityMul) == 0x00004C, "Member 'FSHFlashlightControlData::BackLightIntensityMul' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, bOverrideLightshaftMaterial0EdgeColor) == 0x000050, "Member 'FSHFlashlightControlData::bOverrideLightshaftMaterial0EdgeColor' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, LightshaftMaterial0EdgeColor) == 0x000054, "Member 'FSHFlashlightControlData::LightshaftMaterial0EdgeColor' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, bOverrideLightshaftMaterial0TintEmission) == 0x000064, "Member 'FSHFlashlightControlData::bOverrideLightshaftMaterial0TintEmission' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, LightshaftMaterial0TintEmission) == 0x000068, "Member 'FSHFlashlightControlData::LightshaftMaterial0TintEmission' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, bOverrideLightshaftMaterial1EdgeColor) == 0x000078, "Member 'FSHFlashlightControlData::bOverrideLightshaftMaterial1EdgeColor' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, LightshaftMaterial1EdgeColor) == 0x00007C, "Member 'FSHFlashlightControlData::LightshaftMaterial1EdgeColor' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, bOverrideLightshaftMaterial1TintEmission) == 0x00008C, "Member 'FSHFlashlightControlData::bOverrideLightshaftMaterial1TintEmission' has a wrong offset!");
static_assert(offsetof(FSHFlashlightControlData, LightshaftMaterial1TintEmission) == 0x000090, "Member 'FSHFlashlightControlData::LightshaftMaterial1TintEmission' has a wrong offset!");

// ScriptStruct SHProto.SHCharacterPlayLightingControlData
// 0x001C (0x001C - 0x0000)
struct FSHCharacterPlayLightingControlData final
{
public:
	bool                                          bOverrideGlobalIntensityMul;                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GlobalIntensityMul;                                // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideGlobalColor;                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           GlobalColor;                                       // 0x000C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHCharacterPlayLightingControlData) == 0x000004, "Wrong alignment on FSHCharacterPlayLightingControlData");
static_assert(sizeof(FSHCharacterPlayLightingControlData) == 0x00001C, "Wrong size on FSHCharacterPlayLightingControlData");
static_assert(offsetof(FSHCharacterPlayLightingControlData, bOverrideGlobalIntensityMul) == 0x000000, "Member 'FSHCharacterPlayLightingControlData::bOverrideGlobalIntensityMul' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayLightingControlData, GlobalIntensityMul) == 0x000004, "Member 'FSHCharacterPlayLightingControlData::GlobalIntensityMul' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayLightingControlData, bOverrideGlobalColor) == 0x000008, "Member 'FSHCharacterPlayLightingControlData::bOverrideGlobalColor' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayLightingControlData, GlobalColor) == 0x00000C, "Member 'FSHCharacterPlayLightingControlData::GlobalColor' has a wrong offset!");

// ScriptStruct SHProto.SHCharacterPlayRimLightingControlData
// 0x002C (0x002C - 0x0000)
struct FSHCharacterPlayRimLightingControlData final
{
public:
	bool                                          bOverride_RimLightIntensity;                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride_RimLightColor;                           // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride_RimLightETA;                             // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride_RimLightBias;                            // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride_RimLightAngleMin;                        // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride_RimLightAngleMax;                        // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RimLightIntensity;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RimLightColor;                                     // 0x000C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RimLightETA;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RimLightBias;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RimLightAngleMin;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RimLightAngleMax;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHCharacterPlayRimLightingControlData) == 0x000004, "Wrong alignment on FSHCharacterPlayRimLightingControlData");
static_assert(sizeof(FSHCharacterPlayRimLightingControlData) == 0x00002C, "Wrong size on FSHCharacterPlayRimLightingControlData");
static_assert(offsetof(FSHCharacterPlayRimLightingControlData, bOverride_RimLightIntensity) == 0x000000, "Member 'FSHCharacterPlayRimLightingControlData::bOverride_RimLightIntensity' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayRimLightingControlData, bOverride_RimLightColor) == 0x000001, "Member 'FSHCharacterPlayRimLightingControlData::bOverride_RimLightColor' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayRimLightingControlData, bOverride_RimLightETA) == 0x000002, "Member 'FSHCharacterPlayRimLightingControlData::bOverride_RimLightETA' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayRimLightingControlData, bOverride_RimLightBias) == 0x000003, "Member 'FSHCharacterPlayRimLightingControlData::bOverride_RimLightBias' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayRimLightingControlData, bOverride_RimLightAngleMin) == 0x000004, "Member 'FSHCharacterPlayRimLightingControlData::bOverride_RimLightAngleMin' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayRimLightingControlData, bOverride_RimLightAngleMax) == 0x000005, "Member 'FSHCharacterPlayRimLightingControlData::bOverride_RimLightAngleMax' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayRimLightingControlData, RimLightIntensity) == 0x000008, "Member 'FSHCharacterPlayRimLightingControlData::RimLightIntensity' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayRimLightingControlData, RimLightColor) == 0x00000C, "Member 'FSHCharacterPlayRimLightingControlData::RimLightColor' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayRimLightingControlData, RimLightETA) == 0x00001C, "Member 'FSHCharacterPlayRimLightingControlData::RimLightETA' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayRimLightingControlData, RimLightBias) == 0x000020, "Member 'FSHCharacterPlayRimLightingControlData::RimLightBias' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayRimLightingControlData, RimLightAngleMin) == 0x000024, "Member 'FSHCharacterPlayRimLightingControlData::RimLightAngleMin' has a wrong offset!");
static_assert(offsetof(FSHCharacterPlayRimLightingControlData, RimLightAngleMax) == 0x000028, "Member 'FSHCharacterPlayRimLightingControlData::RimLightAngleMax' has a wrong offset!");

// ScriptStruct SHProto.SHFlashlightLookAtSettings
// 0x0008 (0x0008 - 0x0000)
struct FSHFlashlightLookAtSettings final
{
public:
	bool                                          bKeepFollow;                                       // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintainSocketHeightToOffset;                     // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotatonInterpSpeed;                                // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHFlashlightLookAtSettings) == 0x000004, "Wrong alignment on FSHFlashlightLookAtSettings");
static_assert(sizeof(FSHFlashlightLookAtSettings) == 0x000008, "Wrong size on FSHFlashlightLookAtSettings");
static_assert(offsetof(FSHFlashlightLookAtSettings, bKeepFollow) == 0x000000, "Member 'FSHFlashlightLookAtSettings::bKeepFollow' has a wrong offset!");
static_assert(offsetof(FSHFlashlightLookAtSettings, bMaintainSocketHeightToOffset) == 0x000001, "Member 'FSHFlashlightLookAtSettings::bMaintainSocketHeightToOffset' has a wrong offset!");
static_assert(offsetof(FSHFlashlightLookAtSettings, RotatonInterpSpeed) == 0x000004, "Member 'FSHFlashlightLookAtSettings::RotatonInterpSpeed' has a wrong offset!");

// ScriptStruct SHProto.SHFlashlightPlainSocketSettings
// 0x000C (0x000C - 0x0000)
struct FSHFlashlightPlainSocketSettings final
{
public:
	float                                         bBlendFromCurrentState;                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationInterpSpeed;                               // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotatonInterpSpeed;                                // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHFlashlightPlainSocketSettings) == 0x000004, "Wrong alignment on FSHFlashlightPlainSocketSettings");
static_assert(sizeof(FSHFlashlightPlainSocketSettings) == 0x00000C, "Wrong size on FSHFlashlightPlainSocketSettings");
static_assert(offsetof(FSHFlashlightPlainSocketSettings, bBlendFromCurrentState) == 0x000000, "Member 'FSHFlashlightPlainSocketSettings::bBlendFromCurrentState' has a wrong offset!");
static_assert(offsetof(FSHFlashlightPlainSocketSettings, LocationInterpSpeed) == 0x000004, "Member 'FSHFlashlightPlainSocketSettings::LocationInterpSpeed' has a wrong offset!");
static_assert(offsetof(FSHFlashlightPlainSocketSettings, RotatonInterpSpeed) == 0x000008, "Member 'FSHFlashlightPlainSocketSettings::RotatonInterpSpeed' has a wrong offset!");

// ScriptStruct SHProto.SHFleshLipCeilingTileShakePhysics
// 0x0030 (0x0030 - 0x0000)
struct FSHFleshLipCeilingTileShakePhysics final
{
public:
	class UNiagaraComponent*                      ParticleEmitter;                                   // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHFleshLipCeilingTileShakePhysics) == 0x000008, "Wrong alignment on FSHFleshLipCeilingTileShakePhysics");
static_assert(sizeof(FSHFleshLipCeilingTileShakePhysics) == 0x000030, "Wrong size on FSHFleshLipCeilingTileShakePhysics");
static_assert(offsetof(FSHFleshLipCeilingTileShakePhysics, ParticleEmitter) == 0x000000, "Member 'FSHFleshLipCeilingTileShakePhysics::ParticleEmitter' has a wrong offset!");

// ScriptStruct SHProto.SHFleshLipCeilingTile
// 0x0048 (0x0048 - 0x0000)
struct FSHFleshLipCeilingTile final
{
public:
	class ASHFleshLipCeilingTileActor*            TileActor;                                         // 0x0000(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSHFleshLipCeilingTileShakePhysics     TileShakePhysics;                                  // 0x0008(0x0030)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHFleshLipCeilingTile) == 0x000008, "Wrong alignment on FSHFleshLipCeilingTile");
static_assert(sizeof(FSHFleshLipCeilingTile) == 0x000048, "Wrong size on FSHFleshLipCeilingTile");
static_assert(offsetof(FSHFleshLipCeilingTile, TileActor) == 0x000000, "Member 'FSHFleshLipCeilingTile::TileActor' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingTile, TileShakePhysics) == 0x000008, "Member 'FSHFleshLipCeilingTile::TileShakePhysics' has a wrong offset!");

// ScriptStruct SHProto.SHFleshLipCeilingTileShakePhysicsConfiguration
// 0x00A0 (0x00A0 - 0x0000)
struct FSHFleshLipCeilingTileShakePhysicsConfiguration final
{
public:
	float                                         TilePushFadeOutHalfTime;                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileForceAccumulationLimit;                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileForceAccumulationFadeOutHalfTime;              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileJumpRotationScale;                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileJumpLiftFrequency;                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileJumpFadeOutHalfTime;                           // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileJumpRotationsPerJump;                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileJumpRotationRandomizationScale;                // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         TileParticles;                                     // 0x0020(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TileParticlesAlphaParameterName;                   // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMinMaxVector2D                        TileParticlesParameterRange;                       // 0x0030(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TileParticlesTransform;                            // 0x0040(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHFleshLipCeilingTileShakePhysicsConfiguration) == 0x000010, "Wrong alignment on FSHFleshLipCeilingTileShakePhysicsConfiguration");
static_assert(sizeof(FSHFleshLipCeilingTileShakePhysicsConfiguration) == 0x0000A0, "Wrong size on FSHFleshLipCeilingTileShakePhysicsConfiguration");
static_assert(offsetof(FSHFleshLipCeilingTileShakePhysicsConfiguration, TilePushFadeOutHalfTime) == 0x000000, "Member 'FSHFleshLipCeilingTileShakePhysicsConfiguration::TilePushFadeOutHalfTime' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingTileShakePhysicsConfiguration, TileForceAccumulationLimit) == 0x000004, "Member 'FSHFleshLipCeilingTileShakePhysicsConfiguration::TileForceAccumulationLimit' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingTileShakePhysicsConfiguration, TileForceAccumulationFadeOutHalfTime) == 0x000008, "Member 'FSHFleshLipCeilingTileShakePhysicsConfiguration::TileForceAccumulationFadeOutHalfTime' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingTileShakePhysicsConfiguration, TileJumpRotationScale) == 0x00000C, "Member 'FSHFleshLipCeilingTileShakePhysicsConfiguration::TileJumpRotationScale' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingTileShakePhysicsConfiguration, TileJumpLiftFrequency) == 0x000010, "Member 'FSHFleshLipCeilingTileShakePhysicsConfiguration::TileJumpLiftFrequency' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingTileShakePhysicsConfiguration, TileJumpFadeOutHalfTime) == 0x000014, "Member 'FSHFleshLipCeilingTileShakePhysicsConfiguration::TileJumpFadeOutHalfTime' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingTileShakePhysicsConfiguration, TileJumpRotationsPerJump) == 0x000018, "Member 'FSHFleshLipCeilingTileShakePhysicsConfiguration::TileJumpRotationsPerJump' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingTileShakePhysicsConfiguration, TileJumpRotationRandomizationScale) == 0x00001C, "Member 'FSHFleshLipCeilingTileShakePhysicsConfiguration::TileJumpRotationRandomizationScale' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingTileShakePhysicsConfiguration, TileParticles) == 0x000020, "Member 'FSHFleshLipCeilingTileShakePhysicsConfiguration::TileParticles' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingTileShakePhysicsConfiguration, TileParticlesAlphaParameterName) == 0x000028, "Member 'FSHFleshLipCeilingTileShakePhysicsConfiguration::TileParticlesAlphaParameterName' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingTileShakePhysicsConfiguration, TileParticlesParameterRange) == 0x000030, "Member 'FSHFleshLipCeilingTileShakePhysicsConfiguration::TileParticlesParameterRange' has a wrong offset!");
static_assert(offsetof(FSHFleshLipCeilingTileShakePhysicsConfiguration, TileParticlesTransform) == 0x000040, "Member 'FSHFleshLipCeilingTileShakePhysicsConfiguration::TileParticlesTransform' has a wrong offset!");

// ScriptStruct SHProto.SHFleshLipTransformationStateCurves
// 0x0024 (0x0024 - 0x0000)
struct FSHFleshLipTransformationStateCurves final
{
public:
	struct FSimpleBentCurve                       HeightCurve;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleBentCurve                       RotationCurve;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleBentCurve                       CeilingAvoidCurveAbove;                            // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleBentCurve                       CeilingAvoidCurveBelow;                            // 0x0018(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CeilingPassRadiusScale;                            // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHFleshLipTransformationStateCurves) == 0x000004, "Wrong alignment on FSHFleshLipTransformationStateCurves");
static_assert(sizeof(FSHFleshLipTransformationStateCurves) == 0x000024, "Wrong size on FSHFleshLipTransformationStateCurves");
static_assert(offsetof(FSHFleshLipTransformationStateCurves, HeightCurve) == 0x000000, "Member 'FSHFleshLipTransformationStateCurves::HeightCurve' has a wrong offset!");
static_assert(offsetof(FSHFleshLipTransformationStateCurves, RotationCurve) == 0x000008, "Member 'FSHFleshLipTransformationStateCurves::RotationCurve' has a wrong offset!");
static_assert(offsetof(FSHFleshLipTransformationStateCurves, CeilingAvoidCurveAbove) == 0x000010, "Member 'FSHFleshLipTransformationStateCurves::CeilingAvoidCurveAbove' has a wrong offset!");
static_assert(offsetof(FSHFleshLipTransformationStateCurves, CeilingAvoidCurveBelow) == 0x000018, "Member 'FSHFleshLipTransformationStateCurves::CeilingAvoidCurveBelow' has a wrong offset!");
static_assert(offsetof(FSHFleshLipTransformationStateCurves, CeilingPassRadiusScale) == 0x000020, "Member 'FSHFleshLipTransformationStateCurves::CeilingPassRadiusScale' has a wrong offset!");

// ScriptStruct SHProto.SHFlickerGroupStatus
// 0x0018 (0x0018 - 0x0000)
struct FSHFlickerGroupStatus final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupId;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHFlickerGroupState                          State;                                             // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Multiplier;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggersOnOffSound;                                // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHFlickerGroupStatus) == 0x000004, "Wrong alignment on FSHFlickerGroupStatus");
static_assert(sizeof(FSHFlickerGroupStatus) == 0x000018, "Wrong size on FSHFlickerGroupStatus");
static_assert(offsetof(FSHFlickerGroupStatus, Name) == 0x000000, "Member 'FSHFlickerGroupStatus::Name' has a wrong offset!");
static_assert(offsetof(FSHFlickerGroupStatus, GroupId) == 0x000008, "Member 'FSHFlickerGroupStatus::GroupId' has a wrong offset!");
static_assert(offsetof(FSHFlickerGroupStatus, State) == 0x00000C, "Member 'FSHFlickerGroupStatus::State' has a wrong offset!");
static_assert(offsetof(FSHFlickerGroupStatus, Multiplier) == 0x000010, "Member 'FSHFlickerGroupStatus::Multiplier' has a wrong offset!");
static_assert(offsetof(FSHFlickerGroupStatus, TriggersOnOffSound) == 0x000014, "Member 'FSHFlickerGroupStatus::TriggersOnOffSound' has a wrong offset!");

// ScriptStruct SHProto.SHFlickerMesh
// 0x0020 (0x0020 - 0x0000)
struct FSHFlickerMesh final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSHFlickerMaterial>             Materials;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          HasOffTag;                                         // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHFlickerMesh) == 0x000008, "Wrong alignment on FSHFlickerMesh");
static_assert(sizeof(FSHFlickerMesh) == 0x000020, "Wrong size on FSHFlickerMesh");
static_assert(offsetof(FSHFlickerMesh, Component) == 0x000000, "Member 'FSHFlickerMesh::Component' has a wrong offset!");
static_assert(offsetof(FSHFlickerMesh, Materials) == 0x000008, "Member 'FSHFlickerMesh::Materials' has a wrong offset!");
static_assert(offsetof(FSHFlickerMesh, HasOffTag) == 0x000018, "Member 'FSHFlickerMesh::HasOffTag' has a wrong offset!");

// ScriptStruct SHProto.SHFlickerLightSavedIntensities
// 0x000C (0x000C - 0x0000)
struct FSHFlickerLightSavedIntensities final
{
public:
	class FName                                   ComponentName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseIntensity;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHFlickerLightSavedIntensities) == 0x000004, "Wrong alignment on FSHFlickerLightSavedIntensities");
static_assert(sizeof(FSHFlickerLightSavedIntensities) == 0x00000C, "Wrong size on FSHFlickerLightSavedIntensities");
static_assert(offsetof(FSHFlickerLightSavedIntensities, ComponentName) == 0x000000, "Member 'FSHFlickerLightSavedIntensities::ComponentName' has a wrong offset!");
static_assert(offsetof(FSHFlickerLightSavedIntensities, BaseIntensity) == 0x000008, "Member 'FSHFlickerLightSavedIntensities::BaseIntensity' has a wrong offset!");

// ScriptStruct SHProto.SHFlickerGroup
// 0x0030 (0x0030 - 0x0000)
struct FSHFlickerGroup final
{
public:
	int32                                         GroupId;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHFlickerMesh>                 Meshes;                                            // 0x0008(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FSHFlickerLight>                Lights;                                            // 0x0018(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OnOffTrigger;                                      // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHFlickerGroup) == 0x000008, "Wrong alignment on FSHFlickerGroup");
static_assert(sizeof(FSHFlickerGroup) == 0x000030, "Wrong size on FSHFlickerGroup");
static_assert(offsetof(FSHFlickerGroup, GroupId) == 0x000000, "Member 'FSHFlickerGroup::GroupId' has a wrong offset!");
static_assert(offsetof(FSHFlickerGroup, Meshes) == 0x000008, "Member 'FSHFlickerGroup::Meshes' has a wrong offset!");
static_assert(offsetof(FSHFlickerGroup, Lights) == 0x000018, "Member 'FSHFlickerGroup::Lights' has a wrong offset!");
static_assert(offsetof(FSHFlickerGroup, Multiplier) == 0x000028, "Member 'FSHFlickerGroup::Multiplier' has a wrong offset!");
static_assert(offsetof(FSHFlickerGroup, OnOffTrigger) == 0x00002C, "Member 'FSHFlickerGroup::OnOffTrigger' has a wrong offset!");

// ScriptStruct SHProto.SHFloatCondition
// 0x0008 (0x0008 - 0x0000)
struct FSHFloatCondition final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHFloatOperationType                         OperationType;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHFloatCondition) == 0x000004, "Wrong alignment on FSHFloatCondition");
static_assert(sizeof(FSHFloatCondition) == 0x000008, "Wrong size on FSHFloatCondition");
static_assert(offsetof(FSHFloatCondition, Value) == 0x000000, "Member 'FSHFloatCondition::Value' has a wrong offset!");
static_assert(offsetof(FSHFloatCondition, OperationType) == 0x000004, "Member 'FSHFloatCondition::OperationType' has a wrong offset!");

// ScriptStruct SHProto.SHQueuedSpawnRequestTicket
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FSHQueuedSpawnRequestTicket final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHQueuedSpawnRequestTicket) == 0x000004, "Wrong alignment on FSHQueuedSpawnRequestTicket");
static_assert(sizeof(FSHQueuedSpawnRequestTicket) == 0x000008, "Wrong size on FSHQueuedSpawnRequestTicket");

// ScriptStruct SHProto.SHInputKeyDataStruct
// 0x0010 (0x0010 - 0x0000)
struct FSHInputKeyDataStruct final
{
public:
	TArray<struct FKey>                           InputKeys;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHInputKeyDataStruct) == 0x000008, "Wrong alignment on FSHInputKeyDataStruct");
static_assert(sizeof(FSHInputKeyDataStruct) == 0x000010, "Wrong size on FSHInputKeyDataStruct");
static_assert(offsetof(FSHInputKeyDataStruct, InputKeys) == 0x000000, "Member 'FSHInputKeyDataStruct::InputKeys' has a wrong offset!");

// ScriptStruct SHProto.SHMapObjectsStruct
// 0x0010 (0x0010 - 0x0000)
struct FSHMapObjectsStruct final
{
public:
	TArray<struct FSHMapObjectDataStruct>         Objects;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHMapObjectsStruct) == 0x000008, "Wrong alignment on FSHMapObjectsStruct");
static_assert(sizeof(FSHMapObjectsStruct) == 0x000010, "Wrong size on FSHMapObjectsStruct");
static_assert(offsetof(FSHMapObjectsStruct, Objects) == 0x000000, "Member 'FSHMapObjectsStruct::Objects' has a wrong offset!");

// ScriptStruct SHProto.SHMapDynamicObjectsContainer
// 0x0010 (0x0010 - 0x0000)
struct FSHMapDynamicObjectsContainer final
{
public:
	TArray<struct FSHMapDynamicObjectDataStruct>  Objects;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHMapDynamicObjectsContainer) == 0x000008, "Wrong alignment on FSHMapDynamicObjectsContainer");
static_assert(sizeof(FSHMapDynamicObjectsContainer) == 0x000010, "Wrong size on FSHMapDynamicObjectsContainer");
static_assert(offsetof(FSHMapDynamicObjectsContainer, Objects) == 0x000000, "Member 'FSHMapDynamicObjectsContainer::Objects' has a wrong offset!");

// ScriptStruct SHProto.SHMapDataConfigStruct
// 0x000C (0x000C - 0x0000)
struct FSHMapDataConfigStruct final
{
public:
	class FName                                   ObjectID;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHMapsEnum                                   Map;                                               // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHMapDataConfigStruct) == 0x000004, "Wrong alignment on FSHMapDataConfigStruct");
static_assert(sizeof(FSHMapDataConfigStruct) == 0x00000C, "Wrong size on FSHMapDataConfigStruct");
static_assert(offsetof(FSHMapDataConfigStruct, ObjectID) == 0x000000, "Member 'FSHMapDataConfigStruct::ObjectID' has a wrong offset!");
static_assert(offsetof(FSHMapDataConfigStruct, Map) == 0x000008, "Member 'FSHMapDataConfigStruct::Map' has a wrong offset!");

// ScriptStruct SHProto.SHGameplayTutorialCoreData
// 0x0038 (0x0038 - 0x0000)
struct FSHGameplayTutorialCoreData
{
public:
	class FText                                   TutorialText;                                      // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bShouldUpdateOnDeviceChange;                       // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUE4InputHandle>                TextArguments;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseTimeout;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeoutValue;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHGameplayTutorialCoreData) == 0x000008, "Wrong alignment on FSHGameplayTutorialCoreData");
static_assert(sizeof(FSHGameplayTutorialCoreData) == 0x000038, "Wrong size on FSHGameplayTutorialCoreData");
static_assert(offsetof(FSHGameplayTutorialCoreData, TutorialText) == 0x000000, "Member 'FSHGameplayTutorialCoreData::TutorialText' has a wrong offset!");
static_assert(offsetof(FSHGameplayTutorialCoreData, bShouldUpdateOnDeviceChange) == 0x000018, "Member 'FSHGameplayTutorialCoreData::bShouldUpdateOnDeviceChange' has a wrong offset!");
static_assert(offsetof(FSHGameplayTutorialCoreData, TextArguments) == 0x000020, "Member 'FSHGameplayTutorialCoreData::TextArguments' has a wrong offset!");
static_assert(offsetof(FSHGameplayTutorialCoreData, bUseTimeout) == 0x000030, "Member 'FSHGameplayTutorialCoreData::bUseTimeout' has a wrong offset!");
static_assert(offsetof(FSHGameplayTutorialCoreData, TimeoutValue) == 0x000034, "Member 'FSHGameplayTutorialCoreData::TimeoutValue' has a wrong offset!");

// ScriptStruct SHProto.SHGameplayTutorialData
// 0x0008 (0x0040 - 0x0038)
struct FSHGameplayTutorialData final : public FSHGameplayTutorialCoreData
{
public:
	bool                                          bOnlyExplicitRegisterAction;                       // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHGameplayTutorialData) == 0x000008, "Wrong alignment on FSHGameplayTutorialData");
static_assert(sizeof(FSHGameplayTutorialData) == 0x000040, "Wrong size on FSHGameplayTutorialData");
static_assert(offsetof(FSHGameplayTutorialData, bOnlyExplicitRegisterAction) == 0x000038, "Member 'FSHGameplayTutorialData::bOnlyExplicitRegisterAction' has a wrong offset!");

// ScriptStruct SHProto.SHInventoryCategoryConfig
// 0x0030 (0x0030 - 0x0000)
struct FSHInventoryCategoryConfig final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<ESHItemTypeEnum>                       AllowedItemTypes;                                  // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsSubcategory;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHGameplaySection                            GameplaySectionFilter;                             // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHInventoryCategoryConfig) == 0x000008, "Wrong alignment on FSHInventoryCategoryConfig");
static_assert(sizeof(FSHInventoryCategoryConfig) == 0x000030, "Wrong size on FSHInventoryCategoryConfig");
static_assert(offsetof(FSHInventoryCategoryConfig, DisplayName) == 0x000000, "Member 'FSHInventoryCategoryConfig::DisplayName' has a wrong offset!");
static_assert(offsetof(FSHInventoryCategoryConfig, AllowedItemTypes) == 0x000018, "Member 'FSHInventoryCategoryConfig::AllowedItemTypes' has a wrong offset!");
static_assert(offsetof(FSHInventoryCategoryConfig, bIsSubcategory) == 0x000028, "Member 'FSHInventoryCategoryConfig::bIsSubcategory' has a wrong offset!");
static_assert(offsetof(FSHInventoryCategoryConfig, GameplaySectionFilter) == 0x000029, "Member 'FSHInventoryCategoryConfig::GameplaySectionFilter' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionStateSerializedData
// 0x0038 (0x0038 - 0x0000)
struct FSHHitReactionStateSerializedData final
{
public:
	TArray<struct FSHHitReactionStateAnimationSerializedData> BoundAnimations;                                   // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSHHitReactionStateAnimationSerializedData> FinishingAnimations;                               // 0x0010(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	bool                                          bStateStartedManually;                             // 0x0020(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RemainingDuration;                                 // 0x0024(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHHitReactionResponseType                    StateHitReactionType;                              // 0x0028(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StateHitReactionVariant;                           // 0x002C(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateWantsToBlockAI;                              // 0x0034(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateWantsToPreventControllerRotation;            // 0x0035(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHHitReactionStateSerializedData) == 0x000008, "Wrong alignment on FSHHitReactionStateSerializedData");
static_assert(sizeof(FSHHitReactionStateSerializedData) == 0x000038, "Wrong size on FSHHitReactionStateSerializedData");
static_assert(offsetof(FSHHitReactionStateSerializedData, BoundAnimations) == 0x000000, "Member 'FSHHitReactionStateSerializedData::BoundAnimations' has a wrong offset!");
static_assert(offsetof(FSHHitReactionStateSerializedData, FinishingAnimations) == 0x000010, "Member 'FSHHitReactionStateSerializedData::FinishingAnimations' has a wrong offset!");
static_assert(offsetof(FSHHitReactionStateSerializedData, bStateStartedManually) == 0x000020, "Member 'FSHHitReactionStateSerializedData::bStateStartedManually' has a wrong offset!");
static_assert(offsetof(FSHHitReactionStateSerializedData, RemainingDuration) == 0x000024, "Member 'FSHHitReactionStateSerializedData::RemainingDuration' has a wrong offset!");
static_assert(offsetof(FSHHitReactionStateSerializedData, StateHitReactionType) == 0x000028, "Member 'FSHHitReactionStateSerializedData::StateHitReactionType' has a wrong offset!");
static_assert(offsetof(FSHHitReactionStateSerializedData, StateHitReactionVariant) == 0x00002C, "Member 'FSHHitReactionStateSerializedData::StateHitReactionVariant' has a wrong offset!");
static_assert(offsetof(FSHHitReactionStateSerializedData, bStateWantsToBlockAI) == 0x000034, "Member 'FSHHitReactionStateSerializedData::bStateWantsToBlockAI' has a wrong offset!");
static_assert(offsetof(FSHHitReactionStateSerializedData, bStateWantsToPreventControllerRotation) == 0x000035, "Member 'FSHHitReactionStateSerializedData::bStateWantsToPreventControllerRotation' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionTypePermissionState
// 0x0048 (0x0048 - 0x0000)
struct FSHHitReactionTypePermissionState final
{
public:
	TArray<class FName>                           DontDelayVariants;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USHHitReactionConfig>    OverrideConfig;                                    // 0x0010(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHHitReactionTypePermissionState) == 0x000008, "Wrong alignment on FSHHitReactionTypePermissionState");
static_assert(sizeof(FSHHitReactionTypePermissionState) == 0x000048, "Wrong size on FSHHitReactionTypePermissionState");
static_assert(offsetof(FSHHitReactionTypePermissionState, DontDelayVariants) == 0x000000, "Member 'FSHHitReactionTypePermissionState::DontDelayVariants' has a wrong offset!");
static_assert(offsetof(FSHHitReactionTypePermissionState, OverrideConfig) == 0x000010, "Member 'FSHHitReactionTypePermissionState::OverrideConfig' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionTypeDelayedHitReactions
// 0x0010 (0x0010 - 0x0000)
struct FSHHitReactionTypeDelayedHitReactions final
{
public:
	TArray<struct FSHHitReactionArtificialHitConfiguration> HitReactions;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHHitReactionTypeDelayedHitReactions) == 0x000008, "Wrong alignment on FSHHitReactionTypeDelayedHitReactions");
static_assert(sizeof(FSHHitReactionTypeDelayedHitReactions) == 0x000010, "Wrong size on FSHHitReactionTypeDelayedHitReactions");
static_assert(offsetof(FSHHitReactionTypeDelayedHitReactions, HitReactions) == 0x000000, "Member 'FSHHitReactionTypeDelayedHitReactions::HitReactions' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionSubcomponentSerializedData
// 0x0010 (0x0010 - 0x0000)
struct FSHHitReactionSubcomponentSerializedData final
{
public:
	TArray<struct FSHHitReactionStateSerializedData> HitReactionStates;                                 // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHHitReactionSubcomponentSerializedData) == 0x000008, "Wrong alignment on FSHHitReactionSubcomponentSerializedData");
static_assert(sizeof(FSHHitReactionSubcomponentSerializedData) == 0x000010, "Wrong size on FSHHitReactionSubcomponentSerializedData");
static_assert(offsetof(FSHHitReactionSubcomponentSerializedData, HitReactionStates) == 0x000000, "Member 'FSHHitReactionSubcomponentSerializedData::HitReactionStates' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionHitData
// 0x0088 (0x0088 - 0x0000)
struct FSHHitReactionHitData final
{
public:
	class UDamageType*                            DamageType;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHHitReactionResponseType                    ResponseType;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ResponseVariant;                                   // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationLimit;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitForce;                                          // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHHitReactionHitType                         HitType;                                           // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitLocation;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SourceLocation;                                    // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0070(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitBone;                                           // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitBoneShapeIndex;                                 // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHHitReactionHitData) == 0x000008, "Wrong alignment on FSHHitReactionHitData");
static_assert(sizeof(FSHHitReactionHitData) == 0x000088, "Wrong size on FSHHitReactionHitData");
static_assert(offsetof(FSHHitReactionHitData, DamageType) == 0x000000, "Member 'FSHHitReactionHitData::DamageType' has a wrong offset!");
static_assert(offsetof(FSHHitReactionHitData, ResponseType) == 0x000008, "Member 'FSHHitReactionHitData::ResponseType' has a wrong offset!");
static_assert(offsetof(FSHHitReactionHitData, ResponseVariant) == 0x00000C, "Member 'FSHHitReactionHitData::ResponseVariant' has a wrong offset!");
static_assert(offsetof(FSHHitReactionHitData, DurationLimit) == 0x000014, "Member 'FSHHitReactionHitData::DurationLimit' has a wrong offset!");
static_assert(offsetof(FSHHitReactionHitData, HitForce) == 0x000018, "Member 'FSHHitReactionHitData::HitForce' has a wrong offset!");
static_assert(offsetof(FSHHitReactionHitData, HitType) == 0x000030, "Member 'FSHHitReactionHitData::HitType' has a wrong offset!");
static_assert(offsetof(FSHHitReactionHitData, HitLocation) == 0x000038, "Member 'FSHHitReactionHitData::HitLocation' has a wrong offset!");
static_assert(offsetof(FSHHitReactionHitData, SourceLocation) == 0x000050, "Member 'FSHHitReactionHitData::SourceLocation' has a wrong offset!");
static_assert(offsetof(FSHHitReactionHitData, DamageCauser) == 0x000068, "Member 'FSHHitReactionHitData::DamageCauser' has a wrong offset!");
static_assert(offsetof(FSHHitReactionHitData, HitComponent) == 0x000070, "Member 'FSHHitReactionHitData::HitComponent' has a wrong offset!");
static_assert(offsetof(FSHHitReactionHitData, HitBone) == 0x000078, "Member 'FSHHitReactionHitData::HitBone' has a wrong offset!");
static_assert(offsetof(FSHHitReactionHitData, HitBoneShapeIndex) == 0x000080, "Member 'FSHHitReactionHitData::HitBoneShapeIndex' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionConfigurationConditions
// 0x00A8 (0x00A8 - 0x0000)
struct FSHHitReactionConfigurationConditions final
{
public:
	float                                         PassChance;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDirectionCondition                    HitDirection;                                      // 0x0004(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDirectionCondition                    ImpactDirection;                                   // 0x0018(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDirectionCondition                    ForceDirection;                                    // 0x002C(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDirectionCondition                    TargetMovementDirection;                           // 0x0040(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FMinMaxVector2D                        TargetMovementVelocity;                            // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHHitReactionCollisionConditionConfiguration> CollisionTraces;                                   // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSHHitReactionCollisionConditionConfiguration> RequiredCollisionTraces;                           // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSHHitReactionCollisionConditionConfiguration> PreventingCollisionTraces;                         // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bAllowForDirectionalHits;                          // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowForSurfaceHits;                              // 0x0091(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowForRadialHits;                               // 0x0092(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckWallAngle;                                   // 0x0093(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OnWallAngle;                                       // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHHitReactionConfigurationConditions) == 0x000008, "Wrong alignment on FSHHitReactionConfigurationConditions");
static_assert(sizeof(FSHHitReactionConfigurationConditions) == 0x0000A8, "Wrong size on FSHHitReactionConfigurationConditions");
static_assert(offsetof(FSHHitReactionConfigurationConditions, PassChance) == 0x000000, "Member 'FSHHitReactionConfigurationConditions::PassChance' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfigurationConditions, HitDirection) == 0x000004, "Member 'FSHHitReactionConfigurationConditions::HitDirection' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfigurationConditions, ImpactDirection) == 0x000018, "Member 'FSHHitReactionConfigurationConditions::ImpactDirection' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfigurationConditions, ForceDirection) == 0x00002C, "Member 'FSHHitReactionConfigurationConditions::ForceDirection' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfigurationConditions, TargetMovementDirection) == 0x000040, "Member 'FSHHitReactionConfigurationConditions::TargetMovementDirection' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfigurationConditions, TargetMovementVelocity) == 0x000054, "Member 'FSHHitReactionConfigurationConditions::TargetMovementVelocity' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfigurationConditions, CollisionTraces) == 0x000060, "Member 'FSHHitReactionConfigurationConditions::CollisionTraces' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfigurationConditions, RequiredCollisionTraces) == 0x000070, "Member 'FSHHitReactionConfigurationConditions::RequiredCollisionTraces' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfigurationConditions, PreventingCollisionTraces) == 0x000080, "Member 'FSHHitReactionConfigurationConditions::PreventingCollisionTraces' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfigurationConditions, bAllowForDirectionalHits) == 0x000090, "Member 'FSHHitReactionConfigurationConditions::bAllowForDirectionalHits' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfigurationConditions, bAllowForSurfaceHits) == 0x000091, "Member 'FSHHitReactionConfigurationConditions::bAllowForSurfaceHits' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfigurationConditions, bAllowForRadialHits) == 0x000092, "Member 'FSHHitReactionConfigurationConditions::bAllowForRadialHits' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfigurationConditions, bCheckWallAngle) == 0x000093, "Member 'FSHHitReactionConfigurationConditions::bCheckWallAngle' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfigurationConditions, OnWallAngle) == 0x000098, "Member 'FSHHitReactionConfigurationConditions::OnWallAngle' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionConfiguration
// 0x01F8 (0x01F8 - 0x0000)
struct FSHHitReactionConfiguration final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DebugReactionName;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSHHitReactionConfigurationConditions  Conditions;                                        // 0x0020(0x00A8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSHHitReactionStateConfiguration       HitReactionState;                                  // 0x00C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHHitReactionAnimationConfiguration> Animations;                                        // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSHHitReactionAnimationConfiguration> FinishingAnimations;                               // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSHHitReactionAnimationConfiguration> TwitchAnimations;                                  // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSHHitReactionRotationConfiguration    RotationConfiguration;                             // 0x0108(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHHitReactionPhysicsConfiguration     Physics;                                           // 0x0120(0x00D8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHHitReactionConfiguration) == 0x000008, "Wrong alignment on FSHHitReactionConfiguration");
static_assert(sizeof(FSHHitReactionConfiguration) == 0x0001F8, "Wrong size on FSHHitReactionConfiguration");
static_assert(offsetof(FSHHitReactionConfiguration, DebugReactionName) == 0x000010, "Member 'FSHHitReactionConfiguration::DebugReactionName' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfiguration, Conditions) == 0x000020, "Member 'FSHHitReactionConfiguration::Conditions' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfiguration, HitReactionState) == 0x0000C8, "Member 'FSHHitReactionConfiguration::HitReactionState' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfiguration, Animations) == 0x0000D8, "Member 'FSHHitReactionConfiguration::Animations' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfiguration, FinishingAnimations) == 0x0000E8, "Member 'FSHHitReactionConfiguration::FinishingAnimations' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfiguration, TwitchAnimations) == 0x0000F8, "Member 'FSHHitReactionConfiguration::TwitchAnimations' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfiguration, RotationConfiguration) == 0x000108, "Member 'FSHHitReactionConfiguration::RotationConfiguration' has a wrong offset!");
static_assert(offsetof(FSHHitReactionConfiguration, Physics) == 0x000120, "Member 'FSHHitReactionConfiguration::Physics' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionBodyMapBoneResponse
// 0x0018 (0x0018 - 0x0000)
struct FSHHitReactionBodyMapBoneResponse final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoneShapeIndex;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USHHitReactionConfig*                   HitReactionConfig;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHHitReactionBodyMapBoneResponse) == 0x000008, "Wrong alignment on FSHHitReactionBodyMapBoneResponse");
static_assert(sizeof(FSHHitReactionBodyMapBoneResponse) == 0x000018, "Wrong size on FSHHitReactionBodyMapBoneResponse");
static_assert(offsetof(FSHHitReactionBodyMapBoneResponse, BoneName) == 0x000000, "Member 'FSHHitReactionBodyMapBoneResponse::BoneName' has a wrong offset!");
static_assert(offsetof(FSHHitReactionBodyMapBoneResponse, BoneShapeIndex) == 0x000008, "Member 'FSHHitReactionBodyMapBoneResponse::BoneShapeIndex' has a wrong offset!");
static_assert(offsetof(FSHHitReactionBodyMapBoneResponse, HitReactionConfig) == 0x000010, "Member 'FSHHitReactionBodyMapBoneResponse::HitReactionConfig' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionResultRotation
// 0x000C (0x000C - 0x0000)
struct FSHHitReactionResultRotation final
{
public:
	float                                         AddYaw;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationDuration;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplaceCurrentRotation;                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHHitReactionResultRotation) == 0x000004, "Wrong alignment on FSHHitReactionResultRotation");
static_assert(sizeof(FSHHitReactionResultRotation) == 0x00000C, "Wrong size on FSHHitReactionResultRotation");
static_assert(offsetof(FSHHitReactionResultRotation, AddYaw) == 0x000000, "Member 'FSHHitReactionResultRotation::AddYaw' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResultRotation, RotationDuration) == 0x000004, "Member 'FSHHitReactionResultRotation::RotationDuration' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResultRotation, bReplaceCurrentRotation) == 0x000008, "Member 'FSHHitReactionResultRotation::bReplaceCurrentRotation' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionResultAnimation
// 0x00B0 (0x00B0 - 0x0000)
struct FSHHitReactionResultAnimation final
{
public:
	struct FPlayAnimationData                     Animation;                                         // 0x0000(0x00B0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHHitReactionResultAnimation) == 0x000008, "Wrong alignment on FSHHitReactionResultAnimation");
static_assert(sizeof(FSHHitReactionResultAnimation) == 0x0000B0, "Wrong size on FSHHitReactionResultAnimation");
static_assert(offsetof(FSHHitReactionResultAnimation, Animation) == 0x000000, "Member 'FSHHitReactionResultAnimation::Animation' has a wrong offset!");

// ScriptStruct SHProto.SHHitReactionResult
// 0x0078 (0x0078 - 0x0000)
struct FSHHitReactionResult final
{
public:
	class FString                                 DebugVisualBehaviorName;                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSHHitReactionResultState              HitReactionState;                                  // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FSHHitReactionResultAnimation>  Animations;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSHHitReactionResultAnimation>  FinishingAnimations;                               // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSHHitReactionResultAnimation>  TwitchAnimations;                                  // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSHHitReactionResultBonePhysics> BonePhysics;                                       // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSHHitReactionResultRotation           Rotation;                                          // 0x0068(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHHitReactionResult) == 0x000008, "Wrong alignment on FSHHitReactionResult");
static_assert(sizeof(FSHHitReactionResult) == 0x000078, "Wrong size on FSHHitReactionResult");
static_assert(offsetof(FSHHitReactionResult, DebugVisualBehaviorName) == 0x000000, "Member 'FSHHitReactionResult::DebugVisualBehaviorName' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResult, HitReactionState) == 0x000010, "Member 'FSHHitReactionResult::HitReactionState' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResult, Animations) == 0x000028, "Member 'FSHHitReactionResult::Animations' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResult, FinishingAnimations) == 0x000038, "Member 'FSHHitReactionResult::FinishingAnimations' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResult, TwitchAnimations) == 0x000048, "Member 'FSHHitReactionResult::TwitchAnimations' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResult, BonePhysics) == 0x000058, "Member 'FSHHitReactionResult::BonePhysics' has a wrong offset!");
static_assert(offsetof(FSHHitReactionResult, Rotation) == 0x000068, "Member 'FSHHitReactionResult::Rotation' has a wrong offset!");

// ScriptStruct SHProto.SHHookedMeatBoneworkHandler
// 0x0018 (0x0018 - 0x0000)
struct FSHHookedMeatBoneworkHandler final
{
public:
	TArray<struct FSHMeatHealthValues>            BonesHealthValues;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHHookedMeatBoneworkHandler) == 0x000008, "Wrong alignment on FSHHookedMeatBoneworkHandler");
static_assert(sizeof(FSHHookedMeatBoneworkHandler) == 0x000018, "Wrong size on FSHHookedMeatBoneworkHandler");
static_assert(offsetof(FSHHookedMeatBoneworkHandler, BonesHealthValues) == 0x000000, "Member 'FSHHookedMeatBoneworkHandler::BonesHealthValues' has a wrong offset!");

// ScriptStruct SHProto.SHIntCondition
// 0x0008 (0x0008 - 0x0000)
struct FSHIntCondition final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHIntOperationType                           OperationType;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHIntCondition) == 0x000004, "Wrong alignment on FSHIntCondition");
static_assert(sizeof(FSHIntCondition) == 0x000008, "Wrong size on FSHIntCondition");
static_assert(offsetof(FSHIntCondition, Value) == 0x000000, "Member 'FSHIntCondition::Value' has a wrong offset!");
static_assert(offsetof(FSHIntCondition, OperationType) == 0x000004, "Member 'FSHIntCondition::OperationType' has a wrong offset!");

// ScriptStruct SHProto.SHInteractionStopData
// 0x0001 (0x0001 - 0x0000)
struct FSHInteractionStopData
{
public:
	ESHInteractionStopReason                      Reason;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHInteractionStopData) == 0x000001, "Wrong alignment on FSHInteractionStopData");
static_assert(sizeof(FSHInteractionStopData) == 0x000001, "Wrong size on FSHInteractionStopData");
static_assert(offsetof(FSHInteractionStopData, Reason) == 0x000000, "Member 'FSHInteractionStopData::Reason' has a wrong offset!");

// ScriptStruct SHProto.SHInteractionGenericStopData
// 0x0000 (0x0001 - 0x0001)
struct FSHInteractionGenericStopData final : public FSHInteractionStopData
{
};
static_assert(alignof(FSHInteractionGenericStopData) == 0x000001, "Wrong alignment on FSHInteractionGenericStopData");
static_assert(sizeof(FSHInteractionGenericStopData) == 0x000001, "Wrong size on FSHInteractionGenericStopData");

// ScriptStruct SHProto.SHInteractionIconSet
// 0x0001 (0x0001 - 0x0000)
struct FSHInteractionIconSet final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHInteractionIconSet) == 0x000001, "Wrong alignment on FSHInteractionIconSet");
static_assert(sizeof(FSHInteractionIconSet) == 0x000001, "Wrong size on FSHInteractionIconSet");

// ScriptStruct SHProto.SHItemAttachSlotData
// 0x0038 (0x0038 - 0x0000)
struct FSHItemAttachSlotData final
{
public:
	class FName                                   SlotName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeLocation;                                  // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeRotation;                                  // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHItemAttachSlotData) == 0x000008, "Wrong alignment on FSHItemAttachSlotData");
static_assert(sizeof(FSHItemAttachSlotData) == 0x000038, "Wrong size on FSHItemAttachSlotData");
static_assert(offsetof(FSHItemAttachSlotData, SlotName) == 0x000000, "Member 'FSHItemAttachSlotData::SlotName' has a wrong offset!");
static_assert(offsetof(FSHItemAttachSlotData, RelativeLocation) == 0x000008, "Member 'FSHItemAttachSlotData::RelativeLocation' has a wrong offset!");
static_assert(offsetof(FSHItemAttachSlotData, RelativeRotation) == 0x000020, "Member 'FSHItemAttachSlotData::RelativeRotation' has a wrong offset!");

// ScriptStruct SHProto.SHItemInvestigationAnimsData
// 0x0090 (0x0090 - 0x0000)
struct FSHItemInvestigationAnimsData final
{
public:
	TSoftObjectPtr<class UAnimSequence>           SetupAnimation;                                    // 0x0000(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           InvestigationAnimation;                            // 0x0030(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           FinishAnimation;                                   // 0x0060(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHItemInvestigationAnimsData) == 0x000008, "Wrong alignment on FSHItemInvestigationAnimsData");
static_assert(sizeof(FSHItemInvestigationAnimsData) == 0x000090, "Wrong size on FSHItemInvestigationAnimsData");
static_assert(offsetof(FSHItemInvestigationAnimsData, SetupAnimation) == 0x000000, "Member 'FSHItemInvestigationAnimsData::SetupAnimation' has a wrong offset!");
static_assert(offsetof(FSHItemInvestigationAnimsData, InvestigationAnimation) == 0x000030, "Member 'FSHItemInvestigationAnimsData::InvestigationAnimation' has a wrong offset!");
static_assert(offsetof(FSHItemInvestigationAnimsData, FinishAnimation) == 0x000060, "Member 'FSHItemInvestigationAnimsData::FinishAnimation' has a wrong offset!");

// ScriptStruct SHProto.SHItemInvestigationTranscriptContext
// 0x0038 (0x0038 - 0x0000)
struct FSHItemInvestigationTranscriptContext final
{
public:
	struct FMinMaxVector2D                        AnimationTimeRange;                                // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USHTranscriptData>       TranscriptData;                                    // 0x0008(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHItemInvestigationTranscriptContext) == 0x000008, "Wrong alignment on FSHItemInvestigationTranscriptContext");
static_assert(sizeof(FSHItemInvestigationTranscriptContext) == 0x000038, "Wrong size on FSHItemInvestigationTranscriptContext");
static_assert(offsetof(FSHItemInvestigationTranscriptContext, AnimationTimeRange) == 0x000000, "Member 'FSHItemInvestigationTranscriptContext::AnimationTimeRange' has a wrong offset!");
static_assert(offsetof(FSHItemInvestigationTranscriptContext, TranscriptData) == 0x000008, "Member 'FSHItemInvestigationTranscriptContext::TranscriptData' has a wrong offset!");

// ScriptStruct SHProto.SHItemDataStruct
// 0x03E8 (0x03F0 - 0x0008)
struct FSHItemDataStruct final : public FTableRowBase
{
public:
	ESHItemTypeEnum                               Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHGameplaySection                            GameplaySection;                                   // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCollectable;                                     // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStackable;                                       // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlockInventoryInvestigation;                       // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UStreamableRenderAsset>  Mesh;                                              // 0x0010(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshWorldScale;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   SkeletalMeshAnimClass;                             // 0x0048(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InteractionIconOffset;                             // 0x0078(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkSwitchValue>          ItemAudioType;                                     // 0x0090(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                InventoryTexture;                                  // 0x00C0(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x00F0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0108(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bOverrideMeshInInvestigation;                      // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UStreamableRenderAsset>  MeshInInvestigation;                               // 0x0128(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SkeletalMeshAnimClassInInvestigation;              // 0x0158(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, TSoftObjectPtr<class UMaterialInterface>> MeshInInvestigationMaterialsOverrides;             // 0x0188(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         InvestigationMeshWorldScale;                       // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHItemAttachSlotData                  InvesitagtionAttachData;                           // 0x01E0(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   InvesitagtionExeOverride;                          // 0x0218(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ESHItemAttachSlotType, struct FSHItemAttachSlotData> QuickTakeEquipSlotParams;                          // 0x0248(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           QuickTakeHandPoseOverrideAnimation;                // 0x0298(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemInvestigationType                        InvestigationType;                                 // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationSpeedKeys;                                 // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpeedMouse;                                // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHItemInvestigationAnimsData          InvestigationAnimations;                           // 0x02D8(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           TakeAnimation;                                     // 0x0368(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReadable;                                        // 0x0398(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USHTranscriptData>       TranscriptData;                                    // 0x03A0(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultTranscriptDataIfNoContextValid;         // 0x03D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D1[0x7];                                      // 0x03D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHItemInvestigationTranscriptContext> InvestigationTranscriptContexts;                   // 0x03D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DefaultMeshBoundsScale;                            // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvestigationMeshBoundsScale;                      // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHItemDataStruct) == 0x000008, "Wrong alignment on FSHItemDataStruct");
static_assert(sizeof(FSHItemDataStruct) == 0x0003F0, "Wrong size on FSHItemDataStruct");
static_assert(offsetof(FSHItemDataStruct, Type) == 0x000008, "Member 'FSHItemDataStruct::Type' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, GameplaySection) == 0x000009, "Member 'FSHItemDataStruct::GameplaySection' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, IsCollectable) == 0x00000A, "Member 'FSHItemDataStruct::IsCollectable' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, IsStackable) == 0x00000B, "Member 'FSHItemDataStruct::IsStackable' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, BlockInventoryInvestigation) == 0x00000C, "Member 'FSHItemDataStruct::BlockInventoryInvestigation' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, Mesh) == 0x000010, "Member 'FSHItemDataStruct::Mesh' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, MeshWorldScale) == 0x000040, "Member 'FSHItemDataStruct::MeshWorldScale' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, SkeletalMeshAnimClass) == 0x000048, "Member 'FSHItemDataStruct::SkeletalMeshAnimClass' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, InteractionIconOffset) == 0x000078, "Member 'FSHItemDataStruct::InteractionIconOffset' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, ItemAudioType) == 0x000090, "Member 'FSHItemDataStruct::ItemAudioType' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, InventoryTexture) == 0x0000C0, "Member 'FSHItemDataStruct::InventoryTexture' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, DisplayName) == 0x0000F0, "Member 'FSHItemDataStruct::DisplayName' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, Description) == 0x000108, "Member 'FSHItemDataStruct::Description' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, bOverrideMeshInInvestigation) == 0x000120, "Member 'FSHItemDataStruct::bOverrideMeshInInvestigation' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, MeshInInvestigation) == 0x000128, "Member 'FSHItemDataStruct::MeshInInvestigation' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, SkeletalMeshAnimClassInInvestigation) == 0x000158, "Member 'FSHItemDataStruct::SkeletalMeshAnimClassInInvestigation' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, MeshInInvestigationMaterialsOverrides) == 0x000188, "Member 'FSHItemDataStruct::MeshInInvestigationMaterialsOverrides' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, InvestigationMeshWorldScale) == 0x0001D8, "Member 'FSHItemDataStruct::InvestigationMeshWorldScale' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, InvesitagtionAttachData) == 0x0001E0, "Member 'FSHItemDataStruct::InvesitagtionAttachData' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, InvesitagtionExeOverride) == 0x000218, "Member 'FSHItemDataStruct::InvesitagtionExeOverride' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, QuickTakeEquipSlotParams) == 0x000248, "Member 'FSHItemDataStruct::QuickTakeEquipSlotParams' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, QuickTakeHandPoseOverrideAnimation) == 0x000298, "Member 'FSHItemDataStruct::QuickTakeHandPoseOverrideAnimation' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, InvestigationType) == 0x0002C8, "Member 'FSHItemDataStruct::InvestigationType' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, RotationSpeedKeys) == 0x0002CC, "Member 'FSHItemDataStruct::RotationSpeedKeys' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, RotationSpeedMouse) == 0x0002D0, "Member 'FSHItemDataStruct::RotationSpeedMouse' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, InvestigationAnimations) == 0x0002D8, "Member 'FSHItemDataStruct::InvestigationAnimations' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, TakeAnimation) == 0x000368, "Member 'FSHItemDataStruct::TakeAnimation' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, IsReadable) == 0x000398, "Member 'FSHItemDataStruct::IsReadable' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, TranscriptData) == 0x0003A0, "Member 'FSHItemDataStruct::TranscriptData' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, bUseDefaultTranscriptDataIfNoContextValid) == 0x0003D0, "Member 'FSHItemDataStruct::bUseDefaultTranscriptDataIfNoContextValid' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, InvestigationTranscriptContexts) == 0x0003D8, "Member 'FSHItemDataStruct::InvestigationTranscriptContexts' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, DefaultMeshBoundsScale) == 0x0003E8, "Member 'FSHItemDataStruct::DefaultMeshBoundsScale' has a wrong offset!");
static_assert(offsetof(FSHItemDataStruct, InvestigationMeshBoundsScale) == 0x0003EC, "Member 'FSHItemDataStruct::InvestigationMeshBoundsScale' has a wrong offset!");

// ScriptStruct SHProto.SHCombineItemsRecipeDataStruct
// 0x0020 (0x0028 - 0x0008)
struct FSHCombineItemsRecipeDataStruct final : public FTableRowBase
{
public:
	struct FDataTableRowHandle                    ProductItem;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FDataTableRowHandle>            RequiredItems;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHCombineItemsRecipeDataStruct) == 0x000008, "Wrong alignment on FSHCombineItemsRecipeDataStruct");
static_assert(sizeof(FSHCombineItemsRecipeDataStruct) == 0x000028, "Wrong size on FSHCombineItemsRecipeDataStruct");
static_assert(offsetof(FSHCombineItemsRecipeDataStruct, ProductItem) == 0x000008, "Member 'FSHCombineItemsRecipeDataStruct::ProductItem' has a wrong offset!");
static_assert(offsetof(FSHCombineItemsRecipeDataStruct, RequiredItems) == 0x000018, "Member 'FSHCombineItemsRecipeDataStruct::RequiredItems' has a wrong offset!");

// ScriptStruct SHProto.SHItemEquipmentDataStruct
// 0x0030 (0x0038 - 0x0008)
struct FSHItemEquipmentDataStruct final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   EquipmentClass;                                    // 0x0008(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHItemEquipmentDataStruct) == 0x000008, "Wrong alignment on FSHItemEquipmentDataStruct");
static_assert(sizeof(FSHItemEquipmentDataStruct) == 0x000038, "Wrong size on FSHItemEquipmentDataStruct");
static_assert(offsetof(FSHItemEquipmentDataStruct, EquipmentClass) == 0x000008, "Member 'FSHItemEquipmentDataStruct::EquipmentClass' has a wrong offset!");

// ScriptStruct SHProto.SHItemMapDataStruct
// 0x0038 (0x0040 - 0x0008)
struct FSHItemMapDataStruct final : public FTableRowBase
{
public:
	ESHMapsEnum                                   AssignedMap;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHMapsFamily                                 MapsFamily;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MapsFamilyOrder;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AssignedWidget;                                    // 0x0010(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHItemMapDataStruct) == 0x000008, "Wrong alignment on FSHItemMapDataStruct");
static_assert(sizeof(FSHItemMapDataStruct) == 0x000040, "Wrong size on FSHItemMapDataStruct");
static_assert(offsetof(FSHItemMapDataStruct, AssignedMap) == 0x000008, "Member 'FSHItemMapDataStruct::AssignedMap' has a wrong offset!");
static_assert(offsetof(FSHItemMapDataStruct, MapsFamily) == 0x000009, "Member 'FSHItemMapDataStruct::MapsFamily' has a wrong offset!");
static_assert(offsetof(FSHItemMapDataStruct, MapsFamilyOrder) == 0x00000C, "Member 'FSHItemMapDataStruct::MapsFamilyOrder' has a wrong offset!");
static_assert(offsetof(FSHItemMapDataStruct, AssignedWidget) == 0x000010, "Member 'FSHItemMapDataStruct::AssignedWidget' has a wrong offset!");

// ScriptStruct SHProto.SHItemsStorageConfig
// 0x0030 (0x0030 - 0x0000)
struct FSHItemsStorageConfig final
{
public:
	TArray<ESHItemTypeEnum>                       ItemTypesWhitelist;                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ESHGameplaySection>                    GameplaySectionsWhitelist;                         // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ESHGameplaySection>                    GameplaySectionsBlacklist;                         // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHItemsStorageConfig) == 0x000008, "Wrong alignment on FSHItemsStorageConfig");
static_assert(sizeof(FSHItemsStorageConfig) == 0x000030, "Wrong size on FSHItemsStorageConfig");
static_assert(offsetof(FSHItemsStorageConfig, ItemTypesWhitelist) == 0x000000, "Member 'FSHItemsStorageConfig::ItemTypesWhitelist' has a wrong offset!");
static_assert(offsetof(FSHItemsStorageConfig, GameplaySectionsWhitelist) == 0x000010, "Member 'FSHItemsStorageConfig::GameplaySectionsWhitelist' has a wrong offset!");
static_assert(offsetof(FSHItemsStorageConfig, GameplaySectionsBlacklist) == 0x000020, "Member 'FSHItemsStorageConfig::GameplaySectionsBlacklist' has a wrong offset!");

// ScriptStruct SHProto.SHItemUseableDataStruct
// 0x0030 (0x0038 - 0x0008)
struct FSHItemUseableDataStruct final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   ExecutiveClass;                                    // 0x0008(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHItemUseableDataStruct) == 0x000008, "Wrong alignment on FSHItemUseableDataStruct");
static_assert(sizeof(FSHItemUseableDataStruct) == 0x000038, "Wrong size on FSHItemUseableDataStruct");
static_assert(offsetof(FSHItemUseableDataStruct, ExecutiveClass) == 0x000008, "Member 'FSHItemUseableDataStruct::ExecutiveClass' has a wrong offset!");

// ScriptStruct SHProto.SHItemUseExeCustomSetupData
// 0x0068 (0x0068 - 0x0000)
struct FSHItemUseExeCustomSetupData final
{
public:
	TSoftObjectPtr<class UStreamableRenderAsset>  Mesh;                                              // 0x0000(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSHItemAttachSlotData                  AttachData;                                        // 0x0030(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHItemUseExeCustomSetupData) == 0x000008, "Wrong alignment on FSHItemUseExeCustomSetupData");
static_assert(sizeof(FSHItemUseExeCustomSetupData) == 0x000068, "Wrong size on FSHItemUseExeCustomSetupData");
static_assert(offsetof(FSHItemUseExeCustomSetupData, Mesh) == 0x000000, "Member 'FSHItemUseExeCustomSetupData::Mesh' has a wrong offset!");
static_assert(offsetof(FSHItemUseExeCustomSetupData, AttachData) == 0x000030, "Member 'FSHItemUseExeCustomSetupData::AttachData' has a wrong offset!");

// ScriptStruct SHProto.SHWeaponHitFXCustomization
// 0x0003 (0x0003 - 0x0000)
struct FSHWeaponHitFXCustomization final
{
public:
	uint8                                         Pad_0[0x3];                                        // 0x0000(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHWeaponHitFXCustomization) == 0x000001, "Wrong alignment on FSHWeaponHitFXCustomization");
static_assert(sizeof(FSHWeaponHitFXCustomization) == 0x000003, "Wrong size on FSHWeaponHitFXCustomization");

// ScriptStruct SHProto.SHWeaponPoseAnimations
// 0x0450 (0x0450 - 0x0000)
struct FSHWeaponPoseAnimations final
{
public:
	TSoftObjectPtr<class USHMovementAnimationsSetData> AnimationsData;                                    // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayAnimationData                     EquipWeaponAnimation;                              // 0x0030(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPlayAnimationData                     UnequipWeaponAnimation;                            // 0x00E0(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPlayAnimationData                     ChangeWeaponUnequipAnimation;                      // 0x0190(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPlayAnimationData                     ChangeWeaponEquipAnimation;                        // 0x0240(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPlayAnimationData                     ChangeWeaponUnequipInAimAnimation;                 // 0x02F0(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPlayAnimationData                     ChangeWeaponEquipInAimAnimation;                   // 0x03A0(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHWeaponPoseAnimations) == 0x000008, "Wrong alignment on FSHWeaponPoseAnimations");
static_assert(sizeof(FSHWeaponPoseAnimations) == 0x000450, "Wrong size on FSHWeaponPoseAnimations");
static_assert(offsetof(FSHWeaponPoseAnimations, AnimationsData) == 0x000000, "Member 'FSHWeaponPoseAnimations::AnimationsData' has a wrong offset!");
static_assert(offsetof(FSHWeaponPoseAnimations, EquipWeaponAnimation) == 0x000030, "Member 'FSHWeaponPoseAnimations::EquipWeaponAnimation' has a wrong offset!");
static_assert(offsetof(FSHWeaponPoseAnimations, UnequipWeaponAnimation) == 0x0000E0, "Member 'FSHWeaponPoseAnimations::UnequipWeaponAnimation' has a wrong offset!");
static_assert(offsetof(FSHWeaponPoseAnimations, ChangeWeaponUnequipAnimation) == 0x000190, "Member 'FSHWeaponPoseAnimations::ChangeWeaponUnequipAnimation' has a wrong offset!");
static_assert(offsetof(FSHWeaponPoseAnimations, ChangeWeaponEquipAnimation) == 0x000240, "Member 'FSHWeaponPoseAnimations::ChangeWeaponEquipAnimation' has a wrong offset!");
static_assert(offsetof(FSHWeaponPoseAnimations, ChangeWeaponUnequipInAimAnimation) == 0x0002F0, "Member 'FSHWeaponPoseAnimations::ChangeWeaponUnequipInAimAnimation' has a wrong offset!");
static_assert(offsetof(FSHWeaponPoseAnimations, ChangeWeaponEquipInAimAnimation) == 0x0003A0, "Member 'FSHWeaponPoseAnimations::ChangeWeaponEquipInAimAnimation' has a wrong offset!");

// ScriptStruct SHProto.SHDodgeActionDataStruct
// 0x00B8 (0x0178 - 0x00C0)
struct FSHDodgeActionDataStruct final : public FSHSlideActionDataStruct
{
public:
	float                                         DodgeCooldownValue;                                // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotateCharacterToView;                            // 0x00C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBoostCameraInterpLagSpeed;                        // 0x00C5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDodgeOverrrideCameraProfile;                      // 0x00C6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C7[0x1];                                       // 0x00C7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHCameraDataFull                      DodgeCameraProfileOverrride;                       // 0x00C8(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHDodgeActionDataStruct) == 0x000008, "Wrong alignment on FSHDodgeActionDataStruct");
static_assert(sizeof(FSHDodgeActionDataStruct) == 0x000178, "Wrong size on FSHDodgeActionDataStruct");
static_assert(offsetof(FSHDodgeActionDataStruct, DodgeCooldownValue) == 0x0000C0, "Member 'FSHDodgeActionDataStruct::DodgeCooldownValue' has a wrong offset!");
static_assert(offsetof(FSHDodgeActionDataStruct, bRotateCharacterToView) == 0x0000C4, "Member 'FSHDodgeActionDataStruct::bRotateCharacterToView' has a wrong offset!");
static_assert(offsetof(FSHDodgeActionDataStruct, bBoostCameraInterpLagSpeed) == 0x0000C5, "Member 'FSHDodgeActionDataStruct::bBoostCameraInterpLagSpeed' has a wrong offset!");
static_assert(offsetof(FSHDodgeActionDataStruct, bDodgeOverrrideCameraProfile) == 0x0000C6, "Member 'FSHDodgeActionDataStruct::bDodgeOverrrideCameraProfile' has a wrong offset!");
static_assert(offsetof(FSHDodgeActionDataStruct, DodgeCameraProfileOverrride) == 0x0000C8, "Member 'FSHDodgeActionDataStruct::DodgeCameraProfileOverrride' has a wrong offset!");

// ScriptStruct SHProto.SHItemWeaponDataStruct
// 0x0158 (0x0160 - 0x0008)
struct FSHItemWeaponDataStruct final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   CustomClass;                                       // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHHitReactionMaps*                     HitReactionMaps;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ESHCombatPoseType, struct FSHWeaponPoseAnimations> Animations;                                        // 0x0040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ESHCombatPoseType, struct FSHDodgeActionDataStruct> DodgesMapping;                                     // 0x0090(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ESHCombatPoseType, struct FItemQuickGrabAnimationData> ItemQuickGrabMapping;                              // 0x00E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CrosshairWidgetClass;                              // 0x0130(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHItemWeaponDataStruct) == 0x000008, "Wrong alignment on FSHItemWeaponDataStruct");
static_assert(sizeof(FSHItemWeaponDataStruct) == 0x000160, "Wrong size on FSHItemWeaponDataStruct");
static_assert(offsetof(FSHItemWeaponDataStruct, CustomClass) == 0x000008, "Member 'FSHItemWeaponDataStruct::CustomClass' has a wrong offset!");
static_assert(offsetof(FSHItemWeaponDataStruct, HitReactionMaps) == 0x000038, "Member 'FSHItemWeaponDataStruct::HitReactionMaps' has a wrong offset!");
static_assert(offsetof(FSHItemWeaponDataStruct, Animations) == 0x000040, "Member 'FSHItemWeaponDataStruct::Animations' has a wrong offset!");
static_assert(offsetof(FSHItemWeaponDataStruct, DodgesMapping) == 0x000090, "Member 'FSHItemWeaponDataStruct::DodgesMapping' has a wrong offset!");
static_assert(offsetof(FSHItemWeaponDataStruct, ItemQuickGrabMapping) == 0x0000E0, "Member 'FSHItemWeaponDataStruct::ItemQuickGrabMapping' has a wrong offset!");
static_assert(offsetof(FSHItemWeaponDataStruct, CrosshairWidgetClass) == 0x000130, "Member 'FSHItemWeaponDataStruct::CrosshairWidgetClass' has a wrong offset!");

// ScriptStruct SHProto.SHWeaponRangedPointingData
// 0x000C (0x000C - 0x0000)
struct FSHWeaponRangedPointingData final
{
public:
	bool                                          bIsPointedActorForbiddingToBeShoot;                // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  PointedActor;                                      // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHWeaponRangedPointingData) == 0x000004, "Wrong alignment on FSHWeaponRangedPointingData");
static_assert(sizeof(FSHWeaponRangedPointingData) == 0x00000C, "Wrong size on FSHWeaponRangedPointingData");
static_assert(offsetof(FSHWeaponRangedPointingData, bIsPointedActorForbiddingToBeShoot) == 0x000000, "Member 'FSHWeaponRangedPointingData::bIsPointedActorForbiddingToBeShoot' has a wrong offset!");
static_assert(offsetof(FSHWeaponRangedPointingData, PointedActor) == 0x000004, "Member 'FSHWeaponRangedPointingData::PointedActor' has a wrong offset!");

// ScriptStruct SHProto.SHWeaponRangedFireDetails
// 0x0018 (0x0018 - 0x0000)
struct FSHWeaponRangedFireDetails final
{
public:
	int32                                         TracesNum;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     FoundHits;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHWeaponRangedFireDetails) == 0x000008, "Wrong alignment on FSHWeaponRangedFireDetails");
static_assert(sizeof(FSHWeaponRangedFireDetails) == 0x000018, "Wrong size on FSHWeaponRangedFireDetails");
static_assert(offsetof(FSHWeaponRangedFireDetails, TracesNum) == 0x000000, "Member 'FSHWeaponRangedFireDetails::TracesNum' has a wrong offset!");
static_assert(offsetof(FSHWeaponRangedFireDetails, FoundHits) == 0x000008, "Member 'FSHWeaponRangedFireDetails::FoundHits' has a wrong offset!");

// ScriptStruct SHProto.SHJamesSkeletonHierarchy
// 0x0000 (0x0108 - 0x0108)
struct FSHJamesSkeletonHierarchy final : public FSkeletonHierarchy
{
};
static_assert(alignof(FSHJamesSkeletonHierarchy) == 0x000008, "Wrong alignment on FSHJamesSkeletonHierarchy");
static_assert(sizeof(FSHJamesSkeletonHierarchy) == 0x000108, "Wrong size on FSHJamesSkeletonHierarchy");

// ScriptStruct SHProto.SHLauraSkeletonHierarchy
// 0x0000 (0x0108 - 0x0108)
struct FSHLauraSkeletonHierarchy final : public FSkeletonHierarchy
{
};
static_assert(alignof(FSHLauraSkeletonHierarchy) == 0x000008, "Wrong alignment on FSHLauraSkeletonHierarchy");
static_assert(sizeof(FSHLauraSkeletonHierarchy) == 0x000108, "Wrong size on FSHLauraSkeletonHierarchy");

// ScriptStruct SHProto.SHLightingChannelsPack
// 0x0003 (0x0003 - 0x0000)
struct FSHLightingChannelsPack final
{
public:
	bool                                          Ch0;                                               // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ch1;                                               // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ch2;                                               // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHLightingChannelsPack) == 0x000001, "Wrong alignment on FSHLightingChannelsPack");
static_assert(sizeof(FSHLightingChannelsPack) == 0x000003, "Wrong size on FSHLightingChannelsPack");
static_assert(offsetof(FSHLightingChannelsPack, Ch0) == 0x000000, "Member 'FSHLightingChannelsPack::Ch0' has a wrong offset!");
static_assert(offsetof(FSHLightingChannelsPack, Ch1) == 0x000001, "Member 'FSHLightingChannelsPack::Ch1' has a wrong offset!");
static_assert(offsetof(FSHLightingChannelsPack, Ch2) == 0x000002, "Member 'FSHLightingChannelsPack::Ch2' has a wrong offset!");

// ScriptStruct SHProto.AnimationMovementSpeed
// 0x0008 (0x0008 - 0x0000)
struct FAnimationMovementSpeed final
{
public:
	float                                         Forward;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Back;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationMovementSpeed) == 0x000004, "Wrong alignment on FAnimationMovementSpeed");
static_assert(sizeof(FAnimationMovementSpeed) == 0x000008, "Wrong size on FAnimationMovementSpeed");
static_assert(offsetof(FAnimationMovementSpeed, Forward) == 0x000000, "Member 'FAnimationMovementSpeed::Forward' has a wrong offset!");
static_assert(offsetof(FAnimationMovementSpeed, Back) == 0x000004, "Member 'FAnimationMovementSpeed::Back' has a wrong offset!");

// ScriptStruct SHProto.ObstacleForwardCheckSettings
// 0x0028 (0x0028 - 0x0000)
struct FObstacleForwardCheckSettings final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LocationFromSocket;                                // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObstacleForwardCheckSettings) == 0x000008, "Wrong alignment on FObstacleForwardCheckSettings");
static_assert(sizeof(FObstacleForwardCheckSettings) == 0x000028, "Wrong size on FObstacleForwardCheckSettings");
static_assert(offsetof(FObstacleForwardCheckSettings, Distance) == 0x000000, "Member 'FObstacleForwardCheckSettings::Distance' has a wrong offset!");
static_assert(offsetof(FObstacleForwardCheckSettings, LocationFromSocket) == 0x000004, "Member 'FObstacleForwardCheckSettings::LocationFromSocket' has a wrong offset!");
static_assert(offsetof(FObstacleForwardCheckSettings, SocketName) == 0x000008, "Member 'FObstacleForwardCheckSettings::SocketName' has a wrong offset!");
static_assert(offsetof(FObstacleForwardCheckSettings, LocationOffset) == 0x000010, "Member 'FObstacleForwardCheckSettings::LocationOffset' has a wrong offset!");

// ScriptStruct SHProto.DeadZoneRange
// 0x000C (0x000C - 0x0000)
struct FDeadZoneRange final
{
public:
	float                                         MinValue;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetValue;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeadZoneRange) == 0x000004, "Wrong alignment on FDeadZoneRange");
static_assert(sizeof(FDeadZoneRange) == 0x00000C, "Wrong size on FDeadZoneRange");
static_assert(offsetof(FDeadZoneRange, MinValue) == 0x000000, "Member 'FDeadZoneRange::MinValue' has a wrong offset!");
static_assert(offsetof(FDeadZoneRange, MaxValue) == 0x000004, "Member 'FDeadZoneRange::MaxValue' has a wrong offset!");
static_assert(offsetof(FDeadZoneRange, TargetValue) == 0x000008, "Member 'FDeadZoneRange::TargetValue' has a wrong offset!");

// ScriptStruct SHProto.EquipToAimAnimation
// 0x0010 (0x0010 - 0x0000)
struct FEquipToAimAnimation final
{
public:
	class UAnimationAsset*                        Animation;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipToAimAnimation) == 0x000008, "Wrong alignment on FEquipToAimAnimation");
static_assert(sizeof(FEquipToAimAnimation) == 0x000010, "Wrong size on FEquipToAimAnimation");
static_assert(offsetof(FEquipToAimAnimation, Animation) == 0x000000, "Member 'FEquipToAimAnimation::Animation' has a wrong offset!");
static_assert(offsetof(FEquipToAimAnimation, BlendInTime) == 0x000008, "Member 'FEquipToAimAnimation::BlendInTime' has a wrong offset!");
static_assert(offsetof(FEquipToAimAnimation, BlendOutTime) == 0x00000C, "Member 'FEquipToAimAnimation::BlendOutTime' has a wrong offset!");

// ScriptStruct SHProto.SHLyingFigureSkeletonHierarchy
// 0x0000 (0x0108 - 0x0108)
struct FSHLyingFigureSkeletonHierarchy final : public FSkeletonHierarchy
{
};
static_assert(alignof(FSHLyingFigureSkeletonHierarchy) == 0x000008, "Wrong alignment on FSHLyingFigureSkeletonHierarchy");
static_assert(sizeof(FSHLyingFigureSkeletonHierarchy) == 0x000108, "Wrong size on FSHLyingFigureSkeletonHierarchy");

// ScriptStruct SHProto.SHMandarinSkeletonHierarchy
// 0x0000 (0x0108 - 0x0108)
struct FSHMandarinSkeletonHierarchy final : public FSkeletonHierarchy
{
};
static_assert(alignof(FSHMandarinSkeletonHierarchy) == 0x000008, "Wrong alignment on FSHMandarinSkeletonHierarchy");
static_assert(sizeof(FSHMandarinSkeletonHierarchy) == 0x000108, "Wrong size on FSHMandarinSkeletonHierarchy");

// ScriptStruct SHProto.SHMannequinSkeletonHierarchy
// 0x0000 (0x0108 - 0x0108)
struct FSHMannequinSkeletonHierarchy final : public FSkeletonHierarchy
{
};
static_assert(alignof(FSHMannequinSkeletonHierarchy) == 0x000008, "Wrong alignment on FSHMannequinSkeletonHierarchy");
static_assert(sizeof(FSHMannequinSkeletonHierarchy) == 0x000108, "Wrong size on FSHMannequinSkeletonHierarchy");

// ScriptStruct SHProto.SHMariaFlashlightReactionAnimSubcompSettings
// 0x0110 (0x0118 - 0x0008)
struct FSHMariaFlashlightReactionAnimSubcompSettings final : public FSHAnimSubcompSettings
{
public:
	float                                         BlendIn_InterpSpeed;                               // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOut_InterpSpeed;                              // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutReactionDelay;                             // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BlackboardKeyName;                                 // 0x0014(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DialogTalkRequiredShineTime;                       // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DialogTalkInterval;                                // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDialogDialog                          DialogID;                                          // 0x0028(0x0028)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDialogInfo                            DialogInfo;                                        // 0x0050(0x00C8)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHMariaFlashlightReactionAnimSubcompSettings) == 0x000008, "Wrong alignment on FSHMariaFlashlightReactionAnimSubcompSettings");
static_assert(sizeof(FSHMariaFlashlightReactionAnimSubcompSettings) == 0x000118, "Wrong size on FSHMariaFlashlightReactionAnimSubcompSettings");
static_assert(offsetof(FSHMariaFlashlightReactionAnimSubcompSettings, BlendIn_InterpSpeed) == 0x000008, "Member 'FSHMariaFlashlightReactionAnimSubcompSettings::BlendIn_InterpSpeed' has a wrong offset!");
static_assert(offsetof(FSHMariaFlashlightReactionAnimSubcompSettings, BlendOut_InterpSpeed) == 0x00000C, "Member 'FSHMariaFlashlightReactionAnimSubcompSettings::BlendOut_InterpSpeed' has a wrong offset!");
static_assert(offsetof(FSHMariaFlashlightReactionAnimSubcompSettings, BlendOutReactionDelay) == 0x000010, "Member 'FSHMariaFlashlightReactionAnimSubcompSettings::BlendOutReactionDelay' has a wrong offset!");
static_assert(offsetof(FSHMariaFlashlightReactionAnimSubcompSettings, BlackboardKeyName) == 0x000014, "Member 'FSHMariaFlashlightReactionAnimSubcompSettings::BlackboardKeyName' has a wrong offset!");
static_assert(offsetof(FSHMariaFlashlightReactionAnimSubcompSettings, DialogTalkRequiredShineTime) == 0x00001C, "Member 'FSHMariaFlashlightReactionAnimSubcompSettings::DialogTalkRequiredShineTime' has a wrong offset!");
static_assert(offsetof(FSHMariaFlashlightReactionAnimSubcompSettings, DialogTalkInterval) == 0x000020, "Member 'FSHMariaFlashlightReactionAnimSubcompSettings::DialogTalkInterval' has a wrong offset!");
static_assert(offsetof(FSHMariaFlashlightReactionAnimSubcompSettings, DialogID) == 0x000028, "Member 'FSHMariaFlashlightReactionAnimSubcompSettings::DialogID' has a wrong offset!");
static_assert(offsetof(FSHMariaFlashlightReactionAnimSubcompSettings, DialogInfo) == 0x000050, "Member 'FSHMariaFlashlightReactionAnimSubcompSettings::DialogInfo' has a wrong offset!");

// ScriptStruct SHProto.SHMarySkeletonHierarchy
// 0x0000 (0x0108 - 0x0108)
struct FSHMarySkeletonHierarchy final : public FSkeletonHierarchy
{
};
static_assert(alignof(FSHMarySkeletonHierarchy) == 0x000008, "Wrong alignment on FSHMarySkeletonHierarchy");
static_assert(sizeof(FSHMarySkeletonHierarchy) == 0x000108, "Wrong size on FSHMarySkeletonHierarchy");

// ScriptStruct SHProto.SHMaryTransformationStateCurves
// 0x0024 (0x0024 - 0x0000)
struct FSHMaryTransformationStateCurves final
{
public:
	struct FSimpleBentCurve                       HeightCurve;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleBentCurve                       RotationCurve;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleBentCurve                       CeilingAvoidCurveAbove;                            // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleBentCurve                       CeilingAvoidCurveBelow;                            // 0x0018(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CeilingPassRadiusScale;                            // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHMaryTransformationStateCurves) == 0x000004, "Wrong alignment on FSHMaryTransformationStateCurves");
static_assert(sizeof(FSHMaryTransformationStateCurves) == 0x000024, "Wrong size on FSHMaryTransformationStateCurves");
static_assert(offsetof(FSHMaryTransformationStateCurves, HeightCurve) == 0x000000, "Member 'FSHMaryTransformationStateCurves::HeightCurve' has a wrong offset!");
static_assert(offsetof(FSHMaryTransformationStateCurves, RotationCurve) == 0x000008, "Member 'FSHMaryTransformationStateCurves::RotationCurve' has a wrong offset!");
static_assert(offsetof(FSHMaryTransformationStateCurves, CeilingAvoidCurveAbove) == 0x000010, "Member 'FSHMaryTransformationStateCurves::CeilingAvoidCurveAbove' has a wrong offset!");
static_assert(offsetof(FSHMaryTransformationStateCurves, CeilingAvoidCurveBelow) == 0x000018, "Member 'FSHMaryTransformationStateCurves::CeilingAvoidCurveBelow' has a wrong offset!");
static_assert(offsetof(FSHMaryTransformationStateCurves, CeilingPassRadiusScale) == 0x000020, "Member 'FSHMaryTransformationStateCurves::CeilingPassRadiusScale' has a wrong offset!");

// ScriptStruct SHProto.MenuTutorial
// 0x0028 (0x0028 - 0x0000)
struct FMenuTutorial final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FUE4InputHandle>                Actions;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMenuTutorial) == 0x000008, "Wrong alignment on FMenuTutorial");
static_assert(sizeof(FMenuTutorial) == 0x000028, "Wrong size on FMenuTutorial");
static_assert(offsetof(FMenuTutorial, Text) == 0x000000, "Member 'FMenuTutorial::Text' has a wrong offset!");
static_assert(offsetof(FMenuTutorial, Actions) == 0x000018, "Member 'FMenuTutorial::Actions' has a wrong offset!");

// ScriptStruct SHProto.SHMQSpiderSkeletonHierarchy
// 0x0000 (0x0108 - 0x0108)
struct FSHMQSpiderSkeletonHierarchy final : public FSkeletonHierarchy
{
};
static_assert(alignof(FSHMQSpiderSkeletonHierarchy) == 0x000008, "Wrong alignment on FSHMQSpiderSkeletonHierarchy");
static_assert(sizeof(FSHMQSpiderSkeletonHierarchy) == 0x000108, "Wrong size on FSHMQSpiderSkeletonHierarchy");

// ScriptStruct SHProto.SHNPCAnimInstanceLocomotionSlotConfiguration
// 0x0010 (0x0010 - 0x0000)
struct FSHNPCAnimInstanceLocomotionSlotConfiguration final
{
public:
	class FName                                   LocomotionTag;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LocomotionSnapshotName;                            // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSHNPCAnimInstanceLocomotionSlotConfiguration) == 0x000004, "Wrong alignment on FSHNPCAnimInstanceLocomotionSlotConfiguration");
static_assert(sizeof(FSHNPCAnimInstanceLocomotionSlotConfiguration) == 0x000010, "Wrong size on FSHNPCAnimInstanceLocomotionSlotConfiguration");
static_assert(offsetof(FSHNPCAnimInstanceLocomotionSlotConfiguration, LocomotionTag) == 0x000000, "Member 'FSHNPCAnimInstanceLocomotionSlotConfiguration::LocomotionTag' has a wrong offset!");
static_assert(offsetof(FSHNPCAnimInstanceLocomotionSlotConfiguration, LocomotionSnapshotName) == 0x000008, "Member 'FSHNPCAnimInstanceLocomotionSlotConfiguration::LocomotionSnapshotName' has a wrong offset!");

// ScriptStruct SHProto.SHNPCAnimInstanceLocomotionSlot
// 0x0024 (0x0024 - 0x0000)
struct FSHNPCAnimInstanceLocomotionSlot final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class USHNPCLocomotionAnimInstance> CachedLocomotion;                                  // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18[0xC];                                       // 0x0018(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHNPCAnimInstanceLocomotionSlot) == 0x000004, "Wrong alignment on FSHNPCAnimInstanceLocomotionSlot");
static_assert(sizeof(FSHNPCAnimInstanceLocomotionSlot) == 0x000024, "Wrong size on FSHNPCAnimInstanceLocomotionSlot");
static_assert(offsetof(FSHNPCAnimInstanceLocomotionSlot, CachedLocomotion) == 0x000010, "Member 'FSHNPCAnimInstanceLocomotionSlot::CachedLocomotion' has a wrong offset!");

// ScriptStruct SHProto.NurseWalkingProfileData
// 0x0008 (0x0008 - 0x0000)
struct FNurseWalkingProfileData final
{
public:
	float                                         WalkSpeedFactor;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkRootMotionScale;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNurseWalkingProfileData) == 0x000004, "Wrong alignment on FNurseWalkingProfileData");
static_assert(sizeof(FNurseWalkingProfileData) == 0x000008, "Wrong size on FNurseWalkingProfileData");
static_assert(offsetof(FNurseWalkingProfileData, WalkSpeedFactor) == 0x000000, "Member 'FNurseWalkingProfileData::WalkSpeedFactor' has a wrong offset!");
static_assert(offsetof(FNurseWalkingProfileData, WalkRootMotionScale) == 0x000004, "Member 'FNurseWalkingProfileData::WalkRootMotionScale' has a wrong offset!");

// ScriptStruct SHProto.SHPHSkeletonHierarchy
// 0x0000 (0x0108 - 0x0108)
struct FSHPHSkeletonHierarchy final : public FSkeletonHierarchy
{
};
static_assert(alignof(FSHPHSkeletonHierarchy) == 0x000008, "Wrong alignment on FSHPHSkeletonHierarchy");
static_assert(sizeof(FSHPHSkeletonHierarchy) == 0x000108, "Wrong size on FSHPHSkeletonHierarchy");

// ScriptStruct SHProto.SHRagDollSubcompBoneChainSettings
// 0x0038 (0x0038 - 0x0000)
struct FSHRagDollSubcompBoneChainSettings final
{
public:
	class FName                                   ChainName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           SubChainNames;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           BoneNames;                                         // 0x0018(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHRagDollSubcompBoneChainSettings) == 0x000008, "Wrong alignment on FSHRagDollSubcompBoneChainSettings");
static_assert(sizeof(FSHRagDollSubcompBoneChainSettings) == 0x000038, "Wrong size on FSHRagDollSubcompBoneChainSettings");
static_assert(offsetof(FSHRagDollSubcompBoneChainSettings, ChainName) == 0x000000, "Member 'FSHRagDollSubcompBoneChainSettings::ChainName' has a wrong offset!");
static_assert(offsetof(FSHRagDollSubcompBoneChainSettings, SubChainNames) == 0x000008, "Member 'FSHRagDollSubcompBoneChainSettings::SubChainNames' has a wrong offset!");
static_assert(offsetof(FSHRagDollSubcompBoneChainSettings, BoneNames) == 0x000018, "Member 'FSHRagDollSubcompBoneChainSettings::BoneNames' has a wrong offset!");

// ScriptStruct SHProto.SHRagDollSubcompSettings
// 0x0030 (0x0038 - 0x0008)
struct FSHRagDollSubcompSettings final : public FSHAnimSubcompSettings
{
public:
	class FName                                   RagDollPhysicsIdentifier;                          // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSHRagDollSubcompBoneChainSettings> RagDollBoneChains;                                 // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_20[0x18];                                      // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHRagDollSubcompSettings) == 0x000008, "Wrong alignment on FSHRagDollSubcompSettings");
static_assert(sizeof(FSHRagDollSubcompSettings) == 0x000038, "Wrong size on FSHRagDollSubcompSettings");
static_assert(offsetof(FSHRagDollSubcompSettings, RagDollPhysicsIdentifier) == 0x000008, "Member 'FSHRagDollSubcompSettings::RagDollPhysicsIdentifier' has a wrong offset!");
static_assert(offsetof(FSHRagDollSubcompSettings, RagDollBoneChains) == 0x000010, "Member 'FSHRagDollSubcompSettings::RagDollBoneChains' has a wrong offset!");

// ScriptStruct SHProto.SHRangedAutoAimWeaponConfigurationData
// 0x0010 (0x0010 - 0x0000)
struct FSHRangedAutoAimWeaponConfigurationData final
{
public:
	float                                         MaxRange;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RangeToStrengthMappingCurve;                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHRangedAutoAimWeaponConfigurationData) == 0x000008, "Wrong alignment on FSHRangedAutoAimWeaponConfigurationData");
static_assert(sizeof(FSHRangedAutoAimWeaponConfigurationData) == 0x000010, "Wrong size on FSHRangedAutoAimWeaponConfigurationData");
static_assert(offsetof(FSHRangedAutoAimWeaponConfigurationData, MaxRange) == 0x000000, "Member 'FSHRangedAutoAimWeaponConfigurationData::MaxRange' has a wrong offset!");
static_assert(offsetof(FSHRangedAutoAimWeaponConfigurationData, RangeToStrengthMappingCurve) == 0x000008, "Member 'FSHRangedAutoAimWeaponConfigurationData::RangeToStrengthMappingCurve' has a wrong offset!");

// ScriptStruct SHProto.SHRangedAutoAimConfigurationData
// 0x0018 (0x0018 - 0x0000)
struct FSHRangedAutoAimConfigurationData final
{
public:
	float                                         MinInputValueToDisableMagnet;                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InfluenceRadiusAsExtentMul;                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoAimInputBaseValue;                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RadiusDistanceStrengthMappingCurve;                // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHRangedAutoAimConfigurationData) == 0x000008, "Wrong alignment on FSHRangedAutoAimConfigurationData");
static_assert(sizeof(FSHRangedAutoAimConfigurationData) == 0x000018, "Wrong size on FSHRangedAutoAimConfigurationData");
static_assert(offsetof(FSHRangedAutoAimConfigurationData, MinInputValueToDisableMagnet) == 0x000000, "Member 'FSHRangedAutoAimConfigurationData::MinInputValueToDisableMagnet' has a wrong offset!");
static_assert(offsetof(FSHRangedAutoAimConfigurationData, InfluenceRadiusAsExtentMul) == 0x000004, "Member 'FSHRangedAutoAimConfigurationData::InfluenceRadiusAsExtentMul' has a wrong offset!");
static_assert(offsetof(FSHRangedAutoAimConfigurationData, AutoAimInputBaseValue) == 0x000008, "Member 'FSHRangedAutoAimConfigurationData::AutoAimInputBaseValue' has a wrong offset!");
static_assert(offsetof(FSHRangedAutoAimConfigurationData, RadiusDistanceStrengthMappingCurve) == 0x000010, "Member 'FSHRangedAutoAimConfigurationData::RadiusDistanceStrengthMappingCurve' has a wrong offset!");

// ScriptStruct SHProto.ConsoleOverrideData
// 0x0030 (0x0030 - 0x0000)
struct FConsoleOverrideData final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PreservedValue;                                    // 0x0020(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConsoleOverrideData) == 0x000008, "Wrong alignment on FConsoleOverrideData");
static_assert(sizeof(FConsoleOverrideData) == 0x000030, "Wrong size on FConsoleOverrideData");
static_assert(offsetof(FConsoleOverrideData, Name) == 0x000000, "Member 'FConsoleOverrideData::Name' has a wrong offset!");
static_assert(offsetof(FConsoleOverrideData, Value) == 0x000010, "Member 'FConsoleOverrideData::Value' has a wrong offset!");
static_assert(offsetof(FConsoleOverrideData, PreservedValue) == 0x000020, "Member 'FConsoleOverrideData::PreservedValue' has a wrong offset!");

// ScriptStruct SHProto.ReviveAnimationData
// 0x00C0 (0x00C0 - 0x0000)
struct FReviveAnimationData final
{
public:
	class UAnimationAsset*                        Animation;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HipsForward;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HipsRight;                                         // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HipsUp;                                            // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EBones, struct FVector>                  BoneDirection;                                     // 0x0050(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ERevivePose                                   RevivePose;                                        // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ActorForwardBasedOnHips;                           // 0x00A8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReviveAnimationData) == 0x000008, "Wrong alignment on FReviveAnimationData");
static_assert(sizeof(FReviveAnimationData) == 0x0000C0, "Wrong size on FReviveAnimationData");
static_assert(offsetof(FReviveAnimationData, Animation) == 0x000000, "Member 'FReviveAnimationData::Animation' has a wrong offset!");
static_assert(offsetof(FReviveAnimationData, HipsForward) == 0x000008, "Member 'FReviveAnimationData::HipsForward' has a wrong offset!");
static_assert(offsetof(FReviveAnimationData, HipsRight) == 0x000020, "Member 'FReviveAnimationData::HipsRight' has a wrong offset!");
static_assert(offsetof(FReviveAnimationData, HipsUp) == 0x000038, "Member 'FReviveAnimationData::HipsUp' has a wrong offset!");
static_assert(offsetof(FReviveAnimationData, BoneDirection) == 0x000050, "Member 'FReviveAnimationData::BoneDirection' has a wrong offset!");
static_assert(offsetof(FReviveAnimationData, RevivePose) == 0x0000A0, "Member 'FReviveAnimationData::RevivePose' has a wrong offset!");
static_assert(offsetof(FReviveAnimationData, ActorForwardBasedOnHips) == 0x0000A8, "Member 'FReviveAnimationData::ActorForwardBasedOnHips' has a wrong offset!");

// ScriptStruct SHProto.SHRotationSnapOperation
// 0x0098 (0x0098 - 0x0000)
struct alignas(0x08) FSHRotationSnapOperation final
{
public:
	uint8                                         Pad_0[0x98];                                       // 0x0000(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHRotationSnapOperation) == 0x000008, "Wrong alignment on FSHRotationSnapOperation");
static_assert(sizeof(FSHRotationSnapOperation) == 0x000098, "Wrong size on FSHRotationSnapOperation");

// ScriptStruct SHProto.SHSaveData
// 0x0110 (0x0120 - 0x0010)
struct FSHSaveData final : public FSaveData
{
public:
	struct FLevelStreamingActorData               PlayerData;                                        // 0x0010(0x0030)(Transient, NativeAccessSpecifierPublic)
	struct FSaveDataStreaming                     StreamingData;                                     // 0x0040(0x00D0)(Transient, NativeAccessSpecifierPublic)
	class FName                                   SavePointName;                                     // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECombatDifficulty                             CombatDifficulty;                                  // 0x0118(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPuzzlesDifficulty                            PuzzlesDifficulty;                                 // 0x0119(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A[0x6];                                      // 0x011A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHSaveData) == 0x000010, "Wrong alignment on FSHSaveData");
static_assert(sizeof(FSHSaveData) == 0x000120, "Wrong size on FSHSaveData");
static_assert(offsetof(FSHSaveData, PlayerData) == 0x000010, "Member 'FSHSaveData::PlayerData' has a wrong offset!");
static_assert(offsetof(FSHSaveData, StreamingData) == 0x000040, "Member 'FSHSaveData::StreamingData' has a wrong offset!");
static_assert(offsetof(FSHSaveData, SavePointName) == 0x000110, "Member 'FSHSaveData::SavePointName' has a wrong offset!");
static_assert(offsetof(FSHSaveData, CombatDifficulty) == 0x000118, "Member 'FSHSaveData::CombatDifficulty' has a wrong offset!");
static_assert(offsetof(FSHSaveData, PuzzlesDifficulty) == 0x000119, "Member 'FSHSaveData::PuzzlesDifficulty' has a wrong offset!");

// ScriptStruct SHProto.GameSaveSlotInfo
// 0x0048 (0x0080 - 0x0038)
struct FGameSaveSlotInfo final : public FSaveSlotInfo
{
public:
	uint8                                         IsNewGamePlus : 1;                                 // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SavePointName;                                     // 0x003C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              SavePointImage;                                    // 0x0048(0x0030)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECombatDifficulty                             CombatDifficulty;                                  // 0x0078(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPuzzlesDifficulty                            PuzzlesDifficulty;                                 // 0x0079(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESavePointFilterId                            Filter;                                            // 0x007A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B[0x5];                                       // 0x007B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameSaveSlotInfo) == 0x000008, "Wrong alignment on FGameSaveSlotInfo");
static_assert(sizeof(FGameSaveSlotInfo) == 0x000080, "Wrong size on FGameSaveSlotInfo");
static_assert(offsetof(FGameSaveSlotInfo, SavePointName) == 0x00003C, "Member 'FGameSaveSlotInfo::SavePointName' has a wrong offset!");
static_assert(offsetof(FGameSaveSlotInfo, SavePointImage) == 0x000048, "Member 'FGameSaveSlotInfo::SavePointImage' has a wrong offset!");
static_assert(offsetof(FGameSaveSlotInfo, CombatDifficulty) == 0x000078, "Member 'FGameSaveSlotInfo::CombatDifficulty' has a wrong offset!");
static_assert(offsetof(FGameSaveSlotInfo, PuzzlesDifficulty) == 0x000079, "Member 'FGameSaveSlotInfo::PuzzlesDifficulty' has a wrong offset!");
static_assert(offsetof(FGameSaveSlotInfo, Filter) == 0x00007A, "Member 'FGameSaveSlotInfo::Filter' has a wrong offset!");

// ScriptStruct SHProto.TutorialsData
// 0x0060 (0x0060 - 0x0000)
struct FTutorialsData final
{
public:
	bool                                          Visibility;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         FontInfo;                                          // 0x0008(0x0058)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTutorialsData) == 0x000008, "Wrong alignment on FTutorialsData");
static_assert(sizeof(FTutorialsData) == 0x000060, "Wrong size on FTutorialsData");
static_assert(offsetof(FTutorialsData, Visibility) == 0x000000, "Member 'FTutorialsData::Visibility' has a wrong offset!");
static_assert(offsetof(FTutorialsData, FontInfo) == 0x000008, "Member 'FTutorialsData::FontInfo' has a wrong offset!");

// ScriptStruct SHProto.ReticleData
// 0x000C (0x000C - 0x0000)
struct FReticleData final
{
public:
	EReticleVisibility                            Visibility;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReticleThickness                             Thickness;                                         // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Opacity;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReticleColor                                 Color;                                             // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReticleData) == 0x000004, "Wrong alignment on FReticleData");
static_assert(sizeof(FReticleData) == 0x00000C, "Wrong size on FReticleData");
static_assert(offsetof(FReticleData, Visibility) == 0x000000, "Member 'FReticleData::Visibility' has a wrong offset!");
static_assert(offsetof(FReticleData, Thickness) == 0x000001, "Member 'FReticleData::Thickness' has a wrong offset!");
static_assert(offsetof(FReticleData, Opacity) == 0x000004, "Member 'FReticleData::Opacity' has a wrong offset!");
static_assert(offsetof(FReticleData, Color) == 0x000008, "Member 'FReticleData::Color' has a wrong offset!");

// ScriptStruct SHProto.InteractionIconData
// 0x00C8 (0x00C8 - 0x0000)
struct FInteractionIconData final
{
public:
	EInteractionIconVisibility                    Visibility;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionIconSize                          Size;                                              // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScaleMultiplier;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSettingOptionVisualizationData        VisualizationData;                                 // 0x0008(0x0060)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSettingOptionVisualizationData        SizeData;                                          // 0x0068(0x0060)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionIconData) == 0x000008, "Wrong alignment on FInteractionIconData");
static_assert(sizeof(FInteractionIconData) == 0x0000C8, "Wrong size on FInteractionIconData");
static_assert(offsetof(FInteractionIconData, Visibility) == 0x000000, "Member 'FInteractionIconData::Visibility' has a wrong offset!");
static_assert(offsetof(FInteractionIconData, Size) == 0x000001, "Member 'FInteractionIconData::Size' has a wrong offset!");
static_assert(offsetof(FInteractionIconData, ScaleMultiplier) == 0x000004, "Member 'FInteractionIconData::ScaleMultiplier' has a wrong offset!");
static_assert(offsetof(FInteractionIconData, VisualizationData) == 0x000008, "Member 'FInteractionIconData::VisualizationData' has a wrong offset!");
static_assert(offsetof(FInteractionIconData, SizeData) == 0x000068, "Member 'FInteractionIconData::SizeData' has a wrong offset!");

// ScriptStruct SHProto.TraversalIconData
// 0x00C8 (0x00C8 - 0x0000)
struct FTraversalIconData final
{
public:
	EInteractionIconVisibility                    Visibility;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionIconSize                          Size;                                              // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScaleMultiplier;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSettingOptionVisualizationData        VisualizationData;                                 // 0x0008(0x0060)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSettingOptionVisualizationData        SizeData;                                          // 0x0068(0x0060)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTraversalIconData) == 0x000008, "Wrong alignment on FTraversalIconData");
static_assert(sizeof(FTraversalIconData) == 0x0000C8, "Wrong size on FTraversalIconData");
static_assert(offsetof(FTraversalIconData, Visibility) == 0x000000, "Member 'FTraversalIconData::Visibility' has a wrong offset!");
static_assert(offsetof(FTraversalIconData, Size) == 0x000001, "Member 'FTraversalIconData::Size' has a wrong offset!");
static_assert(offsetof(FTraversalIconData, ScaleMultiplier) == 0x000004, "Member 'FTraversalIconData::ScaleMultiplier' has a wrong offset!");
static_assert(offsetof(FTraversalIconData, VisualizationData) == 0x000008, "Member 'FTraversalIconData::VisualizationData' has a wrong offset!");
static_assert(offsetof(FTraversalIconData, SizeData) == 0x000068, "Member 'FTraversalIconData::SizeData' has a wrong offset!");

// ScriptStruct SHProto.StruggleInputData
// 0x0002 (0x0002 - 0x0000)
struct FStruggleInputData final
{
public:
	EStruggleInputVisibility                      Visibility;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStruggleInputSize                            Size;                                              // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStruggleInputData) == 0x000001, "Wrong alignment on FStruggleInputData");
static_assert(sizeof(FStruggleInputData) == 0x000002, "Wrong size on FStruggleInputData");
static_assert(offsetof(FStruggleInputData, Visibility) == 0x000000, "Member 'FStruggleInputData::Visibility' has a wrong offset!");
static_assert(offsetof(FStruggleInputData, Size) == 0x000001, "Member 'FStruggleInputData::Size' has a wrong offset!");

// ScriptStruct SHProto.SHSlideSnapOperation
// 0x00B8 (0x00B8 - 0x0000)
struct alignas(0x08) FSHSlideSnapOperation final
{
public:
	uint8                                         Pad_0[0xB8];                                       // 0x0000(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHSlideSnapOperation) == 0x000008, "Wrong alignment on FSHSlideSnapOperation");
static_assert(sizeof(FSHSlideSnapOperation) == 0x0000B8, "Wrong size on FSHSlideSnapOperation");

// ScriptStruct SHProto.SHSpawnpointItemsDataSet
// 0x0040 (0x0040 - 0x0000)
struct FSHSpawnpointItemsDataSet final
{
public:
	class FString                                 SpawnPointName;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSHItemAndQuantityHandle>       CummulativeItems;                                  // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSHItemAndQuantityHandle>       RemoveFromCummulativeItems;                        // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSHItemAndQuantityHandle>       ThisSpawnpointOnlyItems;                           // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHSpawnpointItemsDataSet) == 0x000008, "Wrong alignment on FSHSpawnpointItemsDataSet");
static_assert(sizeof(FSHSpawnpointItemsDataSet) == 0x000040, "Wrong size on FSHSpawnpointItemsDataSet");
static_assert(offsetof(FSHSpawnpointItemsDataSet, SpawnPointName) == 0x000000, "Member 'FSHSpawnpointItemsDataSet::SpawnPointName' has a wrong offset!");
static_assert(offsetof(FSHSpawnpointItemsDataSet, CummulativeItems) == 0x000010, "Member 'FSHSpawnpointItemsDataSet::CummulativeItems' has a wrong offset!");
static_assert(offsetof(FSHSpawnpointItemsDataSet, RemoveFromCummulativeItems) == 0x000020, "Member 'FSHSpawnpointItemsDataSet::RemoveFromCummulativeItems' has a wrong offset!");
static_assert(offsetof(FSHSpawnpointItemsDataSet, ThisSpawnpointOnlyItems) == 0x000030, "Member 'FSHSpawnpointItemsDataSet::ThisSpawnpointOnlyItems' has a wrong offset!");

// ScriptStruct SHProto.SHSpawnpointTutorialsDataSet
// 0x0040 (0x0040 - 0x0000)
struct FSHSpawnpointTutorialsDataSet final
{
public:
	class FString                                 SpawnPointName;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ESHGameplayTutorialEnum>               CummulativeTutorials;                              // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ESHGameplayTutorialEnum>               RemoveFromCummulativeTutorials;                    // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ESHGameplayTutorialEnum>               ThisSpawnpointOnlyTutorials;                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSHSpawnpointTutorialsDataSet) == 0x000008, "Wrong alignment on FSHSpawnpointTutorialsDataSet");
static_assert(sizeof(FSHSpawnpointTutorialsDataSet) == 0x000040, "Wrong size on FSHSpawnpointTutorialsDataSet");
static_assert(offsetof(FSHSpawnpointTutorialsDataSet, SpawnPointName) == 0x000000, "Member 'FSHSpawnpointTutorialsDataSet::SpawnPointName' has a wrong offset!");
static_assert(offsetof(FSHSpawnpointTutorialsDataSet, CummulativeTutorials) == 0x000010, "Member 'FSHSpawnpointTutorialsDataSet::CummulativeTutorials' has a wrong offset!");
static_assert(offsetof(FSHSpawnpointTutorialsDataSet, RemoveFromCummulativeTutorials) == 0x000020, "Member 'FSHSpawnpointTutorialsDataSet::RemoveFromCummulativeTutorials' has a wrong offset!");
static_assert(offsetof(FSHSpawnpointTutorialsDataSet, ThisSpawnpointOnlyTutorials) == 0x000030, "Member 'FSHSpawnpointTutorialsDataSet::ThisSpawnpointOnlyTutorials' has a wrong offset!");

// ScriptStruct SHProto.SHTraversalDataConfig
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x10) FSHTraversalDataConfig final
{
public:
	uint8                                         Pad_0[0xB0];                                       // 0x0000(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHTraversalDataConfig) == 0x000010, "Wrong alignment on FSHTraversalDataConfig");
static_assert(sizeof(FSHTraversalDataConfig) == 0x0000B0, "Wrong size on FSHTraversalDataConfig");

// ScriptStruct SHProto.SHViewLookOperation
// 0x00F0 (0x00F0 - 0x0000)
struct FSHViewLookOperation final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USHOperationEvents*                     OperationEvents;                                   // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSHViewLookOperationSettings           CurrentSettings;                                   // 0x0010(0x0038)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0xA8];                                      // 0x0048(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHViewLookOperation) == 0x000008, "Wrong alignment on FSHViewLookOperation");
static_assert(sizeof(FSHViewLookOperation) == 0x0000F0, "Wrong size on FSHViewLookOperation");
static_assert(offsetof(FSHViewLookOperation, OperationEvents) == 0x000008, "Member 'FSHViewLookOperation::OperationEvents' has a wrong offset!");
static_assert(offsetof(FSHViewLookOperation, CurrentSettings) == 0x000010, "Member 'FSHViewLookOperation::CurrentSettings' has a wrong offset!");

// ScriptStruct SHProto.SHXWaterIntersection
// 0x0040 (0x0040 - 0x0000)
struct FSHXWaterIntersection final
{
public:
	struct FVector                                WorldLoc;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Velocity;                                          // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESimulatedWaterEffectType                     EffectType;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSHXWaterIntersection) == 0x000008, "Wrong alignment on FSHXWaterIntersection");
static_assert(sizeof(FSHXWaterIntersection) == 0x000040, "Wrong size on FSHXWaterIntersection");
static_assert(offsetof(FSHXWaterIntersection, WorldLoc) == 0x000000, "Member 'FSHXWaterIntersection::WorldLoc' has a wrong offset!");
static_assert(offsetof(FSHXWaterIntersection, Radius) == 0x000018, "Member 'FSHXWaterIntersection::Radius' has a wrong offset!");
static_assert(offsetof(FSHXWaterIntersection, Velocity) == 0x000020, "Member 'FSHXWaterIntersection::Velocity' has a wrong offset!");
static_assert(offsetof(FSHXWaterIntersection, EffectType) == 0x000038, "Member 'FSHXWaterIntersection::EffectType' has a wrong offset!");

// ScriptStruct SHProto.BoneHierarchyData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FBoneHierarchyData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoneHierarchyData) == 0x000004, "Wrong alignment on FBoneHierarchyData");
static_assert(sizeof(FBoneHierarchyData) == 0x00000C, "Wrong size on FBoneHierarchyData");

// ScriptStruct SHProto.SkeletonBoneForHierarchy
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FSkeletonBoneForHierarchy final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkeletonBoneForHierarchy) == 0x000008, "Wrong alignment on FSkeletonBoneForHierarchy");
static_assert(sizeof(FSkeletonBoneForHierarchy) == 0x000028, "Wrong size on FSkeletonBoneForHierarchy");

// ScriptStruct SHProto.BoneRagdoll
// 0x0008 (0x0008 - 0x0000)
struct FBoneRagdoll final
{
public:
	EBones                                        bone;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideSettings;                                 // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendPhysicTargetScale;                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoneRagdoll) == 0x000004, "Wrong alignment on FBoneRagdoll");
static_assert(sizeof(FBoneRagdoll) == 0x000008, "Wrong size on FBoneRagdoll");
static_assert(offsetof(FBoneRagdoll, bone) == 0x000000, "Member 'FBoneRagdoll::bone' has a wrong offset!");
static_assert(offsetof(FBoneRagdoll, bOverrideSettings) == 0x000001, "Member 'FBoneRagdoll::bOverrideSettings' has a wrong offset!");
static_assert(offsetof(FBoneRagdoll, BlendPhysicTargetScale) == 0x000004, "Member 'FBoneRagdoll::BlendPhysicTargetScale' has a wrong offset!");

// ScriptStruct SHProto.SkeletonRagdollProfileData
// 0x0050 (0x0050 - 0x0000)
struct FSkeletonRagdollProfileData final
{
public:
	ERagdollProfileName                           Name;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConstraintProfile;                                 // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendPhysicTarget;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendPhysicInterpSpeed;                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BlendCurve;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInfinitTime;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeOfBlend;                                       // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecificBones;                                    // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBoneRagdoll>                   Bones;                                             // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         WeightImpact;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightImpactDamping;                               // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParentLevelImpact;                                 // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParentLevelDamping;                                // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkeletonRagdollProfileData) == 0x000008, "Wrong alignment on FSkeletonRagdollProfileData");
static_assert(sizeof(FSkeletonRagdollProfileData) == 0x000050, "Wrong size on FSkeletonRagdollProfileData");
static_assert(offsetof(FSkeletonRagdollProfileData, Name) == 0x000000, "Member 'FSkeletonRagdollProfileData::Name' has a wrong offset!");
static_assert(offsetof(FSkeletonRagdollProfileData, ConstraintProfile) == 0x000004, "Member 'FSkeletonRagdollProfileData::ConstraintProfile' has a wrong offset!");
static_assert(offsetof(FSkeletonRagdollProfileData, BlendPhysicTarget) == 0x00000C, "Member 'FSkeletonRagdollProfileData::BlendPhysicTarget' has a wrong offset!");
static_assert(offsetof(FSkeletonRagdollProfileData, BlendPhysicInterpSpeed) == 0x000010, "Member 'FSkeletonRagdollProfileData::BlendPhysicInterpSpeed' has a wrong offset!");
static_assert(offsetof(FSkeletonRagdollProfileData, BlendCurve) == 0x000018, "Member 'FSkeletonRagdollProfileData::BlendCurve' has a wrong offset!");
static_assert(offsetof(FSkeletonRagdollProfileData, bInfinitTime) == 0x000020, "Member 'FSkeletonRagdollProfileData::bInfinitTime' has a wrong offset!");
static_assert(offsetof(FSkeletonRagdollProfileData, TimeOfBlend) == 0x000024, "Member 'FSkeletonRagdollProfileData::TimeOfBlend' has a wrong offset!");
static_assert(offsetof(FSkeletonRagdollProfileData, Priority) == 0x000028, "Member 'FSkeletonRagdollProfileData::Priority' has a wrong offset!");
static_assert(offsetof(FSkeletonRagdollProfileData, bSpecificBones) == 0x00002C, "Member 'FSkeletonRagdollProfileData::bSpecificBones' has a wrong offset!");
static_assert(offsetof(FSkeletonRagdollProfileData, Bones) == 0x000030, "Member 'FSkeletonRagdollProfileData::Bones' has a wrong offset!");
static_assert(offsetof(FSkeletonRagdollProfileData, WeightImpact) == 0x000040, "Member 'FSkeletonRagdollProfileData::WeightImpact' has a wrong offset!");
static_assert(offsetof(FSkeletonRagdollProfileData, WeightImpactDamping) == 0x000044, "Member 'FSkeletonRagdollProfileData::WeightImpactDamping' has a wrong offset!");
static_assert(offsetof(FSkeletonRagdollProfileData, ParentLevelImpact) == 0x000048, "Member 'FSkeletonRagdollProfileData::ParentLevelImpact' has a wrong offset!");
static_assert(offsetof(FSkeletonRagdollProfileData, ParentLevelDamping) == 0x00004C, "Member 'FSkeletonRagdollProfileData::ParentLevelDamping' has a wrong offset!");

}

