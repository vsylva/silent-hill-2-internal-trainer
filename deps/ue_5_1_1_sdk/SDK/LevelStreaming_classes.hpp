#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: LevelStreaming

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "LevelStreaming_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "UMG_classes.hpp"
#include "InputCore_structs.hpp"


namespace SDK
{

// Class LevelStreaming.LevelStreamingManagerProvider
// 0x0000 (0x0028 - 0x0028)
class ILevelStreamingManagerProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingManagerProvider">();
	}
	static class ILevelStreamingManagerProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILevelStreamingManagerProvider>();
	}
};
static_assert(alignof(ILevelStreamingManagerProvider) == 0x000008, "Wrong alignment on ILevelStreamingManagerProvider");
static_assert(sizeof(ILevelStreamingManagerProvider) == 0x000028, "Wrong size on ILevelStreamingManagerProvider");

// Class LevelStreaming.LevelStreamingActorSerializer
// 0x0000 (0x0028 - 0x0028)
class ULevelStreamingActorSerializer : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingActorSerializer">();
	}
	static class ULevelStreamingActorSerializer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingActorSerializer>();
	}
};
static_assert(alignof(ULevelStreamingActorSerializer) == 0x000008, "Wrong alignment on ULevelStreamingActorSerializer");
static_assert(sizeof(ULevelStreamingActorSerializer) == 0x000028, "Wrong size on ULevelStreamingActorSerializer");

// Class LevelStreaming.LevelStreamingActorSerializerDefault
// 0x0240 (0x0268 - 0x0028)
class ULevelStreamingActorSerializerDefault : public ULevelStreamingActorSerializer
{
public:
	uint8                                         Pad_28[0x240];                                     // 0x0028(0x0240)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DynamicActorOnBeginPlay(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingActorSerializerDefault">();
	}
	static class ULevelStreamingActorSerializerDefault* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingActorSerializerDefault>();
	}
};
static_assert(alignof(ULevelStreamingActorSerializerDefault) == 0x000008, "Wrong alignment on ULevelStreamingActorSerializerDefault");
static_assert(sizeof(ULevelStreamingActorSerializerDefault) == 0x000268, "Wrong size on ULevelStreamingActorSerializerDefault");

// Class LevelStreaming.LevelStreamingDatabase
// 0x01A0 (0x01C8 - 0x0028)
class ULevelStreamingDatabase final : public UObject
{
public:
	TArray<class UStreamableLevels*>              StreamableLevels;                                  // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UStreamableLevelState*>          Levels;                                            // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UStreamableLevelBatchState*>     Batches;                                           // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ULevelStreamingRequestState*>    Requests;                                          // 0x0058(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class ULevelStreamingActorSerializer*         ActorSerializer;                                   // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FLevelStreamingActorData>       Actors;                                            // 0x0070(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FLevelStreamingRuntimeActorData> RuntimeActors;                                     // 0x0080(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          IsUsingActorSerializer;                            // 0x0090(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_91[0x137];                                     // 0x0091(0x0137)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingDatabase">();
	}
	static class ULevelStreamingDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingDatabase>();
	}
};
static_assert(alignof(ULevelStreamingDatabase) == 0x000008, "Wrong alignment on ULevelStreamingDatabase");
static_assert(sizeof(ULevelStreamingDatabase) == 0x0001C8, "Wrong size on ULevelStreamingDatabase");
static_assert(offsetof(ULevelStreamingDatabase, StreamableLevels) == 0x000028, "Member 'ULevelStreamingDatabase::StreamableLevels' has a wrong offset!");
static_assert(offsetof(ULevelStreamingDatabase, Levels) == 0x000038, "Member 'ULevelStreamingDatabase::Levels' has a wrong offset!");
static_assert(offsetof(ULevelStreamingDatabase, Batches) == 0x000048, "Member 'ULevelStreamingDatabase::Batches' has a wrong offset!");
static_assert(offsetof(ULevelStreamingDatabase, Requests) == 0x000058, "Member 'ULevelStreamingDatabase::Requests' has a wrong offset!");
static_assert(offsetof(ULevelStreamingDatabase, ActorSerializer) == 0x000068, "Member 'ULevelStreamingDatabase::ActorSerializer' has a wrong offset!");
static_assert(offsetof(ULevelStreamingDatabase, Actors) == 0x000070, "Member 'ULevelStreamingDatabase::Actors' has a wrong offset!");
static_assert(offsetof(ULevelStreamingDatabase, RuntimeActors) == 0x000080, "Member 'ULevelStreamingDatabase::RuntimeActors' has a wrong offset!");
static_assert(offsetof(ULevelStreamingDatabase, IsUsingActorSerializer) == 0x000090, "Member 'ULevelStreamingDatabase::IsUsingActorSerializer' has a wrong offset!");

// Class LevelStreaming.LevelStreamingDataLayerSubsystem
// 0x0008 (0x0038 - 0x0030)
class ULevelStreamingDataLayerSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDataLayerRuntimeStateChanged(class UDataLayerInstance* DataLayer, EDataLayerRuntimeState State);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingDataLayerSubsystem">();
	}
	static class ULevelStreamingDataLayerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingDataLayerSubsystem>();
	}
};
static_assert(alignof(ULevelStreamingDataLayerSubsystem) == 0x000008, "Wrong alignment on ULevelStreamingDataLayerSubsystem");
static_assert(sizeof(ULevelStreamingDataLayerSubsystem) == 0x000038, "Wrong size on ULevelStreamingDataLayerSubsystem");

// Class LevelStreaming.LevelStreamingDebugWidget
// 0x0080 (0x02F8 - 0x0278)
class ULevelStreamingDebugWidget : public UUserWidget
{
public:
	struct FStreamableLevel                       PersistentLevel;                                   // 0x0278(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FStreamableLevelDebugData>      Data;                                              // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnDataRecreated();
	void OnRefreshed();
	struct FLinearColor SelectNextLineColor(const struct FStreamableLevelBatch& PreviousBatch, const struct FStreamableLevelBatch& NextBatch, const struct FLinearColor& CurrentColor, const struct FLinearColor& FirstColor, const struct FLinearColor& SecondColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingDebugWidget">();
	}
	static class ULevelStreamingDebugWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingDebugWidget>();
	}
};
static_assert(alignof(ULevelStreamingDebugWidget) == 0x000008, "Wrong alignment on ULevelStreamingDebugWidget");
static_assert(sizeof(ULevelStreamingDebugWidget) == 0x0002F8, "Wrong size on ULevelStreamingDebugWidget");
static_assert(offsetof(ULevelStreamingDebugWidget, PersistentLevel) == 0x000278, "Member 'ULevelStreamingDebugWidget::PersistentLevel' has a wrong offset!");
static_assert(offsetof(ULevelStreamingDebugWidget, Data) == 0x0002E8, "Member 'ULevelStreamingDebugWidget::Data' has a wrong offset!");

// Class LevelStreaming.LevelStreamingEventsComponent
// 0x00B0 (0x0150 - 0x00A0)
class ULevelStreamingEventsComponent final : public UActorComponent
{
public:
	TArray<struct FStreamableLevelHandle>         ObservedLevels;                                    // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          ObserveCurrentLevel;                               // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStreamableLevelBatchHandle>    ObservedBatches;                                   // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          ObserveCurrentBatch;                               // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          WaitForIdle;                                       // 0x00C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnLevelsChanged;                                   // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnBatchesChanged;                                  // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class ULevelStreamingManager*                 StreamingManager;                                  // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UStreamableLevelState*>          ObservedLevelStates;                               // 0x00F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UStreamableLevelBatchState*>     ObservedBatchStates;                               // 0x0108(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_118[0x38];                                     // 0x0118(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetBatchesStatus(EStreamableLevelStatus* OutStatus);
	bool GetLevelsStatus(EStreamableLevelStatus* OutStatus);
	void StatusChanged__DelegateSignature(class ULevelStreamingEventsComponent* Events, EStreamableLevelStatus Status);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingEventsComponent">();
	}
	static class ULevelStreamingEventsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingEventsComponent>();
	}
};
static_assert(alignof(ULevelStreamingEventsComponent) == 0x000008, "Wrong alignment on ULevelStreamingEventsComponent");
static_assert(sizeof(ULevelStreamingEventsComponent) == 0x000150, "Wrong size on ULevelStreamingEventsComponent");
static_assert(offsetof(ULevelStreamingEventsComponent, ObservedLevels) == 0x0000A0, "Member 'ULevelStreamingEventsComponent::ObservedLevels' has a wrong offset!");
static_assert(offsetof(ULevelStreamingEventsComponent, ObserveCurrentLevel) == 0x0000B0, "Member 'ULevelStreamingEventsComponent::ObserveCurrentLevel' has a wrong offset!");
static_assert(offsetof(ULevelStreamingEventsComponent, ObservedBatches) == 0x0000B8, "Member 'ULevelStreamingEventsComponent::ObservedBatches' has a wrong offset!");
static_assert(offsetof(ULevelStreamingEventsComponent, ObserveCurrentBatch) == 0x0000C8, "Member 'ULevelStreamingEventsComponent::ObserveCurrentBatch' has a wrong offset!");
static_assert(offsetof(ULevelStreamingEventsComponent, WaitForIdle) == 0x0000C9, "Member 'ULevelStreamingEventsComponent::WaitForIdle' has a wrong offset!");
static_assert(offsetof(ULevelStreamingEventsComponent, OnLevelsChanged) == 0x0000D0, "Member 'ULevelStreamingEventsComponent::OnLevelsChanged' has a wrong offset!");
static_assert(offsetof(ULevelStreamingEventsComponent, OnBatchesChanged) == 0x0000E0, "Member 'ULevelStreamingEventsComponent::OnBatchesChanged' has a wrong offset!");
static_assert(offsetof(ULevelStreamingEventsComponent, StreamingManager) == 0x0000F0, "Member 'ULevelStreamingEventsComponent::StreamingManager' has a wrong offset!");
static_assert(offsetof(ULevelStreamingEventsComponent, ObservedLevelStates) == 0x0000F8, "Member 'ULevelStreamingEventsComponent::ObservedLevelStates' has a wrong offset!");
static_assert(offsetof(ULevelStreamingEventsComponent, ObservedBatchStates) == 0x000108, "Member 'ULevelStreamingEventsComponent::ObservedBatchStates' has a wrong offset!");

// Class LevelStreaming.LevelStreamingManager
// 0x01A0 (0x01D0 - 0x0030)
class ULevelStreamingManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStreamableLevels*                      StreamableLevels;                                  // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ULevelStreamingTask*>            Tasks;                                             // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class ULevelStreamingTaskSelector*            TaskSelector;                                      // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelStreamingDatabase*                Database;                                          // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FLevelStreamingSlot>            Slots;                                             // 0x0060(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x18];                                      // 0x0070(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelStreamingDebugWidget*             DebugWidget;                                       // 0x0088(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x140];                                     // 0x0090(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void OnActorEndPlayDynamic(class AActor* Actor, EEndPlayReason EndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingManager">();
	}
	static class ULevelStreamingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingManager>();
	}
};
static_assert(alignof(ULevelStreamingManager) == 0x000008, "Wrong alignment on ULevelStreamingManager");
static_assert(sizeof(ULevelStreamingManager) == 0x0001D0, "Wrong size on ULevelStreamingManager");
static_assert(offsetof(ULevelStreamingManager, StreamableLevels) == 0x000038, "Member 'ULevelStreamingManager::StreamableLevels' has a wrong offset!");
static_assert(offsetof(ULevelStreamingManager, Tasks) == 0x000040, "Member 'ULevelStreamingManager::Tasks' has a wrong offset!");
static_assert(offsetof(ULevelStreamingManager, TaskSelector) == 0x000050, "Member 'ULevelStreamingManager::TaskSelector' has a wrong offset!");
static_assert(offsetof(ULevelStreamingManager, Database) == 0x000058, "Member 'ULevelStreamingManager::Database' has a wrong offset!");
static_assert(offsetof(ULevelStreamingManager, Slots) == 0x000060, "Member 'ULevelStreamingManager::Slots' has a wrong offset!");
static_assert(offsetof(ULevelStreamingManager, DebugWidget) == 0x000088, "Member 'ULevelStreamingManager::DebugWidget' has a wrong offset!");

// Class LevelStreaming.LevelStreamingRequestCollection
// 0x0010 (0x0040 - 0x0030)
class ULevelStreamingRequestCollection final : public UDataAsset
{
public:
	TArray<class ULevelStreamingRequests*>        Requests;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingRequestCollection">();
	}
	static class ULevelStreamingRequestCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingRequestCollection>();
	}
};
static_assert(alignof(ULevelStreamingRequestCollection) == 0x000008, "Wrong alignment on ULevelStreamingRequestCollection");
static_assert(sizeof(ULevelStreamingRequestCollection) == 0x000040, "Wrong size on ULevelStreamingRequestCollection");
static_assert(offsetof(ULevelStreamingRequestCollection, Requests) == 0x000030, "Member 'ULevelStreamingRequestCollection::Requests' has a wrong offset!");

// Class LevelStreaming.LevelStreamingRequests
// 0x0010 (0x0040 - 0x0030)
class ULevelStreamingRequests final : public UDataAsset
{
public:
	TArray<struct FLevelStreamingRequest>         Requests;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingRequests">();
	}
	static class ULevelStreamingRequests* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingRequests>();
	}
};
static_assert(alignof(ULevelStreamingRequests) == 0x000008, "Wrong alignment on ULevelStreamingRequests");
static_assert(sizeof(ULevelStreamingRequests) == 0x000040, "Wrong size on ULevelStreamingRequests");
static_assert(offsetof(ULevelStreamingRequests, Requests) == 0x000030, "Member 'ULevelStreamingRequests::Requests' has a wrong offset!");

// Class LevelStreaming.LevelStreamingRequestState
// 0x0060 (0x0088 - 0x0028)
class ULevelStreamingRequestState final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLevelStreamingRequestBatchState> Batches;                                           // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x18];                                      // 0x0070(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingRequestState">();
	}
	static class ULevelStreamingRequestState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingRequestState>();
	}
};
static_assert(alignof(ULevelStreamingRequestState) == 0x000008, "Wrong alignment on ULevelStreamingRequestState");
static_assert(sizeof(ULevelStreamingRequestState) == 0x000088, "Wrong size on ULevelStreamingRequestState");
static_assert(offsetof(ULevelStreamingRequestState, Batches) == 0x000060, "Member 'ULevelStreamingRequestState::Batches' has a wrong offset!");

// Class LevelStreaming.LevelStreamingSerializationConfig
// 0x0028 (0x00C8 - 0x00A0)
class ULevelStreamingSerializationConfig final : public UActorComponent
{
public:
	bool                                          RestoreActorTransform;                             // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          RestoreActorVisibility;                            // 0x00A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SerializeComponentsOnlyWithSaveGame;               // 0x00A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          RestoreComponentsVisibility;                       // 0x00A3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          RestoreComponentsTransform;                        // 0x00A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SkipTransformRestoreForDetachedComponents;         // 0x00A5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          RestoreActorAttachment;                            // 0x00A6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A7[0x1];                                       // 0x00A7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SkipTransformRestoreForComponents;                 // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         SkipTransformRestoreForComponetsClasses;           // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingSerializationConfig">();
	}
	static class ULevelStreamingSerializationConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingSerializationConfig>();
	}
};
static_assert(alignof(ULevelStreamingSerializationConfig) == 0x000008, "Wrong alignment on ULevelStreamingSerializationConfig");
static_assert(sizeof(ULevelStreamingSerializationConfig) == 0x0000C8, "Wrong size on ULevelStreamingSerializationConfig");
static_assert(offsetof(ULevelStreamingSerializationConfig, RestoreActorTransform) == 0x0000A0, "Member 'ULevelStreamingSerializationConfig::RestoreActorTransform' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSerializationConfig, RestoreActorVisibility) == 0x0000A1, "Member 'ULevelStreamingSerializationConfig::RestoreActorVisibility' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSerializationConfig, SerializeComponentsOnlyWithSaveGame) == 0x0000A2, "Member 'ULevelStreamingSerializationConfig::SerializeComponentsOnlyWithSaveGame' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSerializationConfig, RestoreComponentsVisibility) == 0x0000A3, "Member 'ULevelStreamingSerializationConfig::RestoreComponentsVisibility' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSerializationConfig, RestoreComponentsTransform) == 0x0000A4, "Member 'ULevelStreamingSerializationConfig::RestoreComponentsTransform' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSerializationConfig, SkipTransformRestoreForDetachedComponents) == 0x0000A5, "Member 'ULevelStreamingSerializationConfig::SkipTransformRestoreForDetachedComponents' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSerializationConfig, RestoreActorAttachment) == 0x0000A6, "Member 'ULevelStreamingSerializationConfig::RestoreActorAttachment' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSerializationConfig, SkipTransformRestoreForComponents) == 0x0000A8, "Member 'ULevelStreamingSerializationConfig::SkipTransformRestoreForComponents' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSerializationConfig, SkipTransformRestoreForComponetsClasses) == 0x0000B8, "Member 'ULevelStreamingSerializationConfig::SkipTransformRestoreForComponetsClasses' has a wrong offset!");

// Class LevelStreaming.LevelStreamingSettings
// 0x0130 (0x0168 - 0x0038)
class ULevelStreamingSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UStreamableLevels>       StreamableLevels;                                  // 0x0038(0x0030)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class ULevelStreamingRequestCollection> RequestCollection;                                 // 0x0068(0x0030)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TaskSelectorClass;                                 // 0x0098(0x0030)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ActorSerializerClass;                              // 0x00C8(0x0030)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SerializationConfigClass;                          // 0x00F8(0x0030)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DelayIdleEvents;                                   // 0x0128(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLevelStreamingSlotConfig>      Slots;                                             // 0x0130(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	bool                                          ForceGCWhenLevelsArePendingPurge;                  // 0x0140(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FullPurgeWhenForcingGC;                            // 0x0141(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_142[0x2];                                      // 0x0142(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOfPendingLevelsRequiredForGC;                // 0x0144(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShortestDelayBetweenForcingGC;                     // 0x0148(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULevelStreamingDebugWidget> DebugWidgetClass;                                  // 0x0150(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FKey>                           ShowDebugWidgetKeys;                               // 0x0158(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingSettings">();
	}
	static class ULevelStreamingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingSettings>();
	}
};
static_assert(alignof(ULevelStreamingSettings) == 0x000008, "Wrong alignment on ULevelStreamingSettings");
static_assert(sizeof(ULevelStreamingSettings) == 0x000168, "Wrong size on ULevelStreamingSettings");
static_assert(offsetof(ULevelStreamingSettings, StreamableLevels) == 0x000038, "Member 'ULevelStreamingSettings::StreamableLevels' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSettings, RequestCollection) == 0x000068, "Member 'ULevelStreamingSettings::RequestCollection' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSettings, TaskSelectorClass) == 0x000098, "Member 'ULevelStreamingSettings::TaskSelectorClass' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSettings, ActorSerializerClass) == 0x0000C8, "Member 'ULevelStreamingSettings::ActorSerializerClass' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSettings, SerializationConfigClass) == 0x0000F8, "Member 'ULevelStreamingSettings::SerializationConfigClass' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSettings, DelayIdleEvents) == 0x000128, "Member 'ULevelStreamingSettings::DelayIdleEvents' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSettings, Slots) == 0x000130, "Member 'ULevelStreamingSettings::Slots' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSettings, ForceGCWhenLevelsArePendingPurge) == 0x000140, "Member 'ULevelStreamingSettings::ForceGCWhenLevelsArePendingPurge' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSettings, FullPurgeWhenForcingGC) == 0x000141, "Member 'ULevelStreamingSettings::FullPurgeWhenForcingGC' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSettings, NumberOfPendingLevelsRequiredForGC) == 0x000144, "Member 'ULevelStreamingSettings::NumberOfPendingLevelsRequiredForGC' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSettings, ShortestDelayBetweenForcingGC) == 0x000148, "Member 'ULevelStreamingSettings::ShortestDelayBetweenForcingGC' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSettings, DebugWidgetClass) == 0x000150, "Member 'ULevelStreamingSettings::DebugWidgetClass' has a wrong offset!");
static_assert(offsetof(ULevelStreamingSettings, ShowDebugWidgetKeys) == 0x000158, "Member 'ULevelStreamingSettings::ShowDebugWidgetKeys' has a wrong offset!");

// Class LevelStreaming.LevelStreamingStaticLibrary
// 0x0000 (0x0028 - 0x0028)
class ULevelStreamingStaticLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AreLevelBatchHandlesEqual(const struct FStreamableLevelBatchHandle& A, const struct FStreamableLevelBatchHandle& B);
	static bool AreLevelBatchHandlesNotEqual(const struct FStreamableLevelBatchHandle& A, const struct FStreamableLevelBatchHandle& B);
	static bool AreLevelHandlesEqual(const struct FStreamableLevelHandle& A, const struct FStreamableLevelHandle& B);
	static bool AreLevelHandlesNotEqual(const struct FStreamableLevelHandle& A, const struct FStreamableLevelHandle& B);
	static bool AreRequestHandlesEqual(const struct FLevelStreamingRequestHandle& A, const struct FLevelStreamingRequestHandle& B);
	static bool AreRequestHandlesNotEqual(const struct FLevelStreamingRequestHandle& A, const struct FLevelStreamingRequestHandle& B);
	static void CacheWorldState(class UObject* WorldContextObject);
	static class FString ConvertBatchHandleToString(const struct FStreamableLevelBatchHandle& BatchHandle);
	static void ConvertLevelHandleToLevel(class UObject* WorldContextObject, const struct FStreamableLevelHandle& LevelHandle, struct FStreamableLevel* OutLevel, bool* OutIsValid);
	static class UStreamableLevelState* ConvertLevelHandleToLevelState(class UObject* WorldContextObject, const struct FStreamableLevelHandle& LevelHandle);
	static class FString ConvertLevelHandleToString(const struct FStreamableLevelHandle& LevelHandle);
	static class FString ConvertRequestHandleToString(const struct FLevelStreamingRequestHandle& RequestHandle);
	static class UStreamableLevelBatchState* FindActorBatchState(class UObject* WorldContextObject, class AActor* Actor);
	static class UStreamableLevelState* FindActorLevelState(class UObject* WorldContextObject, class AActor* Actor);
	static TArray<class UStreamableLevelBatchState*> GetAllBatchStates(class UObject* WorldContextObject);
	static TArray<class UStreamableLevelState*> GetAllLevelStates(class UObject* WorldContextObject);
	static void HideStreamedBatch(class UObject* WorldContextObject, const struct FStreamableLevelBatchHandle& BatchHandle, const int32 Priority);
	static void HideStreamedLevel(class UObject* WorldContextObject, const struct FStreamableLevelHandle& LevelHandle, const int32 Priority);
	static bool IsActorBatchLoadedVisible(class UObject* WorldContextObject, class AActor* Actor);
	static void RemoveRuntimeActorFromDatabase(class UObject* WorldContextObject, class AActor* Actor);
	static void ResetStreamedBatchTransform(class UObject* WorldContextObject, const struct FStreamableLevelBatchHandle& BatchHandle);
	static void ResetStreamedLevelTransform(class UObject* WorldContextObject, const struct FStreamableLevelHandle& LevelHandle);
	static void SetStreamedBatchTransform(class UObject* WorldContextObject, const struct FStreamableLevelBatchHandle& BatchHandle, const struct FTransform& Transform, const TSoftObjectPtr<class AActor> Pivot);
	static void SetStreamedLevelTransform(class UObject* WorldContextObject, const struct FStreamableLevelHandle& LevelHandle, const struct FTransform& Transform, const TSoftObjectPtr<class AActor> Pivot);
	static void SetStreamingIntegrationSpeed(const class UObject* WorldContextObject, EStreamingIntegrationSpeed Speed);
	static void ShowStreamedBatch(class UObject* WorldContextObject, const struct FStreamableLevelBatchHandle& BatchHandle, const bool LoadIfUnloaded, const int32 Priority);
	static void ShowStreamedLevel(class UObject* WorldContextObject, const struct FStreamableLevelHandle& LevelHandle, const bool LoadIfUnloaded, const int32 Priority);
	static void StartBatchStreaming(class UObject* WorldContextObject, const struct FStreamableLevelBatchHandle& BatchHandle, const bool MakeVisible, const int32 Priority);
	static void StartLevelStreaming(class UObject* WorldContextObject, const struct FStreamableLevelHandle& LevelHandle, const bool MakeVisible, const int32 Priority);
	static class ULevelStreamingRequestState* SubmitRequest(class UObject* WorldContextObject, const struct FLevelStreamingRequestHandle& RequestHandle);
	static void TravelToLevel(class UObject* WorldContextObject, const struct FStreamableLevelHandle& LevelHandle);
	static void UnloadStreamedBatch(class UObject* WorldContextObject, const struct FStreamableLevelBatchHandle& BatchHandle, const int32 Priority);
	static void UnloadStreamedLevel(class UObject* WorldContextObject, const struct FStreamableLevelHandle& LevelHandle, const int32 Priority);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingStaticLibrary">();
	}
	static class ULevelStreamingStaticLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingStaticLibrary>();
	}
};
static_assert(alignof(ULevelStreamingStaticLibrary) == 0x000008, "Wrong alignment on ULevelStreamingStaticLibrary");
static_assert(sizeof(ULevelStreamingStaticLibrary) == 0x000028, "Wrong size on ULevelStreamingStaticLibrary");

// Class LevelStreaming.LevelStreamingTask
// 0x0118 (0x0140 - 0x0028)
class alignas(0x10) ULevelStreamingTask final : public UObject
{
public:
	class UStreamableLevelState*                  State;                                             // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x110];                                     // 0x0030(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingTask">();
	}
	static class ULevelStreamingTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingTask>();
	}
};
static_assert(alignof(ULevelStreamingTask) == 0x000010, "Wrong alignment on ULevelStreamingTask");
static_assert(sizeof(ULevelStreamingTask) == 0x000140, "Wrong size on ULevelStreamingTask");
static_assert(offsetof(ULevelStreamingTask, State) == 0x000028, "Member 'ULevelStreamingTask::State' has a wrong offset!");

// Class LevelStreaming.LevelStreamingTaskSelector
// 0x0000 (0x0028 - 0x0028)
class ULevelStreamingTaskSelector : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingTaskSelector">();
	}
	static class ULevelStreamingTaskSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingTaskSelector>();
	}
};
static_assert(alignof(ULevelStreamingTaskSelector) == 0x000008, "Wrong alignment on ULevelStreamingTaskSelector");
static_assert(sizeof(ULevelStreamingTaskSelector) == 0x000028, "Wrong size on ULevelStreamingTaskSelector");

// Class LevelStreaming.LevelStreamingTaskSelectorDefault
// 0x0010 (0x0038 - 0x0028)
class ULevelStreamingTaskSelectorDefault final : public ULevelStreamingTaskSelector
{
public:
	int32                                         ShowPriority;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HidePriority;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoadingPriority;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnloadingPriority;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingTaskSelectorDefault">();
	}
	static class ULevelStreamingTaskSelectorDefault* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingTaskSelectorDefault>();
	}
};
static_assert(alignof(ULevelStreamingTaskSelectorDefault) == 0x000008, "Wrong alignment on ULevelStreamingTaskSelectorDefault");
static_assert(sizeof(ULevelStreamingTaskSelectorDefault) == 0x000038, "Wrong size on ULevelStreamingTaskSelectorDefault");
static_assert(offsetof(ULevelStreamingTaskSelectorDefault, ShowPriority) == 0x000028, "Member 'ULevelStreamingTaskSelectorDefault::ShowPriority' has a wrong offset!");
static_assert(offsetof(ULevelStreamingTaskSelectorDefault, HidePriority) == 0x00002C, "Member 'ULevelStreamingTaskSelectorDefault::HidePriority' has a wrong offset!");
static_assert(offsetof(ULevelStreamingTaskSelectorDefault, LoadingPriority) == 0x000030, "Member 'ULevelStreamingTaskSelectorDefault::LoadingPriority' has a wrong offset!");
static_assert(offsetof(ULevelStreamingTaskSelectorDefault, UnloadingPriority) == 0x000034, "Member 'ULevelStreamingTaskSelectorDefault::UnloadingPriority' has a wrong offset!");

// Class LevelStreaming.StreamableLevelBatchConfig
// 0x0070 (0x00A0 - 0x0030)
class UStreamableLevelBatchConfig final : public UDataAsset
{
public:
	struct FStreamableLevelBatchHandle            Batch;                                             // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BatchTransform;                                    // 0x0040(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StreamableLevelBatchConfig">();
	}
	static class UStreamableLevelBatchConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStreamableLevelBatchConfig>();
	}
};
static_assert(alignof(UStreamableLevelBatchConfig) == 0x000010, "Wrong alignment on UStreamableLevelBatchConfig");
static_assert(sizeof(UStreamableLevelBatchConfig) == 0x0000A0, "Wrong size on UStreamableLevelBatchConfig");
static_assert(offsetof(UStreamableLevelBatchConfig, Batch) == 0x000030, "Member 'UStreamableLevelBatchConfig::Batch' has a wrong offset!");
static_assert(offsetof(UStreamableLevelBatchConfig, BatchTransform) == 0x000040, "Member 'UStreamableLevelBatchConfig::BatchTransform' has a wrong offset!");

// Class LevelStreaming.StreamableLevelBatchState
// 0x0070 (0x0098 - 0x0028)
class UStreamableLevelBatchState final : public UObject
{
public:
	struct FStreamableLevelBatch                  Batch;                                             // 0x0028(0x0048)(NativeAccessSpecifierPrivate)
	TArray<class UStreamableLevelState*>          Levels;                                            // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x18];                                      // 0x0080(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StreamableLevelBatchState">();
	}
	static class UStreamableLevelBatchState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStreamableLevelBatchState>();
	}
};
static_assert(alignof(UStreamableLevelBatchState) == 0x000008, "Wrong alignment on UStreamableLevelBatchState");
static_assert(sizeof(UStreamableLevelBatchState) == 0x000098, "Wrong size on UStreamableLevelBatchState");
static_assert(offsetof(UStreamableLevelBatchState, Batch) == 0x000028, "Member 'UStreamableLevelBatchState::Batch' has a wrong offset!");
static_assert(offsetof(UStreamableLevelBatchState, Levels) == 0x000070, "Member 'UStreamableLevelBatchState::Levels' has a wrong offset!");

// Class LevelStreaming.StreamableLevelConfig
// 0x0070 (0x00A0 - 0x0030)
class UStreamableLevelConfig final : public UDataAsset
{
public:
	struct FStreamableLevelHandle                 Level;                                             // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LevelTransform;                                    // 0x0040(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StreamableLevelConfig">();
	}
	static class UStreamableLevelConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStreamableLevelConfig>();
	}
};
static_assert(alignof(UStreamableLevelConfig) == 0x000010, "Wrong alignment on UStreamableLevelConfig");
static_assert(sizeof(UStreamableLevelConfig) == 0x0000A0, "Wrong size on UStreamableLevelConfig");
static_assert(offsetof(UStreamableLevelConfig, Level) == 0x000030, "Member 'UStreamableLevelConfig::Level' has a wrong offset!");
static_assert(offsetof(UStreamableLevelConfig, LevelTransform) == 0x000040, "Member 'UStreamableLevelConfig::LevelTransform' has a wrong offset!");

// Class LevelStreaming.StreamableLevels
// 0x0068 (0x0098 - 0x0030)
class UStreamableLevels final : public UDataAsset
{
public:
	TArray<struct FDirectoryPath>                 AllowedDirectories;                                // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UWorld>>          WhitelistedLevels;                                 // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UWorld>>          BlacklistedLevels;                                 // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FStreamableLevel>               Levels;                                            // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FStreamableLevelBatch>          Batches;                                           // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          RestrictBatchPostfixes;                            // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         AllowedBatchPostfixes;                             // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StreamableLevels">();
	}
	static class UStreamableLevels* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStreamableLevels>();
	}
};
static_assert(alignof(UStreamableLevels) == 0x000008, "Wrong alignment on UStreamableLevels");
static_assert(sizeof(UStreamableLevels) == 0x000098, "Wrong size on UStreamableLevels");
static_assert(offsetof(UStreamableLevels, AllowedDirectories) == 0x000030, "Member 'UStreamableLevels::AllowedDirectories' has a wrong offset!");
static_assert(offsetof(UStreamableLevels, WhitelistedLevels) == 0x000040, "Member 'UStreamableLevels::WhitelistedLevels' has a wrong offset!");
static_assert(offsetof(UStreamableLevels, BlacklistedLevels) == 0x000050, "Member 'UStreamableLevels::BlacklistedLevels' has a wrong offset!");
static_assert(offsetof(UStreamableLevels, Levels) == 0x000060, "Member 'UStreamableLevels::Levels' has a wrong offset!");
static_assert(offsetof(UStreamableLevels, Batches) == 0x000070, "Member 'UStreamableLevels::Batches' has a wrong offset!");
static_assert(offsetof(UStreamableLevels, RestrictBatchPostfixes) == 0x000080, "Member 'UStreamableLevels::RestrictBatchPostfixes' has a wrong offset!");
static_assert(offsetof(UStreamableLevels, AllowedBatchPostfixes) == 0x000088, "Member 'UStreamableLevels::AllowedBatchPostfixes' has a wrong offset!");

// Class LevelStreaming.StreamableLevelState
// 0x01B8 (0x01E0 - 0x0028)
class alignas(0x10) UStreamableLevelState final : public UObject
{
public:
	struct FStreamableLevel                       Level;                                             // 0x0028(0x0070)(NativeAccessSpecifierPrivate)
	class ULevelStreaming*                        LevelStreaming;                                    // 0x0098(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UStreamableLevelState*>          Sublevels;                                         // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	EStreamableLevelStatus                        Status;                                            // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          StreamingCallbacksBound;                           // 0x00B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B2[0x12E];                                     // 0x00B2(0x012E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UStreamableLevelBatchState* GetBatch();
	class UStreamableLevelConfig* GetConfig();
	class ULevelStreaming* GetLevelStreaming();
	void HandleLevelHidden();
	void HandleLevelLoaded();
	void HandleLevelShown();
	void HandleLevelUnloaded();

	const struct FStreamableLevel GetLevel() const;
	struct FStreamableLevelHandle GetLevelHandle() const;
	class FName GetLevelName() const;
	const class FString GetLevelNameAsString() const;
	class FName GetLevelPath() const;
	class FString GetLevelPathAsString() const;
	EStreamableLevelType GetLevelType() const;
	EStreamableLevelStatus GetStatus() const;
	const TArray<class UStreamableLevelState*> GetSublevels() const;
	bool HasBatch() const;
	bool HasLevelConfig() const;
	bool HasLevelStreaming() const;
	bool IsHidden() const;
	bool IsLoaded() const;
	bool IsUnloaded() const;
	bool IsVisible() const;
	bool ShouldBeAlwaysLoaded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StreamableLevelState">();
	}
	static class UStreamableLevelState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStreamableLevelState>();
	}
};
static_assert(alignof(UStreamableLevelState) == 0x000010, "Wrong alignment on UStreamableLevelState");
static_assert(sizeof(UStreamableLevelState) == 0x0001E0, "Wrong size on UStreamableLevelState");
static_assert(offsetof(UStreamableLevelState, Level) == 0x000028, "Member 'UStreamableLevelState::Level' has a wrong offset!");
static_assert(offsetof(UStreamableLevelState, LevelStreaming) == 0x000098, "Member 'UStreamableLevelState::LevelStreaming' has a wrong offset!");
static_assert(offsetof(UStreamableLevelState, Sublevels) == 0x0000A0, "Member 'UStreamableLevelState::Sublevels' has a wrong offset!");
static_assert(offsetof(UStreamableLevelState, Status) == 0x0000B0, "Member 'UStreamableLevelState::Status' has a wrong offset!");
static_assert(offsetof(UStreamableLevelState, StreamingCallbacksBound) == 0x0000B1, "Member 'UStreamableLevelState::StreamingCallbacksBound' has a wrong offset!");

// Class LevelStreaming.StreamingVolume
// 0x0040 (0x0328 - 0x02E8)
class AStreamingVolume final : public AVolume
{
public:
	class UBoxComponent*                          PreloadBox;                                        // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnablePreload;                                    // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStreamableLevelBatchHandle>    Requests;                                          // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x20];                                     // 0x0308(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UStreamingVolumeManager* GetStreamingVolumeManager();
	void SetEnable(const bool Enable, const class UObject* Object);

	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StreamingVolume">();
	}
	static class AStreamingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStreamingVolume>();
	}
};
static_assert(alignof(AStreamingVolume) == 0x000008, "Wrong alignment on AStreamingVolume");
static_assert(sizeof(AStreamingVolume) == 0x000328, "Wrong size on AStreamingVolume");
static_assert(offsetof(AStreamingVolume, PreloadBox) == 0x0002E8, "Member 'AStreamingVolume::PreloadBox' has a wrong offset!");
static_assert(offsetof(AStreamingVolume, bEnablePreload) == 0x0002F0, "Member 'AStreamingVolume::bEnablePreload' has a wrong offset!");
static_assert(offsetof(AStreamingVolume, Requests) == 0x0002F8, "Member 'AStreamingVolume::Requests' has a wrong offset!");

// Class LevelStreaming.StreamingVolumeManager
// 0x0090 (0x00C0 - 0x0030)
class UStreamingVolumeManager final : public ULocalPlayerSubsystem
{
public:
	float                                         ShownBeforeHideTime;                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HiddenBeforeUnloadTime;                            // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AStreamingVolume*>               RegisteredVolumes;                                 // 0x0038(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FManagedStreamableLevelBatchHandle> ManagedBatches;                                    // 0x0048(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x68];                                      // 0x0058(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StreamingVolumeManager_DebugInstantMode();
	void StreamingVolumeManager_DrawSingle_IndexVolume(int32 InVolumeIndexToDraw);
	void StreamingVolumeManager_DrawSingle_NextVolume();
	void StreamingVolumeManager_DrawSingle_PreviousVolume();
	void StreamingVolumeManager_DrawSingleDebug();
	void StreamingVolumeManager_DrawSmartDebug();
	void StreamingVolumeManager_PrintDebug();
	void StreamingVolumeManager_TestEnable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StreamingVolumeManager">();
	}
	static class UStreamingVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStreamingVolumeManager>();
	}
};
static_assert(alignof(UStreamingVolumeManager) == 0x000008, "Wrong alignment on UStreamingVolumeManager");
static_assert(sizeof(UStreamingVolumeManager) == 0x0000C0, "Wrong size on UStreamingVolumeManager");
static_assert(offsetof(UStreamingVolumeManager, ShownBeforeHideTime) == 0x000030, "Member 'UStreamingVolumeManager::ShownBeforeHideTime' has a wrong offset!");
static_assert(offsetof(UStreamingVolumeManager, HiddenBeforeUnloadTime) == 0x000034, "Member 'UStreamingVolumeManager::HiddenBeforeUnloadTime' has a wrong offset!");
static_assert(offsetof(UStreamingVolumeManager, RegisteredVolumes) == 0x000038, "Member 'UStreamingVolumeManager::RegisteredVolumes' has a wrong offset!");
static_assert(offsetof(UStreamingVolumeManager, ManagedBatches) == 0x000048, "Member 'UStreamingVolumeManager::ManagedBatches' has a wrong offset!");

}

