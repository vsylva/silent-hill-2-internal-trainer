#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SHProto

#include "Basic.hpp"

#include "Mai_structs.hpp"
#include "Mai_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "UCSW_structs.hpp"
#include "UCSW_classes.hpp"
#include "UCCE_structs.hpp"
#include "UCW_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "SHProto_structs.hpp"
#include "Dialog_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "NiagaraAnimNotifies_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "AIModule_classes.hpp"
#include "GameBase_structs.hpp"
#include "GameBase_classes.hpp"
#include "Niagara_classes.hpp"
#include "Foliage_classes.hpp"
#include "Being_structs.hpp"
#include "Being_classes.hpp"
#include "BlooberWwise_classes.hpp"
#include "AkAudio_structs.hpp"
#include "UMG_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "LevelSequence_classes.hpp"
#include "UCA_structs.hpp"
#include "CinematicCamera_classes.hpp"
#include "InputRebinding_structs.hpp"
#include "TemplateSequence_classes.hpp"
#include "SlateCore_structs.hpp"
#include "Cutscenes_classes.hpp"
#include "InputCore_structs.hpp"
#include "Commons_structs.hpp"
#include "Commons_classes.hpp"
#include "GeometryCollectionEngine_classes.hpp"
#include "SimpleSpawnPoints_structs.hpp"
#include "SimpleSpawnPoints_classes.hpp"
#include "Player_structs.hpp"
#include "Player_classes.hpp"
#include "PostProcessVolumeEx_classes.hpp"
#include "Detection_classes.hpp"


namespace SDK
{

// Class SHProto.SHAnimNotify_AIWeaponEquip
// 0x0000 (0x0038 - 0x0038)
class USHAnimNotify_AIWeaponEquip final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_AIWeaponEquip">();
	}
	static class USHAnimNotify_AIWeaponEquip* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_AIWeaponEquip>();
	}
};
static_assert(alignof(USHAnimNotify_AIWeaponEquip) == 0x000008, "Wrong alignment on USHAnimNotify_AIWeaponEquip");
static_assert(sizeof(USHAnimNotify_AIWeaponEquip) == 0x000038, "Wrong size on USHAnimNotify_AIWeaponEquip");

// Class SHProto.SHAnimNotify_IKPelvisEnable
// 0x0008 (0x0040 - 0x0038)
class USHAnimNotify_IKPelvisEnable final : public UAnimNotify
{
public:
	float                                         InterpSpeed;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_IKPelvisEnable">();
	}
	static class USHAnimNotify_IKPelvisEnable* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_IKPelvisEnable>();
	}
};
static_assert(alignof(USHAnimNotify_IKPelvisEnable) == 0x000008, "Wrong alignment on USHAnimNotify_IKPelvisEnable");
static_assert(sizeof(USHAnimNotify_IKPelvisEnable) == 0x000040, "Wrong size on USHAnimNotify_IKPelvisEnable");
static_assert(offsetof(USHAnimNotify_IKPelvisEnable, InterpSpeed) == 0x000038, "Member 'USHAnimNotify_IKPelvisEnable::InterpSpeed' has a wrong offset!");

// Class SHProto.SHCineCameraActor
// 0x0010 (0x0A70 - 0x0A60)
class ASHCineCameraActor final : public ACineCameraActor
{
public:
	uint8                                         Pad_A60[0x10];                                     // 0x0A60(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USHCineCameraComponent* GetSHCineCameraComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCineCameraActor">();
	}
	static class ASHCineCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHCineCameraActor>();
	}
};
static_assert(alignof(ASHCineCameraActor) == 0x000010, "Wrong alignment on ASHCineCameraActor");
static_assert(sizeof(ASHCineCameraActor) == 0x000A70, "Wrong size on ASHCineCameraActor");

// Class SHProto.AmbientSpotLight
// 0x0000 (0x02C8 - 0x02C8)
class AAmbientSpotLight final : public ASpotLight
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmbientSpotLight">();
	}
	static class AAmbientSpotLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAmbientSpotLight>();
	}
};
static_assert(alignof(AAmbientSpotLight) == 0x000008, "Wrong alignment on AAmbientSpotLight");
static_assert(sizeof(AAmbientSpotLight) == 0x0002C8, "Wrong size on AAmbientSpotLight");

// Class SHProto.SHDebugAnimInstance
// 0x0000 (0x0350 - 0x0350)
class USHDebugAnimInstance final : public UAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDebugAnimInstance">();
	}
	static class USHDebugAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDebugAnimInstance>();
	}
};
static_assert(alignof(USHDebugAnimInstance) == 0x000010, "Wrong alignment on USHDebugAnimInstance");
static_assert(sizeof(USHDebugAnimInstance) == 0x000350, "Wrong size on USHDebugAnimInstance");

// Class SHProto.AnimNotify_WeaponRanged_ShellEject
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_WeaponRanged_ShellEject final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_WeaponRanged_ShellEject">();
	}
	static class UAnimNotify_WeaponRanged_ShellEject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_WeaponRanged_ShellEject>();
	}
};
static_assert(alignof(UAnimNotify_WeaponRanged_ShellEject) == 0x000008, "Wrong alignment on UAnimNotify_WeaponRanged_ShellEject");
static_assert(sizeof(UAnimNotify_WeaponRanged_ShellEject) == 0x000038, "Wrong size on UAnimNotify_WeaponRanged_ShellEject");

// Class SHProto.SHGameplayFocusSlotButton
// 0x0028 (0x02A0 - 0x0278)
class USHGameplayFocusSlotButton final : public UUserWidget
{
public:
	class UButton*                                ButtonCore;                                        // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ButtonTextBlock;                                   // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInputModeEnabled;                               // 0x0288(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMultiItem;                                      // 0x0289(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A[0x6];                                      // 0x028A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USHGameplayFocusSlotsWidget*            WidgetOwner;                                       // 0x0290(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ButtonPressed();
	void OnSetHighlight(bool Enable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayFocusSlotButton">();
	}
	static class USHGameplayFocusSlotButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayFocusSlotButton>();
	}
};
static_assert(alignof(USHGameplayFocusSlotButton) == 0x000008, "Wrong alignment on USHGameplayFocusSlotButton");
static_assert(sizeof(USHGameplayFocusSlotButton) == 0x0002A0, "Wrong size on USHGameplayFocusSlotButton");
static_assert(offsetof(USHGameplayFocusSlotButton, ButtonCore) == 0x000278, "Member 'USHGameplayFocusSlotButton::ButtonCore' has a wrong offset!");
static_assert(offsetof(USHGameplayFocusSlotButton, ButtonTextBlock) == 0x000280, "Member 'USHGameplayFocusSlotButton::ButtonTextBlock' has a wrong offset!");
static_assert(offsetof(USHGameplayFocusSlotButton, bIsInputModeEnabled) == 0x000288, "Member 'USHGameplayFocusSlotButton::bIsInputModeEnabled' has a wrong offset!");
static_assert(offsetof(USHGameplayFocusSlotButton, bIsMultiItem) == 0x000289, "Member 'USHGameplayFocusSlotButton::bIsMultiItem' has a wrong offset!");
static_assert(offsetof(USHGameplayFocusSlotButton, WidgetOwner) == 0x000290, "Member 'USHGameplayFocusSlotButton::WidgetOwner' has a wrong offset!");

// Class SHProto.SHAnimNotify_AIWeaponEnablePhysics
// 0x0000 (0x0038 - 0x0038)
class USHAnimNotify_AIWeaponEnablePhysics final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_AIWeaponEnablePhysics">();
	}
	static class USHAnimNotify_AIWeaponEnablePhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_AIWeaponEnablePhysics>();
	}
};
static_assert(alignof(USHAnimNotify_AIWeaponEnablePhysics) == 0x000008, "Wrong alignment on USHAnimNotify_AIWeaponEnablePhysics");
static_assert(sizeof(USHAnimNotify_AIWeaponEnablePhysics) == 0x000038, "Wrong size on USHAnimNotify_AIWeaponEnablePhysics");

// Class SHProto.SHNPCLocomotionAnimInstance
// 0x0050 (0x03A0 - 0x0350)
#pragma pack(push, 0x1)
class alignas(0x10) USHNPCLocomotionAnimInstance : public UAnimInstance
{
public:
	float                                         TurnInPlaceMinAngle;                               // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnInPlaceMinAngleInMovement;                     // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnInPlaceToMoveAngleTolerate;                    // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PelvisOffsetInterpSpeed;                           // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FeetIKLockIncrementInterpolationSpeed;             // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FeetIKLockDecrementInterpolationSpeed;             // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWarpingEnable;                                    // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_361[0x3];                                      // 0x0361(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StrideScale;                                       // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                StrideDirection;                                   // 0x0368(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHNPCAnimInstanceStateData*            P_AnimInstanceStateData;                           // 0x0380(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x10];                                     // 0x0388(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USHAnimComponent* GetAnimComponent();
	void K2_OnAnimInstanceStateDataUpdated();
	void K2_OnReplacedOtherLocomotionAnimInstance(class USHNPCLocomotionAnimInstance* PreviousLocomotionInstance);
	void MovementVariationRandomChange();
	void OnMoveStartBegin();

	float GetDesiredStrafeAngle() const;
	void GetSpeedWarping(bool* OutWarpingEnabled, float* OutStrideScale, struct FVector* OutStrideDirection) const;
	float GetStrafeAngle() const;
	float GetStrideWarpingSmooth() const;
	float GetTurnInPlaceAngle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHNPCLocomotionAnimInstance">();
	}
	static class USHNPCLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHNPCLocomotionAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(USHNPCLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHNPCLocomotionAnimInstance");
static_assert(sizeof(USHNPCLocomotionAnimInstance) == 0x0003A0, "Wrong size on USHNPCLocomotionAnimInstance");
static_assert(offsetof(USHNPCLocomotionAnimInstance, TurnInPlaceMinAngle) == 0x000348, "Member 'USHNPCLocomotionAnimInstance::TurnInPlaceMinAngle' has a wrong offset!");
static_assert(offsetof(USHNPCLocomotionAnimInstance, TurnInPlaceMinAngleInMovement) == 0x00034C, "Member 'USHNPCLocomotionAnimInstance::TurnInPlaceMinAngleInMovement' has a wrong offset!");
static_assert(offsetof(USHNPCLocomotionAnimInstance, TurnInPlaceToMoveAngleTolerate) == 0x000350, "Member 'USHNPCLocomotionAnimInstance::TurnInPlaceToMoveAngleTolerate' has a wrong offset!");
static_assert(offsetof(USHNPCLocomotionAnimInstance, PelvisOffsetInterpSpeed) == 0x000354, "Member 'USHNPCLocomotionAnimInstance::PelvisOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(USHNPCLocomotionAnimInstance, FeetIKLockIncrementInterpolationSpeed) == 0x000358, "Member 'USHNPCLocomotionAnimInstance::FeetIKLockIncrementInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(USHNPCLocomotionAnimInstance, FeetIKLockDecrementInterpolationSpeed) == 0x00035C, "Member 'USHNPCLocomotionAnimInstance::FeetIKLockDecrementInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(USHNPCLocomotionAnimInstance, bWarpingEnable) == 0x000360, "Member 'USHNPCLocomotionAnimInstance::bWarpingEnable' has a wrong offset!");
static_assert(offsetof(USHNPCLocomotionAnimInstance, StrideScale) == 0x000364, "Member 'USHNPCLocomotionAnimInstance::StrideScale' has a wrong offset!");
static_assert(offsetof(USHNPCLocomotionAnimInstance, StrideDirection) == 0x000368, "Member 'USHNPCLocomotionAnimInstance::StrideDirection' has a wrong offset!");
static_assert(offsetof(USHNPCLocomotionAnimInstance, P_AnimInstanceStateData) == 0x000380, "Member 'USHNPCLocomotionAnimInstance::P_AnimInstanceStateData' has a wrong offset!");

// Class SHProto.SHMonsterLocomotionAnimInstance
// 0x0010 (0x03B0 - 0x03A0)
#pragma pack(push, 0x1)
class alignas(0x10) USHMonsterLocomotionAnimInstance : public USHNPCLocomotionAnimInstance
{
public:
	float                                         IdleStartTime;                                     // 0x0398(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarpingEnableOW;                                  // 0x039C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39D[0x3];                                      // 0x039D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StrideScaleOW;                                     // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOtherWorldEnemy;                                // 0x03A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A5[0x3];                                      // 0x03A5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnStanceChangedToAggressive();
	void K2_OnStanceChangedToCautious();
	void K2_OnStanceChangedToMaximum();
	void K2_OnStanceChangedToNeutral();

	bool GetIsOtherWorldEnemy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMonsterLocomotionAnimInstance">();
	}
	static class USHMonsterLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMonsterLocomotionAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(USHMonsterLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHMonsterLocomotionAnimInstance");
static_assert(sizeof(USHMonsterLocomotionAnimInstance) == 0x0003B0, "Wrong size on USHMonsterLocomotionAnimInstance");
static_assert(offsetof(USHMonsterLocomotionAnimInstance, IdleStartTime) == 0x000398, "Member 'USHMonsterLocomotionAnimInstance::IdleStartTime' has a wrong offset!");
static_assert(offsetof(USHMonsterLocomotionAnimInstance, bWarpingEnableOW) == 0x00039C, "Member 'USHMonsterLocomotionAnimInstance::bWarpingEnableOW' has a wrong offset!");
static_assert(offsetof(USHMonsterLocomotionAnimInstance, StrideScaleOW) == 0x0003A0, "Member 'USHMonsterLocomotionAnimInstance::StrideScaleOW' has a wrong offset!");
static_assert(offsetof(USHMonsterLocomotionAnimInstance, bIsOtherWorldEnemy) == 0x0003A4, "Member 'USHMonsterLocomotionAnimInstance::bIsOtherWorldEnemy' has a wrong offset!");

// Class SHProto.SHAnimNotifyState_AIWeaponEnvCollisionWindow
// 0x0000 (0x0030 - 0x0030)
class USHAnimNotifyState_AIWeaponEnvCollisionWindow final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotifyState_AIWeaponEnvCollisionWindow">();
	}
	static class USHAnimNotifyState_AIWeaponEnvCollisionWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotifyState_AIWeaponEnvCollisionWindow>();
	}
};
static_assert(alignof(USHAnimNotifyState_AIWeaponEnvCollisionWindow) == 0x000008, "Wrong alignment on USHAnimNotifyState_AIWeaponEnvCollisionWindow");
static_assert(sizeof(USHAnimNotifyState_AIWeaponEnvCollisionWindow) == 0x000030, "Wrong size on USHAnimNotifyState_AIWeaponEnvCollisionWindow");

// Class SHProto.SHCharacterStatics
// 0x0000 (0x0028 - 0x0028)
class USHCharacterStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool CanCharacterBeFinished(const class ACharacter* CheckedCharacter);
	static class ASHCharacterPlay* GetCharacterPlay(const class UObject* WorldContextObject);
	static class APawn* GetEddiePawn(const class UObject* WorldContextObject);
	static class APawn* GetMariaPawn(const class UObject* WorldContextObject);
	static struct FVector GetTrueCharacterLocation(const class AActor* InCharacterActor);
	static bool IsCharacterDead(const class ACharacter* CheckedCharacter);
	static bool IsCharacterInCutscene(const class ACharacter* Character);
	static bool IsCharacterInSyncAction(const class ACharacter* CheckedCharacter);
	static bool IsCharacterKnockedDown(const class ACharacter* CheckedCharacter);
	static bool IsCharacterOnGround(const class ACharacter* CheckedCharacter);
	static bool SetActorTeam(const class UObject* WorldContextObject, class APawn* PawnActor, const struct FGenericTeamId& TeamID);
	static void SwitchCharacterPlay(const class UObject* WorldContextObject, ESHSuccessFailureEnum* Result, class ASHCharacterPlay** Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterStatics">();
	}
	static class USHCharacterStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterStatics>();
	}
};
static_assert(alignof(USHCharacterStatics) == 0x000008, "Wrong alignment on USHCharacterStatics");
static_assert(sizeof(USHCharacterStatics) == 0x000028, "Wrong size on USHCharacterStatics");

// Class SHProto.AmbientRectLight
// 0x0000 (0x02C8 - 0x02C8)
class AAmbientRectLight final : public ARectLight
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmbientRectLight">();
	}
	static class AAmbientRectLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAmbientRectLight>();
	}
};
static_assert(alignof(AAmbientRectLight) == 0x000008, "Wrong alignment on AAmbientRectLight");
static_assert(sizeof(AAmbientRectLight) == 0x0002C8, "Wrong size on AAmbientRectLight");

// Class SHProto.SHLyingFigureMovementHistoryComponent
// 0x0050 (0x02F0 - 0x02A0)
class USHLyingFigureMovementHistoryComponent final : public USceneComponent
{
public:
	float                                         MinimumDistance;                                   // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumDistance;                                   // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumDirectionAnglePerDistance;                  // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumRotationAngle;                              // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumScaleDelta;                                 // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumHistoryDistance;                            // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TeleportDistance;                                  // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawMovementPath;                                 // 0x02BC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BD[0x33];                                     // 0x02BD(0x0033)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddMovementWaypoint(const struct FTransform& InWorldTransform);
	void ResetMovementHistory();

	void DebugDrawMovementPath(float InDuration) const;
	bool FindWaypointAtDistance(struct FTransform* OutTransform, float* OutDistance, float* OutTimeBehind, float InDistanceBehind, float InMinimumDistanceFromCurrentPosition) const;
	bool FindWaypointAtTime(struct FTransform* OutTransform, float* OutDistance, float* OutTimeBehind, float InDeltaTimeBehind, float InMinimumDistanceFromCurrentPosition) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLyingFigureMovementHistoryComponent">();
	}
	static class USHLyingFigureMovementHistoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLyingFigureMovementHistoryComponent>();
	}
};
static_assert(alignof(USHLyingFigureMovementHistoryComponent) == 0x000010, "Wrong alignment on USHLyingFigureMovementHistoryComponent");
static_assert(sizeof(USHLyingFigureMovementHistoryComponent) == 0x0002F0, "Wrong size on USHLyingFigureMovementHistoryComponent");
static_assert(offsetof(USHLyingFigureMovementHistoryComponent, MinimumDistance) == 0x0002A0, "Member 'USHLyingFigureMovementHistoryComponent::MinimumDistance' has a wrong offset!");
static_assert(offsetof(USHLyingFigureMovementHistoryComponent, MaximumDistance) == 0x0002A4, "Member 'USHLyingFigureMovementHistoryComponent::MaximumDistance' has a wrong offset!");
static_assert(offsetof(USHLyingFigureMovementHistoryComponent, MaximumDirectionAnglePerDistance) == 0x0002A8, "Member 'USHLyingFigureMovementHistoryComponent::MaximumDirectionAnglePerDistance' has a wrong offset!");
static_assert(offsetof(USHLyingFigureMovementHistoryComponent, MaximumRotationAngle) == 0x0002AC, "Member 'USHLyingFigureMovementHistoryComponent::MaximumRotationAngle' has a wrong offset!");
static_assert(offsetof(USHLyingFigureMovementHistoryComponent, MaximumScaleDelta) == 0x0002B0, "Member 'USHLyingFigureMovementHistoryComponent::MaximumScaleDelta' has a wrong offset!");
static_assert(offsetof(USHLyingFigureMovementHistoryComponent, MinimumHistoryDistance) == 0x0002B4, "Member 'USHLyingFigureMovementHistoryComponent::MinimumHistoryDistance' has a wrong offset!");
static_assert(offsetof(USHLyingFigureMovementHistoryComponent, TeleportDistance) == 0x0002B8, "Member 'USHLyingFigureMovementHistoryComponent::TeleportDistance' has a wrong offset!");
static_assert(offsetof(USHLyingFigureMovementHistoryComponent, bDrawMovementPath) == 0x0002BC, "Member 'USHLyingFigureMovementHistoryComponent::bDrawMovementPath' has a wrong offset!");

// Class SHProto.SHNPCAnimInstance
// 0x0090 (0x03E0 - 0x0350)
#pragma pack(push, 0x1)
class alignas(0x10) USHNPCAnimInstance : public UAnimInstance
{
public:
	TSubclassOf<class USHNPCAnimInstanceStateData> AnimInstanceStateDataClass;                        // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSHNPCAnimInstanceLocomotionSlotConfiguration> LocomotionSlotConfigurations;                      // 0x0350(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bDrawAnimInstanceDebug;                            // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRagdollDeathEnable;                               // 0x0361(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_362[0x6];                                      // 0x0362(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWholeBodyTranslation                  AdditionalTranslation;                             // 0x0368(0x0048)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         AdditionalTranslationAlpha;                        // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USHNPCAnimInstanceStateData*            P_AnimInstanceStateData;                           // 0x03B8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSHNPCAnimInstanceLocomotionSlot> P_LocomotionSlots;                                 // 0x03C0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D0[0x8];                                      // 0x03D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnAnimInstanceStateDataUpdated();
	void MoveEndBegin();
	void OnDeath();
	void OnDeathEvent();
	void OnLocomotionAnimInstanceChanged_BPEvent(int32 SlotIndex);
	void OnLocomotionAnimInstanceInitialised_BPEvent(int32 SlotIndex);
	void OnRevive();
	void OnReviveEvent();
	class UAnimInstance* SetNewLocomotionAnimInstance(TSubclassOf<class USHNPCLocomotionAnimInstance> NewLocomotionInstance, bool ForceReplacement, float TransitionDuration, float TransitionDelay, int32 SlotIndex);

	class USHAnimComponent* GetAnimComponent() const;
	class FName GetChangeLocomotionSnapshotName(int32 SlotIndex) const;
	class USHNPCLocomotionAnimInstance* GetLocomotionAnimInstance(int32 SlotIndex) const;
	float GetLocomotionChangeAlpha(int32 SlotIndex) const;
	class FName GetLocomotionTag(int32 SlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHNPCAnimInstance">();
	}
	static class USHNPCAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHNPCAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(USHNPCAnimInstance) == 0x000010, "Wrong alignment on USHNPCAnimInstance");
static_assert(sizeof(USHNPCAnimInstance) == 0x0003E0, "Wrong size on USHNPCAnimInstance");
static_assert(offsetof(USHNPCAnimInstance, AnimInstanceStateDataClass) == 0x000348, "Member 'USHNPCAnimInstance::AnimInstanceStateDataClass' has a wrong offset!");
static_assert(offsetof(USHNPCAnimInstance, LocomotionSlotConfigurations) == 0x000350, "Member 'USHNPCAnimInstance::LocomotionSlotConfigurations' has a wrong offset!");
static_assert(offsetof(USHNPCAnimInstance, bDrawAnimInstanceDebug) == 0x000360, "Member 'USHNPCAnimInstance::bDrawAnimInstanceDebug' has a wrong offset!");
static_assert(offsetof(USHNPCAnimInstance, bRagdollDeathEnable) == 0x000361, "Member 'USHNPCAnimInstance::bRagdollDeathEnable' has a wrong offset!");
static_assert(offsetof(USHNPCAnimInstance, AdditionalTranslation) == 0x000368, "Member 'USHNPCAnimInstance::AdditionalTranslation' has a wrong offset!");
static_assert(offsetof(USHNPCAnimInstance, AdditionalTranslationAlpha) == 0x0003B0, "Member 'USHNPCAnimInstance::AdditionalTranslationAlpha' has a wrong offset!");
static_assert(offsetof(USHNPCAnimInstance, P_AnimInstanceStateData) == 0x0003B8, "Member 'USHNPCAnimInstance::P_AnimInstanceStateData' has a wrong offset!");
static_assert(offsetof(USHNPCAnimInstance, P_LocomotionSlots) == 0x0003C0, "Member 'USHNPCAnimInstance::P_LocomotionSlots' has a wrong offset!");

// Class SHProto.SHMonsterAnimInstance
// 0x0000 (0x03E0 - 0x03E0)
class USHMonsterAnimInstance : public USHNPCAnimInstance
{
public:
	EMaiAggroStance                               AggroStance;                                       // 0x03D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOtherWorldEnemy;                                // 0x03D9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLying;                                          // 0x03DA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTransforming;                                   // 0x03DB(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool DecrementReviveSeizure(float InReduceSeizuresCount);
	void K2_OnStanceChangedToAggressive();
	void K2_OnStanceChangedToCautious();
	void K2_OnStanceChangedToMaximum();
	void K2_OnStanceChangedToNeutral();
	void K2_OnTransformationToLyingFinished();
	void K2_OnTransformationToLyingStarted();
	void K2_OnTransformationToStandingFinished();
	void K2_OnTransformationToStandingStarted();
	void SetEnemyIsOtherWorld(bool InEnemyIsOW);
	void SetEnemyReviveSeizuresToBePlayed(float InSeizuresCount);

	float GetRemainingReviveSeizuresCount() const;
	bool IsLying(bool IncludeTransformingInto, bool IncludeTransformingOutOf) const;
	bool IsOtherWorldEnemy() const;
	bool IsStanding(bool IncludeTransformingInto, bool IncludeTransformingOutOf) const;
	bool IsTransformingToLying() const;
	bool IsTransformingToStanding() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMonsterAnimInstance">();
	}
	static class USHMonsterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMonsterAnimInstance>();
	}
};
static_assert(alignof(USHMonsterAnimInstance) == 0x000010, "Wrong alignment on USHMonsterAnimInstance");
static_assert(sizeof(USHMonsterAnimInstance) == 0x0003E0, "Wrong size on USHMonsterAnimInstance");
static_assert(offsetof(USHMonsterAnimInstance, AggroStance) == 0x0003D8, "Member 'USHMonsterAnimInstance::AggroStance' has a wrong offset!");
static_assert(offsetof(USHMonsterAnimInstance, bIsOtherWorldEnemy) == 0x0003D9, "Member 'USHMonsterAnimInstance::bIsOtherWorldEnemy' has a wrong offset!");
static_assert(offsetof(USHMonsterAnimInstance, bIsLying) == 0x0003DA, "Member 'USHMonsterAnimInstance::bIsLying' has a wrong offset!");
static_assert(offsetof(USHMonsterAnimInstance, bIsTransforming) == 0x0003DB, "Member 'USHMonsterAnimInstance::bIsTransforming' has a wrong offset!");

// Class SHProto.SHCreeperAnimInstance
// 0x0010 (0x03F0 - 0x03E0)
class USHCreeperAnimInstance final : public USHMonsterAnimInstance
{
public:
	bool                                          IsAttacking;                                       // 0x03E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackWalkingRate;                                 // 0x03E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USHCreeperAnimInstanceStateData* GetCreeperAnimInstanceStateData() const;
	class USHCreeperLocomotionAnimInstance* GetCreeperLocomotionAnimInstance(int32 SlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCreeperAnimInstance">();
	}
	static class USHCreeperAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCreeperAnimInstance>();
	}
};
static_assert(alignof(USHCreeperAnimInstance) == 0x000010, "Wrong alignment on USHCreeperAnimInstance");
static_assert(sizeof(USHCreeperAnimInstance) == 0x0003F0, "Wrong size on USHCreeperAnimInstance");
static_assert(offsetof(USHCreeperAnimInstance, IsAttacking) == 0x0003E0, "Member 'USHCreeperAnimInstance::IsAttacking' has a wrong offset!");
static_assert(offsetof(USHCreeperAnimInstance, AttackWalkingRate) == 0x0003E4, "Member 'USHCreeperAnimInstance::AttackWalkingRate' has a wrong offset!");

// Class SHProto.AnimNotify_DoorLockToggle
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_DoorLockToggle final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DoorLockToggle">();
	}
	static class UAnimNotify_DoorLockToggle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DoorLockToggle>();
	}
};
static_assert(alignof(UAnimNotify_DoorLockToggle) == 0x000008, "Wrong alignment on UAnimNotify_DoorLockToggle");
static_assert(sizeof(UAnimNotify_DoorLockToggle) == 0x000038, "Wrong size on UAnimNotify_DoorLockToggle");

// Class SHProto.SHFreezingVolume
// 0x0000 (0x02E8 - 0x02E8)
class ASHFreezingVolume final : public AVolume
{
public:
	bool IsPointWithin(const struct FVector& Point) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFreezingVolume">();
	}
	static class ASHFreezingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHFreezingVolume>();
	}
};
static_assert(alignof(ASHFreezingVolume) == 0x000008, "Wrong alignment on ASHFreezingVolume");
static_assert(sizeof(ASHFreezingVolume) == 0x0002E8, "Wrong size on ASHFreezingVolume");

// Class SHProto.AmbientPointLight
// 0x0000 (0x02C8 - 0x02C8)
class AAmbientPointLight final : public APointLight
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmbientPointLight">();
	}
	static class AAmbientPointLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAmbientPointLight>();
	}
};
static_assert(alignof(AAmbientPointLight) == 0x000008, "Wrong alignment on AAmbientPointLight");
static_assert(sizeof(AAmbientPointLight) == 0x0002C8, "Wrong size on AAmbientPointLight");

// Class SHProto.SHAudioHealthSettings
// 0x0048 (0x0078 - 0x0030)
class USHAudioHealthSettings final : public UDataAsset
{
public:
	class UAkAudioEvent*                          ReceivedDamageEvent_Generic;                       // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          Play_CriticalInjuryEvent;                          // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          Stop_CriticalInjuryEvent;                          // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                RTPC_HealthPercentage;                             // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          AudioHealthState_Fine;                             // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          AudioHealthState_LowInjury;                        // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          AudioHealthState_HeavyInjury;                      // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          AudioHealthState_CriticalInjury;                   // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          AudioHealthState_Dead;                             // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAudioHealthSettings">();
	}
	static class USHAudioHealthSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAudioHealthSettings>();
	}
};
static_assert(alignof(USHAudioHealthSettings) == 0x000008, "Wrong alignment on USHAudioHealthSettings");
static_assert(sizeof(USHAudioHealthSettings) == 0x000078, "Wrong size on USHAudioHealthSettings");
static_assert(offsetof(USHAudioHealthSettings, ReceivedDamageEvent_Generic) == 0x000030, "Member 'USHAudioHealthSettings::ReceivedDamageEvent_Generic' has a wrong offset!");
static_assert(offsetof(USHAudioHealthSettings, Play_CriticalInjuryEvent) == 0x000038, "Member 'USHAudioHealthSettings::Play_CriticalInjuryEvent' has a wrong offset!");
static_assert(offsetof(USHAudioHealthSettings, Stop_CriticalInjuryEvent) == 0x000040, "Member 'USHAudioHealthSettings::Stop_CriticalInjuryEvent' has a wrong offset!");
static_assert(offsetof(USHAudioHealthSettings, RTPC_HealthPercentage) == 0x000048, "Member 'USHAudioHealthSettings::RTPC_HealthPercentage' has a wrong offset!");
static_assert(offsetof(USHAudioHealthSettings, AudioHealthState_Fine) == 0x000050, "Member 'USHAudioHealthSettings::AudioHealthState_Fine' has a wrong offset!");
static_assert(offsetof(USHAudioHealthSettings, AudioHealthState_LowInjury) == 0x000058, "Member 'USHAudioHealthSettings::AudioHealthState_LowInjury' has a wrong offset!");
static_assert(offsetof(USHAudioHealthSettings, AudioHealthState_HeavyInjury) == 0x000060, "Member 'USHAudioHealthSettings::AudioHealthState_HeavyInjury' has a wrong offset!");
static_assert(offsetof(USHAudioHealthSettings, AudioHealthState_CriticalInjury) == 0x000068, "Member 'USHAudioHealthSettings::AudioHealthState_CriticalInjury' has a wrong offset!");
static_assert(offsetof(USHAudioHealthSettings, AudioHealthState_Dead) == 0x000070, "Member 'USHAudioHealthSettings::AudioHealthState_Dead' has a wrong offset!");

// Class SHProto.AmbientPointLightComponent
// 0x0000 (0x0420 - 0x0420)
class UAmbientPointLightComponent final : public UPointLightComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmbientPointLightComponent">();
	}
	static class UAmbientPointLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAmbientPointLightComponent>();
	}
};
static_assert(alignof(UAmbientPointLightComponent) == 0x000010, "Wrong alignment on UAmbientPointLightComponent");
static_assert(sizeof(UAmbientPointLightComponent) == 0x000420, "Wrong size on UAmbientPointLightComponent");

// Class SHProto.SHDPSCounter
// 0x0018 (0x00B8 - 0x00A0)
class USHDPSCounter final : public UActorComponent
{
public:
	float                                         CounterHistoryDurationLimit;                       // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x14];                                      // 0x00A4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessOwnerTakeAnyDamage(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
	void ResetDPS();

	float GetRecentDPS(float HistoryPeriodSeconds) const;
	float GetRecentTotalDamage(float HistoryPeriodSeconds) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDPSCounter">();
	}
	static class USHDPSCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDPSCounter>();
	}
};
static_assert(alignof(USHDPSCounter) == 0x000008, "Wrong alignment on USHDPSCounter");
static_assert(sizeof(USHDPSCounter) == 0x0000B8, "Wrong size on USHDPSCounter");
static_assert(offsetof(USHDPSCounter, CounterHistoryDurationLimit) == 0x0000A0, "Member 'USHDPSCounter::CounterHistoryDurationLimit' has a wrong offset!");

// Class SHProto.EnvQueryTest_ComponentsGameplayTags
// 0x0070 (0x0268 - 0x01F8)
class UEnvQueryTest_ComponentsGameplayTags final : public UEnvQueryTest
{
public:
	struct FGameplayTagQuery                      TagQueryToMatch;                                   // 0x01F8(0x0048)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bRejectIncompatibleItems;                          // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpdatedToUseQuery;                                // 0x0241(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayContainerMatchType                   TagsToMatch;                                       // 0x0242(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_243[0x5];                                      // 0x0243(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x0248(0x0020)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_ComponentsGameplayTags">();
	}
	static class UEnvQueryTest_ComponentsGameplayTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_ComponentsGameplayTags>();
	}
};
static_assert(alignof(UEnvQueryTest_ComponentsGameplayTags) == 0x000008, "Wrong alignment on UEnvQueryTest_ComponentsGameplayTags");
static_assert(sizeof(UEnvQueryTest_ComponentsGameplayTags) == 0x000268, "Wrong size on UEnvQueryTest_ComponentsGameplayTags");
static_assert(offsetof(UEnvQueryTest_ComponentsGameplayTags, TagQueryToMatch) == 0x0001F8, "Member 'UEnvQueryTest_ComponentsGameplayTags::TagQueryToMatch' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_ComponentsGameplayTags, bRejectIncompatibleItems) == 0x000240, "Member 'UEnvQueryTest_ComponentsGameplayTags::bRejectIncompatibleItems' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_ComponentsGameplayTags, bUpdatedToUseQuery) == 0x000241, "Member 'UEnvQueryTest_ComponentsGameplayTags::bUpdatedToUseQuery' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_ComponentsGameplayTags, TagsToMatch) == 0x000242, "Member 'UEnvQueryTest_ComponentsGameplayTags::TagsToMatch' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_ComponentsGameplayTags, GameplayTags) == 0x000248, "Member 'UEnvQueryTest_ComponentsGameplayTags::GameplayTags' has a wrong offset!");

// Class SHProto.SHAudioSpaceSettings
// 0x0038 (0x0068 - 0x0030)
class USHAudioSpaceSettings final : public UDataAsset
{
public:
	class UAkSwitchValue*                         AudioSwitch_Cubature_Indoor_Small;                 // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkSwitchValue*                         AudioSwitch_Cubature_Indoor_Medium;                // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkSwitchValue*                         AudioSwitch_Cubature_Indoor_Large;                 // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkSwitchValue*                         AudioSwitch_Cubature_Outdoor;                      // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          AudioState_World_FW;                               // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          AudioState_World_OW;                               // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                AudioRTPC_World;                                   // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAudioSpaceSettings">();
	}
	static class USHAudioSpaceSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAudioSpaceSettings>();
	}
};
static_assert(alignof(USHAudioSpaceSettings) == 0x000008, "Wrong alignment on USHAudioSpaceSettings");
static_assert(sizeof(USHAudioSpaceSettings) == 0x000068, "Wrong size on USHAudioSpaceSettings");
static_assert(offsetof(USHAudioSpaceSettings, AudioSwitch_Cubature_Indoor_Small) == 0x000030, "Member 'USHAudioSpaceSettings::AudioSwitch_Cubature_Indoor_Small' has a wrong offset!");
static_assert(offsetof(USHAudioSpaceSettings, AudioSwitch_Cubature_Indoor_Medium) == 0x000038, "Member 'USHAudioSpaceSettings::AudioSwitch_Cubature_Indoor_Medium' has a wrong offset!");
static_assert(offsetof(USHAudioSpaceSettings, AudioSwitch_Cubature_Indoor_Large) == 0x000040, "Member 'USHAudioSpaceSettings::AudioSwitch_Cubature_Indoor_Large' has a wrong offset!");
static_assert(offsetof(USHAudioSpaceSettings, AudioSwitch_Cubature_Outdoor) == 0x000048, "Member 'USHAudioSpaceSettings::AudioSwitch_Cubature_Outdoor' has a wrong offset!");
static_assert(offsetof(USHAudioSpaceSettings, AudioState_World_FW) == 0x000050, "Member 'USHAudioSpaceSettings::AudioState_World_FW' has a wrong offset!");
static_assert(offsetof(USHAudioSpaceSettings, AudioState_World_OW) == 0x000058, "Member 'USHAudioSpaceSettings::AudioState_World_OW' has a wrong offset!");
static_assert(offsetof(USHAudioSpaceSettings, AudioRTPC_World) == 0x000060, "Member 'USHAudioSpaceSettings::AudioRTPC_World' has a wrong offset!");

// Class SHProto.AmbientRectLightComponent
// 0x0000 (0x0430 - 0x0430)
class UAmbientRectLightComponent final : public URectLightComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmbientRectLightComponent">();
	}
	static class UAmbientRectLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAmbientRectLightComponent>();
	}
};
static_assert(alignof(UAmbientRectLightComponent) == 0x000010, "Wrong alignment on UAmbientRectLightComponent");
static_assert(sizeof(UAmbientRectLightComponent) == 0x000430, "Wrong size on UAmbientRectLightComponent");

// Class SHProto.AmbientSpotLightComponent
// 0x0000 (0x0430 - 0x0430)
class UAmbientSpotLightComponent final : public USpotLightComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmbientSpotLightComponent">();
	}
	static class UAmbientSpotLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAmbientSpotLightComponent>();
	}
};
static_assert(alignof(UAmbientSpotLightComponent) == 0x000010, "Wrong alignment on UAmbientSpotLightComponent");
static_assert(sizeof(UAmbientSpotLightComponent) == 0x000430, "Wrong size on UAmbientSpotLightComponent");

// Class SHProto.SHCombatSubcomponentBase
// 0x0010 (0x0038 - 0x0028)
class USHCombatSubcomponentBase : public UObject
{
public:
	class ACharacter*                             OwnerCharacter;                                    // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayCombatComponent*        OwnerComponent;                                    // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class ACharacter* GetOwnerCharacter() const;
	class AActor* GetOwningActor() const;
	class USHCharacterPlayCombatComponent* GetOwningComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCombatSubcomponentBase">();
	}
	static class USHCombatSubcomponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCombatSubcomponentBase>();
	}
};
static_assert(alignof(USHCombatSubcomponentBase) == 0x000008, "Wrong alignment on USHCombatSubcomponentBase");
static_assert(sizeof(USHCombatSubcomponentBase) == 0x000038, "Wrong size on USHCombatSubcomponentBase");
static_assert(offsetof(USHCombatSubcomponentBase, OwnerCharacter) == 0x000028, "Member 'USHCombatSubcomponentBase::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHCombatSubcomponentBase, OwnerComponent) == 0x000030, "Member 'USHCombatSubcomponentBase::OwnerComponent' has a wrong offset!");

// Class SHProto.SHWeaponManageCmbSubcomp
// 0x0158 (0x0190 - 0x0038)
class USHWeaponManageCmbSubcomp final : public USHCombatSubcomponentBase
{
public:
	class ASHItemWeapon*                          EquippedWeapon;                                    // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LastUsedWeapon;                                    // 0x0040(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LastUsedMeleeWeapon;                               // 0x0048(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LastUsedRangedWeapon;                              // 0x0050(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x138];                                     // 0x0058(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeWeaponEquipBlendingOut(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void OnChangeWeaponEquipEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void OnChangeWeaponUnequipBlendingOut(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void OnChangeWeaponUnequipEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void OnEquipWeaponEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void OnUnequipWeaponEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void ProcessCombatPoseChangedEvent(class USHCharacterPlayCombatComponent* ComponentPtr);
	void ProcessItemRemovedEvent(class USHCharacterPlayItemsComponent* ComponentPtr, class FName ItemContext);
	void ProcessPreloadItemAssetsEvent(class USHCharacterPlayItemsComponent* ComponentPtr, class FName ItemContext);
	void ProcessReleasePreloadedItemAssetsEvent(class USHCharacterPlayItemsComponent* ComponentPtr, class FName ItemContext);
	bool RequestEquipWeapon(class FName WeaponDataRowName, bool Instant);
	bool RequestUnequipWeapon(bool Instant);
	void SHDebug_Character_Combat_UnequipWeapon();
	void SHHWeaponManageEvent__DelegateSignature(class USHWeaponManageCmbSubcomp* WeaponManagerSubcomp);

	class ASHItemWeapon* GetEquippedWeapon() const;
	class FName GetEquippedWeaponName() const;
	class FName GetLastUsedMeleeWeapon() const;
	class FName GetLastUsedRangedWeapon() const;
	class FName GetLastUsedWeapon() const;
	class FName GetMeleeWeaponToEquip(bool Next) const;
	class FName GetNoWeaponDataTableRowName() const;
	class FName GetRangedWeaponToEquip(bool Next) const;
	bool HasEquippedWeapon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHWeaponManageCmbSubcomp">();
	}
	static class USHWeaponManageCmbSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHWeaponManageCmbSubcomp>();
	}
};
static_assert(alignof(USHWeaponManageCmbSubcomp) == 0x000008, "Wrong alignment on USHWeaponManageCmbSubcomp");
static_assert(sizeof(USHWeaponManageCmbSubcomp) == 0x000190, "Wrong size on USHWeaponManageCmbSubcomp");
static_assert(offsetof(USHWeaponManageCmbSubcomp, EquippedWeapon) == 0x000038, "Member 'USHWeaponManageCmbSubcomp::EquippedWeapon' has a wrong offset!");
static_assert(offsetof(USHWeaponManageCmbSubcomp, LastUsedWeapon) == 0x000040, "Member 'USHWeaponManageCmbSubcomp::LastUsedWeapon' has a wrong offset!");
static_assert(offsetof(USHWeaponManageCmbSubcomp, LastUsedMeleeWeapon) == 0x000048, "Member 'USHWeaponManageCmbSubcomp::LastUsedMeleeWeapon' has a wrong offset!");
static_assert(offsetof(USHWeaponManageCmbSubcomp, LastUsedRangedWeapon) == 0x000050, "Member 'USHWeaponManageCmbSubcomp::LastUsedRangedWeapon' has a wrong offset!");

// Class SHProto.AnalyticsGameplayRecorderComponent
// 0x00B8 (0x0158 - 0x00A0)
class UAnalyticsGameplayRecorderComponent final : public UActorComponent
{
public:
	class FString                                 CurrentSessionFilePath;                            // 0x00A0(0x0010)(ZeroConstructor, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0xA8];                                      // 0x00B0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Analytics_Gameplay_DumpValues();
	void SHDebug_Analytics_Gameplay_EndSession();
	void SHDebug_Analytics_Gameplay_FlushSession();
	void SHDebug_Analytics_Gameplay_StartSession();
	void SHDebug_Analytics_Gameplay_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnalyticsGameplayRecorderComponent">();
	}
	static class UAnalyticsGameplayRecorderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnalyticsGameplayRecorderComponent>();
	}
};
static_assert(alignof(UAnalyticsGameplayRecorderComponent) == 0x000008, "Wrong alignment on UAnalyticsGameplayRecorderComponent");
static_assert(sizeof(UAnalyticsGameplayRecorderComponent) == 0x000158, "Wrong size on UAnalyticsGameplayRecorderComponent");
static_assert(offsetof(UAnalyticsGameplayRecorderComponent, CurrentSessionFilePath) == 0x0000A0, "Member 'UAnalyticsGameplayRecorderComponent::CurrentSessionFilePath' has a wrong offset!");

// Class SHProto.SHAudioInteractionSettings
// 0x0008 (0x0038 - 0x0030)
class USHAudioInteractionSettings final : public UDataAsset
{
public:
	class UAkAudioEvent*                          FocusableOnSolvedAudioEvent;                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAudioInteractionSettings">();
	}
	static class USHAudioInteractionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAudioInteractionSettings>();
	}
};
static_assert(alignof(USHAudioInteractionSettings) == 0x000008, "Wrong alignment on USHAudioInteractionSettings");
static_assert(sizeof(USHAudioInteractionSettings) == 0x000038, "Wrong size on USHAudioInteractionSettings");
static_assert(offsetof(USHAudioInteractionSettings, FocusableOnSolvedAudioEvent) == 0x000030, "Member 'USHAudioInteractionSettings::FocusableOnSolvedAudioEvent' has a wrong offset!");

// Class SHProto.AnalyticsPerformanceRecorderComponent
// 0x00B0 (0x0150 - 0x00A0)
class UAnalyticsPerformanceRecorderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0xB0];                                      // 0x00A0(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Analytics_Performance_DumpCurrentWorldOwnedComponents();
	void SHDebug_Analytics_Performance_EndSession();
	void SHDebug_Analytics_Performance_FlushSession();
	void SHDebug_Analytics_Performance_StartSession();
	void SHDebug_Analytics_Performance_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnalyticsPerformanceRecorderComponent">();
	}
	static class UAnalyticsPerformanceRecorderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnalyticsPerformanceRecorderComponent>();
	}
};
static_assert(alignof(UAnalyticsPerformanceRecorderComponent) == 0x000008, "Wrong alignment on UAnalyticsPerformanceRecorderComponent");
static_assert(sizeof(UAnalyticsPerformanceRecorderComponent) == 0x000150, "Wrong size on UAnalyticsPerformanceRecorderComponent");

// Class SHProto.AnalyticsPerformanceRecorderSettings
// 0x01D0 (0x0208 - 0x0038)
class UAnalyticsPerformanceRecorderSettings final : public UDeveloperSettings
{
public:
	class FString                                 PS5NCSubdirectory;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 XSXNCSubdirectory;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WINNCSubdirectory;                                 // 0x0058(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NCServer;                                          // 0x0068(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NCUser;                                            // 0x0078(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NCAPIKey;                                          // 0x0088(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Preset0StartColor;                                 // 0x0098(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset0StartValue;                                 // 0x00A8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Preset0EndColor;                                   // 0x00AC(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset0EndValue;                                   // 0x00BC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset0BaseRadius;                                 // 0x00C0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset0MergeRadius;                                // 0x00C4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMergeSamplesAction                           Preset0MergeAction;                                // 0x00C8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Preset1StartColor;                                 // 0x00CC(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset1StartValue;                                 // 0x00DC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Preset1EndColor;                                   // 0x00E0(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset1EndValue;                                   // 0x00F0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset1BaseRadius;                                 // 0x00F4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset1MergeRadius;                                // 0x00F8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMergeSamplesAction                           Preset1MergeAction;                                // 0x00FC(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Preset2StartColor;                                 // 0x0100(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset2StartValue;                                 // 0x0110(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Preset2EndColor;                                   // 0x0114(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset2EndValue;                                   // 0x0124(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset2BaseRadius;                                 // 0x0128(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset2MergeRadius;                                // 0x012C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMergeSamplesAction                           Preset2MergeAction;                                // 0x0130(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Preset3StartColor;                                 // 0x0134(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset3StartValue;                                 // 0x0144(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Preset3EndColor;                                   // 0x0148(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset3EndValue;                                   // 0x0158(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset3BaseRadius;                                 // 0x015C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset3MergeRadius;                                // 0x0160(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMergeSamplesAction                           Preset3MergeAction;                                // 0x0164(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Preset4StartColor;                                 // 0x0168(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset4StartValue;                                 // 0x0178(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Preset4EndColor;                                   // 0x017C(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset4EndValue;                                   // 0x018C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset4BaseRadius;                                 // 0x0190(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset4MergeRadius;                                // 0x0194(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMergeSamplesAction                           Preset4MergeAction;                                // 0x0198(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Preset5StartColor;                                 // 0x019C(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset5StartValue;                                 // 0x01AC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Preset5EndColor;                                   // 0x01B0(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset5EndValue;                                   // 0x01C0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset5BaseRadius;                                 // 0x01C4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset5MergeRadius;                                // 0x01C8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMergeSamplesAction                           Preset5MergeAction;                                // 0x01CC(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CD[0x3];                                      // 0x01CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Preset6StartColor;                                 // 0x01D0(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset6StartValue;                                 // 0x01E0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Preset6EndColor;                                   // 0x01E4(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset6EndValue;                                   // 0x01F4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset6BaseRadius;                                 // 0x01F8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Preset6MergeRadius;                                // 0x01FC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMergeSamplesAction                           Preset6MergeAction;                                // 0x0200(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201[0x7];                                      // 0x0201(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnalyticsPerformanceRecorderSettings">();
	}
	static class UAnalyticsPerformanceRecorderSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnalyticsPerformanceRecorderSettings>();
	}
};
static_assert(alignof(UAnalyticsPerformanceRecorderSettings) == 0x000008, "Wrong alignment on UAnalyticsPerformanceRecorderSettings");
static_assert(sizeof(UAnalyticsPerformanceRecorderSettings) == 0x000208, "Wrong size on UAnalyticsPerformanceRecorderSettings");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, PS5NCSubdirectory) == 0x000038, "Member 'UAnalyticsPerformanceRecorderSettings::PS5NCSubdirectory' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, XSXNCSubdirectory) == 0x000048, "Member 'UAnalyticsPerformanceRecorderSettings::XSXNCSubdirectory' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, WINNCSubdirectory) == 0x000058, "Member 'UAnalyticsPerformanceRecorderSettings::WINNCSubdirectory' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, NCServer) == 0x000068, "Member 'UAnalyticsPerformanceRecorderSettings::NCServer' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, NCUser) == 0x000078, "Member 'UAnalyticsPerformanceRecorderSettings::NCUser' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, NCAPIKey) == 0x000088, "Member 'UAnalyticsPerformanceRecorderSettings::NCAPIKey' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset0StartColor) == 0x000098, "Member 'UAnalyticsPerformanceRecorderSettings::Preset0StartColor' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset0StartValue) == 0x0000A8, "Member 'UAnalyticsPerformanceRecorderSettings::Preset0StartValue' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset0EndColor) == 0x0000AC, "Member 'UAnalyticsPerformanceRecorderSettings::Preset0EndColor' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset0EndValue) == 0x0000BC, "Member 'UAnalyticsPerformanceRecorderSettings::Preset0EndValue' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset0BaseRadius) == 0x0000C0, "Member 'UAnalyticsPerformanceRecorderSettings::Preset0BaseRadius' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset0MergeRadius) == 0x0000C4, "Member 'UAnalyticsPerformanceRecorderSettings::Preset0MergeRadius' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset0MergeAction) == 0x0000C8, "Member 'UAnalyticsPerformanceRecorderSettings::Preset0MergeAction' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset1StartColor) == 0x0000CC, "Member 'UAnalyticsPerformanceRecorderSettings::Preset1StartColor' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset1StartValue) == 0x0000DC, "Member 'UAnalyticsPerformanceRecorderSettings::Preset1StartValue' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset1EndColor) == 0x0000E0, "Member 'UAnalyticsPerformanceRecorderSettings::Preset1EndColor' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset1EndValue) == 0x0000F0, "Member 'UAnalyticsPerformanceRecorderSettings::Preset1EndValue' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset1BaseRadius) == 0x0000F4, "Member 'UAnalyticsPerformanceRecorderSettings::Preset1BaseRadius' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset1MergeRadius) == 0x0000F8, "Member 'UAnalyticsPerformanceRecorderSettings::Preset1MergeRadius' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset1MergeAction) == 0x0000FC, "Member 'UAnalyticsPerformanceRecorderSettings::Preset1MergeAction' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset2StartColor) == 0x000100, "Member 'UAnalyticsPerformanceRecorderSettings::Preset2StartColor' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset2StartValue) == 0x000110, "Member 'UAnalyticsPerformanceRecorderSettings::Preset2StartValue' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset2EndColor) == 0x000114, "Member 'UAnalyticsPerformanceRecorderSettings::Preset2EndColor' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset2EndValue) == 0x000124, "Member 'UAnalyticsPerformanceRecorderSettings::Preset2EndValue' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset2BaseRadius) == 0x000128, "Member 'UAnalyticsPerformanceRecorderSettings::Preset2BaseRadius' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset2MergeRadius) == 0x00012C, "Member 'UAnalyticsPerformanceRecorderSettings::Preset2MergeRadius' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset2MergeAction) == 0x000130, "Member 'UAnalyticsPerformanceRecorderSettings::Preset2MergeAction' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset3StartColor) == 0x000134, "Member 'UAnalyticsPerformanceRecorderSettings::Preset3StartColor' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset3StartValue) == 0x000144, "Member 'UAnalyticsPerformanceRecorderSettings::Preset3StartValue' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset3EndColor) == 0x000148, "Member 'UAnalyticsPerformanceRecorderSettings::Preset3EndColor' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset3EndValue) == 0x000158, "Member 'UAnalyticsPerformanceRecorderSettings::Preset3EndValue' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset3BaseRadius) == 0x00015C, "Member 'UAnalyticsPerformanceRecorderSettings::Preset3BaseRadius' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset3MergeRadius) == 0x000160, "Member 'UAnalyticsPerformanceRecorderSettings::Preset3MergeRadius' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset3MergeAction) == 0x000164, "Member 'UAnalyticsPerformanceRecorderSettings::Preset3MergeAction' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset4StartColor) == 0x000168, "Member 'UAnalyticsPerformanceRecorderSettings::Preset4StartColor' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset4StartValue) == 0x000178, "Member 'UAnalyticsPerformanceRecorderSettings::Preset4StartValue' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset4EndColor) == 0x00017C, "Member 'UAnalyticsPerformanceRecorderSettings::Preset4EndColor' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset4EndValue) == 0x00018C, "Member 'UAnalyticsPerformanceRecorderSettings::Preset4EndValue' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset4BaseRadius) == 0x000190, "Member 'UAnalyticsPerformanceRecorderSettings::Preset4BaseRadius' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset4MergeRadius) == 0x000194, "Member 'UAnalyticsPerformanceRecorderSettings::Preset4MergeRadius' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset4MergeAction) == 0x000198, "Member 'UAnalyticsPerformanceRecorderSettings::Preset4MergeAction' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset5StartColor) == 0x00019C, "Member 'UAnalyticsPerformanceRecorderSettings::Preset5StartColor' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset5StartValue) == 0x0001AC, "Member 'UAnalyticsPerformanceRecorderSettings::Preset5StartValue' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset5EndColor) == 0x0001B0, "Member 'UAnalyticsPerformanceRecorderSettings::Preset5EndColor' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset5EndValue) == 0x0001C0, "Member 'UAnalyticsPerformanceRecorderSettings::Preset5EndValue' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset5BaseRadius) == 0x0001C4, "Member 'UAnalyticsPerformanceRecorderSettings::Preset5BaseRadius' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset5MergeRadius) == 0x0001C8, "Member 'UAnalyticsPerformanceRecorderSettings::Preset5MergeRadius' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset5MergeAction) == 0x0001CC, "Member 'UAnalyticsPerformanceRecorderSettings::Preset5MergeAction' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset6StartColor) == 0x0001D0, "Member 'UAnalyticsPerformanceRecorderSettings::Preset6StartColor' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset6StartValue) == 0x0001E0, "Member 'UAnalyticsPerformanceRecorderSettings::Preset6StartValue' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset6EndColor) == 0x0001E4, "Member 'UAnalyticsPerformanceRecorderSettings::Preset6EndColor' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset6EndValue) == 0x0001F4, "Member 'UAnalyticsPerformanceRecorderSettings::Preset6EndValue' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset6BaseRadius) == 0x0001F8, "Member 'UAnalyticsPerformanceRecorderSettings::Preset6BaseRadius' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset6MergeRadius) == 0x0001FC, "Member 'UAnalyticsPerformanceRecorderSettings::Preset6MergeRadius' has a wrong offset!");
static_assert(offsetof(UAnalyticsPerformanceRecorderSettings, Preset6MergeAction) == 0x000200, "Member 'UAnalyticsPerformanceRecorderSettings::Preset6MergeAction' has a wrong offset!");

// Class SHProto.AnimNotify_SHAkEvent
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_SHAkEvent final : public UAnimNotify
{
public:
	void ProcessNotify(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, const struct FAnimNotifyEventReference& EventReference, const class FString& AttachName, class UAkAudioEvent* AudioEvent, bool bFollow, bool bCreatedComponentDestroyOnFinish, float CreatedComponentOcclusionRefreshInverval) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SHAkEvent">();
	}
	static class UAnimNotify_SHAkEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SHAkEvent>();
	}
};
static_assert(alignof(UAnimNotify_SHAkEvent) == 0x000008, "Wrong alignment on UAnimNotify_SHAkEvent");
static_assert(sizeof(UAnimNotify_SHAkEvent) == 0x000038, "Wrong size on UAnimNotify_SHAkEvent");

// Class SHProto.AnimNotify_SHPlayNiagaraEffect
// 0x0000 (0x00D0 - 0x00D0)
class UAnimNotify_SHPlayNiagaraEffect final : public UAnimNotify_PlayNiagaraEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SHPlayNiagaraEffect">();
	}
	static class UAnimNotify_SHPlayNiagaraEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SHPlayNiagaraEffect>();
	}
};
static_assert(alignof(UAnimNotify_SHPlayNiagaraEffect) == 0x000010, "Wrong alignment on UAnimNotify_SHPlayNiagaraEffect");
static_assert(sizeof(UAnimNotify_SHPlayNiagaraEffect) == 0x0000D0, "Wrong size on UAnimNotify_SHPlayNiagaraEffect");

// Class SHProto.SHCombatPushedInterface
// 0x0000 (0x0028 - 0x0028)
class ISHCombatPushedInterface final : public IInterface
{
public:
	bool CanBePushed();
	bool PushedBy(class AActor* Pusher);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCombatPushedInterface">();
	}
	static class ISHCombatPushedInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHCombatPushedInterface>();
	}
};
static_assert(alignof(ISHCombatPushedInterface) == 0x000008, "Wrong alignment on ISHCombatPushedInterface");
static_assert(sizeof(ISHCombatPushedInterface) == 0x000028, "Wrong size on ISHCombatPushedInterface");

// Class SHProto.AskNewGameSettingsWidget
// 0x0050 (0x03E8 - 0x0398)
class UAskNewGameSettingsWidget : public UAskDialogWidget
{
public:
	class UGameOptionsConfig*                     Config;                                            // 0x0398(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayPresetsConfig*                 Presets;                                           // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Visualization_img;                                 // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x38];                                     // 0x03B0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnHideVisualization();
	void BP_OnShowVisualization(const struct FSettingOptionVisualizationData& Visualization);
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AskNewGameSettingsWidget">();
	}
	static class UAskNewGameSettingsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAskNewGameSettingsWidget>();
	}
};
static_assert(alignof(UAskNewGameSettingsWidget) == 0x000008, "Wrong alignment on UAskNewGameSettingsWidget");
static_assert(sizeof(UAskNewGameSettingsWidget) == 0x0003E8, "Wrong size on UAskNewGameSettingsWidget");
static_assert(offsetof(UAskNewGameSettingsWidget, Config) == 0x000398, "Member 'UAskNewGameSettingsWidget::Config' has a wrong offset!");
static_assert(offsetof(UAskNewGameSettingsWidget, Presets) == 0x0003A0, "Member 'UAskNewGameSettingsWidget::Presets' has a wrong offset!");
static_assert(offsetof(UAskNewGameSettingsWidget, Visualization_img) == 0x0003A8, "Member 'UAskNewGameSettingsWidget::Visualization_img' has a wrong offset!");

// Class SHProto.GameOptionSpinBoxWidget
// 0x0060 (0x0378 - 0x0318)
class UGameOptionSpinBoxWidget : public USettingOptionSpinBoxWidget
{
public:
	EGameOptions                                  Option;                                            // 0x0318(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameOptionsConfig*                     Config;                                            // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayPresetsConfig*                 Presets;                                           // 0x0328(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class URetroModeDataListAsset> RetroModes;                                        // 0x0330(0x0030)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDevelopmentAllowAll;                            // 0x0360(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_361[0x17];                                     // 0x0361(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameOptionSpinBoxWidget">();
	}
	static class UGameOptionSpinBoxWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameOptionSpinBoxWidget>();
	}
};
static_assert(alignof(UGameOptionSpinBoxWidget) == 0x000008, "Wrong alignment on UGameOptionSpinBoxWidget");
static_assert(sizeof(UGameOptionSpinBoxWidget) == 0x000378, "Wrong size on UGameOptionSpinBoxWidget");
static_assert(offsetof(UGameOptionSpinBoxWidget, Option) == 0x000318, "Member 'UGameOptionSpinBoxWidget::Option' has a wrong offset!");
static_assert(offsetof(UGameOptionSpinBoxWidget, Config) == 0x000320, "Member 'UGameOptionSpinBoxWidget::Config' has a wrong offset!");
static_assert(offsetof(UGameOptionSpinBoxWidget, Presets) == 0x000328, "Member 'UGameOptionSpinBoxWidget::Presets' has a wrong offset!");
static_assert(offsetof(UGameOptionSpinBoxWidget, RetroModes) == 0x000330, "Member 'UGameOptionSpinBoxWidget::RetroModes' has a wrong offset!");
static_assert(offsetof(UGameOptionSpinBoxWidget, bIsDevelopmentAllowAll) == 0x000360, "Member 'UGameOptionSpinBoxWidget::bIsDevelopmentAllowAll' has a wrong offset!");

// Class SHProto.GameOptionsConfig
// 0x0018 (0x0048 - 0x0030)
class UGameOptionsConfig final : public UDataAsset
{
public:
	TArray<struct FGameOptionsData>               Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UStringTable*                           StringTable;                                       // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameOptionsConfig">();
	}
	static class UGameOptionsConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameOptionsConfig>();
	}
};
static_assert(alignof(UGameOptionsConfig) == 0x000008, "Wrong alignment on UGameOptionsConfig");
static_assert(sizeof(UGameOptionsConfig) == 0x000048, "Wrong size on UGameOptionsConfig");
static_assert(offsetof(UGameOptionsConfig, Options) == 0x000030, "Member 'UGameOptionsConfig::Options' has a wrong offset!");
static_assert(offsetof(UGameOptionsConfig, StringTable) == 0x000040, "Member 'UGameOptionsConfig::StringTable' has a wrong offset!");

// Class SHProto.SHStressCmbSubcompSettings
// 0x0030 (0x0060 - 0x0030)
class USHStressCmbSubcompSettings final : public UDataAsset
{
public:
	float                                         LevelThreshold_Light;                              // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelThreshold_Medium;                             // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelThreshold_High;                               // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloseEnemyClampRadius;                             // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultReactionChance_Medium;                      // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AkEventReaction_Medium;                            // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultReactionChance_High;                        // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AkEventReaction_High;                              // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHStressCmbSubcompSettings">();
	}
	static class USHStressCmbSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHStressCmbSubcompSettings>();
	}
};
static_assert(alignof(USHStressCmbSubcompSettings) == 0x000008, "Wrong alignment on USHStressCmbSubcompSettings");
static_assert(sizeof(USHStressCmbSubcompSettings) == 0x000060, "Wrong size on USHStressCmbSubcompSettings");
static_assert(offsetof(USHStressCmbSubcompSettings, LevelThreshold_Light) == 0x000030, "Member 'USHStressCmbSubcompSettings::LevelThreshold_Light' has a wrong offset!");
static_assert(offsetof(USHStressCmbSubcompSettings, LevelThreshold_Medium) == 0x000034, "Member 'USHStressCmbSubcompSettings::LevelThreshold_Medium' has a wrong offset!");
static_assert(offsetof(USHStressCmbSubcompSettings, LevelThreshold_High) == 0x000038, "Member 'USHStressCmbSubcompSettings::LevelThreshold_High' has a wrong offset!");
static_assert(offsetof(USHStressCmbSubcompSettings, CloseEnemyClampRadius) == 0x00003C, "Member 'USHStressCmbSubcompSettings::CloseEnemyClampRadius' has a wrong offset!");
static_assert(offsetof(USHStressCmbSubcompSettings, DefaultReactionChance_Medium) == 0x000040, "Member 'USHStressCmbSubcompSettings::DefaultReactionChance_Medium' has a wrong offset!");
static_assert(offsetof(USHStressCmbSubcompSettings, AkEventReaction_Medium) == 0x000048, "Member 'USHStressCmbSubcompSettings::AkEventReaction_Medium' has a wrong offset!");
static_assert(offsetof(USHStressCmbSubcompSettings, DefaultReactionChance_High) == 0x000050, "Member 'USHStressCmbSubcompSettings::DefaultReactionChance_High' has a wrong offset!");
static_assert(offsetof(USHStressCmbSubcompSettings, AkEventReaction_High) == 0x000058, "Member 'USHStressCmbSubcompSettings::AkEventReaction_High' has a wrong offset!");

// Class SHProto.SpawnPointsPanelWidget
// 0x0018 (0x0400 - 0x03E8)
class USpawnPointsPanelWidget final : public UAskNewGameSettingsWidget
{
public:
	class USpawnPointsListWidget*                 SpawnPoints_wdg;                                   // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F0[0x10];                                     // 0x03F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnPointsPanelWidget">();
	}
	static class USpawnPointsPanelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnPointsPanelWidget>();
	}
};
static_assert(alignof(USpawnPointsPanelWidget) == 0x000008, "Wrong alignment on USpawnPointsPanelWidget");
static_assert(sizeof(USpawnPointsPanelWidget) == 0x000400, "Wrong size on USpawnPointsPanelWidget");
static_assert(offsetof(USpawnPointsPanelWidget, SpawnPoints_wdg) == 0x0003E8, "Member 'USpawnPointsPanelWidget::SpawnPoints_wdg' has a wrong offset!");

// Class SHProto.SHCheatManager
// 0x0000 (0x0088 - 0x0088)
class USHCheatManager : public UCheatManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCheatManager">();
	}
	static class USHCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCheatManager>();
	}
};
static_assert(alignof(USHCheatManager) == 0x000008, "Wrong alignment on USHCheatManager");
static_assert(sizeof(USHCheatManager) == 0x000088, "Wrong size on USHCheatManager");

// Class SHProto.SHAsyncLoaderComponent
// 0x0048 (0x00E8 - 0x00A0)
class USHAsyncLoaderComponent final : public UActorComponent
{
public:
	TArray<struct FSHAsyncLoadedObjectCache>      LoadedObjects;                                     // 0x00A0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSHAsyncLoadedObjectCache>      LoadedSolidObjects;                                // 0x00B0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSHAsyncLoadedObjectCache>      LoadedCutsceneObjects;                             // 0x00C0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_AsyncLoader_DumpValues();
	void SHDebug_AsyncLoader_ToggleSpam();
	void SHDebug_AsyncLoader_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAsyncLoaderComponent">();
	}
	static class USHAsyncLoaderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAsyncLoaderComponent>();
	}
};
static_assert(alignof(USHAsyncLoaderComponent) == 0x000008, "Wrong alignment on USHAsyncLoaderComponent");
static_assert(sizeof(USHAsyncLoaderComponent) == 0x0000E8, "Wrong size on USHAsyncLoaderComponent");
static_assert(offsetof(USHAsyncLoaderComponent, LoadedObjects) == 0x0000A0, "Member 'USHAsyncLoaderComponent::LoadedObjects' has a wrong offset!");
static_assert(offsetof(USHAsyncLoaderComponent, LoadedSolidObjects) == 0x0000B0, "Member 'USHAsyncLoaderComponent::LoadedSolidObjects' has a wrong offset!");
static_assert(offsetof(USHAsyncLoaderComponent, LoadedCutsceneObjects) == 0x0000C0, "Member 'USHAsyncLoaderComponent::LoadedCutsceneObjects' has a wrong offset!");

// Class SHProto.SHAnimNotify_PlayAudio
// 0x0000 (0x0038 - 0x0038)
class USHAnimNotify_PlayAudio : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_PlayAudio">();
	}
	static class USHAnimNotify_PlayAudio* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_PlayAudio>();
	}
};
static_assert(alignof(USHAnimNotify_PlayAudio) == 0x000008, "Wrong alignment on USHAnimNotify_PlayAudio");
static_assert(sizeof(USHAnimNotify_PlayAudio) == 0x000038, "Wrong size on USHAnimNotify_PlayAudio");

// Class SHProto.SHCombatSnapInterface
// 0x0000 (0x0028 - 0x0028)
class ISHCombatSnapInterface final : public IInterface
{
public:
	bool CanSnapOnActor() const;
	struct FVector GetSnapLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCombatSnapInterface">();
	}
	static class ISHCombatSnapInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHCombatSnapInterface>();
	}
};
static_assert(alignof(ISHCombatSnapInterface) == 0x000008, "Wrong alignment on ISHCombatSnapInterface");
static_assert(sizeof(ISHCombatSnapInterface) == 0x000028, "Wrong size on ISHCombatSnapInterface");

// Class SHProto.SHAnimNotify_PlayAudioWeapon
// 0x0008 (0x0040 - 0x0038)
class USHAnimNotify_PlayAudioWeapon final : public USHAnimNotify_PlayAudio
{
public:
	class UAkAudioEvent*                          AudioEventToPlay;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_PlayAudioWeapon">();
	}
	static class USHAnimNotify_PlayAudioWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_PlayAudioWeapon>();
	}
};
static_assert(alignof(USHAnimNotify_PlayAudioWeapon) == 0x000008, "Wrong alignment on USHAnimNotify_PlayAudioWeapon");
static_assert(sizeof(USHAnimNotify_PlayAudioWeapon) == 0x000040, "Wrong size on USHAnimNotify_PlayAudioWeapon");
static_assert(offsetof(USHAnimNotify_PlayAudioWeapon, AudioEventToPlay) == 0x000038, "Member 'USHAnimNotify_PlayAudioWeapon::AudioEventToPlay' has a wrong offset!");

// Class SHProto.SHAnimNotify_PlayAudioLadder
// 0x0010 (0x0048 - 0x0038)
class USHAnimNotify_PlayAudioLadder final : public USHAnimNotify_PlayAudio
{
public:
	class UAkAudioEvent*                          AudioEventToPlay;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundPositionSocketName;                           // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_PlayAudioLadder">();
	}
	static class USHAnimNotify_PlayAudioLadder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_PlayAudioLadder>();
	}
};
static_assert(alignof(USHAnimNotify_PlayAudioLadder) == 0x000008, "Wrong alignment on USHAnimNotify_PlayAudioLadder");
static_assert(sizeof(USHAnimNotify_PlayAudioLadder) == 0x000048, "Wrong size on USHAnimNotify_PlayAudioLadder");
static_assert(offsetof(USHAnimNotify_PlayAudioLadder, AudioEventToPlay) == 0x000038, "Member 'USHAnimNotify_PlayAudioLadder::AudioEventToPlay' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_PlayAudioLadder, SoundPositionSocketName) == 0x000040, "Member 'USHAnimNotify_PlayAudioLadder::SoundPositionSocketName' has a wrong offset!");

// Class SHProto.SHFXComponent
// 0x0050 (0x00F0 - 0x00A0)
class USHFXComponent : public UActorComponent
{
public:
	TSet<class USHFXSubcomponent*>                OwnedSubcomponents;                                // 0x00A0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	class USHFXSubcomponent* FindSubcomponentByClass(const TSubclassOf<class USHFXSubcomponent> SubcomponentClass) const;
	bool IsInitialized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXComponent">();
	}
	static class USHFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXComponent>();
	}
};
static_assert(alignof(USHFXComponent) == 0x000008, "Wrong alignment on USHFXComponent");
static_assert(sizeof(USHFXComponent) == 0x0000F0, "Wrong size on USHFXComponent");
static_assert(offsetof(USHFXComponent, OwnedSubcomponents) == 0x0000A0, "Member 'USHFXComponent::OwnedSubcomponents' has a wrong offset!");

// Class SHProto.SHEnemyBaseFXComponent
// 0x0038 (0x0128 - 0x00F0)
class USHEnemyBaseFXComponent : public USHFXComponent
{
public:
	class USHFXBloodPuddleSubcompSettings*        BloodPuddleSettings;                               // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXPenetrateSplashSubcompSettings*    PenetrateSplashSettings;                           // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXSplashPuddleSubcompSettings*       SplashPuddleSettings;                              // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXBleedingSubcompSettings*           BleedingSettings;                                  // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXVisualHPSubcompSettings*           VisualHPSettings;                                  // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXWaterInteractionSubcompSettings*   WaterInteractionSettings;                          // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXRaingWettingSubcompSettings*       RainWettingSettings;                               // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEnemyBaseFXComponent">();
	}
	static class USHEnemyBaseFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEnemyBaseFXComponent>();
	}
};
static_assert(alignof(USHEnemyBaseFXComponent) == 0x000008, "Wrong alignment on USHEnemyBaseFXComponent");
static_assert(sizeof(USHEnemyBaseFXComponent) == 0x000128, "Wrong size on USHEnemyBaseFXComponent");
static_assert(offsetof(USHEnemyBaseFXComponent, BloodPuddleSettings) == 0x0000F0, "Member 'USHEnemyBaseFXComponent::BloodPuddleSettings' has a wrong offset!");
static_assert(offsetof(USHEnemyBaseFXComponent, PenetrateSplashSettings) == 0x0000F8, "Member 'USHEnemyBaseFXComponent::PenetrateSplashSettings' has a wrong offset!");
static_assert(offsetof(USHEnemyBaseFXComponent, SplashPuddleSettings) == 0x000100, "Member 'USHEnemyBaseFXComponent::SplashPuddleSettings' has a wrong offset!");
static_assert(offsetof(USHEnemyBaseFXComponent, BleedingSettings) == 0x000108, "Member 'USHEnemyBaseFXComponent::BleedingSettings' has a wrong offset!");
static_assert(offsetof(USHEnemyBaseFXComponent, VisualHPSettings) == 0x000110, "Member 'USHEnemyBaseFXComponent::VisualHPSettings' has a wrong offset!");
static_assert(offsetof(USHEnemyBaseFXComponent, WaterInteractionSettings) == 0x000118, "Member 'USHEnemyBaseFXComponent::WaterInteractionSettings' has a wrong offset!");
static_assert(offsetof(USHEnemyBaseFXComponent, RainWettingSettings) == 0x000120, "Member 'USHEnemyBaseFXComponent::RainWettingSettings' has a wrong offset!");

// Class SHProto.SHAnimNotify_EnableBonePhysics
// 0x0058 (0x0090 - 0x0038)
class USHAnimNotify_EnableBonePhysics final : public UAnimNotify
{
public:
	TArray<class FName>                           BoneNames;                                         // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ActivateParentBodyLevelsAbove;                     // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSHBonePhysicsPhysicsBlendInput        PhysicsBlend;                                      // 0x004C(0x0014)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          AllowRootPhysics;                                  // 0x0060(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PhysicsIdentifier;                                 // 0x0064(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ApplyLocalForce;                                   // 0x0070(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHAnimNotifyEnableBonePhysicsForceApplicationTarget ForceApplicationTarget;                            // 0x0088(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ApplyForceToChildrenMultiplier;                    // 0x008C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_EnableBonePhysics">();
	}
	static class USHAnimNotify_EnableBonePhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_EnableBonePhysics>();
	}
};
static_assert(alignof(USHAnimNotify_EnableBonePhysics) == 0x000008, "Wrong alignment on USHAnimNotify_EnableBonePhysics");
static_assert(sizeof(USHAnimNotify_EnableBonePhysics) == 0x000090, "Wrong size on USHAnimNotify_EnableBonePhysics");
static_assert(offsetof(USHAnimNotify_EnableBonePhysics, BoneNames) == 0x000038, "Member 'USHAnimNotify_EnableBonePhysics::BoneNames' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_EnableBonePhysics, ActivateParentBodyLevelsAbove) == 0x000048, "Member 'USHAnimNotify_EnableBonePhysics::ActivateParentBodyLevelsAbove' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_EnableBonePhysics, PhysicsBlend) == 0x00004C, "Member 'USHAnimNotify_EnableBonePhysics::PhysicsBlend' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_EnableBonePhysics, AllowRootPhysics) == 0x000060, "Member 'USHAnimNotify_EnableBonePhysics::AllowRootPhysics' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_EnableBonePhysics, PhysicsIdentifier) == 0x000064, "Member 'USHAnimNotify_EnableBonePhysics::PhysicsIdentifier' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_EnableBonePhysics, ApplyLocalForce) == 0x000070, "Member 'USHAnimNotify_EnableBonePhysics::ApplyLocalForce' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_EnableBonePhysics, ForceApplicationTarget) == 0x000088, "Member 'USHAnimNotify_EnableBonePhysics::ForceApplicationTarget' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_EnableBonePhysics, ApplyForceToChildrenMultiplier) == 0x00008C, "Member 'USHAnimNotify_EnableBonePhysics::ApplyForceToChildrenMultiplier' has a wrong offset!");

// Class SHProto.SHAnimNotify_FadeOutBonePhysics
// 0x0010 (0x0048 - 0x0038)
class USHAnimNotify_FadeOutBonePhysics final : public UAnimNotify
{
public:
	float                                         BlendOutTime;                                      // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutCurveBend;                                 // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PhysicsIdentifier;                                 // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_FadeOutBonePhysics">();
	}
	static class USHAnimNotify_FadeOutBonePhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_FadeOutBonePhysics>();
	}
};
static_assert(alignof(USHAnimNotify_FadeOutBonePhysics) == 0x000008, "Wrong alignment on USHAnimNotify_FadeOutBonePhysics");
static_assert(sizeof(USHAnimNotify_FadeOutBonePhysics) == 0x000048, "Wrong size on USHAnimNotify_FadeOutBonePhysics");
static_assert(offsetof(USHAnimNotify_FadeOutBonePhysics, BlendOutTime) == 0x000038, "Member 'USHAnimNotify_FadeOutBonePhysics::BlendOutTime' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_FadeOutBonePhysics, BlendOutCurveBend) == 0x00003C, "Member 'USHAnimNotify_FadeOutBonePhysics::BlendOutCurveBend' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_FadeOutBonePhysics, PhysicsIdentifier) == 0x000040, "Member 'USHAnimNotify_FadeOutBonePhysics::PhysicsIdentifier' has a wrong offset!");

// Class SHProto.SHEndingFactorsStatics
// 0x0000 (0x0028 - 0x0028)
class USHEndingFactorsStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool AddValueBlissEnding(class UObject* WorldContextObject);
	static bool AddValueUFOEndingFactor(class UObject* WorldContextObject);
	static void AddValueWestCityFWMariaRedirectionsCommentsEndingFactor(class UObject* WorldContextObject);
	static bool AllowAddValueBlissEnding(class UObject* WorldContextObject);
	static bool CanPlayBlissEnding(class UObject* WorldContextObject);
	static bool CanPlayUFOEnding(class UObject* WorldContextObject);
	static ESHEndingType GetCurrentEndingType(const class UObject* WorldContextObject);
	static void SetHospitalFWLyingMariaInteractionsEndingFactor(class UObject* WorldContextObject, bool InValue);
	static void SetHotelFWKilledAllDefenselessEnemiesEndingFactor(class UObject* WorldContextObject, bool InValue);
	static void SetHotelFWListenedSickbedConversationEndingFactor(class UObject* WorldContextObject, bool InValue);
	static void SetHotelFWPyramidHeadBossAftermathEndingFactorValue(class UObject* WorldContextObject, ESHHotelFWPyramidHeadBossAftermathEndingFactorValue InValue);
	static void SetHotelOWMirrorPuzzleEndingFactor(class UObject* WorldContextObject, ESHHotelOWMirrorPuzzleEndingFactorValue InValue);
	static void SetLabyrinthMariaRoomsEndingFactor(class UObject* WorldContextObject, bool InValue);
	static void SetNeelysBarMessageEndingFactor(class UObject* WorldContextObject, bool InValue);
	static void SetPrisonGallowPuzzleEndingFactor(class UObject* WorldContextObject, ESHPrisonGallowPuzzleEndingFactorValue InValue);
	static void SetPyramidHeadBossFightOutcomeEndingFactor(class UObject* WorldContextObject, ESHPyramidHeadBossFightOutcomeEndingFactorValue InValue);
	static void SetWestCityFWInteractedAllAtHeavensNightEndingFactor(class UObject* WorldContextObject, bool InValue);
	static void SetWestCityFWMariaInteractionsEndingFactor(class UObject* WorldContextObject, bool InValue);
	static void SetWoodsideCoinPuzzleEndingFactor(class UObject* WorldContextObject, ESHWoodsideCoinPuzzleEndingFactorValue InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEndingFactorsStatics">();
	}
	static class USHEndingFactorsStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEndingFactorsStatics>();
	}
};
static_assert(alignof(USHEndingFactorsStatics) == 0x000008, "Wrong alignment on USHEndingFactorsStatics");
static_assert(sizeof(USHEndingFactorsStatics) == 0x000028, "Wrong size on USHEndingFactorsStatics");

// Class SHProto.BTTask_MBP3WallRun
// 0x0080 (0x00F0 - 0x0070)
class UBTTask_MBP3WallRun final : public UBTTaskNode
{
public:
	struct FGameplayTag                           AnimTag;                                           // 0x0070(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StartingWallIndex;                                 // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxSequences;                                      // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPickRandomIndex;                                  // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayAllSequences;                                 // 0x0081(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_82[0x2];                                       // 0x0082(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndWaitTime;                                       // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomDeviation;                                   // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           MontageStartSections;                              // 0x0090(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           MontageWallSections;                               // 0x00A0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           MontageEndSections;                                // 0x00B0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x30];                                      // 0x00C0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MBP3WallRun">();
	}
	static class UBTTask_MBP3WallRun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MBP3WallRun>();
	}
};
static_assert(alignof(UBTTask_MBP3WallRun) == 0x000008, "Wrong alignment on UBTTask_MBP3WallRun");
static_assert(sizeof(UBTTask_MBP3WallRun) == 0x0000F0, "Wrong size on UBTTask_MBP3WallRun");
static_assert(offsetof(UBTTask_MBP3WallRun, AnimTag) == 0x000070, "Member 'UBTTask_MBP3WallRun::AnimTag' has a wrong offset!");
static_assert(offsetof(UBTTask_MBP3WallRun, StartingWallIndex) == 0x000078, "Member 'UBTTask_MBP3WallRun::StartingWallIndex' has a wrong offset!");
static_assert(offsetof(UBTTask_MBP3WallRun, MaxSequences) == 0x00007C, "Member 'UBTTask_MBP3WallRun::MaxSequences' has a wrong offset!");
static_assert(offsetof(UBTTask_MBP3WallRun, bPickRandomIndex) == 0x000080, "Member 'UBTTask_MBP3WallRun::bPickRandomIndex' has a wrong offset!");
static_assert(offsetof(UBTTask_MBP3WallRun, bPlayAllSequences) == 0x000081, "Member 'UBTTask_MBP3WallRun::bPlayAllSequences' has a wrong offset!");
static_assert(offsetof(UBTTask_MBP3WallRun, EndWaitTime) == 0x000084, "Member 'UBTTask_MBP3WallRun::EndWaitTime' has a wrong offset!");
static_assert(offsetof(UBTTask_MBP3WallRun, RandomDeviation) == 0x000088, "Member 'UBTTask_MBP3WallRun::RandomDeviation' has a wrong offset!");
static_assert(offsetof(UBTTask_MBP3WallRun, MontageStartSections) == 0x000090, "Member 'UBTTask_MBP3WallRun::MontageStartSections' has a wrong offset!");
static_assert(offsetof(UBTTask_MBP3WallRun, MontageWallSections) == 0x0000A0, "Member 'UBTTask_MBP3WallRun::MontageWallSections' has a wrong offset!");
static_assert(offsetof(UBTTask_MBP3WallRun, MontageEndSections) == 0x0000B0, "Member 'UBTTask_MBP3WallRun::MontageEndSections' has a wrong offset!");

// Class SHProto.SHSwarmBase
// 0x00C8 (0x0378 - 0x02B0)
class ASHSwarmBase final : public AActor
{
public:
	class UNiagaraComponent*                      _NiagaraComp;                                      // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHSwarmBoundRegion*                    _MainBoundRegion;                                  // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        _FollowPointsRoot;                                 // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CreeperLifetime;                                   // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CreeperSize;                                       // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnBurst;                                        // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnRate;                                         // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StartSpeed;                                        // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreferMoveThanStand;                               // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      BehaviourStateTime;                                // 0x0300(0x0010)(Edit, BlueprintVisible, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      BehaviourStateSpeed;                               // 0x0310(0x0010)(Edit, BlueprintVisible, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 BehaviourStateAngleCone;                           // 0x0320(0x0010)(Edit, BlueprintVisible, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          DestroyRegionsEnabled;                             // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RegionsFollowEnabled;                              // 0x0331(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RegionFollowIsGlobal;                              // 0x0332(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESwarmFollowType                              RegionFollowType;                                  // 0x0333(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _FlashlightInfluenceEnabled;                       // 0x0334(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _UseCharacterFlashlightParams;                     // 0x0335(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_336[0x2];                                      // 0x0336(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _FlashlightConeInner;                              // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _FlashlightConeOuter;                              // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _FlashlightDistanceRange;                          // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _FlashlightStrengthEffect;                         // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _GunshootRadius;                                   // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _GunshootOriginTime;                               // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _GunshootStrength;                                 // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _GunshootFalloffExp;                               // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ShowDebugInPlayMode;                              // 0x0358(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ASHCharacterPlay*                       _CharacterPlay;                                    // 0x0360(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHFlashlight*                          _FlashlightPtr;                                    // 0x0368(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _SwarmDisabled;                                    // 0x0370(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetValidRegions(TSubclassOf<class USHSwarmRegionBase> RegionClass, TArray<class USHSwarmRegionBase*>* OutComponents, bool RemoveDisabledRegions);
	void InitializeSwarm();
	void OnFlashlightOff();
	void OnFlashlightOn();
	void OnWeaponFireEffect();
	void OnWeaponFireEffectImpl(class USHRangedCmbSubcomp* RangedCombatSubcomponent, class ASHItemWeapon* ItemWeaponContext);
	void RefreshAllRegions();
	void RefreshAllVariables();
	void RefreshBoundRegions();
	void RefreshDestroyRegions();
	void RefreshFollowPoints();
	void RefreshFollowRegions();
	void RefreshReflectRegions();
	void RefreshRegions(const class FName& RegionNiagaraName, const TSubclassOf<class USHSwarmRegionBase> RegionClass);
	void RefreshRegionsSimply(const class FName& RegionNiagaraName, const TSubclassOf<class USHSwarmRegionBase> RegionClass);
	void RefreshSpawnRegions();
	void SetSwarmDisabled(bool IsDisable);
	void ShowAllDebugRegions(bool IsShow);
	void UpdateStateAngleCone(ESwarmCreeperState State, float Angle);
	void UpdateStateParameters();
	void UpdateStateSpeed(ESwarmCreeperState State, const struct FVector2D& Speed);
	void UpdateStateTime(ESwarmCreeperState State, const struct FVector2D& Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSwarmBase">();
	}
	static class ASHSwarmBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHSwarmBase>();
	}
};
static_assert(alignof(ASHSwarmBase) == 0x000008, "Wrong alignment on ASHSwarmBase");
static_assert(sizeof(ASHSwarmBase) == 0x000378, "Wrong size on ASHSwarmBase");
static_assert(offsetof(ASHSwarmBase, _NiagaraComp) == 0x0002B0, "Member 'ASHSwarmBase::_NiagaraComp' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, _MainBoundRegion) == 0x0002B8, "Member 'ASHSwarmBase::_MainBoundRegion' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, _FollowPointsRoot) == 0x0002C0, "Member 'ASHSwarmBase::_FollowPointsRoot' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, CreeperLifetime) == 0x0002C8, "Member 'ASHSwarmBase::CreeperLifetime' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, CreeperSize) == 0x0002D0, "Member 'ASHSwarmBase::CreeperSize' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, SpawnBurst) == 0x0002E0, "Member 'ASHSwarmBase::SpawnBurst' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, SpawnRate) == 0x0002E4, "Member 'ASHSwarmBase::SpawnRate' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, StartSpeed) == 0x0002E8, "Member 'ASHSwarmBase::StartSpeed' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, PreferMoveThanStand) == 0x0002F8, "Member 'ASHSwarmBase::PreferMoveThanStand' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, BehaviourStateTime) == 0x000300, "Member 'ASHSwarmBase::BehaviourStateTime' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, BehaviourStateSpeed) == 0x000310, "Member 'ASHSwarmBase::BehaviourStateSpeed' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, BehaviourStateAngleCone) == 0x000320, "Member 'ASHSwarmBase::BehaviourStateAngleCone' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, DestroyRegionsEnabled) == 0x000330, "Member 'ASHSwarmBase::DestroyRegionsEnabled' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, RegionsFollowEnabled) == 0x000331, "Member 'ASHSwarmBase::RegionsFollowEnabled' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, RegionFollowIsGlobal) == 0x000332, "Member 'ASHSwarmBase::RegionFollowIsGlobal' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, RegionFollowType) == 0x000333, "Member 'ASHSwarmBase::RegionFollowType' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, _FlashlightInfluenceEnabled) == 0x000334, "Member 'ASHSwarmBase::_FlashlightInfluenceEnabled' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, _UseCharacterFlashlightParams) == 0x000335, "Member 'ASHSwarmBase::_UseCharacterFlashlightParams' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, _FlashlightConeInner) == 0x000338, "Member 'ASHSwarmBase::_FlashlightConeInner' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, _FlashlightConeOuter) == 0x00033C, "Member 'ASHSwarmBase::_FlashlightConeOuter' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, _FlashlightDistanceRange) == 0x000340, "Member 'ASHSwarmBase::_FlashlightDistanceRange' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, _FlashlightStrengthEffect) == 0x000344, "Member 'ASHSwarmBase::_FlashlightStrengthEffect' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, _GunshootRadius) == 0x000348, "Member 'ASHSwarmBase::_GunshootRadius' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, _GunshootOriginTime) == 0x00034C, "Member 'ASHSwarmBase::_GunshootOriginTime' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, _GunshootStrength) == 0x000350, "Member 'ASHSwarmBase::_GunshootStrength' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, _GunshootFalloffExp) == 0x000354, "Member 'ASHSwarmBase::_GunshootFalloffExp' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, _ShowDebugInPlayMode) == 0x000358, "Member 'ASHSwarmBase::_ShowDebugInPlayMode' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, _CharacterPlay) == 0x000360, "Member 'ASHSwarmBase::_CharacterPlay' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, _FlashlightPtr) == 0x000368, "Member 'ASHSwarmBase::_FlashlightPtr' has a wrong offset!");
static_assert(offsetof(ASHSwarmBase, _SwarmDisabled) == 0x000370, "Member 'ASHSwarmBase::_SwarmDisabled' has a wrong offset!");

// Class SHProto.AnimNotify_ModifyCombatInputMode
// 0x0058 (0x0090 - 0x0038)
class UAnimNotify_ModifyCombatInputMode final : public UAnimNotify
{
public:
	ESHCombatInputModeEnum                        RequiredInputMode;                                 // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESHModifyCombatInputModeAction, ESHModifyCombatInputModeOperation> Tasks;                                             // 0x0040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ModifyCombatInputMode">();
	}
	static class UAnimNotify_ModifyCombatInputMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ModifyCombatInputMode>();
	}
};
static_assert(alignof(UAnimNotify_ModifyCombatInputMode) == 0x000008, "Wrong alignment on UAnimNotify_ModifyCombatInputMode");
static_assert(sizeof(UAnimNotify_ModifyCombatInputMode) == 0x000090, "Wrong size on UAnimNotify_ModifyCombatInputMode");
static_assert(offsetof(UAnimNotify_ModifyCombatInputMode, RequiredInputMode) == 0x000038, "Member 'UAnimNotify_ModifyCombatInputMode::RequiredInputMode' has a wrong offset!");
static_assert(offsetof(UAnimNotify_ModifyCombatInputMode, Tasks) == 0x000040, "Member 'UAnimNotify_ModifyCombatInputMode::Tasks' has a wrong offset!");

// Class SHProto.SHEndingFactor
// 0x0008 (0x0030 - 0x0028)
class USHEndingFactor : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEndingFactor">();
	}
	static class USHEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEndingFactor>();
	}
};
static_assert(alignof(USHEndingFactor) == 0x000008, "Wrong alignment on USHEndingFactor");
static_assert(sizeof(USHEndingFactor) == 0x000030, "Wrong size on USHEndingFactor");

// Class SHProto.SHBoolEndingFactor
// 0x0058 (0x0088 - 0x0030)
class USHBoolEndingFactor : public USHEndingFactor
{
public:
	TMap<ESHBoolEndingFactorValues, struct FSHEndingScoreChanger> ValueToScoreChangeMap;                             // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          Value;                                             // 0x0080(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBoolEndingFactor">();
	}
	static class USHBoolEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBoolEndingFactor>();
	}
};
static_assert(alignof(USHBoolEndingFactor) == 0x000008, "Wrong alignment on USHBoolEndingFactor");
static_assert(sizeof(USHBoolEndingFactor) == 0x000088, "Wrong size on USHBoolEndingFactor");
static_assert(offsetof(USHBoolEndingFactor, ValueToScoreChangeMap) == 0x000030, "Member 'USHBoolEndingFactor::ValueToScoreChangeMap' has a wrong offset!");
static_assert(offsetof(USHBoolEndingFactor, Value) == 0x000080, "Member 'USHBoolEndingFactor::Value' has a wrong offset!");

// Class SHProto.SHCityOWNeelysBarMessageEndingFactor
// 0x0000 (0x0088 - 0x0088)
class USHCityOWNeelysBarMessageEndingFactor final : public USHBoolEndingFactor
{
public:
	void SHDebug_Character_Endings_CityOWNeelysBarMessageEndingFactor_SetDebugValue(bool InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCityOWNeelysBarMessageEndingFactor">();
	}
	static class USHCityOWNeelysBarMessageEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCityOWNeelysBarMessageEndingFactor>();
	}
};
static_assert(alignof(USHCityOWNeelysBarMessageEndingFactor) == 0x000008, "Wrong alignment on USHCityOWNeelysBarMessageEndingFactor");
static_assert(sizeof(USHCityOWNeelysBarMessageEndingFactor) == 0x000088, "Wrong size on USHCityOWNeelysBarMessageEndingFactor");

// Class SHProto.AnimNotify_AnyAllowOverride
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_AnyAllowOverride final : public UAnimNotify
{
public:
	ESHCombatInputModeEnum                        RequiredInputMode;                                 // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AnyAllowOverride">();
	}
	static class UAnimNotify_AnyAllowOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AnyAllowOverride>();
	}
};
static_assert(alignof(UAnimNotify_AnyAllowOverride) == 0x000008, "Wrong alignment on UAnimNotify_AnyAllowOverride");
static_assert(sizeof(UAnimNotify_AnyAllowOverride) == 0x000040, "Wrong size on UAnimNotify_AnyAllowOverride");
static_assert(offsetof(UAnimNotify_AnyAllowOverride, RequiredInputMode) == 0x000038, "Member 'UAnimNotify_AnyAllowOverride::RequiredInputMode' has a wrong offset!");

// Class SHProto.AnimNotify_HitReactAllowOverride
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_HitReactAllowOverride final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_HitReactAllowOverride">();
	}
	static class UAnimNotify_HitReactAllowOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_HitReactAllowOverride>();
	}
};
static_assert(alignof(UAnimNotify_HitReactAllowOverride) == 0x000008, "Wrong alignment on UAnimNotify_HitReactAllowOverride");
static_assert(sizeof(UAnimNotify_HitReactAllowOverride) == 0x000038, "Wrong size on UAnimNotify_HitReactAllowOverride");

// Class SHProto.SHAimedAtComponent
// 0x0040 (0x00E0 - 0x00A0)
class USHAimedAtComponent : public UActorComponent
{
public:
	bool                                          bIsAlloweedToBeShoot;                              // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanTickWhileNotBeingAimedAt;                      // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAimStarted;                                      // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAimEnded;                                        // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  AimingActor;                                       // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  AimedWithActor;                                    // 0x00D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AimedAtEvent__DelegateSignature();
	void EndBeingAimedAt(class AActor* InAimingActor);
	void ResetAimedAtDuration();
	void StartBeingAimedAt(class AActor* InAimingActor, class AActor* InAimedWithActor);

	class AActor* GetAimedWithActor() const;
	class AActor* GetAimingActor() const;
	float GetBeingAimedAtDuration() const;
	bool IsAlloweedToBeShoot() const;
	bool IsBeingAimedAt() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAimedAtComponent">();
	}
	static class USHAimedAtComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAimedAtComponent>();
	}
};
static_assert(alignof(USHAimedAtComponent) == 0x000008, "Wrong alignment on USHAimedAtComponent");
static_assert(sizeof(USHAimedAtComponent) == 0x0000E0, "Wrong size on USHAimedAtComponent");
static_assert(offsetof(USHAimedAtComponent, bIsAlloweedToBeShoot) == 0x0000A0, "Member 'USHAimedAtComponent::bIsAlloweedToBeShoot' has a wrong offset!");
static_assert(offsetof(USHAimedAtComponent, bCanTickWhileNotBeingAimedAt) == 0x0000A1, "Member 'USHAimedAtComponent::bCanTickWhileNotBeingAimedAt' has a wrong offset!");
static_assert(offsetof(USHAimedAtComponent, OnAimStarted) == 0x0000A8, "Member 'USHAimedAtComponent::OnAimStarted' has a wrong offset!");
static_assert(offsetof(USHAimedAtComponent, OnAimEnded) == 0x0000B8, "Member 'USHAimedAtComponent::OnAimEnded' has a wrong offset!");
static_assert(offsetof(USHAimedAtComponent, AimingActor) == 0x0000C8, "Member 'USHAimedAtComponent::AimingActor' has a wrong offset!");
static_assert(offsetof(USHAimedAtComponent, AimedWithActor) == 0x0000D0, "Member 'USHAimedAtComponent::AimedWithActor' has a wrong offset!");

// Class SHProto.SHEnemyAimedAtCountingComponent
// 0x0000 (0x00E0 - 0x00E0)
class USHEnemyAimedAtCountingComponent final : public USHAimedAtComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEnemyAimedAtCountingComponent">();
	}
	static class USHEnemyAimedAtCountingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEnemyAimedAtCountingComponent>();
	}
};
static_assert(alignof(USHEnemyAimedAtCountingComponent) == 0x000008, "Wrong alignment on USHEnemyAimedAtCountingComponent");
static_assert(sizeof(USHEnemyAimedAtCountingComponent) == 0x0000E0, "Wrong size on USHEnemyAimedAtCountingComponent");

// Class SHProto.AnimNotify_DodgePowerArmourWindow
// 0x0008 (0x0038 - 0x0030)
class UAnimNotify_DodgePowerArmourWindow final : public UAnimNotifyState
{
public:
	bool                                          bLimitToRequiredCombatDifficulty;                  // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECombatDifficulty                             RequiredCombatDifficulty;                          // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DodgePowerArmourWindow">();
	}
	static class UAnimNotify_DodgePowerArmourWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DodgePowerArmourWindow>();
	}
};
static_assert(alignof(UAnimNotify_DodgePowerArmourWindow) == 0x000008, "Wrong alignment on UAnimNotify_DodgePowerArmourWindow");
static_assert(sizeof(UAnimNotify_DodgePowerArmourWindow) == 0x000038, "Wrong size on UAnimNotify_DodgePowerArmourWindow");
static_assert(offsetof(UAnimNotify_DodgePowerArmourWindow, bLimitToRequiredCombatDifficulty) == 0x000030, "Member 'UAnimNotify_DodgePowerArmourWindow::bLimitToRequiredCombatDifficulty' has a wrong offset!");
static_assert(offsetof(UAnimNotify_DodgePowerArmourWindow, RequiredCombatDifficulty) == 0x000031, "Member 'UAnimNotify_DodgePowerArmourWindow::RequiredCombatDifficulty' has a wrong offset!");

// Class SHProto.AnimNotify_InputBufferTimedWindow
// 0x0018 (0x0050 - 0x0038)
class UAnimNotify_InputBufferTimedWindow final : public UAnimNotify
{
public:
	float                                         WindowDuration;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESHInputBufferAction>                  AllowedInputActionsToBuffer;                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_InputBufferTimedWindow">();
	}
	static class UAnimNotify_InputBufferTimedWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_InputBufferTimedWindow>();
	}
};
static_assert(alignof(UAnimNotify_InputBufferTimedWindow) == 0x000008, "Wrong alignment on UAnimNotify_InputBufferTimedWindow");
static_assert(sizeof(UAnimNotify_InputBufferTimedWindow) == 0x000050, "Wrong size on UAnimNotify_InputBufferTimedWindow");
static_assert(offsetof(UAnimNotify_InputBufferTimedWindow, WindowDuration) == 0x000038, "Member 'UAnimNotify_InputBufferTimedWindow::WindowDuration' has a wrong offset!");
static_assert(offsetof(UAnimNotify_InputBufferTimedWindow, AllowedInputActionsToBuffer) == 0x000040, "Member 'UAnimNotify_InputBufferTimedWindow::AllowedInputActionsToBuffer' has a wrong offset!");

// Class SHProto.SHCrosshairWidgetBase
// 0x0020 (0x0298 - 0x0278)
class USHCrosshairWidgetBase : public UUserWidget
{
public:
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x0278(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_280[0x18];                                     // 0x0280(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCrosshairWidgetBase">();
	}
	static class USHCrosshairWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCrosshairWidgetBase>();
	}
};
static_assert(alignof(USHCrosshairWidgetBase) == 0x000008, "Wrong alignment on USHCrosshairWidgetBase");
static_assert(sizeof(USHCrosshairWidgetBase) == 0x000298, "Wrong size on USHCrosshairWidgetBase");
static_assert(offsetof(USHCrosshairWidgetBase, OwnerCharacter) == 0x000278, "Member 'USHCrosshairWidgetBase::OwnerCharacter' has a wrong offset!");

// Class SHProto.SHCrosshairWidget
// 0x01E8 (0x0480 - 0x0298)
class USHCrosshairWidget final : public USHCrosshairWidgetBase
{
public:
	class UImage*                                 CrosshairImage;                                    // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeOutAnim;                                       // 0x02A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeInAnim;                                        // 0x02A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCrosshairAtlasUseInterpolation;                   // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ReticleSize;                                       // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FReticleTextureConfig                  ReticleTextureConfig;                              // 0x02C8(0x00A8)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FReticleTextureConfig                  MinimalReticleTextureConfig;                       // 0x0370(0x00A8)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         AimOpacity;                                        // 0x0418(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FriendlyAimOpacity;                                // 0x041C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               CrosshairDynamicMaterial;                          // 0x0420(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              CurrentlyUsedCrosshairTextureSoft;                 // 0x0428(0x0030)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       CurrentPlayingAnimation;                           // 0x0458(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_460[0x20];                                     // 0x0460(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCrosshairWidget">();
	}
	static class USHCrosshairWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCrosshairWidget>();
	}
};
static_assert(alignof(USHCrosshairWidget) == 0x000008, "Wrong alignment on USHCrosshairWidget");
static_assert(sizeof(USHCrosshairWidget) == 0x000480, "Wrong size on USHCrosshairWidget");
static_assert(offsetof(USHCrosshairWidget, CrosshairImage) == 0x000298, "Member 'USHCrosshairWidget::CrosshairImage' has a wrong offset!");
static_assert(offsetof(USHCrosshairWidget, FadeOutAnim) == 0x0002A0, "Member 'USHCrosshairWidget::FadeOutAnim' has a wrong offset!");
static_assert(offsetof(USHCrosshairWidget, FadeInAnim) == 0x0002A8, "Member 'USHCrosshairWidget::FadeInAnim' has a wrong offset!");
static_assert(offsetof(USHCrosshairWidget, bCrosshairAtlasUseInterpolation) == 0x0002B0, "Member 'USHCrosshairWidget::bCrosshairAtlasUseInterpolation' has a wrong offset!");
static_assert(offsetof(USHCrosshairWidget, ReticleSize) == 0x0002B8, "Member 'USHCrosshairWidget::ReticleSize' has a wrong offset!");
static_assert(offsetof(USHCrosshairWidget, ReticleTextureConfig) == 0x0002C8, "Member 'USHCrosshairWidget::ReticleTextureConfig' has a wrong offset!");
static_assert(offsetof(USHCrosshairWidget, MinimalReticleTextureConfig) == 0x000370, "Member 'USHCrosshairWidget::MinimalReticleTextureConfig' has a wrong offset!");
static_assert(offsetof(USHCrosshairWidget, AimOpacity) == 0x000418, "Member 'USHCrosshairWidget::AimOpacity' has a wrong offset!");
static_assert(offsetof(USHCrosshairWidget, FriendlyAimOpacity) == 0x00041C, "Member 'USHCrosshairWidget::FriendlyAimOpacity' has a wrong offset!");
static_assert(offsetof(USHCrosshairWidget, CrosshairDynamicMaterial) == 0x000420, "Member 'USHCrosshairWidget::CrosshairDynamicMaterial' has a wrong offset!");
static_assert(offsetof(USHCrosshairWidget, CurrentlyUsedCrosshairTextureSoft) == 0x000428, "Member 'USHCrosshairWidget::CurrentlyUsedCrosshairTextureSoft' has a wrong offset!");
static_assert(offsetof(USHCrosshairWidget, CurrentPlayingAnimation) == 0x000458, "Member 'USHCrosshairWidget::CurrentPlayingAnimation' has a wrong offset!");

// Class SHProto.AnimNotify_EquipWeapon
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_EquipWeapon final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EquipWeapon">();
	}
	static class UAnimNotify_EquipWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EquipWeapon>();
	}
};
static_assert(alignof(UAnimNotify_EquipWeapon) == 0x000008, "Wrong alignment on UAnimNotify_EquipWeapon");
static_assert(sizeof(UAnimNotify_EquipWeapon) == 0x000038, "Wrong size on UAnimNotify_EquipWeapon");

// Class SHProto.AnimNotify_UnequipWeapon
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_UnequipWeapon final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_UnequipWeapon">();
	}
	static class UAnimNotify_UnequipWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_UnequipWeapon>();
	}
};
static_assert(alignof(UAnimNotify_UnequipWeapon) == 0x000008, "Wrong alignment on UAnimNotify_UnequipWeapon");
static_assert(sizeof(UAnimNotify_UnequipWeapon) == 0x000038, "Wrong size on UAnimNotify_UnequipWeapon");

// Class SHProto.SHControlTipsPanel
// 0x01B0 (0x0550 - 0x03A0)
class USHControlTipsPanel final : public UControlTipsPanel
{
public:
	class UWidget*                                Main_panel;                                        // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                Background_border;                                 // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            BackgroundBrush;                                   // 0x03B0(0x00D0)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            EmptyBkgrBrush;                                    // 0x0480(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void Hide();
	void Show(const TArray<class FName>& WantedTooltips, bool WithBackground, bool UseVisibilitySettings);
	void ShowBackground(bool Show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHControlTipsPanel">();
	}
	static class USHControlTipsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHControlTipsPanel>();
	}
};
static_assert(alignof(USHControlTipsPanel) == 0x000010, "Wrong alignment on USHControlTipsPanel");
static_assert(sizeof(USHControlTipsPanel) == 0x000550, "Wrong size on USHControlTipsPanel");
static_assert(offsetof(USHControlTipsPanel, Main_panel) == 0x0003A0, "Member 'USHControlTipsPanel::Main_panel' has a wrong offset!");
static_assert(offsetof(USHControlTipsPanel, Background_border) == 0x0003A8, "Member 'USHControlTipsPanel::Background_border' has a wrong offset!");
static_assert(offsetof(USHControlTipsPanel, BackgroundBrush) == 0x0003B0, "Member 'USHControlTipsPanel::BackgroundBrush' has a wrong offset!");
static_assert(offsetof(USHControlTipsPanel, EmptyBkgrBrush) == 0x000480, "Member 'USHControlTipsPanel::EmptyBkgrBrush' has a wrong offset!");

// Class SHProto.AnimNotify_ChangeWeapon
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_ChangeWeapon final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ChangeWeapon">();
	}
	static class UAnimNotify_ChangeWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ChangeWeapon>();
	}
};
static_assert(alignof(UAnimNotify_ChangeWeapon) == 0x000008, "Wrong alignment on UAnimNotify_ChangeWeapon");
static_assert(sizeof(UAnimNotify_ChangeWeapon) == 0x000038, "Wrong size on UAnimNotify_ChangeWeapon");

// Class SHProto.SHAnimSubcomponentBase
// 0x0010 (0x0038 - 0x0028)
class USHAnimSubcomponentBase : public UObject
{
public:
	class ACharacter*                             OwnerCharacter;                                    // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAnimComponent*                       OwnerComponent;                                    // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimSubcomponentBase">();
	}
	static class USHAnimSubcomponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimSubcomponentBase>();
	}
};
static_assert(alignof(USHAnimSubcomponentBase) == 0x000008, "Wrong alignment on USHAnimSubcomponentBase");
static_assert(sizeof(USHAnimSubcomponentBase) == 0x000038, "Wrong size on USHAnimSubcomponentBase");
static_assert(offsetof(USHAnimSubcomponentBase, OwnerCharacter) == 0x000028, "Member 'USHAnimSubcomponentBase::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHAnimSubcomponentBase, OwnerComponent) == 0x000030, "Member 'USHAnimSubcomponentBase::OwnerComponent' has a wrong offset!");

// Class SHProto.SHRagDollSubcomp
// 0x0088 (0x00C0 - 0x0038)
class USHRagDollSubcomp final : public USHAnimSubcomponentBase
{
public:
	struct FSHRagDollSubcompSettings              RagDollSettings;                                   // 0x0038(0x0038)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x50];                                      // 0x0070(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHRagDollSubcomp">();
	}
	static class USHRagDollSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHRagDollSubcomp>();
	}
};
static_assert(alignof(USHRagDollSubcomp) == 0x000008, "Wrong alignment on USHRagDollSubcomp");
static_assert(sizeof(USHRagDollSubcomp) == 0x0000C0, "Wrong size on USHRagDollSubcomp");
static_assert(offsetof(USHRagDollSubcomp, RagDollSettings) == 0x000038, "Member 'USHRagDollSubcomp::RagDollSettings' has a wrong offset!");

// Class SHProto.AnimNotify_MeleeAttackCheck
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_MeleeAttackCheck final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_MeleeAttackCheck">();
	}
	static class UAnimNotify_MeleeAttackCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_MeleeAttackCheck>();
	}
};
static_assert(alignof(UAnimNotify_MeleeAttackCheck) == 0x000008, "Wrong alignment on UAnimNotify_MeleeAttackCheck");
static_assert(sizeof(UAnimNotify_MeleeAttackCheck) == 0x000038, "Wrong size on UAnimNotify_MeleeAttackCheck");

// Class SHProto.SHLookAtTargetScoreFunction
// 0x0000 (0x0028 - 0x0028)
class USHLookAtTargetScoreFunction final : public UObject
{
public:
	class AActor* GetActorFromTarget(const struct FSHLookAtTarget& LookAtTarget) const;
	class ACharacter* GetCharacter() const;
	int32 GetDefaultLookAtTargetScore(const struct FSHLookAtTarget& LookAtTarget) const;
	int32 GetLookAtTargetScore(const struct FSHLookAtTarget& LookAtTarget) const;
	struct FVector2D GetTargetActorAngleDeltas(const struct FSHLookAtTarget& LookAtTarget) const;
	float GetTargetActortDistance(const struct FSHLookAtTarget& LookAtTarget) const;
	struct FVector2D GetTargetComponentAngleDeltas(const struct FSHLookAtTarget& LookAtTarget) const;
	float GetTargetComponentDistance(const struct FSHLookAtTarget& LookAtTarget) const;
	bool IsLookAtTargetValid(const struct FSHLookAtTarget& LookAtTarget) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLookAtTargetScoreFunction">();
	}
	static class USHLookAtTargetScoreFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLookAtTargetScoreFunction>();
	}
};
static_assert(alignof(USHLookAtTargetScoreFunction) == 0x000008, "Wrong alignment on USHLookAtTargetScoreFunction");
static_assert(sizeof(USHLookAtTargetScoreFunction) == 0x000028, "Wrong size on USHLookAtTargetScoreFunction");

// Class SHProto.SHStatisticsValueProcessor
// 0x0008 (0x0030 - 0x0028)
class USHStatisticsValueProcessor : public UObject
{
public:
	class USHCharacterPlayStatisticsComponent*    OwnerComponent;                                    // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHStatisticsValueProcessor">();
	}
	static class USHStatisticsValueProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHStatisticsValueProcessor>();
	}
};
static_assert(alignof(USHStatisticsValueProcessor) == 0x000008, "Wrong alignment on USHStatisticsValueProcessor");
static_assert(sizeof(USHStatisticsValueProcessor) == 0x000030, "Wrong size on USHStatisticsValueProcessor");
static_assert(offsetof(USHStatisticsValueProcessor, OwnerComponent) == 0x000028, "Member 'USHStatisticsValueProcessor::OwnerComponent' has a wrong offset!");

// Class SHProto.SHCombatStatisticsValueProcessor
// 0x0070 (0x00A0 - 0x0030)
class USHCombatStatisticsValueProcessor final : public USHStatisticsValueProcessor
{
public:
	int32                                         MeleeWeaponKillcount;                              // 0x0030(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RangedWeaponKillcount;                             // 0x0034(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RangedShootsFired;                                 // 0x0038(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PerformedDodges;                                   // 0x003C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BrokenGlass;                                       // 0x0040(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HealsApplied;                                      // 0x0044(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReceivedDamage;                                    // 0x0048(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, int32>                      WeaponToKillsMap;                                  // 0x0050(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)

public:
	void ProcessRangedFireSuccess(class USHRangedCmbSubcomp* RangedCombatSubcomponent, class ASHItemWeapon* ItemWeaponContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCombatStatisticsValueProcessor">();
	}
	static class USHCombatStatisticsValueProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCombatStatisticsValueProcessor>();
	}
};
static_assert(alignof(USHCombatStatisticsValueProcessor) == 0x000008, "Wrong alignment on USHCombatStatisticsValueProcessor");
static_assert(sizeof(USHCombatStatisticsValueProcessor) == 0x0000A0, "Wrong size on USHCombatStatisticsValueProcessor");
static_assert(offsetof(USHCombatStatisticsValueProcessor, MeleeWeaponKillcount) == 0x000030, "Member 'USHCombatStatisticsValueProcessor::MeleeWeaponKillcount' has a wrong offset!");
static_assert(offsetof(USHCombatStatisticsValueProcessor, RangedWeaponKillcount) == 0x000034, "Member 'USHCombatStatisticsValueProcessor::RangedWeaponKillcount' has a wrong offset!");
static_assert(offsetof(USHCombatStatisticsValueProcessor, RangedShootsFired) == 0x000038, "Member 'USHCombatStatisticsValueProcessor::RangedShootsFired' has a wrong offset!");
static_assert(offsetof(USHCombatStatisticsValueProcessor, PerformedDodges) == 0x00003C, "Member 'USHCombatStatisticsValueProcessor::PerformedDodges' has a wrong offset!");
static_assert(offsetof(USHCombatStatisticsValueProcessor, BrokenGlass) == 0x000040, "Member 'USHCombatStatisticsValueProcessor::BrokenGlass' has a wrong offset!");
static_assert(offsetof(USHCombatStatisticsValueProcessor, HealsApplied) == 0x000044, "Member 'USHCombatStatisticsValueProcessor::HealsApplied' has a wrong offset!");
static_assert(offsetof(USHCombatStatisticsValueProcessor, ReceivedDamage) == 0x000048, "Member 'USHCombatStatisticsValueProcessor::ReceivedDamage' has a wrong offset!");
static_assert(offsetof(USHCombatStatisticsValueProcessor, WeaponToKillsMap) == 0x000050, "Member 'USHCombatStatisticsValueProcessor::WeaponToKillsMap' has a wrong offset!");

// Class SHProto.AnimNotify_BlendOutMeleeCamera
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_BlendOutMeleeCamera final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_BlendOutMeleeCamera">();
	}
	static class UAnimNotify_BlendOutMeleeCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_BlendOutMeleeCamera>();
	}
};
static_assert(alignof(UAnimNotify_BlendOutMeleeCamera) == 0x000008, "Wrong alignment on UAnimNotify_BlendOutMeleeCamera");
static_assert(sizeof(UAnimNotify_BlendOutMeleeCamera) == 0x000038, "Wrong size on UAnimNotify_BlendOutMeleeCamera");

// Class SHProto.SHLabyrinthMariaRoomsEndingFactor
// 0x0000 (0x0088 - 0x0088)
class USHLabyrinthMariaRoomsEndingFactor final : public USHBoolEndingFactor
{
public:
	void SHDebug_Character_Endings_LabyrinthMariaRoomsEndingFactor_SetDebugValue(bool InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLabyrinthMariaRoomsEndingFactor">();
	}
	static class USHLabyrinthMariaRoomsEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLabyrinthMariaRoomsEndingFactor>();
	}
};
static_assert(alignof(USHLabyrinthMariaRoomsEndingFactor) == 0x000008, "Wrong alignment on USHLabyrinthMariaRoomsEndingFactor");
static_assert(sizeof(USHLabyrinthMariaRoomsEndingFactor) == 0x000088, "Wrong size on USHLabyrinthMariaRoomsEndingFactor");

// Class SHProto.AnimNotify_MeleeAttackComboWindow
// 0x0000 (0x0030 - 0x0030)
class UAnimNotify_MeleeAttackComboWindow final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_MeleeAttackComboWindow">();
	}
	static class UAnimNotify_MeleeAttackComboWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_MeleeAttackComboWindow>();
	}
};
static_assert(alignof(UAnimNotify_MeleeAttackComboWindow) == 0x000008, "Wrong alignment on UAnimNotify_MeleeAttackComboWindow");
static_assert(sizeof(UAnimNotify_MeleeAttackComboWindow) == 0x000030, "Wrong size on UAnimNotify_MeleeAttackComboWindow");

// Class SHProto.SHCreeperLocomotionAnimInstance
// 0x0040 (0x03F0 - 0x03B0)
class USHCreeperLocomotionAnimInstance final : public USHMonsterLocomotionAnimInstance
{
public:
	ESHCreeperAnimInstanceLocomotionState         LocomotionStateRequest;                            // 0x03A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveChangeLegOnGround;                             // 0x03AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveChangeStrafeAngle;                             // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeed;                                     // 0x03B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeAngle;                                       // 0x03B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredStrafeAngle;                                // 0x03BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubgoalDistanceForStraightMovement;                // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceMinAngleInFastMovement;                 // 0x03C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceAngle;                                  // 0x03C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementTypeFlipIntervalMin;                       // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementTypeFlipIntervalMax;                       // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsWalkingStraight;                                 // 0x03D4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsNearSubgoal;                                     // 0x03D5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D6[0x2];                                      // 0x03D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           MovementTypeFlipTimer;                             // 0x03D8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0x10];                                     // 0x03E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CacheTurnInPlaceAngle();
	void GetDesiredVelocitySizeAndYaw(float* OutVectorSize, float* OutVectorYaw, float Smoothing);

	class USHCreeperAnimInstanceStateData* GetCreeperAnimInstanceStateData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCreeperLocomotionAnimInstance">();
	}
	static class USHCreeperLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCreeperLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHCreeperLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHCreeperLocomotionAnimInstance");
static_assert(sizeof(USHCreeperLocomotionAnimInstance) == 0x0003F0, "Wrong size on USHCreeperLocomotionAnimInstance");
static_assert(offsetof(USHCreeperLocomotionAnimInstance, LocomotionStateRequest) == 0x0003A8, "Member 'USHCreeperLocomotionAnimInstance::LocomotionStateRequest' has a wrong offset!");
static_assert(offsetof(USHCreeperLocomotionAnimInstance, MoveChangeLegOnGround) == 0x0003AC, "Member 'USHCreeperLocomotionAnimInstance::MoveChangeLegOnGround' has a wrong offset!");
static_assert(offsetof(USHCreeperLocomotionAnimInstance, MoveChangeStrafeAngle) == 0x0003B0, "Member 'USHCreeperLocomotionAnimInstance::MoveChangeStrafeAngle' has a wrong offset!");
static_assert(offsetof(USHCreeperLocomotionAnimInstance, MovementSpeed) == 0x0003B4, "Member 'USHCreeperLocomotionAnimInstance::MovementSpeed' has a wrong offset!");
static_assert(offsetof(USHCreeperLocomotionAnimInstance, StrafeAngle) == 0x0003B8, "Member 'USHCreeperLocomotionAnimInstance::StrafeAngle' has a wrong offset!");
static_assert(offsetof(USHCreeperLocomotionAnimInstance, DesiredStrafeAngle) == 0x0003BC, "Member 'USHCreeperLocomotionAnimInstance::DesiredStrafeAngle' has a wrong offset!");
static_assert(offsetof(USHCreeperLocomotionAnimInstance, SubgoalDistanceForStraightMovement) == 0x0003C0, "Member 'USHCreeperLocomotionAnimInstance::SubgoalDistanceForStraightMovement' has a wrong offset!");
static_assert(offsetof(USHCreeperLocomotionAnimInstance, TurnInPlaceMinAngleInFastMovement) == 0x0003C4, "Member 'USHCreeperLocomotionAnimInstance::TurnInPlaceMinAngleInFastMovement' has a wrong offset!");
static_assert(offsetof(USHCreeperLocomotionAnimInstance, TurnInPlaceAngle) == 0x0003C8, "Member 'USHCreeperLocomotionAnimInstance::TurnInPlaceAngle' has a wrong offset!");
static_assert(offsetof(USHCreeperLocomotionAnimInstance, MovementTypeFlipIntervalMin) == 0x0003CC, "Member 'USHCreeperLocomotionAnimInstance::MovementTypeFlipIntervalMin' has a wrong offset!");
static_assert(offsetof(USHCreeperLocomotionAnimInstance, MovementTypeFlipIntervalMax) == 0x0003D0, "Member 'USHCreeperLocomotionAnimInstance::MovementTypeFlipIntervalMax' has a wrong offset!");
static_assert(offsetof(USHCreeperLocomotionAnimInstance, IsWalkingStraight) == 0x0003D4, "Member 'USHCreeperLocomotionAnimInstance::IsWalkingStraight' has a wrong offset!");
static_assert(offsetof(USHCreeperLocomotionAnimInstance, IsNearSubgoal) == 0x0003D5, "Member 'USHCreeperLocomotionAnimInstance::IsNearSubgoal' has a wrong offset!");
static_assert(offsetof(USHCreeperLocomotionAnimInstance, MovementTypeFlipTimer) == 0x0003D8, "Member 'USHCreeperLocomotionAnimInstance::MovementTypeFlipTimer' has a wrong offset!");

// Class SHProto.SHHitReactionMaps
// 0x0140 (0x0170 - 0x0030)
class USHHitReactionMaps final : public UDataAsset
{
public:
	TMap<TSubclassOf<class UDamageType>, struct FPlayAnimationData> SoftDamageHitReactions;                            // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UDamageType>, struct FPlayAnimationData> ContinuousDamageHitReactions;                      // 0x0080(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UDamageType>, struct FPlayAnimationData> StunDamageHitReactions;                            // 0x00D0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UDamageType>, struct FSHSlideActionDataStruct> HitReactions;                                      // 0x0120(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHitReactionMaps">();
	}
	static class USHHitReactionMaps* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHHitReactionMaps>();
	}
};
static_assert(alignof(USHHitReactionMaps) == 0x000008, "Wrong alignment on USHHitReactionMaps");
static_assert(sizeof(USHHitReactionMaps) == 0x000170, "Wrong size on USHHitReactionMaps");
static_assert(offsetof(USHHitReactionMaps, SoftDamageHitReactions) == 0x000030, "Member 'USHHitReactionMaps::SoftDamageHitReactions' has a wrong offset!");
static_assert(offsetof(USHHitReactionMaps, ContinuousDamageHitReactions) == 0x000080, "Member 'USHHitReactionMaps::ContinuousDamageHitReactions' has a wrong offset!");
static_assert(offsetof(USHHitReactionMaps, StunDamageHitReactions) == 0x0000D0, "Member 'USHHitReactionMaps::StunDamageHitReactions' has a wrong offset!");
static_assert(offsetof(USHHitReactionMaps, HitReactions) == 0x000120, "Member 'USHHitReactionMaps::HitReactions' has a wrong offset!");

// Class SHProto.AnimNotify_ReloadFillWeaponClip
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_ReloadFillWeaponClip final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ReloadFillWeaponClip">();
	}
	static class UAnimNotify_ReloadFillWeaponClip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ReloadFillWeaponClip>();
	}
};
static_assert(alignof(UAnimNotify_ReloadFillWeaponClip) == 0x000008, "Wrong alignment on UAnimNotify_ReloadFillWeaponClip");
static_assert(sizeof(UAnimNotify_ReloadFillWeaponClip) == 0x000038, "Wrong size on UAnimNotify_ReloadFillWeaponClip");

// Class SHProto.SHIntEndingFactor
// 0x0058 (0x0088 - 0x0030)
class USHIntEndingFactor : public USHEndingFactor
{
public:
	TMap<struct FSHIntCondition, struct FSHEndingScoreChanger> ConditionToScoreChangeMap;                         // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0080(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHIntEndingFactor">();
	}
	static class USHIntEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHIntEndingFactor>();
	}
};
static_assert(alignof(USHIntEndingFactor) == 0x000008, "Wrong alignment on USHIntEndingFactor");
static_assert(sizeof(USHIntEndingFactor) == 0x000088, "Wrong size on USHIntEndingFactor");
static_assert(offsetof(USHIntEndingFactor, ConditionToScoreChangeMap) == 0x000030, "Member 'USHIntEndingFactor::ConditionToScoreChangeMap' has a wrong offset!");
static_assert(offsetof(USHIntEndingFactor, Value) == 0x000080, "Member 'USHIntEndingFactor::Value' has a wrong offset!");

// Class SHProto.SHWestCityFWMariaRedirectionsCommentsEndingFactor
// 0x0000 (0x0088 - 0x0088)
class USHWestCityFWMariaRedirectionsCommentsEndingFactor final : public USHIntEndingFactor
{
public:
	void SHDebug_Character_Endings_WestCityFWMariaRedirectionsCommentsEndingFactor_SetDebugValue(int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHWestCityFWMariaRedirectionsCommentsEndingFactor">();
	}
	static class USHWestCityFWMariaRedirectionsCommentsEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHWestCityFWMariaRedirectionsCommentsEndingFactor>();
	}
};
static_assert(alignof(USHWestCityFWMariaRedirectionsCommentsEndingFactor) == 0x000008, "Wrong alignment on USHWestCityFWMariaRedirectionsCommentsEndingFactor");
static_assert(sizeof(USHWestCityFWMariaRedirectionsCommentsEndingFactor) == 0x000088, "Wrong size on USHWestCityFWMariaRedirectionsCommentsEndingFactor");

// Class SHProto.AnimNotify_ReloadLoopEndCheck
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_ReloadLoopEndCheck final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ReloadLoopEndCheck">();
	}
	static class UAnimNotify_ReloadLoopEndCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ReloadLoopEndCheck>();
	}
};
static_assert(alignof(UAnimNotify_ReloadLoopEndCheck) == 0x000008, "Wrong alignment on UAnimNotify_ReloadLoopEndCheck");
static_assert(sizeof(UAnimNotify_ReloadLoopEndCheck) == 0x000038, "Wrong size on UAnimNotify_ReloadLoopEndCheck");

// Class SHProto.AnimNotify_SingleActionPrepareReady
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_SingleActionPrepareReady final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SingleActionPrepareReady">();
	}
	static class UAnimNotify_SingleActionPrepareReady* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SingleActionPrepareReady>();
	}
};
static_assert(alignof(UAnimNotify_SingleActionPrepareReady) == 0x000008, "Wrong alignment on UAnimNotify_SingleActionPrepareReady");
static_assert(sizeof(UAnimNotify_SingleActionPrepareReady) == 0x000038, "Wrong size on UAnimNotify_SingleActionPrepareReady");

// Class SHProto.SHCustomDecalComponent
// 0x0058 (0x00F8 - 0x00A0)
class USHCustomDecalComponent final : public UActorComponent
{
public:
	TMap<class UMeshComponent*, struct FCustomDecalMeshHits> ManagedMeshesHits;                                 // 0x00A0(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCustomDecalComponent">();
	}
	static class USHCustomDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCustomDecalComponent>();
	}
};
static_assert(alignof(USHCustomDecalComponent) == 0x000008, "Wrong alignment on USHCustomDecalComponent");
static_assert(sizeof(USHCustomDecalComponent) == 0x0000F8, "Wrong size on USHCustomDecalComponent");
static_assert(offsetof(USHCustomDecalComponent, ManagedMeshesHits) == 0x0000A0, "Member 'USHCustomDecalComponent::ManagedMeshesHits' has a wrong offset!");

// Class SHProto.AnimNotify_DoorLocked
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_DoorLocked final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DoorLocked">();
	}
	static class UAnimNotify_DoorLocked* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DoorLocked>();
	}
};
static_assert(alignof(UAnimNotify_DoorLocked) == 0x000008, "Wrong alignment on UAnimNotify_DoorLocked");
static_assert(sizeof(UAnimNotify_DoorLocked) == 0x000038, "Wrong size on UAnimNotify_DoorLocked");

// Class SHProto.SHReceiveDamageCmbSubcomp
// 0x0078 (0x00B0 - 0x0038)
class USHReceiveDamageCmbSubcomp final : public USHCombatSubcomponentBase
{
public:
	uint8                                         Pad_38[0x78];                                      // 0x0038(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReceiveDamageEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	float ReceiveDamage(float DamageValue, const class UObject* Object, const struct FVector& HitDirection, const TSubclassOf<class UDamageType>& DamageType);
	void SetReceiveContinuousDamageBlocked(const bool Blocked, const class UObject* Object);
	void SetReceiveSoftDamageBlocked(const bool Blocked, const class UObject* Object);
	void SetReceiveStunDamageBlocked(const bool Blocked, const class UObject* Object);
	bool SynchroReceiveDamage(const class UObject* Object, const struct FPlayAnimationData& AnimData);

	bool IsReceiveContinuousDamageBlocked() const;
	bool IsReceiveSoftDamageBlocked() const;
	bool IsReceiveStunDamageBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHReceiveDamageCmbSubcomp">();
	}
	static class USHReceiveDamageCmbSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHReceiveDamageCmbSubcomp>();
	}
};
static_assert(alignof(USHReceiveDamageCmbSubcomp) == 0x000008, "Wrong alignment on USHReceiveDamageCmbSubcomp");
static_assert(sizeof(USHReceiveDamageCmbSubcomp) == 0x0000B0, "Wrong size on USHReceiveDamageCmbSubcomp");

// Class SHProto.AnimNotify_DoorUnlock
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_DoorUnlock final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DoorUnlock">();
	}
	static class UAnimNotify_DoorUnlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DoorUnlock>();
	}
};
static_assert(alignof(UAnimNotify_DoorUnlock) == 0x000008, "Wrong alignment on UAnimNotify_DoorUnlock");
static_assert(sizeof(UAnimNotify_DoorUnlock) == 0x000038, "Wrong size on UAnimNotify_DoorUnlock");

// Class SHProto.SHLocomotionAnimInstance
// 0x01A0 (0x04F0 - 0x0350)
#pragma pack(push, 0x1)
class alignas(0x10) USHLocomotionAnimInstance : public UAnimInstance
{
public:
	ELocomotionState                              LocomotionState;                                   // 0x0348(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFullBodyAnimation;                                // 0x0349(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34A[0x6];                                      // 0x034A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAnimationMovementSpeed>        AnimationsMovementSpeed;                           // 0x0350(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVector                                Velocity;                                          // 0x0360(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Speed;                                             // 0x0378(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VelocityRelative;                                  // 0x0380(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MoveXYCurrent;                                     // 0x0398(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedXY;                                           // 0x03A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveXYAngle;                                       // 0x03AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveDirection;                                     // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          StopImmediatelyRequested;                          // 0x03B4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          StartImmediatelyRequested;                         // 0x03B5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          PlayStopAnimationRequested;                        // 0x03B6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B7[0x1];                                      // 0x03B7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StopAnimationMoveDirection;                        // 0x03B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Lean;                                              // 0x03C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeanInterpSpeed;                                   // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeanMaxSpeedValue;                                 // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              IdleCustomCoolDownRandomRange;                     // 0x03D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIdleCustomPlayRequested;                          // 0x03E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FObstacleForwardCheckSettings          ObstacleForwardCheckSettings;                      // 0x03F0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         PelvisOffsetInterpSpeed;                           // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FeetIKLockInterpSpeed;                             // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseMoveDirectionDeadZonesMapping;                  // 0x0420(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDeadZoneRange>                 MoveDirectionDeadZonesMapping;                     // 0x0428(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         StateWeight_Move;                                  // 0x0438(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StateWeight_IdleLoop;                              // 0x043C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimTimeRemaining_IdleCustom;                      // 0x0440(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_444[0xA4];                                     // 0x0444(0x00A4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIdleCustomEnter();
	void OnIdleCustomExit();
	void OnIdleCustomStateUpdate(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnIdleEnter();
	void OnIdleExit();
	void OnIdleLoopEnter();
	void OnIdleLoopExit();
	void OnIdleLoopStateUpdate(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnMoveEnter();
	void OnMoveExit();
	void OnMoveStateUpdate(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStopEnter();
	void SetForcedCloseToWallState(bool Enabled, class UObject* RequestOwner);

	float GetControlRotationYawDelta() const;
	ESHMovementProfile GetCurrentMovementProfile() const;
	class ASHItemWeapon* GetEquippedWeapon() const;
	bool GetForcedCloseToWallState() const;
	ESHHealthStateEnum GetHealthState() const;
	ESHInteriorExteriorStateEnum GetInteriorExteriorState() const;
	float GetMoveDirection() const;
	float GetQuantizedMoveDirection() const;
	bool HasMovementInput() const;
	bool HasValidLookAtTarget() const;
	bool IsCloseToEnemy() const;
	bool IsCloseToWall() const;
	bool IsInDangerMode() const;
	bool IsInWater() const;
	bool IsMoving() const;
	bool IsObstacleDetected() const;
	bool IsSprinting(bool OverrideIfInWater) const;
	bool IsSprinting_WaterOverride() const;
	bool NotShouldMove() const;
	bool Rule_IdleCustomToIdleDefault() const;
	bool Rule_IdleDefaultToIdleCustom() const;
	bool Rule_RunToWalk() const;
	bool Rule_WalkToRun() const;
	bool ShouldMove() const;
	bool ShouldProcessRotateInPlace() const;
	float TryGetCurrentStateWeight(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLocomotionAnimInstance">();
	}
	static class USHLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLocomotionAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(USHLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHLocomotionAnimInstance");
static_assert(sizeof(USHLocomotionAnimInstance) == 0x0004F0, "Wrong size on USHLocomotionAnimInstance");
static_assert(offsetof(USHLocomotionAnimInstance, LocomotionState) == 0x000348, "Member 'USHLocomotionAnimInstance::LocomotionState' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, bFullBodyAnimation) == 0x000349, "Member 'USHLocomotionAnimInstance::bFullBodyAnimation' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, AnimationsMovementSpeed) == 0x000350, "Member 'USHLocomotionAnimInstance::AnimationsMovementSpeed' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, Velocity) == 0x000360, "Member 'USHLocomotionAnimInstance::Velocity' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, Speed) == 0x000378, "Member 'USHLocomotionAnimInstance::Speed' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, VelocityRelative) == 0x000380, "Member 'USHLocomotionAnimInstance::VelocityRelative' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, MoveXYCurrent) == 0x000398, "Member 'USHLocomotionAnimInstance::MoveXYCurrent' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, SpeedXY) == 0x0003A8, "Member 'USHLocomotionAnimInstance::SpeedXY' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, MoveXYAngle) == 0x0003AC, "Member 'USHLocomotionAnimInstance::MoveXYAngle' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, MoveDirection) == 0x0003B0, "Member 'USHLocomotionAnimInstance::MoveDirection' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, StopImmediatelyRequested) == 0x0003B4, "Member 'USHLocomotionAnimInstance::StopImmediatelyRequested' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, StartImmediatelyRequested) == 0x0003B5, "Member 'USHLocomotionAnimInstance::StartImmediatelyRequested' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, PlayStopAnimationRequested) == 0x0003B6, "Member 'USHLocomotionAnimInstance::PlayStopAnimationRequested' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, StopAnimationMoveDirection) == 0x0003B8, "Member 'USHLocomotionAnimInstance::StopAnimationMoveDirection' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, Lean) == 0x0003C0, "Member 'USHLocomotionAnimInstance::Lean' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, LeanInterpSpeed) == 0x0003D0, "Member 'USHLocomotionAnimInstance::LeanInterpSpeed' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, LeanMaxSpeedValue) == 0x0003D4, "Member 'USHLocomotionAnimInstance::LeanMaxSpeedValue' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, IdleCustomCoolDownRandomRange) == 0x0003D8, "Member 'USHLocomotionAnimInstance::IdleCustomCoolDownRandomRange' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, bIdleCustomPlayRequested) == 0x0003E8, "Member 'USHLocomotionAnimInstance::bIdleCustomPlayRequested' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, ObstacleForwardCheckSettings) == 0x0003F0, "Member 'USHLocomotionAnimInstance::ObstacleForwardCheckSettings' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, PelvisOffsetInterpSpeed) == 0x000418, "Member 'USHLocomotionAnimInstance::PelvisOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, FeetIKLockInterpSpeed) == 0x00041C, "Member 'USHLocomotionAnimInstance::FeetIKLockInterpSpeed' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, UseMoveDirectionDeadZonesMapping) == 0x000420, "Member 'USHLocomotionAnimInstance::UseMoveDirectionDeadZonesMapping' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, MoveDirectionDeadZonesMapping) == 0x000428, "Member 'USHLocomotionAnimInstance::MoveDirectionDeadZonesMapping' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, StateWeight_Move) == 0x000438, "Member 'USHLocomotionAnimInstance::StateWeight_Move' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, StateWeight_IdleLoop) == 0x00043C, "Member 'USHLocomotionAnimInstance::StateWeight_IdleLoop' has a wrong offset!");
static_assert(offsetof(USHLocomotionAnimInstance, AnimTimeRemaining_IdleCustom) == 0x000440, "Member 'USHLocomotionAnimInstance::AnimTimeRemaining_IdleCustom' has a wrong offset!");

// Class SHProto.AnimNotify_DoorHandIKStart
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_DoorHandIKStart final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DoorHandIKStart">();
	}
	static class UAnimNotify_DoorHandIKStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DoorHandIKStart>();
	}
};
static_assert(alignof(UAnimNotify_DoorHandIKStart) == 0x000008, "Wrong alignment on UAnimNotify_DoorHandIKStart");
static_assert(sizeof(UAnimNotify_DoorHandIKStart) == 0x000038, "Wrong size on UAnimNotify_DoorHandIKStart");

// Class SHProto.SHCustomSaveStatics
// 0x0000 (0x0028 - 0x0028)
class USHCustomSaveStatics final : public UBlueprintFunctionLibrary
{
public:
	static int32 CountUniqueSeenEndings(const class UObject* WorldContextObject);
	static void FetchActorSavedPropertyBoolValue(const class UObject* WorldContextObject, const struct FGuid& InActorGuid, class FName InPropertyName, bool* OutFetchSuccess, bool* OutFoundValue);
	static int32 GetDeathCount(const class UObject* WorldContextObject);
	static bool HasEverFinishedGame(const class UObject* WorldContextObject);
	static bool HasEverSeenLeaveEnding(const class UObject* WorldContextObject);
	static bool HasSeenBlissEnding(const class UObject* WorldContextObject);
	static bool HasSeenInWaterEnding(const class UObject* WorldContextObject);
	static bool HasSeenMariaEnding(const class UObject* WorldContextObject);
	static bool HasSeenRebirthEnding(const class UObject* WorldContextObject);
	static bool HasSeenStillnessEnding(const class UObject* WorldContextObject);
	static bool IsNewGamePlus(const class UObject* WorldContextObject);
	static void RegisterSeenEnding(const class UObject* WorldContextObject, ESHEndingType InEndingType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCustomSaveStatics">();
	}
	static class USHCustomSaveStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCustomSaveStatics>();
	}
};
static_assert(alignof(USHCustomSaveStatics) == 0x000008, "Wrong alignment on USHCustomSaveStatics");
static_assert(sizeof(USHCustomSaveStatics) == 0x000028, "Wrong size on USHCustomSaveStatics");

// Class SHProto.SHAnimComponent
// 0x01F0 (0x0290 - 0x00A0)
class USHAnimComponent : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x58];                                      // 0x00A0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GameplayLinkedAnimInstNodeTag;                     // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              GameplayLinkedAnimInstDefaultClass;                // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class USHAnimSubcomponentBase*>          OwnedSubcomponents;                                // 0x0108(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class UAnimInstance*                          AnimInstance;                                      // 0x0158(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAnimActionExecutiveBase*             AnimActionExe;                                     // 0x0160(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0x128];                                    // 0x0168(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CreateAnimActionExe(TSubclassOf<class USHAnimActionExecutiveBase> AnimActionExeClass, class UObject* InContextObject);
	class UAnimInstance* LinkGameplayAnimInst(TSubclassOf<class UAnimInstance> InClass);
	void SetAnimActionBlocked(const bool Blocked, const class UObject* Object);
	void UnlinkGameplayAnimInst();

	class USHAnimSubcomponentBase* FindSubcomponentByClass(const TSubclassOf<class USHAnimSubcomponentBase> SubcomponentClass) const;
	class USHAnimActionExecutiveBase* GetAnimActionExe() const;
	EBones GetBoneFromName(class FName BoneType) const;
	struct FVector GetBoneLocation(EBones BoneType, EBoneSpaces TransformSpace) const;
	class FName GetBoneName(EBones BoneType) const;
	struct FVector GetBoneRootLocation() const;
	struct FRotator GetBoneRotation(EBones BoneType, ERelativeTransformSpace TransformSpace) const;
	struct FTransform GetBoneTransform(EBones BoneType, ERelativeTransformSpace Space) const;
	struct FVector GetCharacterBodyForward() const;
	struct FRotator GetCharacterBodyRotation() const;
	struct FVector GetHipsForward() const;
	class FName GetSkeletonSocketName(ESkeletonSockets SocketType) const;
	bool IsAnimActionBlocked() const;
	bool IsGameplayLinkedAnimInstSupported() const;
	bool IsInitialized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimComponent">();
	}
	static class USHAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimComponent>();
	}
};
static_assert(alignof(USHAnimComponent) == 0x000008, "Wrong alignment on USHAnimComponent");
static_assert(sizeof(USHAnimComponent) == 0x000290, "Wrong size on USHAnimComponent");
static_assert(offsetof(USHAnimComponent, GameplayLinkedAnimInstNodeTag) == 0x0000F8, "Member 'USHAnimComponent::GameplayLinkedAnimInstNodeTag' has a wrong offset!");
static_assert(offsetof(USHAnimComponent, GameplayLinkedAnimInstDefaultClass) == 0x000100, "Member 'USHAnimComponent::GameplayLinkedAnimInstDefaultClass' has a wrong offset!");
static_assert(offsetof(USHAnimComponent, OwnedSubcomponents) == 0x000108, "Member 'USHAnimComponent::OwnedSubcomponents' has a wrong offset!");
static_assert(offsetof(USHAnimComponent, AnimInstance) == 0x000158, "Member 'USHAnimComponent::AnimInstance' has a wrong offset!");
static_assert(offsetof(USHAnimComponent, AnimActionExe) == 0x000160, "Member 'USHAnimComponent::AnimActionExe' has a wrong offset!");

// Class SHProto.SHLauraAnimComponent
// 0x0048 (0x02D8 - 0x0290)
class USHLauraAnimComponent final : public USHAnimComponent
{
public:
	struct FSHAnimHeadRotationBaseSubcompSettings HeadRotationSettings;                              // 0x0290(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLauraAnimComponent">();
	}
	static class USHLauraAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLauraAnimComponent>();
	}
};
static_assert(alignof(USHLauraAnimComponent) == 0x000008, "Wrong alignment on USHLauraAnimComponent");
static_assert(sizeof(USHLauraAnimComponent) == 0x0002D8, "Wrong size on USHLauraAnimComponent");
static_assert(offsetof(USHLauraAnimComponent, HeadRotationSettings) == 0x000290, "Member 'USHLauraAnimComponent::HeadRotationSettings' has a wrong offset!");

// Class SHProto.AnimNotify_DoorHandIKStop
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_DoorHandIKStop final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DoorHandIKStop">();
	}
	static class UAnimNotify_DoorHandIKStop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DoorHandIKStop>();
	}
};
static_assert(alignof(UAnimNotify_DoorHandIKStop) == 0x000008, "Wrong alignment on UAnimNotify_DoorHandIKStop");
static_assert(sizeof(UAnimNotify_DoorHandIKStop) == 0x000038, "Wrong size on UAnimNotify_DoorHandIKStop");

// Class SHProto.SHTutorialHandlerBase
// 0x0010 (0x0038 - 0x0028)
class USHTutorialHandlerBase : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTutorialHandlerBase">();
	}
	static class USHTutorialHandlerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTutorialHandlerBase>();
	}
};
static_assert(alignof(USHTutorialHandlerBase) == 0x000008, "Wrong alignment on USHTutorialHandlerBase");
static_assert(sizeof(USHTutorialHandlerBase) == 0x000038, "Wrong size on USHTutorialHandlerBase");

// Class SHProto.SHStruggleTutorialHandler
// 0x0010 (0x0048 - 0x0038)
class USHStruggleTutorialHandler : public USHTutorialHandlerBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHStruggleTutorialHandler">();
	}
	static class USHStruggleTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHStruggleTutorialHandler>();
	}
};
static_assert(alignof(USHStruggleTutorialHandler) == 0x000008, "Wrong alignment on USHStruggleTutorialHandler");
static_assert(sizeof(USHStruggleTutorialHandler) == 0x000048, "Wrong size on USHStruggleTutorialHandler");

// Class SHProto.AnimNotify_UseItemUse
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_UseItemUse final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_UseItemUse">();
	}
	static class UAnimNotify_UseItemUse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_UseItemUse>();
	}
};
static_assert(alignof(UAnimNotify_UseItemUse) == 0x000008, "Wrong alignment on UAnimNotify_UseItemUse");
static_assert(sizeof(UAnimNotify_UseItemUse) == 0x000038, "Wrong size on UAnimNotify_UseItemUse");

// Class SHProto.SHDoor
// 0x00C0 (0x0370 - 0x02B0)
class ASHDoor final : public AActor
{
public:
	class UStaticMeshComponent*                   FrameMesh;                                         // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DoorMesh;                                          // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        DoorMeshHandleSpotAbove;                           // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        DoorMeshHandleSpotBelow;                           // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlaneSideDetectionComponent*           DoorPlaneSideDetectionComponent;                   // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionGenericComponent*         InteractionGeneric;                                // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractionProximitySphere;                        // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            InteractionIcon;                                   // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHRaycastDetectableComponent*          InteractionDetectable;                             // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractionDetectableShape;                        // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconSlotComponent*        InteractionIconSlotFront;                          // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconSlotComponent*        InteractionIconSlotBack;                           // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          PreHitDetector;                                    // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      LockAnimSpotAbove;                                 // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      LockAnimSpotBelow;                                 // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkDoorComponent*                     SHAkDoorComponent;                                 // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          SHAkPortalBounds;                                  // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkPortalDoorComponent*               SHAkPortalDoorComponent;                           // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionManagerComponent*         InteractionManager;                                // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHDoorLockComponent*                   DoorLock;                                          // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHDoorAnimationsComponent*             DoorAnimations;                                    // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHDoorMovementComponent*               DoorMovement;                                      // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayMapDoorComponent*            GameplayMapObject;                                 // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessDoorAlphaChanged(class USHDoorMovementBaseComponent* MovementComponent);
	void ProcessInteractionManagerInitialized(class USHInteractionManagerComponent* Manager);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDoor">();
	}
	static class ASHDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHDoor>();
	}
};
static_assert(alignof(ASHDoor) == 0x000008, "Wrong alignment on ASHDoor");
static_assert(sizeof(ASHDoor) == 0x000370, "Wrong size on ASHDoor");
static_assert(offsetof(ASHDoor, FrameMesh) == 0x0002B0, "Member 'ASHDoor::FrameMesh' has a wrong offset!");
static_assert(offsetof(ASHDoor, DoorMesh) == 0x0002B8, "Member 'ASHDoor::DoorMesh' has a wrong offset!");
static_assert(offsetof(ASHDoor, DoorMeshHandleSpotAbove) == 0x0002C0, "Member 'ASHDoor::DoorMeshHandleSpotAbove' has a wrong offset!");
static_assert(offsetof(ASHDoor, DoorMeshHandleSpotBelow) == 0x0002C8, "Member 'ASHDoor::DoorMeshHandleSpotBelow' has a wrong offset!");
static_assert(offsetof(ASHDoor, DoorPlaneSideDetectionComponent) == 0x0002D0, "Member 'ASHDoor::DoorPlaneSideDetectionComponent' has a wrong offset!");
static_assert(offsetof(ASHDoor, InteractionGeneric) == 0x0002D8, "Member 'ASHDoor::InteractionGeneric' has a wrong offset!");
static_assert(offsetof(ASHDoor, InteractionProximitySphere) == 0x0002E0, "Member 'ASHDoor::InteractionProximitySphere' has a wrong offset!");
static_assert(offsetof(ASHDoor, InteractionIcon) == 0x0002E8, "Member 'ASHDoor::InteractionIcon' has a wrong offset!");
static_assert(offsetof(ASHDoor, InteractionDetectable) == 0x0002F0, "Member 'ASHDoor::InteractionDetectable' has a wrong offset!");
static_assert(offsetof(ASHDoor, InteractionDetectableShape) == 0x0002F8, "Member 'ASHDoor::InteractionDetectableShape' has a wrong offset!");
static_assert(offsetof(ASHDoor, InteractionIconSlotFront) == 0x000300, "Member 'ASHDoor::InteractionIconSlotFront' has a wrong offset!");
static_assert(offsetof(ASHDoor, InteractionIconSlotBack) == 0x000308, "Member 'ASHDoor::InteractionIconSlotBack' has a wrong offset!");
static_assert(offsetof(ASHDoor, PreHitDetector) == 0x000310, "Member 'ASHDoor::PreHitDetector' has a wrong offset!");
static_assert(offsetof(ASHDoor, LockAnimSpotAbove) == 0x000318, "Member 'ASHDoor::LockAnimSpotAbove' has a wrong offset!");
static_assert(offsetof(ASHDoor, LockAnimSpotBelow) == 0x000320, "Member 'ASHDoor::LockAnimSpotBelow' has a wrong offset!");
static_assert(offsetof(ASHDoor, SHAkDoorComponent) == 0x000328, "Member 'ASHDoor::SHAkDoorComponent' has a wrong offset!");
static_assert(offsetof(ASHDoor, SHAkPortalBounds) == 0x000330, "Member 'ASHDoor::SHAkPortalBounds' has a wrong offset!");
static_assert(offsetof(ASHDoor, SHAkPortalDoorComponent) == 0x000338, "Member 'ASHDoor::SHAkPortalDoorComponent' has a wrong offset!");
static_assert(offsetof(ASHDoor, InteractionManager) == 0x000340, "Member 'ASHDoor::InteractionManager' has a wrong offset!");
static_assert(offsetof(ASHDoor, DoorLock) == 0x000348, "Member 'ASHDoor::DoorLock' has a wrong offset!");
static_assert(offsetof(ASHDoor, DoorAnimations) == 0x000350, "Member 'ASHDoor::DoorAnimations' has a wrong offset!");
static_assert(offsetof(ASHDoor, DoorMovement) == 0x000358, "Member 'ASHDoor::DoorMovement' has a wrong offset!");
static_assert(offsetof(ASHDoor, GameplayMapObject) == 0x000360, "Member 'ASHDoor::GameplayMapObject' has a wrong offset!");

// Class SHProto.AnimNotify_UseItemSpawn
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_UseItemSpawn final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_UseItemSpawn">();
	}
	static class UAnimNotify_UseItemSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_UseItemSpawn>();
	}
};
static_assert(alignof(UAnimNotify_UseItemSpawn) == 0x000008, "Wrong alignment on UAnimNotify_UseItemSpawn");
static_assert(sizeof(UAnimNotify_UseItemSpawn) == 0x000038, "Wrong size on UAnimNotify_UseItemSpawn");

// Class SHProto.AnimNotify_UseItemDestroy
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_UseItemDestroy final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_UseItemDestroy">();
	}
	static class UAnimNotify_UseItemDestroy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_UseItemDestroy>();
	}
};
static_assert(alignof(UAnimNotify_UseItemDestroy) == 0x000008, "Wrong alignment on UAnimNotify_UseItemDestroy");
static_assert(sizeof(UAnimNotify_UseItemDestroy) == 0x000038, "Wrong size on UAnimNotify_UseItemDestroy");

// Class SHProto.SHGameInstanceSubObject
// 0x0000 (0x0028 - 0x0028)
class USHGameInstanceSubObject : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameInstanceSubObject">();
	}
	static class USHGameInstanceSubObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameInstanceSubObject>();
	}
};
static_assert(alignof(USHGameInstanceSubObject) == 0x000008, "Wrong alignment on USHGameInstanceSubObject");
static_assert(sizeof(USHGameInstanceSubObject) == 0x000028, "Wrong size on USHGameInstanceSubObject");

// Class SHProto.SHDebugManager
// 0x0020 (0x0048 - 0x0028)
class USHDebugManager final : public USHGameInstanceSubObject
{
public:
	class USHDebugManagerWidget*                  Widget;                                            // 0x0028(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDebugManager">();
	}
	static class USHDebugManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDebugManager>();
	}
};
static_assert(alignof(USHDebugManager) == 0x000008, "Wrong alignment on USHDebugManager");
static_assert(sizeof(USHDebugManager) == 0x000048, "Wrong size on USHDebugManager");
static_assert(offsetof(USHDebugManager, Widget) == 0x000028, "Member 'USHDebugManager::Widget' has a wrong offset!");

// Class SHProto.AnimNotify_Grab
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_Grab final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_Grab">();
	}
	static class UAnimNotify_Grab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_Grab>();
	}
};
static_assert(alignof(UAnimNotify_Grab) == 0x000008, "Wrong alignment on UAnimNotify_Grab");
static_assert(sizeof(UAnimNotify_Grab) == 0x000038, "Wrong size on UAnimNotify_Grab");

// Class SHProto.SHTraversalBase
// 0x0008 (0x02B8 - 0x02B0)
class ASHTraversalBase : public AActor
{
public:
	class USphereComponent*                       ProximitySphere;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalBase">();
	}
	static class ASHTraversalBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHTraversalBase>();
	}
};
static_assert(alignof(ASHTraversalBase) == 0x000008, "Wrong alignment on ASHTraversalBase");
static_assert(sizeof(ASHTraversalBase) == 0x0002B8, "Wrong size on ASHTraversalBase");
static_assert(offsetof(ASHTraversalBase, ProximitySphere) == 0x0002B0, "Member 'ASHTraversalBase::ProximitySphere' has a wrong offset!");

// Class SHProto.SHTraversalLadder
// 0x0100 (0x03B8 - 0x02B8)
class ASHTraversalLadder final : public ASHTraversalBase
{
public:
	class UStaticMeshComponent*                   LadderMesh;                                        // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionGenericComponent*         InteractionGenericAbove;                           // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractionProximitySphereAbove;                   // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            InteractionIconAbove;                              // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHRaycastDetectableComponent*          InteractionDetectableAbove;                        // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractionDetectableShapeAbove;                   // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionGenericComponent*         InteractionGenericBelow;                           // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractionProximitySphereBelow;                   // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            InteractionIconBelow;                              // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHRaycastDetectableComponent*          InteractionDetectableBelow;                        // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractionDetectableShapeBelow;                   // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayMapLadderComponent*          GameplayMapObject;                                 // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionManagerComponent*         InteractionManagerAbove;                           // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionManagerComponent*         InteractionManagerBelow;                           // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StepsNum;                                          // 0x0328(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              PitchViewRotationLimit;                            // 0x0330(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              YawViewRotationLimit;                              // 0x0340(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   AnimInstanceClass;                                 // 0x0350(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             TraversalStartedEvent;                             // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             TraversalFinishedEvent;                            // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       InteractingCharacter;                              // 0x03A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHTraversalLadderAnimInstance*         LinkedTraversalLadderAnimGraphInstance;            // 0x03A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTraversalFinished(const ESHDetectionSide Side);
	void OnTraversalStarted(const ESHDetectionSide Side);
	void ProcessEndTraversalFinish();
	void ProcessEndTraversalStart();
	void ProcessInteract(class USHInteractionGenericComponent* Generic, class ASHCharacterPlay* Character);
	void ProcessInteractionManagerAboveInitialized(class USHInteractionManagerComponent* Manager);
	void ProcessInteractionManagerBelowInitialized(class USHInteractionManagerComponent* Manager);
	void ProcessLookAtRotationAbsoluteEnd(bool WasCompleted);
	void ProcessMovementSnapEnd(bool WasCompleted);
	void ProcessSlideSnapEnd(bool WasCompleted);
	void SHLadderEvent__DelegateSignature(class ASHTraversalLadder* LadderActorPtr);
	void SHLadderTraversalEvent__DelegateSignature(class ASHTraversalLadder* LadderActorPtr, ESHDetectionSide Side);

	struct FTransform ComputeStepWorldTransformClosestTo(const struct FVector& InWorldLoc) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalLadder">();
	}
	static class ASHTraversalLadder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHTraversalLadder>();
	}
};
static_assert(alignof(ASHTraversalLadder) == 0x000008, "Wrong alignment on ASHTraversalLadder");
static_assert(sizeof(ASHTraversalLadder) == 0x0003B8, "Wrong size on ASHTraversalLadder");
static_assert(offsetof(ASHTraversalLadder, LadderMesh) == 0x0002B8, "Member 'ASHTraversalLadder::LadderMesh' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, InteractionGenericAbove) == 0x0002C0, "Member 'ASHTraversalLadder::InteractionGenericAbove' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, InteractionProximitySphereAbove) == 0x0002C8, "Member 'ASHTraversalLadder::InteractionProximitySphereAbove' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, InteractionIconAbove) == 0x0002D0, "Member 'ASHTraversalLadder::InteractionIconAbove' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, InteractionDetectableAbove) == 0x0002D8, "Member 'ASHTraversalLadder::InteractionDetectableAbove' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, InteractionDetectableShapeAbove) == 0x0002E0, "Member 'ASHTraversalLadder::InteractionDetectableShapeAbove' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, InteractionGenericBelow) == 0x0002E8, "Member 'ASHTraversalLadder::InteractionGenericBelow' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, InteractionProximitySphereBelow) == 0x0002F0, "Member 'ASHTraversalLadder::InteractionProximitySphereBelow' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, InteractionIconBelow) == 0x0002F8, "Member 'ASHTraversalLadder::InteractionIconBelow' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, InteractionDetectableBelow) == 0x000300, "Member 'ASHTraversalLadder::InteractionDetectableBelow' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, InteractionDetectableShapeBelow) == 0x000308, "Member 'ASHTraversalLadder::InteractionDetectableShapeBelow' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, GameplayMapObject) == 0x000310, "Member 'ASHTraversalLadder::GameplayMapObject' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, InteractionManagerAbove) == 0x000318, "Member 'ASHTraversalLadder::InteractionManagerAbove' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, InteractionManagerBelow) == 0x000320, "Member 'ASHTraversalLadder::InteractionManagerBelow' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, StepsNum) == 0x000328, "Member 'ASHTraversalLadder::StepsNum' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, PitchViewRotationLimit) == 0x000330, "Member 'ASHTraversalLadder::PitchViewRotationLimit' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, YawViewRotationLimit) == 0x000340, "Member 'ASHTraversalLadder::YawViewRotationLimit' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, AnimInstanceClass) == 0x000350, "Member 'ASHTraversalLadder::AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, TraversalStartedEvent) == 0x000380, "Member 'ASHTraversalLadder::TraversalStartedEvent' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, TraversalFinishedEvent) == 0x000390, "Member 'ASHTraversalLadder::TraversalFinishedEvent' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, InteractingCharacter) == 0x0003A0, "Member 'ASHTraversalLadder::InteractingCharacter' has a wrong offset!");
static_assert(offsetof(ASHTraversalLadder, LinkedTraversalLadderAnimGraphInstance) == 0x0003A8, "Member 'ASHTraversalLadder::LinkedTraversalLadderAnimGraphInstance' has a wrong offset!");

// Class SHProto.AnimNotify_InvestigationFlipEnd
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_InvestigationFlipEnd final : public UAnimNotify
{
public:
	float                                         Time;                                              // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlipSide;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_InvestigationFlipEnd">();
	}
	static class UAnimNotify_InvestigationFlipEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_InvestigationFlipEnd>();
	}
};
static_assert(alignof(UAnimNotify_InvestigationFlipEnd) == 0x000008, "Wrong alignment on UAnimNotify_InvestigationFlipEnd");
static_assert(sizeof(UAnimNotify_InvestigationFlipEnd) == 0x000040, "Wrong size on UAnimNotify_InvestigationFlipEnd");
static_assert(offsetof(UAnimNotify_InvestigationFlipEnd, Time) == 0x000038, "Member 'UAnimNotify_InvestigationFlipEnd::Time' has a wrong offset!");
static_assert(offsetof(UAnimNotify_InvestigationFlipEnd, FlipSide) == 0x00003C, "Member 'UAnimNotify_InvestigationFlipEnd::FlipSide' has a wrong offset!");

// Class SHProto.AnimNotify_ItemHide
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_ItemHide final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ItemHide">();
	}
	static class UAnimNotify_ItemHide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ItemHide>();
	}
};
static_assert(alignof(UAnimNotify_ItemHide) == 0x000008, "Wrong alignment on UAnimNotify_ItemHide");
static_assert(sizeof(UAnimNotify_ItemHide) == 0x000038, "Wrong size on UAnimNotify_ItemHide");

// Class SHProto.SHLyingFigureLocomotionAnimInstance
// 0x0000 (0x03B0 - 0x03B0)
#pragma pack(push, 0x1)
class alignas(0x10) USHLyingFigureLocomotionAnimInstance : public USHMonsterLocomotionAnimInstance
{
public:
	class USHLyingFigureAnimInstanceStateData* GetLyingFigureAnimInstanceStateData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLyingFigureLocomotionAnimInstance">();
	}
	static class USHLyingFigureLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLyingFigureLocomotionAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(USHLyingFigureLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHLyingFigureLocomotionAnimInstance");
static_assert(sizeof(USHLyingFigureLocomotionAnimInstance) == 0x0003B0, "Wrong size on USHLyingFigureLocomotionAnimInstance");

// Class SHProto.SHLyingFigureCrawlingLocomotionAnimInstance
// 0x0070 (0x0420 - 0x03B0)
class USHLyingFigureCrawlingLocomotionAnimInstance final : public USHLyingFigureLocomotionAnimInstance
{
public:
	struct FVector                                DesiredVelocityIncrementHalfTime;                  // 0x03A8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DesiredVelocityDecrementHalfTime;                  // 0x03C0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetDesiredVelocity;                             // 0x03D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DesiredYawAdjustmentHalfTime;                      // 0x03F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetDesiredRotationYaw;                          // 0x03F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESHLyingFigureAnimInstanceCrawlingLocomotionState LocomotionState;                                   // 0x03F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F9[0x27];                                     // 0x03F9(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetSmoothedDesiredRotationYaw(float* OutYaw) const;
	void GetSmoothedDesiredVelocity(struct FVector* OutVelocity) const;
	void GetSmoothedDesiredVelocitySizeAndYaw(float* OutVelocitySize, float* OutVelocityYaw) const;
	void GetTargetDesiredRotationYaw(float* OutYaw) const;
	void GetTargetDesiredVelocity(struct FVector* OutVelocity) const;
	void GetTargetDesiredVelocitySizeAndYaw(float* OutVelocitySize, float* OutVelocityYaw) const;
	void GetTransformationToStandingAnimation(const struct FRotator& InLocalRotation, class UAnimSequenceBase** OutAnimation, float* OutPlayRate, float* OutBlendInDuration, float* OutBlendOutDuration, struct FRotator* OutAnimationRotation, struct FRotator* OutRemainderRotation, bool* OutUsesDelayedRootRotation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLyingFigureCrawlingLocomotionAnimInstance">();
	}
	static class USHLyingFigureCrawlingLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLyingFigureCrawlingLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHLyingFigureCrawlingLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHLyingFigureCrawlingLocomotionAnimInstance");
static_assert(sizeof(USHLyingFigureCrawlingLocomotionAnimInstance) == 0x000420, "Wrong size on USHLyingFigureCrawlingLocomotionAnimInstance");
static_assert(offsetof(USHLyingFigureCrawlingLocomotionAnimInstance, DesiredVelocityIncrementHalfTime) == 0x0003A8, "Member 'USHLyingFigureCrawlingLocomotionAnimInstance::DesiredVelocityIncrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHLyingFigureCrawlingLocomotionAnimInstance, DesiredVelocityDecrementHalfTime) == 0x0003C0, "Member 'USHLyingFigureCrawlingLocomotionAnimInstance::DesiredVelocityDecrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHLyingFigureCrawlingLocomotionAnimInstance, TargetDesiredVelocity) == 0x0003D8, "Member 'USHLyingFigureCrawlingLocomotionAnimInstance::TargetDesiredVelocity' has a wrong offset!");
static_assert(offsetof(USHLyingFigureCrawlingLocomotionAnimInstance, DesiredYawAdjustmentHalfTime) == 0x0003F0, "Member 'USHLyingFigureCrawlingLocomotionAnimInstance::DesiredYawAdjustmentHalfTime' has a wrong offset!");
static_assert(offsetof(USHLyingFigureCrawlingLocomotionAnimInstance, TargetDesiredRotationYaw) == 0x0003F4, "Member 'USHLyingFigureCrawlingLocomotionAnimInstance::TargetDesiredRotationYaw' has a wrong offset!");
static_assert(offsetof(USHLyingFigureCrawlingLocomotionAnimInstance, LocomotionState) == 0x0003F8, "Member 'USHLyingFigureCrawlingLocomotionAnimInstance::LocomotionState' has a wrong offset!");

// Class SHProto.SHAnimNotify_FlashlightDisablePlainSocketMode
// 0x0008 (0x0040 - 0x0038)
class USHAnimNotify_FlashlightDisablePlainSocketMode final : public UAnimNotify
{
public:
	float                                         BlendTime;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_FlashlightDisablePlainSocketMode">();
	}
	static class USHAnimNotify_FlashlightDisablePlainSocketMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_FlashlightDisablePlainSocketMode>();
	}
};
static_assert(alignof(USHAnimNotify_FlashlightDisablePlainSocketMode) == 0x000008, "Wrong alignment on USHAnimNotify_FlashlightDisablePlainSocketMode");
static_assert(sizeof(USHAnimNotify_FlashlightDisablePlainSocketMode) == 0x000040, "Wrong size on USHAnimNotify_FlashlightDisablePlainSocketMode");
static_assert(offsetof(USHAnimNotify_FlashlightDisablePlainSocketMode, BlendTime) == 0x000038, "Member 'USHAnimNotify_FlashlightDisablePlainSocketMode::BlendTime' has a wrong offset!");

// Class SHProto.SHDefenceCmbSubcomp
// 0x02F8 (0x0330 - 0x0038)
class USHDefenceCmbSubcomp final : public USHCombatSubcomponentBase
{
public:
	FMulticastInlineDelegateProperty_             OnIsOnFloorChangedEvent;                           // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class USHDefenceCmbSubcompSettings*           Settings;                                          // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x2E0];                                     // 0x0050(0x02E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleSyncedActionBegin(class ACharacter* CharacterSynchedWith);
	void HandleSyncedActionEnd(class ACharacter* CharacterSynchedWith);
	void OnDodgeBlendingOut(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void OnDodgeEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void OnQuickTurnEnd(bool bWasCompleted);
	bool RequestDefaultFallToFloor();
	bool RequestFallToFloor(const struct FPlayAnimationData& FallAnim, const struct FSHCameraAnimationData& CameraAnim);
	void RequestPerformDodge(const struct FVector& InMovementVector);
	void SetDodgeBlocked(bool InBlocked, class UObject* Object);
	void SHDefenceEvent__DelegateSignature(class USHDefenceCmbSubcomp* DefenceCmbSubcomp);

	bool IsInQuickTurn() const;
	bool IsInSuperArmour() const;
	bool IsOnFloor() const;
	bool IsRightAfterDodge() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDefenceCmbSubcomp">();
	}
	static class USHDefenceCmbSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDefenceCmbSubcomp>();
	}
};
static_assert(alignof(USHDefenceCmbSubcomp) == 0x000008, "Wrong alignment on USHDefenceCmbSubcomp");
static_assert(sizeof(USHDefenceCmbSubcomp) == 0x000330, "Wrong size on USHDefenceCmbSubcomp");
static_assert(offsetof(USHDefenceCmbSubcomp, OnIsOnFloorChangedEvent) == 0x000038, "Member 'USHDefenceCmbSubcomp::OnIsOnFloorChangedEvent' has a wrong offset!");
static_assert(offsetof(USHDefenceCmbSubcomp, Settings) == 0x000048, "Member 'USHDefenceCmbSubcomp::Settings' has a wrong offset!");

// Class SHProto.SHLocomotionRangeAnimInstance
// 0x0070 (0x0560 - 0x04F0)
class USHLocomotionRangeAnimInstance final : public USHLocomotionAnimInstance
{
public:
	bool                                          bHasAmmo;                                          // 0x04E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E9[0x3];                                      // 0x04E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimOffsetArmsInterpSpeed;                          // 0x04EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HeadRotation;                                      // 0x04F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AimOffsetArms;                                     // 0x0500(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEquipToAimAnimation                   EquipToAimAnimation;                               // 0x0510(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FObstacleForwardCheckSettings          AimObstacleCheckSetting;                           // 0x0520(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsAiming;                                         // 0x0548(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_549[0x7];                                      // 0x0549(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USHAnimMontagePlayer*                   EquipToAimPlayer_Hand;                             // 0x0550(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAnimMontagePlayer*                   EquipToAimPlayer_Body;                             // 0x0558(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class FName GetAimPoseWeightCurveName() const;
	bool IsAimPoseBlendingIn(bool MustBePureAimPose) const;
	bool IsAimPoseBlendingInOurOut(bool MustBePureAimPose) const;
	bool IsAimPoseBlendingOut(bool MustBePureAimPose) const;
	bool IsAnyPreAimOffsetSlotAnimationPlaying() const;
	bool IsPureAimPoseBlendingInOurOut() const;
	float MapAimPoseWeightToIgnoreWeaponIKCurve() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLocomotionRangeAnimInstance">();
	}
	static class USHLocomotionRangeAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLocomotionRangeAnimInstance>();
	}
};
static_assert(alignof(USHLocomotionRangeAnimInstance) == 0x000010, "Wrong alignment on USHLocomotionRangeAnimInstance");
static_assert(sizeof(USHLocomotionRangeAnimInstance) == 0x000560, "Wrong size on USHLocomotionRangeAnimInstance");
static_assert(offsetof(USHLocomotionRangeAnimInstance, bHasAmmo) == 0x0004E8, "Member 'USHLocomotionRangeAnimInstance::bHasAmmo' has a wrong offset!");
static_assert(offsetof(USHLocomotionRangeAnimInstance, AimOffsetArmsInterpSpeed) == 0x0004EC, "Member 'USHLocomotionRangeAnimInstance::AimOffsetArmsInterpSpeed' has a wrong offset!");
static_assert(offsetof(USHLocomotionRangeAnimInstance, HeadRotation) == 0x0004F0, "Member 'USHLocomotionRangeAnimInstance::HeadRotation' has a wrong offset!");
static_assert(offsetof(USHLocomotionRangeAnimInstance, AimOffsetArms) == 0x000500, "Member 'USHLocomotionRangeAnimInstance::AimOffsetArms' has a wrong offset!");
static_assert(offsetof(USHLocomotionRangeAnimInstance, EquipToAimAnimation) == 0x000510, "Member 'USHLocomotionRangeAnimInstance::EquipToAimAnimation' has a wrong offset!");
static_assert(offsetof(USHLocomotionRangeAnimInstance, AimObstacleCheckSetting) == 0x000520, "Member 'USHLocomotionRangeAnimInstance::AimObstacleCheckSetting' has a wrong offset!");
static_assert(offsetof(USHLocomotionRangeAnimInstance, bIsAiming) == 0x000548, "Member 'USHLocomotionRangeAnimInstance::bIsAiming' has a wrong offset!");
static_assert(offsetof(USHLocomotionRangeAnimInstance, EquipToAimPlayer_Hand) == 0x000550, "Member 'USHLocomotionRangeAnimInstance::EquipToAimPlayer_Hand' has a wrong offset!");
static_assert(offsetof(USHLocomotionRangeAnimInstance, EquipToAimPlayer_Body) == 0x000558, "Member 'USHLocomotionRangeAnimInstance::EquipToAimPlayer_Body' has a wrong offset!");

// Class SHProto.AnimNotify_Pushable_RequestApplyAttachment
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_Pushable_RequestApplyAttachment final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_Pushable_RequestApplyAttachment">();
	}
	static class UAnimNotify_Pushable_RequestApplyAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_Pushable_RequestApplyAttachment>();
	}
};
static_assert(alignof(UAnimNotify_Pushable_RequestApplyAttachment) == 0x000008, "Wrong alignment on UAnimNotify_Pushable_RequestApplyAttachment");
static_assert(sizeof(UAnimNotify_Pushable_RequestApplyAttachment) == 0x000038, "Wrong size on UAnimNotify_Pushable_RequestApplyAttachment");

// Class SHProto.SHSwarmRegionBase
// 0x0030 (0x02D0 - 0x02A0)
class USHSwarmRegionBase : public USceneComponent
{
public:
	bool                                          IsEnabled;                                         // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESwarmRegionType                              RegionType;                                        // 0x02A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A2[0x2];                                      // 0x02A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SphereRadius;                                      // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x02A8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowDebug;                                         // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 RegionColor;                                       // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetScaledShapeSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSwarmRegionBase">();
	}
	static class USHSwarmRegionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSwarmRegionBase>();
	}
};
static_assert(alignof(USHSwarmRegionBase) == 0x000010, "Wrong alignment on USHSwarmRegionBase");
static_assert(sizeof(USHSwarmRegionBase) == 0x0002D0, "Wrong size on USHSwarmRegionBase");
static_assert(offsetof(USHSwarmRegionBase, IsEnabled) == 0x0002A0, "Member 'USHSwarmRegionBase::IsEnabled' has a wrong offset!");
static_assert(offsetof(USHSwarmRegionBase, RegionType) == 0x0002A1, "Member 'USHSwarmRegionBase::RegionType' has a wrong offset!");
static_assert(offsetof(USHSwarmRegionBase, SphereRadius) == 0x0002A4, "Member 'USHSwarmRegionBase::SphereRadius' has a wrong offset!");
static_assert(offsetof(USHSwarmRegionBase, BoxExtent) == 0x0002A8, "Member 'USHSwarmRegionBase::BoxExtent' has a wrong offset!");
static_assert(offsetof(USHSwarmRegionBase, ShowDebug) == 0x0002C0, "Member 'USHSwarmRegionBase::ShowDebug' has a wrong offset!");
static_assert(offsetof(USHSwarmRegionBase, RegionColor) == 0x0002C4, "Member 'USHSwarmRegionBase::RegionColor' has a wrong offset!");

// Class SHProto.SHSwarmBoundRegion
// 0x0000 (0x02D0 - 0x02D0)
class USHSwarmBoundRegion final : public USHSwarmRegionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSwarmBoundRegion">();
	}
	static class USHSwarmBoundRegion* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSwarmBoundRegion>();
	}
};
static_assert(alignof(USHSwarmBoundRegion) == 0x000010, "Wrong alignment on USHSwarmBoundRegion");
static_assert(sizeof(USHSwarmBoundRegion) == 0x0002D0, "Wrong size on USHSwarmBoundRegion");

// Class SHProto.DebugCameraActor
// 0x0020 (0x02D0 - 0x02B0)
class ADebugCameraActor final : public AActor
{
public:
	class UDebugCameraComponent*                  CameraComponent;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        SceneComponent;                                    // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 FriendlyScreenshotName;                            // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugCameraActor">();
	}
	static class ADebugCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugCameraActor>();
	}
};
static_assert(alignof(ADebugCameraActor) == 0x000008, "Wrong alignment on ADebugCameraActor");
static_assert(sizeof(ADebugCameraActor) == 0x0002D0, "Wrong size on ADebugCameraActor");
static_assert(offsetof(ADebugCameraActor, CameraComponent) == 0x0002B0, "Member 'ADebugCameraActor::CameraComponent' has a wrong offset!");
static_assert(offsetof(ADebugCameraActor, SceneComponent) == 0x0002B8, "Member 'ADebugCameraActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(ADebugCameraActor, FriendlyScreenshotName) == 0x0002C0, "Member 'ADebugCameraActor::FriendlyScreenshotName' has a wrong offset!");

// Class SHProto.DebugCameraComponent
// 0x0000 (0x0A50 - 0x0A50)
class UDebugCameraComponent final : public UCameraComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugCameraComponent">();
	}
	static class UDebugCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugCameraComponent>();
	}
};
static_assert(alignof(UDebugCameraComponent) == 0x000010, "Wrong alignment on UDebugCameraComponent");
static_assert(sizeof(UDebugCameraComponent) == 0x000A50, "Wrong size on UDebugCameraComponent");

// Class SHProto.SHCharacterSnapPoint
// 0x0000 (0x02B0 - 0x02B0)
class ASHCharacterSnapPoint final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterSnapPoint">();
	}
	static class ASHCharacterSnapPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHCharacterSnapPoint>();
	}
};
static_assert(alignof(ASHCharacterSnapPoint) == 0x000008, "Wrong alignment on ASHCharacterSnapPoint");
static_assert(sizeof(ASHCharacterSnapPoint) == 0x0002B0, "Wrong size on ASHCharacterSnapPoint");

// Class SHProto.SHDebugGameMode
// 0x0080 (0x0430 - 0x03B0)
class ASHDebugGameMode final : public ABGameModeBase
{
public:
	uint8                                         Pad_3B0[0x48];                                     // 0x03B0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class ASceneCapture2D*                        CaptureActor;                                      // 0x03F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 Target;                                            // 0x0400(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ALocalFogVolumeActor*>           FogActors;                                         // 0x0408(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ADebugCameraActor*>              CameraActors;                                      // 0x0418(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UGameModeMenuController*                GameMenuController;                                // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDebugGameMode">();
	}
	static class ASHDebugGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHDebugGameMode>();
	}
};
static_assert(alignof(ASHDebugGameMode) == 0x000008, "Wrong alignment on ASHDebugGameMode");
static_assert(sizeof(ASHDebugGameMode) == 0x000430, "Wrong size on ASHDebugGameMode");
static_assert(offsetof(ASHDebugGameMode, CaptureActor) == 0x0003F8, "Member 'ASHDebugGameMode::CaptureActor' has a wrong offset!");
static_assert(offsetof(ASHDebugGameMode, Target) == 0x000400, "Member 'ASHDebugGameMode::Target' has a wrong offset!");
static_assert(offsetof(ASHDebugGameMode, FogActors) == 0x000408, "Member 'ASHDebugGameMode::FogActors' has a wrong offset!");
static_assert(offsetof(ASHDebugGameMode, CameraActors) == 0x000418, "Member 'ASHDebugGameMode::CameraActors' has a wrong offset!");
static_assert(offsetof(ASHDebugGameMode, GameMenuController) == 0x000428, "Member 'ASHDebugGameMode::GameMenuController' has a wrong offset!");

// Class SHProto.SHTraversalTutorialHandler
// 0x0010 (0x0048 - 0x0038)
class USHTraversalTutorialHandler : public USHTutorialHandlerBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalTutorialHandler">();
	}
	static class USHTraversalTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTraversalTutorialHandler>();
	}
};
static_assert(alignof(USHTraversalTutorialHandler) == 0x000008, "Wrong alignment on USHTraversalTutorialHandler");
static_assert(sizeof(USHTraversalTutorialHandler) == 0x000048, "Wrong size on USHTraversalTutorialHandler");

// Class SHProto.SHTraversalSqueezeTutorialHandler
// 0x0000 (0x0048 - 0x0048)
class USHTraversalSqueezeTutorialHandler final : public USHTraversalTutorialHandler
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalSqueezeTutorialHandler">();
	}
	static class USHTraversalSqueezeTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTraversalSqueezeTutorialHandler>();
	}
};
static_assert(alignof(USHTraversalSqueezeTutorialHandler) == 0x000008, "Wrong alignment on USHTraversalSqueezeTutorialHandler");
static_assert(sizeof(USHTraversalSqueezeTutorialHandler) == 0x000048, "Wrong size on USHTraversalSqueezeTutorialHandler");

// Class SHProto.DebugLightsRootActor
// 0x0000 (0x02B0 - 0x02B0)
class ADebugLightsRootActor final : public AActor
{
public:
	TArray<class AActor*> GetAllChildsWithTag(class FName Tag, bool FromAllRoots);
	TArray<class ADebugLightsRootActor*> GetAllLightsRoots();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugLightsRootActor">();
	}
	static class ADebugLightsRootActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugLightsRootActor>();
	}
};
static_assert(alignof(ADebugLightsRootActor) == 0x000008, "Wrong alignment on ADebugLightsRootActor");
static_assert(sizeof(ADebugLightsRootActor) == 0x0002B0, "Wrong size on ADebugLightsRootActor");

// Class SHProto.SHDebugSettings
// 0x0048 (0x0080 - 0x0038)
class USHDebugSettings final : public UDeveloperSettings
{
public:
	TArray<struct FKey>                           GhostKeys;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<struct FKey>                           DebugCheckPointKeys;                               // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	float                                         SpeedUpTimeDilation;                               // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowDownTimeDilation;                              // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FKey>                           SpeedUpKeys;                                       // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<struct FKey>                           SlowDownKeys;                                      // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDebugSettings">();
	}
	static class USHDebugSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDebugSettings>();
	}
};
static_assert(alignof(USHDebugSettings) == 0x000008, "Wrong alignment on USHDebugSettings");
static_assert(sizeof(USHDebugSettings) == 0x000080, "Wrong size on USHDebugSettings");
static_assert(offsetof(USHDebugSettings, GhostKeys) == 0x000038, "Member 'USHDebugSettings::GhostKeys' has a wrong offset!");
static_assert(offsetof(USHDebugSettings, DebugCheckPointKeys) == 0x000048, "Member 'USHDebugSettings::DebugCheckPointKeys' has a wrong offset!");
static_assert(offsetof(USHDebugSettings, SpeedUpTimeDilation) == 0x000058, "Member 'USHDebugSettings::SpeedUpTimeDilation' has a wrong offset!");
static_assert(offsetof(USHDebugSettings, SlowDownTimeDilation) == 0x00005C, "Member 'USHDebugSettings::SlowDownTimeDilation' has a wrong offset!");
static_assert(offsetof(USHDebugSettings, SpeedUpKeys) == 0x000060, "Member 'USHDebugSettings::SpeedUpKeys' has a wrong offset!");
static_assert(offsetof(USHDebugSettings, SlowDownKeys) == 0x000070, "Member 'USHDebugSettings::SlowDownKeys' has a wrong offset!");

// Class SHProto.DebugPointLight
// 0x0000 (0x02C8 - 0x02C8)
class ADebugPointLight final : public APointLight
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugPointLight">();
	}
	static class ADebugPointLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugPointLight>();
	}
};
static_assert(alignof(ADebugPointLight) == 0x000008, "Wrong alignment on ADebugPointLight");
static_assert(sizeof(ADebugPointLight) == 0x0002C8, "Wrong size on ADebugPointLight");

// Class SHProto.SHMandarinAnimInstance
// 0x0070 (0x0450 - 0x03E0)
class USHMandarinAnimInstance final : public USHMonsterAnimInstance
{
public:
	bool                                          IsHanging;                                         // 0x03E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TongueTransformationAlpha;                         // 0x03E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TongueSnapLocation;                                // 0x03E8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               TongueSnapRotation;                                // 0x0400(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         TongueTransformationFadeInSpeed;                   // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TongueTransformationFadeOutSpeed;                  // 0x041C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               LookRotation;                                      // 0x0420(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         LookRotationAlpha;                                 // 0x0438(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_43C[0x14];                                     // 0x043C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecrementAlphaTongueTransformationAlpha();
	void IncrementAlphaTongueTransformationAlpha();

	class USHMandarinAnimInstanceStateData* GetMandarinAnimInstanceStateData() const;
	class USHMandarinLocomotionAnimInstance* GetMandarinLocomotionAnimInstance(int32 SlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMandarinAnimInstance">();
	}
	static class USHMandarinAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMandarinAnimInstance>();
	}
};
static_assert(alignof(USHMandarinAnimInstance) == 0x000010, "Wrong alignment on USHMandarinAnimInstance");
static_assert(sizeof(USHMandarinAnimInstance) == 0x000450, "Wrong size on USHMandarinAnimInstance");
static_assert(offsetof(USHMandarinAnimInstance, IsHanging) == 0x0003E0, "Member 'USHMandarinAnimInstance::IsHanging' has a wrong offset!");
static_assert(offsetof(USHMandarinAnimInstance, TongueTransformationAlpha) == 0x0003E4, "Member 'USHMandarinAnimInstance::TongueTransformationAlpha' has a wrong offset!");
static_assert(offsetof(USHMandarinAnimInstance, TongueSnapLocation) == 0x0003E8, "Member 'USHMandarinAnimInstance::TongueSnapLocation' has a wrong offset!");
static_assert(offsetof(USHMandarinAnimInstance, TongueSnapRotation) == 0x000400, "Member 'USHMandarinAnimInstance::TongueSnapRotation' has a wrong offset!");
static_assert(offsetof(USHMandarinAnimInstance, TongueTransformationFadeInSpeed) == 0x000418, "Member 'USHMandarinAnimInstance::TongueTransformationFadeInSpeed' has a wrong offset!");
static_assert(offsetof(USHMandarinAnimInstance, TongueTransformationFadeOutSpeed) == 0x00041C, "Member 'USHMandarinAnimInstance::TongueTransformationFadeOutSpeed' has a wrong offset!");
static_assert(offsetof(USHMandarinAnimInstance, LookRotation) == 0x000420, "Member 'USHMandarinAnimInstance::LookRotation' has a wrong offset!");
static_assert(offsetof(USHMandarinAnimInstance, LookRotationAlpha) == 0x000438, "Member 'USHMandarinAnimInstance::LookRotationAlpha' has a wrong offset!");

// Class SHProto.SonyDemoBlockingVolume
// 0x0010 (0x02F8 - 0x02E8)
class ASonyDemoBlockingVolume final : public AVolume
{
public:
	float                                         Proximity;                                         // 0x02E8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MessageIndex;                                      // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SonyDemoBlockingVolume">();
	}
	static class ASonyDemoBlockingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASonyDemoBlockingVolume>();
	}
};
static_assert(alignof(ASonyDemoBlockingVolume) == 0x000008, "Wrong alignment on ASonyDemoBlockingVolume");
static_assert(sizeof(ASonyDemoBlockingVolume) == 0x0002F8, "Wrong size on ASonyDemoBlockingVolume");
static_assert(offsetof(ASonyDemoBlockingVolume, Proximity) == 0x0002E8, "Member 'ASonyDemoBlockingVolume::Proximity' has a wrong offset!");
static_assert(offsetof(ASonyDemoBlockingVolume, MessageIndex) == 0x0002EC, "Member 'ASonyDemoBlockingVolume::MessageIndex' has a wrong offset!");

// Class SHProto.SHPlayerController
// 0x0000 (0x0870 - 0x0870)
class ASHPlayerController : public APlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPlayerController">();
	}
	static class ASHPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHPlayerController>();
	}
};
static_assert(alignof(ASHPlayerController) == 0x000008, "Wrong alignment on ASHPlayerController");
static_assert(sizeof(ASHPlayerController) == 0x000870, "Wrong size on ASHPlayerController");

// Class SHProto.SHDynamicInteractionManagerComponent
// 0x0008 (0x00A8 - 0x00A0)
class USHDynamicInteractionManagerComponent final : public UActorComponent
{
public:
	class ASHDynamicInteractionExecutive*         SpawnedInteractionExe;                             // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DestroySpawnedInteractionExecutive();
	class ASHDynamicInteractionExecutive* SpawnInteractionExecutive(TSubclassOf<class ASHDynamicInteractionExecutive> InteractionExeClass);

	class ASHDynamicInteractionExecutive* GetSpawnedInteractionExecutive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDynamicInteractionManagerComponent">();
	}
	static class USHDynamicInteractionManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDynamicInteractionManagerComponent>();
	}
};
static_assert(alignof(USHDynamicInteractionManagerComponent) == 0x000008, "Wrong alignment on USHDynamicInteractionManagerComponent");
static_assert(sizeof(USHDynamicInteractionManagerComponent) == 0x0000A8, "Wrong size on USHDynamicInteractionManagerComponent");
static_assert(offsetof(USHDynamicInteractionManagerComponent, SpawnedInteractionExe) == 0x0000A0, "Member 'USHDynamicInteractionManagerComponent::SpawnedInteractionExe' has a wrong offset!");

// Class SHProto.DebugSpectatorActor
// 0x0000 (0x0360 - 0x0360)
class ADebugSpectatorActor final : public ASpectatorPawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugSpectatorActor">();
	}
	static class ADebugSpectatorActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugSpectatorActor>();
	}
};
static_assert(alignof(ADebugSpectatorActor) == 0x000008, "Wrong alignment on ADebugSpectatorActor");
static_assert(sizeof(ADebugSpectatorActor) == 0x000360, "Wrong size on ADebugSpectatorActor");

// Class SHProto.DistributionFloatUniformParam
// 0x0018 (0x0050 - 0x0038)
class UDistributionFloatUniformParam final : public UDistributionFloat
{
public:
	class FName                                   MaxParameterName;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MinParameterName;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMax;                                        // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMin;                                        // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistributionFloatUniformParam">();
	}
	static class UDistributionFloatUniformParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistributionFloatUniformParam>();
	}
};
static_assert(alignof(UDistributionFloatUniformParam) == 0x000008, "Wrong alignment on UDistributionFloatUniformParam");
static_assert(sizeof(UDistributionFloatUniformParam) == 0x000050, "Wrong size on UDistributionFloatUniformParam");
static_assert(offsetof(UDistributionFloatUniformParam, MaxParameterName) == 0x000038, "Member 'UDistributionFloatUniformParam::MaxParameterName' has a wrong offset!");
static_assert(offsetof(UDistributionFloatUniformParam, MinParameterName) == 0x000040, "Member 'UDistributionFloatUniformParam::MinParameterName' has a wrong offset!");
static_assert(offsetof(UDistributionFloatUniformParam, DefaultMax) == 0x000048, "Member 'UDistributionFloatUniformParam::DefaultMax' has a wrong offset!");
static_assert(offsetof(UDistributionFloatUniformParam, DefaultMin) == 0x00004C, "Member 'UDistributionFloatUniformParam::DefaultMin' has a wrong offset!");

// Class SHProto.DistributionVectorUniformParam
// 0x0040 (0x0078 - 0x0038)
class UDistributionVectorUniformParam final : public UDistributionVector
{
public:
	class FName                                   MaxParameterName;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MinParameterName;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultMax;                                        // 0x0048(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultMin;                                        // 0x0060(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistributionVectorUniformParam">();
	}
	static class UDistributionVectorUniformParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistributionVectorUniformParam>();
	}
};
static_assert(alignof(UDistributionVectorUniformParam) == 0x000008, "Wrong alignment on UDistributionVectorUniformParam");
static_assert(sizeof(UDistributionVectorUniformParam) == 0x000078, "Wrong size on UDistributionVectorUniformParam");
static_assert(offsetof(UDistributionVectorUniformParam, MaxParameterName) == 0x000038, "Member 'UDistributionVectorUniformParam::MaxParameterName' has a wrong offset!");
static_assert(offsetof(UDistributionVectorUniformParam, MinParameterName) == 0x000040, "Member 'UDistributionVectorUniformParam::MinParameterName' has a wrong offset!");
static_assert(offsetof(UDistributionVectorUniformParam, DefaultMax) == 0x000048, "Member 'UDistributionVectorUniformParam::DefaultMax' has a wrong offset!");
static_assert(offsetof(UDistributionVectorUniformParam, DefaultMin) == 0x000060, "Member 'UDistributionVectorUniformParam::DefaultMin' has a wrong offset!");

// Class SHProto.EnvQueryTest_MeatHealth
// 0x0008 (0x0200 - 0x01F8)
class UEnvQueryTest_MeatHealth final : public UEnvQueryTest
{
public:
	int32                                         TargetChunkCount;                                  // 0x01F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_MeatHealth">();
	}
	static class UEnvQueryTest_MeatHealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_MeatHealth>();
	}
};
static_assert(alignof(UEnvQueryTest_MeatHealth) == 0x000008, "Wrong alignment on UEnvQueryTest_MeatHealth");
static_assert(sizeof(UEnvQueryTest_MeatHealth) == 0x000200, "Wrong size on UEnvQueryTest_MeatHealth");
static_assert(offsetof(UEnvQueryTest_MeatHealth, TargetChunkCount) == 0x0001F8, "Member 'UEnvQueryTest_MeatHealth::TargetChunkCount' has a wrong offset!");

// Class SHProto.SHPlaythroughKilledEnemiesEndingFactor
// 0x0000 (0x0088 - 0x0088)
class USHPlaythroughKilledEnemiesEndingFactor final : public USHIntEndingFactor
{
public:
	void SHDebug_Character_Endings_PlaythroughKilledEnemiesEndingFactor_SetDebugValue(int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPlaythroughKilledEnemiesEndingFactor">();
	}
	static class USHPlaythroughKilledEnemiesEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPlaythroughKilledEnemiesEndingFactor>();
	}
};
static_assert(alignof(USHPlaythroughKilledEnemiesEndingFactor) == 0x000008, "Wrong alignment on USHPlaythroughKilledEnemiesEndingFactor");
static_assert(sizeof(USHPlaythroughKilledEnemiesEndingFactor) == 0x000088, "Wrong size on USHPlaythroughKilledEnemiesEndingFactor");

// Class SHProto.SHEddieAnimInstance
// 0x0060 (0x0440 - 0x03E0)
class USHEddieAnimInstance final : public USHMonsterAnimInstance
{
public:
	ESHEddieAnimInstanceMovementState             MovementState;                                     // 0x03E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESHEddieFaceExpression                        CurrentFaceExpression;                             // 0x03E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E2[0x6];                                      // 0x03E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESHEddieFaceExpression, struct FVector>  FaceExpressionMap;                                 // 0x03E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_438[0x8];                                      // 0x0438(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnEddieMovementStateChanged(ESHEddieAnimInstanceMovementState InMovementState);
	void ResetFaceExpression();
	void SetFaceExpression(const ESHEddieFaceExpression Expression, const float Duration);

	class USHEddieLocomotionAnimInstance* GetActiveEddieLocomotionAnimInstance() const;
	class USHEddieAnimInstanceStateData* GetEddieAnimInstanceStateData() const;
	class USHEddieLimpingLocomotionAnimInstance* GetEddieLimpingLocomotionAnimInstance() const;
	class USHEddieWalkingLocomotionAnimInstance* GetEddieWalkingLocomotionAnimInstance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEddieAnimInstance">();
	}
	static class USHEddieAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEddieAnimInstance>();
	}
};
static_assert(alignof(USHEddieAnimInstance) == 0x000010, "Wrong alignment on USHEddieAnimInstance");
static_assert(sizeof(USHEddieAnimInstance) == 0x000440, "Wrong size on USHEddieAnimInstance");
static_assert(offsetof(USHEddieAnimInstance, MovementState) == 0x0003E0, "Member 'USHEddieAnimInstance::MovementState' has a wrong offset!");
static_assert(offsetof(USHEddieAnimInstance, CurrentFaceExpression) == 0x0003E1, "Member 'USHEddieAnimInstance::CurrentFaceExpression' has a wrong offset!");
static_assert(offsetof(USHEddieAnimInstance, FaceExpressionMap) == 0x0003E8, "Member 'USHEddieAnimInstance::FaceExpressionMap' has a wrong offset!");

// Class SHProto.GameplayPresetsConfig
// 0x0010 (0x0040 - 0x0030)
class UGameplayPresetsConfig final : public UDataAsset
{
public:
	TArray<struct FGameplayPreset>                Presets;                                           // 0x0030(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void PresetsToDefault();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayPresetsConfig">();
	}
	static class UGameplayPresetsConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayPresetsConfig>();
	}
};
static_assert(alignof(UGameplayPresetsConfig) == 0x000008, "Wrong alignment on UGameplayPresetsConfig");
static_assert(sizeof(UGameplayPresetsConfig) == 0x000040, "Wrong size on UGameplayPresetsConfig");
static_assert(offsetof(UGameplayPresetsConfig, Presets) == 0x000030, "Member 'UGameplayPresetsConfig::Presets' has a wrong offset!");

// Class SHProto.SHItemBase
// 0x0088 (0x0338 - 0x02B0)
class ASHItemBase : public AActor
{
public:
	class UMeshComponent*                         Mesh;                                              // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHItemAudioComponent*                  AudioComponent;                                    // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    ItemData;                                          // 0x02C0(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnExecutiveInitEvent;                              // 0x02D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class ACharacter*                             InteractingCharacter;                              // 0x02E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x50];                                     // 0x02E8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintImplementableExecutiveInit(class ASHItemExecutiveBase* Executive);
	void BlueprintImplementableInvestigationFlip(class ASHItemInvestigationExecutive* InvestigationExecutive, bool SideB);
	void BlueprintImplementableInvestigationInputChanged(class ASHItemInvestigationExecutive* InvestigationExecutive, float AnimationTime);
	void BlueprintImplementableInvestigationSwitchedItem(class ASHItemInvestigationExecutive* InvestigationExecutive);
	void BlueprintImplementableMainInvestigationStarted(class ASHItemInvestigationExecutive* InvestigationExecutive);
	void BlueprintImplementablePostInvestigationStarted(class ASHItemInvestigationExecutive* InvestigationExecutive);
	void BlueprintImplementablePreInvestigationStarted(class ASHItemInvestigationExecutive* InvestigationExecutive);
	bool Equip(const class FName SocketName, const struct FVector& RelativeLocation, const struct FVector& RelativeRotation);
	void SetItemDisabled(const bool bInDisabled, const class UObject* InObject);
	void SHItemBaseEvent__DelegateSignature(class ASHItemBase* ItemPtr);
	void SHItemBaseWithExecutiveEvent__DelegateSignature(class ASHItemBase* ItemPtr, class ASHItemExecutiveBase* ExecutivePtr);
	bool Unequip();

	const class ACharacter* GetInteractingCharacter() const;
	bool IsItemDisabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemBase">();
	}
	static class ASHItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHItemBase>();
	}
};
static_assert(alignof(ASHItemBase) == 0x000008, "Wrong alignment on ASHItemBase");
static_assert(sizeof(ASHItemBase) == 0x000338, "Wrong size on ASHItemBase");
static_assert(offsetof(ASHItemBase, Mesh) == 0x0002B0, "Member 'ASHItemBase::Mesh' has a wrong offset!");
static_assert(offsetof(ASHItemBase, AudioComponent) == 0x0002B8, "Member 'ASHItemBase::AudioComponent' has a wrong offset!");
static_assert(offsetof(ASHItemBase, ItemData) == 0x0002C0, "Member 'ASHItemBase::ItemData' has a wrong offset!");
static_assert(offsetof(ASHItemBase, OnExecutiveInitEvent) == 0x0002D0, "Member 'ASHItemBase::OnExecutiveInitEvent' has a wrong offset!");
static_assert(offsetof(ASHItemBase, InteractingCharacter) == 0x0002E0, "Member 'ASHItemBase::InteractingCharacter' has a wrong offset!");

// Class SHProto.SHItem
// 0x0078 (0x03B0 - 0x0338)
class ASHItem : public ASHItemBase
{
public:
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USHInteractionGenericComponent*         InteractionGeneric;                                // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractionProximitySphere;                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            InteractionIcon;                                   // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHRaycastDetectableComponent*          InteractionDetectable;                             // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractionDetectableShape;                        // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionManagerComponent*         InteractionManager;                                // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayMapItemComponent*            GameplayMapObject;                                 // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHItemEmissiveDataHelper*              EmissiveDataHelper;                                // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCollectDifferentItems;                            // 0x0380(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_381[0x3];                                      // 0x0381(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Quantity;                                          // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSHItemAndQuantityHandle>       DifferentItemsToCollect;                           // 0x0388(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          ForceGrabOnly;                                     // 0x0398(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWasCollected;                                     // 0x0399(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39A[0x16];                                     // 0x039A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintImplementableCollected();
	void SHItemEvent__DelegateSignature(class ASHItem* ItemPtr);

	bool WasCollected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItem">();
	}
	static class ASHItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHItem>();
	}
};
static_assert(alignof(ASHItem) == 0x000008, "Wrong alignment on ASHItem");
static_assert(sizeof(ASHItem) == 0x0003B0, "Wrong size on ASHItem");
static_assert(offsetof(ASHItem, InteractionGeneric) == 0x000340, "Member 'ASHItem::InteractionGeneric' has a wrong offset!");
static_assert(offsetof(ASHItem, InteractionProximitySphere) == 0x000348, "Member 'ASHItem::InteractionProximitySphere' has a wrong offset!");
static_assert(offsetof(ASHItem, InteractionIcon) == 0x000350, "Member 'ASHItem::InteractionIcon' has a wrong offset!");
static_assert(offsetof(ASHItem, InteractionDetectable) == 0x000358, "Member 'ASHItem::InteractionDetectable' has a wrong offset!");
static_assert(offsetof(ASHItem, InteractionDetectableShape) == 0x000360, "Member 'ASHItem::InteractionDetectableShape' has a wrong offset!");
static_assert(offsetof(ASHItem, InteractionManager) == 0x000368, "Member 'ASHItem::InteractionManager' has a wrong offset!");
static_assert(offsetof(ASHItem, GameplayMapObject) == 0x000370, "Member 'ASHItem::GameplayMapObject' has a wrong offset!");
static_assert(offsetof(ASHItem, EmissiveDataHelper) == 0x000378, "Member 'ASHItem::EmissiveDataHelper' has a wrong offset!");
static_assert(offsetof(ASHItem, bCollectDifferentItems) == 0x000380, "Member 'ASHItem::bCollectDifferentItems' has a wrong offset!");
static_assert(offsetof(ASHItem, Quantity) == 0x000384, "Member 'ASHItem::Quantity' has a wrong offset!");
static_assert(offsetof(ASHItem, DifferentItemsToCollect) == 0x000388, "Member 'ASHItem::DifferentItemsToCollect' has a wrong offset!");
static_assert(offsetof(ASHItem, ForceGrabOnly) == 0x000398, "Member 'ASHItem::ForceGrabOnly' has a wrong offset!");
static_assert(offsetof(ASHItem, bWasCollected) == 0x000399, "Member 'ASHItem::bWasCollected' has a wrong offset!");

// Class SHProto.SHAnimNotify_IKPelvisDisable
// 0x0008 (0x0040 - 0x0038)
class USHAnimNotify_IKPelvisDisable final : public UAnimNotify
{
public:
	float                                         InterpSpeed;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_IKPelvisDisable">();
	}
	static class USHAnimNotify_IKPelvisDisable* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_IKPelvisDisable>();
	}
};
static_assert(alignof(USHAnimNotify_IKPelvisDisable) == 0x000008, "Wrong alignment on USHAnimNotify_IKPelvisDisable");
static_assert(sizeof(USHAnimNotify_IKPelvisDisable) == 0x000040, "Wrong size on USHAnimNotify_IKPelvisDisable");
static_assert(offsetof(USHAnimNotify_IKPelvisDisable, InterpSpeed) == 0x000038, "Member 'USHAnimNotify_IKPelvisDisable::InterpSpeed' has a wrong offset!");

// Class SHProto.SHAnimNotify_IKFeetEnable
// 0x0000 (0x0038 - 0x0038)
class USHAnimNotify_IKFeetEnable final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_IKFeetEnable">();
	}
	static class USHAnimNotify_IKFeetEnable* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_IKFeetEnable>();
	}
};
static_assert(alignof(USHAnimNotify_IKFeetEnable) == 0x000008, "Wrong alignment on USHAnimNotify_IKFeetEnable");
static_assert(sizeof(USHAnimNotify_IKFeetEnable) == 0x000038, "Wrong size on USHAnimNotify_IKFeetEnable");

// Class SHProto.SHDoorsSettings
// 0x0030 (0x0068 - 0x0038)
class USHDoorsSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UDataTable>              DoorAttachmentKeysDataTable;                       // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDoorsSettings">();
	}
	static class USHDoorsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDoorsSettings>();
	}
};
static_assert(alignof(USHDoorsSettings) == 0x000008, "Wrong alignment on USHDoorsSettings");
static_assert(sizeof(USHDoorsSettings) == 0x000068, "Wrong size on USHDoorsSettings");
static_assert(offsetof(USHDoorsSettings, DoorAttachmentKeysDataTable) == 0x000038, "Member 'USHDoorsSettings::DoorAttachmentKeysDataTable' has a wrong offset!");

// Class SHProto.SHAnimNotify_IKFeetDisable
// 0x0000 (0x0038 - 0x0038)
class USHAnimNotify_IKFeetDisable final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_IKFeetDisable">();
	}
	static class USHAnimNotify_IKFeetDisable* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_IKFeetDisable>();
	}
};
static_assert(alignof(USHAnimNotify_IKFeetDisable) == 0x000008, "Wrong alignment on USHAnimNotify_IKFeetDisable");
static_assert(sizeof(USHAnimNotify_IKFeetDisable) == 0x000038, "Wrong size on USHAnimNotify_IKFeetDisable");

// Class SHProto.SHAnimNotify_IKFeetRotationOffsetEnable
// 0x0000 (0x0038 - 0x0038)
class USHAnimNotify_IKFeetRotationOffsetEnable final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_IKFeetRotationOffsetEnable">();
	}
	static class USHAnimNotify_IKFeetRotationOffsetEnable* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_IKFeetRotationOffsetEnable>();
	}
};
static_assert(alignof(USHAnimNotify_IKFeetRotationOffsetEnable) == 0x000008, "Wrong alignment on USHAnimNotify_IKFeetRotationOffsetEnable");
static_assert(sizeof(USHAnimNotify_IKFeetRotationOffsetEnable) == 0x000038, "Wrong size on USHAnimNotify_IKFeetRotationOffsetEnable");

// Class SHProto.SHDynamicWidgetAnimStatics
// 0x0000 (0x0028 - 0x0028)
class USHDynamicWidgetAnimStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool SHReplacePossessable(class UMovieScene* InMovieScene, const struct FGuid& OldGuid, const struct FMovieScenePossessable& InNewPossessable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDynamicWidgetAnimStatics">();
	}
	static class USHDynamicWidgetAnimStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDynamicWidgetAnimStatics>();
	}
};
static_assert(alignof(USHDynamicWidgetAnimStatics) == 0x000008, "Wrong alignment on USHDynamicWidgetAnimStatics");
static_assert(sizeof(USHDynamicWidgetAnimStatics) == 0x000028, "Wrong size on USHDynamicWidgetAnimStatics");

// Class SHProto.SHAnimNotify_IKFeetRotationOffsetDisable
// 0x0000 (0x0038 - 0x0038)
class USHAnimNotify_IKFeetRotationOffsetDisable final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_IKFeetRotationOffsetDisable">();
	}
	static class USHAnimNotify_IKFeetRotationOffsetDisable* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_IKFeetRotationOffsetDisable>();
	}
};
static_assert(alignof(USHAnimNotify_IKFeetRotationOffsetDisable) == 0x000008, "Wrong alignment on USHAnimNotify_IKFeetRotationOffsetDisable");
static_assert(sizeof(USHAnimNotify_IKFeetRotationOffsetDisable) == 0x000038, "Wrong size on USHAnimNotify_IKFeetRotationOffsetDisable");

// Class SHProto.SHAnimNotifyState_IKFeetDisable
// 0x0008 (0x0038 - 0x0030)
class USHAnimNotifyState_IKFeetDisable final : public UAnimNotifyState
{
public:
	float                                         InterpSpeed;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotifyState_IKFeetDisable">();
	}
	static class USHAnimNotifyState_IKFeetDisable* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotifyState_IKFeetDisable>();
	}
};
static_assert(alignof(USHAnimNotifyState_IKFeetDisable) == 0x000008, "Wrong alignment on USHAnimNotifyState_IKFeetDisable");
static_assert(sizeof(USHAnimNotifyState_IKFeetDisable) == 0x000038, "Wrong size on USHAnimNotifyState_IKFeetDisable");
static_assert(offsetof(USHAnimNotifyState_IKFeetDisable, InterpSpeed) == 0x000030, "Member 'USHAnimNotifyState_IKFeetDisable::InterpSpeed' has a wrong offset!");

// Class SHProto.SHProjectile
// 0x0058 (0x0308 - 0x02B0)
class ASHProjectile : public AActor
{
public:
	class USphereComponent*                       SphereComponent;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProjectileMovementComponent*           ProjectileMovement;                                // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                InitialVelocity;                                   // 0x02C0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnLocation;                                     // 0x02E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoDestroyOnMovementStopeed;                     // 0x02F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F9[0x3];                                      // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifetimeAfterRangeReached;                         // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsMaxRangeReached() const;
	bool WantDrawDebug() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHProjectile">();
	}
	static class ASHProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHProjectile>();
	}
};
static_assert(alignof(ASHProjectile) == 0x000008, "Wrong alignment on ASHProjectile");
static_assert(sizeof(ASHProjectile) == 0x000308, "Wrong size on ASHProjectile");
static_assert(offsetof(ASHProjectile, SphereComponent) == 0x0002B0, "Member 'ASHProjectile::SphereComponent' has a wrong offset!");
static_assert(offsetof(ASHProjectile, ProjectileMovement) == 0x0002B8, "Member 'ASHProjectile::ProjectileMovement' has a wrong offset!");
static_assert(offsetof(ASHProjectile, InitialVelocity) == 0x0002C0, "Member 'ASHProjectile::InitialVelocity' has a wrong offset!");
static_assert(offsetof(ASHProjectile, MaxRange) == 0x0002D8, "Member 'ASHProjectile::MaxRange' has a wrong offset!");
static_assert(offsetof(ASHProjectile, SpawnLocation) == 0x0002E0, "Member 'ASHProjectile::SpawnLocation' has a wrong offset!");
static_assert(offsetof(ASHProjectile, bAutoDestroyOnMovementStopeed) == 0x0002F8, "Member 'ASHProjectile::bAutoDestroyOnMovementStopeed' has a wrong offset!");
static_assert(offsetof(ASHProjectile, LifetimeAfterRangeReached) == 0x0002FC, "Member 'ASHProjectile::LifetimeAfterRangeReached' has a wrong offset!");

// Class SHProto.SHEddieLocomotionAnimInstance
// 0x0010 (0x03C0 - 0x03B0)
class USHEddieLocomotionAnimInstance : public USHMonsterLocomotionAnimInstance
{
public:
	float                                         MoveChangeLegOnGround;                             // 0x03A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveChangeStrafeAngle;                             // 0x03AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeAngle;                                       // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredStrafeAngle;                                // 0x03B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceAngle;                                  // 0x03B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredSpeed;                                      // 0x03BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class USHEddieAnimInstanceStateData* GetEddieAnimInstanceStateData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEddieLocomotionAnimInstance">();
	}
	static class USHEddieLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEddieLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHEddieLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHEddieLocomotionAnimInstance");
static_assert(sizeof(USHEddieLocomotionAnimInstance) == 0x0003C0, "Wrong size on USHEddieLocomotionAnimInstance");
static_assert(offsetof(USHEddieLocomotionAnimInstance, MoveChangeLegOnGround) == 0x0003A8, "Member 'USHEddieLocomotionAnimInstance::MoveChangeLegOnGround' has a wrong offset!");
static_assert(offsetof(USHEddieLocomotionAnimInstance, MoveChangeStrafeAngle) == 0x0003AC, "Member 'USHEddieLocomotionAnimInstance::MoveChangeStrafeAngle' has a wrong offset!");
static_assert(offsetof(USHEddieLocomotionAnimInstance, StrafeAngle) == 0x0003B0, "Member 'USHEddieLocomotionAnimInstance::StrafeAngle' has a wrong offset!");
static_assert(offsetof(USHEddieLocomotionAnimInstance, DesiredStrafeAngle) == 0x0003B4, "Member 'USHEddieLocomotionAnimInstance::DesiredStrafeAngle' has a wrong offset!");
static_assert(offsetof(USHEddieLocomotionAnimInstance, TurnInPlaceAngle) == 0x0003B8, "Member 'USHEddieLocomotionAnimInstance::TurnInPlaceAngle' has a wrong offset!");
static_assert(offsetof(USHEddieLocomotionAnimInstance, DesiredSpeed) == 0x0003BC, "Member 'USHEddieLocomotionAnimInstance::DesiredSpeed' has a wrong offset!");

// Class SHProto.SHEddieWalkingLocomotionAnimInstance
// 0x00B0 (0x0470 - 0x03C0)
class USHEddieWalkingLocomotionAnimInstance final : public USHEddieLocomotionAnimInstance
{
public:
	ESHEddieWalkingAnimInstanceLocomotionState    LocomotionStateRequest;                            // 0x03C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C1[0x3];                                      // 0x03C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementStopDelay;                                 // 0x03C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DesiredVelocityIncrementHalfTime;                  // 0x03C8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DesiredVelocityDecrementHalfTime;                  // 0x03E0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetDesiredVelocity;                             // 0x03F8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DesiredYawAdjustmentHalfTime;                      // 0x0410(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetDesiredRotationYaw;                          // 0x0414(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtAlphaIncrementHalfTime;                      // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtAlphaDecrementHalfTime;                      // 0x041C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_420[0x50];                                     // 0x0420(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetSmoothedDesiredRotationYaw(float* OutYaw) const;
	void GetSmoothedDesiredVelocity(struct FVector* OutVelocity) const;
	void GetSmoothedDesiredVelocitySizeAndYaw(float* OutVelocitySize, float* OutVelocityYaw) const;
	void GetSmoothedDesiredVelocitySizeAndYawLimitedToDirection(float* OutVelocitySize, float* OutVelocityYaw, float InDirectionYaw, float InToleranceAngle) const;
	void GetSmoothedLookAt(struct FRotator* OutRotation, float* OutAlpha) const;
	void GetTargetDesiredRotationYaw(float* OutYaw) const;
	void GetTargetDesiredVelocity(struct FVector* OutVelocity) const;
	void GetTargetDesiredVelocitySizeAndYaw(float* OutVelocitySize, float* OutVelocityYaw) const;
	void GetTargetDesiredVelocitySizeAndYawLimitedToDirection(float* OutVelocitySize, float* OutVelocityYaw, float InDirectionYaw, float InToleranceAngle) const;
	void GetTargetLookAtAlpha(float* OutAlpha) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEddieWalkingLocomotionAnimInstance">();
	}
	static class USHEddieWalkingLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEddieWalkingLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHEddieWalkingLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHEddieWalkingLocomotionAnimInstance");
static_assert(sizeof(USHEddieWalkingLocomotionAnimInstance) == 0x000470, "Wrong size on USHEddieWalkingLocomotionAnimInstance");
static_assert(offsetof(USHEddieWalkingLocomotionAnimInstance, LocomotionStateRequest) == 0x0003C0, "Member 'USHEddieWalkingLocomotionAnimInstance::LocomotionStateRequest' has a wrong offset!");
static_assert(offsetof(USHEddieWalkingLocomotionAnimInstance, MovementStopDelay) == 0x0003C4, "Member 'USHEddieWalkingLocomotionAnimInstance::MovementStopDelay' has a wrong offset!");
static_assert(offsetof(USHEddieWalkingLocomotionAnimInstance, DesiredVelocityIncrementHalfTime) == 0x0003C8, "Member 'USHEddieWalkingLocomotionAnimInstance::DesiredVelocityIncrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHEddieWalkingLocomotionAnimInstance, DesiredVelocityDecrementHalfTime) == 0x0003E0, "Member 'USHEddieWalkingLocomotionAnimInstance::DesiredVelocityDecrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHEddieWalkingLocomotionAnimInstance, TargetDesiredVelocity) == 0x0003F8, "Member 'USHEddieWalkingLocomotionAnimInstance::TargetDesiredVelocity' has a wrong offset!");
static_assert(offsetof(USHEddieWalkingLocomotionAnimInstance, DesiredYawAdjustmentHalfTime) == 0x000410, "Member 'USHEddieWalkingLocomotionAnimInstance::DesiredYawAdjustmentHalfTime' has a wrong offset!");
static_assert(offsetof(USHEddieWalkingLocomotionAnimInstance, TargetDesiredRotationYaw) == 0x000414, "Member 'USHEddieWalkingLocomotionAnimInstance::TargetDesiredRotationYaw' has a wrong offset!");
static_assert(offsetof(USHEddieWalkingLocomotionAnimInstance, LookAtAlphaIncrementHalfTime) == 0x000418, "Member 'USHEddieWalkingLocomotionAnimInstance::LookAtAlphaIncrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHEddieWalkingLocomotionAnimInstance, LookAtAlphaDecrementHalfTime) == 0x00041C, "Member 'USHEddieWalkingLocomotionAnimInstance::LookAtAlphaDecrementHalfTime' has a wrong offset!");

// Class SHProto.KeyRichTexts
// 0x0010 (0x0040 - 0x0030)
class UKeyRichTexts final : public UDataAsset
{
public:
	TArray<struct FUE4KeyRichText>                Keys;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class FText GetKeyDisplayRichText(const struct FKey& Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeyRichTexts">();
	}
	static class UKeyRichTexts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKeyRichTexts>();
	}
};
static_assert(alignof(UKeyRichTexts) == 0x000008, "Wrong alignment on UKeyRichTexts");
static_assert(sizeof(UKeyRichTexts) == 0x000040, "Wrong size on UKeyRichTexts");
static_assert(offsetof(UKeyRichTexts, Keys) == 0x000030, "Member 'UKeyRichTexts::Keys' has a wrong offset!");

// Class SHProto.KeyRichTextsSettings
// 0x0030 (0x0068 - 0x0038)
class UKeyRichTextsSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UKeyRichTexts>           KeyRichTexts;                                      // 0x0038(0x0030)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeyRichTextsSettings">();
	}
	static class UKeyRichTextsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKeyRichTextsSettings>();
	}
};
static_assert(alignof(UKeyRichTextsSettings) == 0x000008, "Wrong alignment on UKeyRichTextsSettings");
static_assert(sizeof(UKeyRichTextsSettings) == 0x000068, "Wrong size on UKeyRichTextsSettings");
static_assert(offsetof(UKeyRichTextsSettings, KeyRichTexts) == 0x000038, "Member 'UKeyRichTextsSettings::KeyRichTexts' has a wrong offset!");

// Class SHProto.SHOtherStatics
// 0x0000 (0x0028 - 0x0028)
class USHOtherStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool BoxComponentEncompassesPoint(class UBoxComponent* InBoxComponent, const struct FVector& InCheckedPoint);
	static bool CanDrawLevelDebug(const class AActor* InActorContext);
	static void ClearWorldState(class UObject* WorldContextObject);
	static void DisableAffectNavigation(class UActorComponent* InActorComponent);
	static void DrawDebugArc(const class UObject* WorldContextObject, const struct FVector& Center, const float MinAngle, const float MaxAngle, float Radius, int32 NumSegments, const struct FLinearColor& Color, float Duration, float Thickness, const struct FVector& YAxis, const struct FVector& ZAxis, bool bDrawAxis);
	static void DrawDebugBoxEx(const class UObject* WorldContextObject, const struct FVector& Center, const struct FVector& Box, const struct FRotator& Rotation, const struct FLinearColor& Color, float Duration, float Thickness, int32 TopPlaneDepthPriority, int32 BottomPlaneDepthPriority, int32 SidesPlanesDepthPriority);
	static void DrawDebugRadiusAtSimpleSplineComponent(class UObject* WorldContextObject, class USplineComponent* SplineComponent, const float Radius, const float HeightOffset, const struct FLinearColor& Color, float Duration, float Thickness);
	static void DrawDebugSegmentRadius2D(const class UObject* WorldContextObject, const struct FVector& SegmentStart, const struct FVector& SegmentEnd, const float Radius, const struct FLinearColor& Color, const float DrawTime, const float Thickness);
	static void DrawDebugSimpleCylinder(const class UObject* WorldContextObject, const struct FVector& StartPosition, const struct FVector& EndPosition, const float Radius, const struct FLinearColor& Color, const float DrawTime, const float Thickness);
	static void DrawDebugStaticMeshComponent(const class UObject* WorldContextObject, class UStaticMeshComponent* StaticMeshComponent, const struct FLinearColor& Color, float Duration, float Thickness);
	static void DrawDebugVolume(const class UObject* WorldContextObject, class AVolume* InVolume, bool bUseTriangulate, const struct FLinearColor& Color, float Duration, float Thickness);
	static class AActor* FindFurthestActor(const struct FVector& Origin, const TArray<class AActor*>& ActorsToCheck, float* Distance);
	static float FInterpToConstantAngle(float Current, float Target, const float DeltaTime, const float Speed);
	static void ForceDisableLumenReflections();
	static void ForceEnableLumenReflections();
	static TArray<struct FVector> GenerateGridLocationsArray(const struct FVector& GridStartPoint, const struct FIntPoint& GridSize, const struct FVector2D& GridDistribution, const struct FTransform& GridWorldTransform);
	static class UAnimationAsset* GetAnimToPlay(class USkeletalMeshComponent* InComponent);
	static class UDataTable* GetEquipmentDataTable();
	static struct FTransform GetFirstViewportTransform();
	static bool GetGenericDeathPlayerFullAreaWork(TSubclassOf<class ASHCharacterPlayGenericDeathPlayer> InClass, struct FVector* OutExtend, struct FVector* OutRelLoc);
	static int32 GetGFrameNumber();
	static class UDataTable* GetItemsDataTable();
	static class UDataTable* GetMapsDataTable();
	static struct FVector GetPreSkinPosition(class USkinnedMeshComponent* Component, class FName BoneName, const struct FVector& WorldPosition);
	static struct FVector GetRootMotionTranslation(class UAnimationAsset* AnimationAsset);
	static struct FRotator GetRotatorInterpTo(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed);
	static float GetRotatorsComponentDelta(const float InRot1, const float InRot2);
	static struct FRotator GetRotatorsDelta(const struct FRotator& InRot1, const struct FRotator& InRot2);
	static int32 GetShowFlagValue(const class FString& InName);
	static class UDataTable* GetUseablesDataTable();
	static class UDataTable* GetWeaponsDataTable();
	static bool HasValidWorld(class UObject* WorldContextObject);
	static bool IsGoalReachable(class AController* Controller, const struct FVector& GoalLocation, TSubclassOf<class UNavigationQueryFilter> FilterClass, float InSearchDistance, float DistanceTolerance);
	static bool IsSonyDemo();
	static bool IsWorldLocInGenericDeathPlayerFullAreaWork(TSubclassOf<class ASHCharacterPlayGenericDeathPlayer> InClass, const struct FVector& InWorldLoc);
	static void LogErrorPIE(const class FString& InLogString);
	static void LogWarnPIE(const class FString& InLogString);
	static void RemoveLinkedAnimInstances(class UAnimInstance* AnimInstance);
	static void RestoreForcedLumenReflections();
	static void SetDefaultCollisionProfile(class UPrimitiveComponent* InComp);
	static void SortIntsArray(TArray<int32>& Array, const bool bAscending);
	static void SplitNameIntMapSortedByInt(const TMap<class FString, int32>& StringIntMap, TArray<class FString>& StringArray, TArray<int32>& IntArray, const bool bAscending);
	static void Trace_ContextObject_CPUProfiler(class UObject* ContextObject);
	static ESHSimpleDirectionType VectorsToSimpleDirectionType(const struct FVector& InVectorA, const struct FVector& InVectorB);
	static bool VolumeEncompassesPoint(class AVolume* InVolume, const struct FVector& InCheckedPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHOtherStatics">();
	}
	static class USHOtherStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHOtherStatics>();
	}
};
static_assert(alignof(USHOtherStatics) == 0x000008, "Wrong alignment on USHOtherStatics");
static_assert(sizeof(USHOtherStatics) == 0x000028, "Wrong size on USHOtherStatics");

// Class SHProto.SHAnimNotify_KnockdownChangeState
// 0x0008 (0x0040 - 0x0038)
class USHAnimNotify_KnockdownChangeState final : public UAnimNotify
{
public:
	EKnockDownState                               KnockDownState;                                    // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_KnockdownChangeState">();
	}
	static class USHAnimNotify_KnockdownChangeState* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_KnockdownChangeState>();
	}
};
static_assert(alignof(USHAnimNotify_KnockdownChangeState) == 0x000008, "Wrong alignment on USHAnimNotify_KnockdownChangeState");
static_assert(sizeof(USHAnimNotify_KnockdownChangeState) == 0x000040, "Wrong size on USHAnimNotify_KnockdownChangeState");
static_assert(offsetof(USHAnimNotify_KnockdownChangeState, KnockDownState) == 0x000038, "Member 'USHAnimNotify_KnockdownChangeState::KnockDownState' has a wrong offset!");

// Class SHProto.SkeletonRagdollProfile
// 0x0080 (0x00A8 - 0x0028)
class USkeletonRagdollProfile : public UObject
{
public:
	bool                                          bIsActive;                                         // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPaused;                                         // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Blend;                                             // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeFromStart;                                     // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 BonesBlend;                                        // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         BonesNum;                                          // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkeletonRagdollProfileData            ProfileData;                                       // 0x0050(0x0050)(Protected, NativeAccessSpecifierProtected)
	float                                         TimeScale;                                         // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeOfBlend;                                       // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletonRagdollProfile">();
	}
	static class USkeletonRagdollProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkeletonRagdollProfile>();
	}
};
static_assert(alignof(USkeletonRagdollProfile) == 0x000008, "Wrong alignment on USkeletonRagdollProfile");
static_assert(sizeof(USkeletonRagdollProfile) == 0x0000A8, "Wrong size on USkeletonRagdollProfile");
static_assert(offsetof(USkeletonRagdollProfile, bIsActive) == 0x000028, "Member 'USkeletonRagdollProfile::bIsActive' has a wrong offset!");
static_assert(offsetof(USkeletonRagdollProfile, bIsPaused) == 0x000029, "Member 'USkeletonRagdollProfile::bIsPaused' has a wrong offset!");
static_assert(offsetof(USkeletonRagdollProfile, Blend) == 0x00002C, "Member 'USkeletonRagdollProfile::Blend' has a wrong offset!");
static_assert(offsetof(USkeletonRagdollProfile, TimeFromStart) == 0x000030, "Member 'USkeletonRagdollProfile::TimeFromStart' has a wrong offset!");
static_assert(offsetof(USkeletonRagdollProfile, BonesBlend) == 0x000038, "Member 'USkeletonRagdollProfile::BonesBlend' has a wrong offset!");
static_assert(offsetof(USkeletonRagdollProfile, BonesNum) == 0x000048, "Member 'USkeletonRagdollProfile::BonesNum' has a wrong offset!");
static_assert(offsetof(USkeletonRagdollProfile, ProfileData) == 0x000050, "Member 'USkeletonRagdollProfile::ProfileData' has a wrong offset!");
static_assert(offsetof(USkeletonRagdollProfile, TimeScale) == 0x0000A0, "Member 'USkeletonRagdollProfile::TimeScale' has a wrong offset!");
static_assert(offsetof(USkeletonRagdollProfile, TimeOfBlend) == 0x0000A4, "Member 'USkeletonRagdollProfile::TimeOfBlend' has a wrong offset!");

// Class SHProto.SkeletonRagdollProfileBonesSpecific
// 0x0000 (0x00A8 - 0x00A8)
class USkeletonRagdollProfileBonesSpecific final : public USkeletonRagdollProfile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletonRagdollProfileBonesSpecific">();
	}
	static class USkeletonRagdollProfileBonesSpecific* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkeletonRagdollProfileBonesSpecific>();
	}
};
static_assert(alignof(USkeletonRagdollProfileBonesSpecific) == 0x000008, "Wrong alignment on USkeletonRagdollProfileBonesSpecific");
static_assert(sizeof(USkeletonRagdollProfileBonesSpecific) == 0x0000A8, "Wrong size on USkeletonRagdollProfileBonesSpecific");

// Class SHProto.SHAnimNState_KnockdownState
// 0x0008 (0x0038 - 0x0030)
class USHAnimNState_KnockdownState final : public UAnimNotifyState
{
public:
	EKnockDownState                               KnockDownState;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKnockDownState                               KnockDownStateOnExit;                              // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNState_KnockdownState">();
	}
	static class USHAnimNState_KnockdownState* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNState_KnockdownState>();
	}
};
static_assert(alignof(USHAnimNState_KnockdownState) == 0x000008, "Wrong alignment on USHAnimNState_KnockdownState");
static_assert(sizeof(USHAnimNState_KnockdownState) == 0x000038, "Wrong size on USHAnimNState_KnockdownState");
static_assert(offsetof(USHAnimNState_KnockdownState, KnockDownState) == 0x000030, "Member 'USHAnimNState_KnockdownState::KnockDownState' has a wrong offset!");
static_assert(offsetof(USHAnimNState_KnockdownState, KnockDownStateOnExit) == 0x000031, "Member 'USHAnimNState_KnockdownState::KnockDownStateOnExit' has a wrong offset!");

// Class SHProto.SHDynamicItemsManager
// 0x0080 (0x0330 - 0x02B0)
class ASHDynamicItemsManager final : public AActor
{
public:
	TSet<TSoftObjectPtr<class ASHDynamicItem>>    ManagedDynamicItems;                               // 0x02B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FSHItemAndQuantityHandle>       DynamicItemsDataQueue;                             // 0x0300(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	bool                                          bCollectDifferentItemData;                         // 0x0310(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDataTableRowHandle>            DynamicDifferentItemDataToCollectQueue;            // 0x0318(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentQueueIndex;                                 // 0x0328(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessItemCollected(class ASHItem* ItemPtr);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDynamicItemsManager">();
	}
	static class ASHDynamicItemsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHDynamicItemsManager>();
	}
};
static_assert(alignof(ASHDynamicItemsManager) == 0x000008, "Wrong alignment on ASHDynamicItemsManager");
static_assert(sizeof(ASHDynamicItemsManager) == 0x000330, "Wrong size on ASHDynamicItemsManager");
static_assert(offsetof(ASHDynamicItemsManager, ManagedDynamicItems) == 0x0002B0, "Member 'ASHDynamicItemsManager::ManagedDynamicItems' has a wrong offset!");
static_assert(offsetof(ASHDynamicItemsManager, DynamicItemsDataQueue) == 0x000300, "Member 'ASHDynamicItemsManager::DynamicItemsDataQueue' has a wrong offset!");
static_assert(offsetof(ASHDynamicItemsManager, bCollectDifferentItemData) == 0x000310, "Member 'ASHDynamicItemsManager::bCollectDifferentItemData' has a wrong offset!");
static_assert(offsetof(ASHDynamicItemsManager, DynamicDifferentItemDataToCollectQueue) == 0x000318, "Member 'ASHDynamicItemsManager::DynamicDifferentItemDataToCollectQueue' has a wrong offset!");
static_assert(offsetof(ASHDynamicItemsManager, CurrentQueueIndex) == 0x000328, "Member 'ASHDynamicItemsManager::CurrentQueueIndex' has a wrong offset!");

// Class SHProto.LoadingHints
// 0x0050 (0x0080 - 0x0030)
class ULoadingHints final : public UDataAsset
{
public:
	TMap<class FName, struct FLoadingHint>        Hints;                                             // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingHints">();
	}
	static class ULoadingHints* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingHints>();
	}
};
static_assert(alignof(ULoadingHints) == 0x000008, "Wrong alignment on ULoadingHints");
static_assert(sizeof(ULoadingHints) == 0x000080, "Wrong size on ULoadingHints");
static_assert(offsetof(ULoadingHints, Hints) == 0x000030, "Member 'ULoadingHints::Hints' has a wrong offset!");

// Class SHProto.LocalFogVolumeActor
// 0x0000 (0x02B0 - 0x02B0)
class ALocalFogVolumeActor : public AActor
{
public:
	void SetDebugPosition(const struct FTransform& Transform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalFogVolumeActor">();
	}
	static class ALocalFogVolumeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALocalFogVolumeActor>();
	}
};
static_assert(alignof(ALocalFogVolumeActor) == 0x000008, "Wrong alignment on ALocalFogVolumeActor");
static_assert(sizeof(ALocalFogVolumeActor) == 0x0002B0, "Wrong size on ALocalFogVolumeActor");

// Class SHProto.SHEddieMeatPushComponent
// 0x0048 (0x00E8 - 0x00A0)
class USHEddieMeatPushComponent final : public UActorComponent
{
public:
	float                                         OverlapUpdateRate;                                 // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASHMeatConveyorBase*                    MeatConveyorRef;                                   // 0x00A8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BBMeatActorKey;                                    // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BBAttackPositionKey;                               // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BBLockAttMeatKey;                                  // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BBShouldPushLeftKey;                               // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessPlayerCharacterInWorkAreaTick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEddieMeatPushComponent">();
	}
	static class USHEddieMeatPushComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEddieMeatPushComponent>();
	}
};
static_assert(alignof(USHEddieMeatPushComponent) == 0x000008, "Wrong alignment on USHEddieMeatPushComponent");
static_assert(sizeof(USHEddieMeatPushComponent) == 0x0000E8, "Wrong size on USHEddieMeatPushComponent");
static_assert(offsetof(USHEddieMeatPushComponent, OverlapUpdateRate) == 0x0000A0, "Member 'USHEddieMeatPushComponent::OverlapUpdateRate' has a wrong offset!");
static_assert(offsetof(USHEddieMeatPushComponent, MeatConveyorRef) == 0x0000A8, "Member 'USHEddieMeatPushComponent::MeatConveyorRef' has a wrong offset!");
static_assert(offsetof(USHEddieMeatPushComponent, BBMeatActorKey) == 0x0000B0, "Member 'USHEddieMeatPushComponent::BBMeatActorKey' has a wrong offset!");
static_assert(offsetof(USHEddieMeatPushComponent, BBAttackPositionKey) == 0x0000B8, "Member 'USHEddieMeatPushComponent::BBAttackPositionKey' has a wrong offset!");
static_assert(offsetof(USHEddieMeatPushComponent, BBLockAttMeatKey) == 0x0000C0, "Member 'USHEddieMeatPushComponent::BBLockAttMeatKey' has a wrong offset!");
static_assert(offsetof(USHEddieMeatPushComponent, BBShouldPushLeftKey) == 0x0000C8, "Member 'USHEddieMeatPushComponent::BBShouldPushLeftKey' has a wrong offset!");

// Class SHProto.SHAnimNotify_LyingTransformation
// 0x0020 (0x0058 - 0x0038)
class USHAnimNotify_LyingTransformation final : public UAnimNotify
{
public:
	class FName                                   TransformationReason;                              // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          TransformToLying;                                  // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransformationDuration;                            // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AwaitDelayedRootRotation;                          // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DisableAIDuringTransformation;                     // 0x0049(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LyingCapsuleAnchor;                                // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumCapsuleExtensions;                          // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_LyingTransformation">();
	}
	static class USHAnimNotify_LyingTransformation* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_LyingTransformation>();
	}
};
static_assert(alignof(USHAnimNotify_LyingTransformation) == 0x000008, "Wrong alignment on USHAnimNotify_LyingTransformation");
static_assert(sizeof(USHAnimNotify_LyingTransformation) == 0x000058, "Wrong size on USHAnimNotify_LyingTransformation");
static_assert(offsetof(USHAnimNotify_LyingTransformation, TransformationReason) == 0x000038, "Member 'USHAnimNotify_LyingTransformation::TransformationReason' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_LyingTransformation, TransformToLying) == 0x000040, "Member 'USHAnimNotify_LyingTransformation::TransformToLying' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_LyingTransformation, TransformationDuration) == 0x000044, "Member 'USHAnimNotify_LyingTransformation::TransformationDuration' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_LyingTransformation, AwaitDelayedRootRotation) == 0x000048, "Member 'USHAnimNotify_LyingTransformation::AwaitDelayedRootRotation' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_LyingTransformation, DisableAIDuringTransformation) == 0x000049, "Member 'USHAnimNotify_LyingTransformation::DisableAIDuringTransformation' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_LyingTransformation, LyingCapsuleAnchor) == 0x00004C, "Member 'USHAnimNotify_LyingTransformation::LyingCapsuleAnchor' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_LyingTransformation, MaximumCapsuleExtensions) == 0x000050, "Member 'USHAnimNotify_LyingTransformation::MaximumCapsuleExtensions' has a wrong offset!");

// Class SHProto.SHAnimNotify_LyingTransformationDelayedRootRotation
// 0x0000 (0x0038 - 0x0038)
class USHAnimNotify_LyingTransformationDelayedRootRotation final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_LyingTransformationDelayedRootRotation">();
	}
	static class USHAnimNotify_LyingTransformationDelayedRootRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_LyingTransformationDelayedRootRotation>();
	}
};
static_assert(alignof(USHAnimNotify_LyingTransformationDelayedRootRotation) == 0x000008, "Wrong alignment on USHAnimNotify_LyingTransformationDelayedRootRotation");
static_assert(sizeof(USHAnimNotify_LyingTransformationDelayedRootRotation) == 0x000038, "Wrong size on USHAnimNotify_LyingTransformationDelayedRootRotation");

// Class SHProto.SHGameMode
// 0x0000 (0x03B0 - 0x03B0)
class ASHGameMode : public ABGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameMode">();
	}
	static class ASHGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHGameMode>();
	}
};
static_assert(alignof(ASHGameMode) == 0x000008, "Wrong alignment on ASHGameMode");
static_assert(sizeof(ASHGameMode) == 0x0003B0, "Wrong size on ASHGameMode");

// Class SHProto.MainMenuGameMode
// 0x0010 (0x03C0 - 0x03B0)
class AMainMenuGameMode : public ASHGameMode
{
public:
	uint8                                         Pad_3B0[0x4];                                      // 0x03B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MenuFadeTime;                                      // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEffectHandle                          LightEffect;                                       // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuGameMode">();
	}
	static class AMainMenuGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMainMenuGameMode>();
	}
};
static_assert(alignof(AMainMenuGameMode) == 0x000008, "Wrong alignment on AMainMenuGameMode");
static_assert(sizeof(AMainMenuGameMode) == 0x0003C0, "Wrong size on AMainMenuGameMode");
static_assert(offsetof(AMainMenuGameMode, MenuFadeTime) == 0x0003B4, "Member 'AMainMenuGameMode::MenuFadeTime' has a wrong offset!");
static_assert(offsetof(AMainMenuGameMode, LightEffect) == 0x0003B8, "Member 'AMainMenuGameMode::LightEffect' has a wrong offset!");

// Class SHProto.SHPlayerCameraManager
// 0x0000 (0x3420 - 0x3420)
class ASHPlayerCameraManager : public APlayerCameraManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPlayerCameraManager">();
	}
	static class ASHPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHPlayerCameraManager>();
	}
};
static_assert(alignof(ASHPlayerCameraManager) == 0x000010, "Wrong alignment on ASHPlayerCameraManager");
static_assert(sizeof(ASHPlayerCameraManager) == 0x003420, "Wrong size on ASHPlayerCameraManager");

// Class SHProto.MandarinLookAtComponent
// 0x0070 (0x0630 - 0x05C0)
class UMandarinLookAtComponent final : public UMaiLookAtComponent
{
public:
	bool                                          IsOver;                                            // 0x05B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B9[0x3];                                      // 0x05B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeadUpdateMinDot;                                  // 0x05BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeHeadRotation;                              // 0x05C0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsLookingAt;                                       // 0x05D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D9[0x3];                                      // 0x05D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtAlphaAddRate;                                // 0x05DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtAlphaLoseRate;                               // 0x05E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtAlpha;                                       // 0x05E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtVinterpRate;                                 // 0x05E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCurrentPriority;                                // 0x05EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DesiredPriority;                                   // 0x05ED(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5EE[0x2];                                      // 0x05EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetZOffset;                                     // 0x05F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoseInterestDistance;                              // 0x05F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackYawLimit;                                    // 0x05F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackPitchLimit;                                  // 0x05FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePitchCorrection;                                // 0x0600(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_601[0x3];                                      // 0x0601(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PitchCorrectionMin;                                // 0x0604(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchCorrectionMax;                                // 0x0608(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAttackLookAtLimits;                             // 0x060C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60D[0x23];                                     // 0x060D(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetLookAtTargetLocation();
	void SetAttackLookAtLimits(bool AttackLimit);
	void SetFreezeLookAt(bool Freeze);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MandarinLookAtComponent">();
	}
	static class UMandarinLookAtComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMandarinLookAtComponent>();
	}
};
static_assert(alignof(UMandarinLookAtComponent) == 0x000010, "Wrong alignment on UMandarinLookAtComponent");
static_assert(sizeof(UMandarinLookAtComponent) == 0x000630, "Wrong size on UMandarinLookAtComponent");
static_assert(offsetof(UMandarinLookAtComponent, IsOver) == 0x0005B8, "Member 'UMandarinLookAtComponent::IsOver' has a wrong offset!");
static_assert(offsetof(UMandarinLookAtComponent, HeadUpdateMinDot) == 0x0005BC, "Member 'UMandarinLookAtComponent::HeadUpdateMinDot' has a wrong offset!");
static_assert(offsetof(UMandarinLookAtComponent, RelativeHeadRotation) == 0x0005C0, "Member 'UMandarinLookAtComponent::RelativeHeadRotation' has a wrong offset!");
static_assert(offsetof(UMandarinLookAtComponent, IsLookingAt) == 0x0005D8, "Member 'UMandarinLookAtComponent::IsLookingAt' has a wrong offset!");
static_assert(offsetof(UMandarinLookAtComponent, LookAtAlphaAddRate) == 0x0005DC, "Member 'UMandarinLookAtComponent::LookAtAlphaAddRate' has a wrong offset!");
static_assert(offsetof(UMandarinLookAtComponent, LookAtAlphaLoseRate) == 0x0005E0, "Member 'UMandarinLookAtComponent::LookAtAlphaLoseRate' has a wrong offset!");
static_assert(offsetof(UMandarinLookAtComponent, LookAtAlpha) == 0x0005E4, "Member 'UMandarinLookAtComponent::LookAtAlpha' has a wrong offset!");
static_assert(offsetof(UMandarinLookAtComponent, LookAtVinterpRate) == 0x0005E8, "Member 'UMandarinLookAtComponent::LookAtVinterpRate' has a wrong offset!");
static_assert(offsetof(UMandarinLookAtComponent, UseCurrentPriority) == 0x0005EC, "Member 'UMandarinLookAtComponent::UseCurrentPriority' has a wrong offset!");
static_assert(offsetof(UMandarinLookAtComponent, DesiredPriority) == 0x0005ED, "Member 'UMandarinLookAtComponent::DesiredPriority' has a wrong offset!");
static_assert(offsetof(UMandarinLookAtComponent, TargetZOffset) == 0x0005F0, "Member 'UMandarinLookAtComponent::TargetZOffset' has a wrong offset!");
static_assert(offsetof(UMandarinLookAtComponent, LoseInterestDistance) == 0x0005F4, "Member 'UMandarinLookAtComponent::LoseInterestDistance' has a wrong offset!");
static_assert(offsetof(UMandarinLookAtComponent, AttackYawLimit) == 0x0005F8, "Member 'UMandarinLookAtComponent::AttackYawLimit' has a wrong offset!");
static_assert(offsetof(UMandarinLookAtComponent, AttackPitchLimit) == 0x0005FC, "Member 'UMandarinLookAtComponent::AttackPitchLimit' has a wrong offset!");
static_assert(offsetof(UMandarinLookAtComponent, UsePitchCorrection) == 0x000600, "Member 'UMandarinLookAtComponent::UsePitchCorrection' has a wrong offset!");
static_assert(offsetof(UMandarinLookAtComponent, PitchCorrectionMin) == 0x000604, "Member 'UMandarinLookAtComponent::PitchCorrectionMin' has a wrong offset!");
static_assert(offsetof(UMandarinLookAtComponent, PitchCorrectionMax) == 0x000608, "Member 'UMandarinLookAtComponent::PitchCorrectionMax' has a wrong offset!");
static_assert(offsetof(UMandarinLookAtComponent, UseAttackLookAtLimits) == 0x00060C, "Member 'UMandarinLookAtComponent::UseAttackLookAtLimits' has a wrong offset!");

// Class SHProto.SHAnimNotify_PlayCharacterCameraShake
// 0x0010 (0x0048 - 0x0038)
class USHAnimNotify_PlayCharacterCameraShake final : public UAnimNotify
{
public:
	TSubclassOf<class UCameraShakeBase>           Shake;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShakeScale;                                        // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_PlayCharacterCameraShake">();
	}
	static class USHAnimNotify_PlayCharacterCameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_PlayCharacterCameraShake>();
	}
};
static_assert(alignof(USHAnimNotify_PlayCharacterCameraShake) == 0x000008, "Wrong alignment on USHAnimNotify_PlayCharacterCameraShake");
static_assert(sizeof(USHAnimNotify_PlayCharacterCameraShake) == 0x000048, "Wrong size on USHAnimNotify_PlayCharacterCameraShake");
static_assert(offsetof(USHAnimNotify_PlayCharacterCameraShake, Shake) == 0x000038, "Member 'USHAnimNotify_PlayCharacterCameraShake::Shake' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_PlayCharacterCameraShake, ShakeScale) == 0x000040, "Member 'USHAnimNotify_PlayCharacterCameraShake::ShakeScale' has a wrong offset!");

// Class SHProto.NiagaraActorDynamic
// 0x0008 (0x02B8 - 0x02B0)
class ANiagaraActorDynamic final : public AActor
{
public:
	class UNiagaraDynamicComponent*               NiagaraComponent;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraActorDynamic">();
	}
	static class ANiagaraActorDynamic* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANiagaraActorDynamic>();
	}
};
static_assert(alignof(ANiagaraActorDynamic) == 0x000008, "Wrong alignment on ANiagaraActorDynamic");
static_assert(sizeof(ANiagaraActorDynamic) == 0x0002B8, "Wrong size on ANiagaraActorDynamic");
static_assert(offsetof(ANiagaraActorDynamic, NiagaraComponent) == 0x0002B0, "Member 'ANiagaraActorDynamic::NiagaraComponent' has a wrong offset!");

// Class SHProto.SHCharacterLookAtLogicComponent
// 0x00E0 (0x0180 - 0x00A0)
class USHCharacterLookAtLogicComponent : public UActorComponent
{
public:
	TArray<TSoftClassPtr<class UClass>>           CharacterLookAtTypesPriorities;                    // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<TSoftClassPtr<class UClass>, class USHLookAtTargetProvider*> LookAtTargetProviders;                             // 0x00B0(0x0050)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class USHLookAtTargetScoreFunction> DefaultLookAtTargetScoreFunctionClass;             // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSoftClassPtr<class UClass>, class USHLookAtTargetScoreFunction*> CustomLookAtTargetScoreFunctions;                  // 0x0108(0x0050)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x20];                                     // 0x0158(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USHLookAtTargetScoreFunction*           DefaultLookAtTargetScoreFunction;                  // 0x0178(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void LookAtActor(class AActor* TargetActor, TSoftClassPtr<class UClass> LookAtTypeID, float BlendSpeed);
	void LookAtComponent(class USceneComponent* TargetComponent, TSoftClassPtr<class UClass> LookAtTypeID, float BlendSpeed);
	void ResetLookAtLogic(float BlendOutSpeed);
	void StopLookAtActor(class AActor* TargetActor, float BlendOutSpeed);
	void StopLookAtComponent(class USceneComponent* TargetComponent, float BlendOutSpeed);

	class USceneComponent* GetCurrentLookAtTarget() const;
	class USHLookAtTargetProvider* GetLookAtTargetProvider(const TSoftClassPtr<class UClass>& LookAtTypeID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterLookAtLogicComponent">();
	}
	static class USHCharacterLookAtLogicComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterLookAtLogicComponent>();
	}
};
static_assert(alignof(USHCharacterLookAtLogicComponent) == 0x000008, "Wrong alignment on USHCharacterLookAtLogicComponent");
static_assert(sizeof(USHCharacterLookAtLogicComponent) == 0x000180, "Wrong size on USHCharacterLookAtLogicComponent");
static_assert(offsetof(USHCharacterLookAtLogicComponent, CharacterLookAtTypesPriorities) == 0x0000A0, "Member 'USHCharacterLookAtLogicComponent::CharacterLookAtTypesPriorities' has a wrong offset!");
static_assert(offsetof(USHCharacterLookAtLogicComponent, LookAtTargetProviders) == 0x0000B0, "Member 'USHCharacterLookAtLogicComponent::LookAtTargetProviders' has a wrong offset!");
static_assert(offsetof(USHCharacterLookAtLogicComponent, DefaultLookAtTargetScoreFunctionClass) == 0x000100, "Member 'USHCharacterLookAtLogicComponent::DefaultLookAtTargetScoreFunctionClass' has a wrong offset!");
static_assert(offsetof(USHCharacterLookAtLogicComponent, CustomLookAtTargetScoreFunctions) == 0x000108, "Member 'USHCharacterLookAtLogicComponent::CustomLookAtTargetScoreFunctions' has a wrong offset!");
static_assert(offsetof(USHCharacterLookAtLogicComponent, DefaultLookAtTargetScoreFunction) == 0x000178, "Member 'USHCharacterLookAtLogicComponent::DefaultLookAtTargetScoreFunction' has a wrong offset!");

// Class SHProto.SHEddieLookAtLogicComponent
// 0x0010 (0x0190 - 0x0180)
class USHEddieLookAtLogicComponent final : public USHCharacterLookAtLogicComponent
{
public:
	uint8                                         Pad_180[0x10];                                     // 0x0180(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEddieLookAtLogicComponent">();
	}
	static class USHEddieLookAtLogicComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEddieLookAtLogicComponent>();
	}
};
static_assert(alignof(USHEddieLookAtLogicComponent) == 0x000008, "Wrong alignment on USHEddieLookAtLogicComponent");
static_assert(sizeof(USHEddieLookAtLogicComponent) == 0x000190, "Wrong size on USHEddieLookAtLogicComponent");

// Class SHProto.NiagaraDynamicComponent
// 0x0000 (0x07E0 - 0x07E0)
class UNiagaraDynamicComponent final : public UNiagaraComponent
{
public:
	class UMaterialInterface*                     OldMaterial;                                       // 0x07D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UMaterialInstanceDynamic* GetDynamicMaterialInstance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraDynamicComponent">();
	}
	static class UNiagaraDynamicComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiagaraDynamicComponent>();
	}
};
static_assert(alignof(UNiagaraDynamicComponent) == 0x000010, "Wrong alignment on UNiagaraDynamicComponent");
static_assert(sizeof(UNiagaraDynamicComponent) == 0x0007E0, "Wrong size on UNiagaraDynamicComponent");
static_assert(offsetof(UNiagaraDynamicComponent, OldMaterial) == 0x0007D8, "Member 'UNiagaraDynamicComponent::OldMaterial' has a wrong offset!");

// Class SHProto.PhysicalAnimationProfileDA
// 0x0050 (0x0080 - 0x0030)
class UPhysicalAnimationProfileDA final : public UDataAsset
{
public:
	TMap<EPhysicalAnimationProfile, struct FPhysicalAnimationProfileData> Profiles;                                          // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicalAnimationProfileDA">();
	}
	static class UPhysicalAnimationProfileDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicalAnimationProfileDA>();
	}
};
static_assert(alignof(UPhysicalAnimationProfileDA) == 0x000008, "Wrong alignment on UPhysicalAnimationProfileDA");
static_assert(sizeof(UPhysicalAnimationProfileDA) == 0x000080, "Wrong size on UPhysicalAnimationProfileDA");
static_assert(offsetof(UPhysicalAnimationProfileDA, Profiles) == 0x000030, "Member 'UPhysicalAnimationProfileDA::Profiles' has a wrong offset!");

// Class SHProto.PlaneSideDetectionComponent
// 0x0000 (0x02A0 - 0x02A0)
class UPlaneSideDetectionComponent final : public USceneComponent
{
public:
	ESHDetectionSide CalculateSide(const ESHDetectionPlaneType Plane, const struct FVector& Location) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaneSideDetectionComponent">();
	}
	static class UPlaneSideDetectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaneSideDetectionComponent>();
	}
};
static_assert(alignof(UPlaneSideDetectionComponent) == 0x000010, "Wrong alignment on UPlaneSideDetectionComponent");
static_assert(sizeof(UPlaneSideDetectionComponent) == 0x0002A0, "Wrong size on UPlaneSideDetectionComponent");

// Class SHProto.PlayGameMode
// 0x00F0 (0x04A0 - 0x03B0)
class APlayGameMode final : public ASHGameMode
{
public:
	class USHTimeManagerComponent*                TimeManager;                                       // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconManagerComponent*     IconManager;                                       // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAsyncLoaderComponent*                AsyncLoader;                                       // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnalyticsGameplayRecorderComponent*    AnalyticsGameplayRecorder;                         // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnalyticsPerformanceRecorderComponent* AnalyticsPerformanceRecorder;                      // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayControllerEffectsManager*    GameplayControllerEffectsManager;                  // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBeingFootstepManagerComponent*         FootstepManager;                                   // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXManagerComponent*                  SHFXManager;                                       // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFogManager*                          SHFogManager;                                      // 0x03F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHWaterManagerComponent*               SHWaterManager;                                    // 0x03F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHRainManagerComponent*                SHRainManager;                                     // 0x0400(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFreezingManagerComponent*            SHFreezingManager;                                 // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkAmbientSoundManagerComponent*      AkAmbientSoundManager;                             // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkComponentsPoolManagerComponent*    AkComponentsPoolManager;                           // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkSpatialAudioVolumeManagerComponent* AkSpatialAudioVolumeManager;                       // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkPortalManagerComponent*            AkPortalManager;                                   // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFlickeringLightManagerComponent*     FlickeringLightManager;                            // 0x0430(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHDoorsManagerComponent*               DoorsManager;                                      // 0x0438(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UUserWidget>>        DemoLockedAreaMessages;                            // 0x0440(0x0010)(Edit, ZeroConstructor, Config, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnGameIsReadyToPlay;                               // 0x0450(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UUserWidget*>                    DemoLockedAreaMessageWidgets;                      // 0x0460(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UPlayTimeComponent*                     PlayTimeComponent;                                 // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_478[0x28];                                     // 0x0478(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndFakeLoading();
	void GameReadyToPlayEvent__DelegateSignature();
	void SHDebug_World_DumpAllActors();
	void SHDebug_World_DumpAllLevels();

	bool IsReadyToPlay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayGameMode">();
	}
	static class APlayGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayGameMode>();
	}
};
static_assert(alignof(APlayGameMode) == 0x000008, "Wrong alignment on APlayGameMode");
static_assert(sizeof(APlayGameMode) == 0x0004A0, "Wrong size on APlayGameMode");
static_assert(offsetof(APlayGameMode, TimeManager) == 0x0003B0, "Member 'APlayGameMode::TimeManager' has a wrong offset!");
static_assert(offsetof(APlayGameMode, IconManager) == 0x0003B8, "Member 'APlayGameMode::IconManager' has a wrong offset!");
static_assert(offsetof(APlayGameMode, AsyncLoader) == 0x0003C0, "Member 'APlayGameMode::AsyncLoader' has a wrong offset!");
static_assert(offsetof(APlayGameMode, AnalyticsGameplayRecorder) == 0x0003C8, "Member 'APlayGameMode::AnalyticsGameplayRecorder' has a wrong offset!");
static_assert(offsetof(APlayGameMode, AnalyticsPerformanceRecorder) == 0x0003D0, "Member 'APlayGameMode::AnalyticsPerformanceRecorder' has a wrong offset!");
static_assert(offsetof(APlayGameMode, GameplayControllerEffectsManager) == 0x0003D8, "Member 'APlayGameMode::GameplayControllerEffectsManager' has a wrong offset!");
static_assert(offsetof(APlayGameMode, FootstepManager) == 0x0003E0, "Member 'APlayGameMode::FootstepManager' has a wrong offset!");
static_assert(offsetof(APlayGameMode, SHFXManager) == 0x0003E8, "Member 'APlayGameMode::SHFXManager' has a wrong offset!");
static_assert(offsetof(APlayGameMode, SHFogManager) == 0x0003F0, "Member 'APlayGameMode::SHFogManager' has a wrong offset!");
static_assert(offsetof(APlayGameMode, SHWaterManager) == 0x0003F8, "Member 'APlayGameMode::SHWaterManager' has a wrong offset!");
static_assert(offsetof(APlayGameMode, SHRainManager) == 0x000400, "Member 'APlayGameMode::SHRainManager' has a wrong offset!");
static_assert(offsetof(APlayGameMode, SHFreezingManager) == 0x000408, "Member 'APlayGameMode::SHFreezingManager' has a wrong offset!");
static_assert(offsetof(APlayGameMode, AkAmbientSoundManager) == 0x000410, "Member 'APlayGameMode::AkAmbientSoundManager' has a wrong offset!");
static_assert(offsetof(APlayGameMode, AkComponentsPoolManager) == 0x000418, "Member 'APlayGameMode::AkComponentsPoolManager' has a wrong offset!");
static_assert(offsetof(APlayGameMode, AkSpatialAudioVolumeManager) == 0x000420, "Member 'APlayGameMode::AkSpatialAudioVolumeManager' has a wrong offset!");
static_assert(offsetof(APlayGameMode, AkPortalManager) == 0x000428, "Member 'APlayGameMode::AkPortalManager' has a wrong offset!");
static_assert(offsetof(APlayGameMode, FlickeringLightManager) == 0x000430, "Member 'APlayGameMode::FlickeringLightManager' has a wrong offset!");
static_assert(offsetof(APlayGameMode, DoorsManager) == 0x000438, "Member 'APlayGameMode::DoorsManager' has a wrong offset!");
static_assert(offsetof(APlayGameMode, DemoLockedAreaMessages) == 0x000440, "Member 'APlayGameMode::DemoLockedAreaMessages' has a wrong offset!");
static_assert(offsetof(APlayGameMode, OnGameIsReadyToPlay) == 0x000450, "Member 'APlayGameMode::OnGameIsReadyToPlay' has a wrong offset!");
static_assert(offsetof(APlayGameMode, DemoLockedAreaMessageWidgets) == 0x000460, "Member 'APlayGameMode::DemoLockedAreaMessageWidgets' has a wrong offset!");
static_assert(offsetof(APlayGameMode, PlayTimeComponent) == 0x000470, "Member 'APlayGameMode::PlayTimeComponent' has a wrong offset!");

// Class SHProto.SEnemyHitReactionSelection
// 0x01B8 (0x01E8 - 0x0030)
class USEnemyHitReactionSelection final : public UDataAsset
{
public:
	struct FSHEnemyHitReactionSelectionHitResponsesConfiguration HitResponsesConfiguration;                         // 0x0030(0x0190)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSHEnemyHitReactionSelectionConsecutiveHitsCountingConfiguration HitCountingConfiguration;                          // 0x01C0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSHEnemyHitReactionSelectionConfiguration HitReactionSelectionConfiguration;                 // 0x01D8(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SEnemyHitReactionSelection">();
	}
	static class USEnemyHitReactionSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<USEnemyHitReactionSelection>();
	}
};
static_assert(alignof(USEnemyHitReactionSelection) == 0x000008, "Wrong alignment on USEnemyHitReactionSelection");
static_assert(sizeof(USEnemyHitReactionSelection) == 0x0001E8, "Wrong size on USEnemyHitReactionSelection");
static_assert(offsetof(USEnemyHitReactionSelection, HitResponsesConfiguration) == 0x000030, "Member 'USEnemyHitReactionSelection::HitResponsesConfiguration' has a wrong offset!");
static_assert(offsetof(USEnemyHitReactionSelection, HitCountingConfiguration) == 0x0001C0, "Member 'USEnemyHitReactionSelection::HitCountingConfiguration' has a wrong offset!");
static_assert(offsetof(USEnemyHitReactionSelection, HitReactionSelectionConfiguration) == 0x0001D8, "Member 'USEnemyHitReactionSelection::HitReactionSelectionConfiguration' has a wrong offset!");

// Class SHProto.PointLightWithShadowDistance
// 0x0000 (0x02C8 - 0x02C8)
class APointLightWithShadowDistance final : public APointLight
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PointLightWithShadowDistance">();
	}
	static class APointLightWithShadowDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<APointLightWithShadowDistance>();
	}
};
static_assert(alignof(APointLightWithShadowDistance) == 0x000008, "Wrong alignment on APointLightWithShadowDistance");
static_assert(sizeof(APointLightWithShadowDistance) == 0x0002C8, "Wrong size on APointLightWithShadowDistance");

// Class SHProto.PointLightWithShadowDistanceComponent
// 0x0010 (0x0430 - 0x0420)
class UPointLightWithShadowDistanceComponent final : public UPointLightComponent
{
public:
	float                                         ShadowMaxDrawDistance;                             // 0x0420(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowMaxDistanceFadeRange;                        // 0x0424(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PointLightWithShadowDistanceComponent">();
	}
	static class UPointLightWithShadowDistanceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPointLightWithShadowDistanceComponent>();
	}
};
static_assert(alignof(UPointLightWithShadowDistanceComponent) == 0x000010, "Wrong alignment on UPointLightWithShadowDistanceComponent");
static_assert(sizeof(UPointLightWithShadowDistanceComponent) == 0x000430, "Wrong size on UPointLightWithShadowDistanceComponent");
static_assert(offsetof(UPointLightWithShadowDistanceComponent, ShadowMaxDrawDistance) == 0x000420, "Member 'UPointLightWithShadowDistanceComponent::ShadowMaxDrawDistance' has a wrong offset!");
static_assert(offsetof(UPointLightWithShadowDistanceComponent, ShadowMaxDistanceFadeRange) == 0x000424, "Member 'UPointLightWithShadowDistanceComponent::ShadowMaxDistanceFadeRange' has a wrong offset!");

// Class SHProto.SHNurseFXComponent
// 0x0008 (0x0130 - 0x0128)
class USHNurseFXComponent final : public USHEnemyBaseFXComponent
{
public:
	class USHFXNurseHeadShakeSubcompSettings*     NurseHeadShakeSettings;                            // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHNurseFXComponent">();
	}
	static class USHNurseFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHNurseFXComponent>();
	}
};
static_assert(alignof(USHNurseFXComponent) == 0x000008, "Wrong alignment on USHNurseFXComponent");
static_assert(sizeof(USHNurseFXComponent) == 0x000130, "Wrong size on USHNurseFXComponent");
static_assert(offsetof(USHNurseFXComponent, NurseHeadShakeSettings) == 0x000128, "Member 'USHNurseFXComponent::NurseHeadShakeSettings' has a wrong offset!");

// Class SHProto.QualityAwareFoliageUserData
// 0x0008 (0x0030 - 0x0028)
class UQualityAwareFoliageUserData final : public UAssetUserData
{
public:
	ELightSignificanceLevel                       ShadowsSignificance;                               // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QualityAwareFoliageUserData">();
	}
	static class UQualityAwareFoliageUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQualityAwareFoliageUserData>();
	}
};
static_assert(alignof(UQualityAwareFoliageUserData) == 0x000008, "Wrong alignment on UQualityAwareFoliageUserData");
static_assert(sizeof(UQualityAwareFoliageUserData) == 0x000030, "Wrong size on UQualityAwareFoliageUserData");
static_assert(offsetof(UQualityAwareFoliageUserData, ShadowsSignificance) == 0x000028, "Member 'UQualityAwareFoliageUserData::ShadowsSignificance' has a wrong offset!");

// Class SHProto.QualityAwareFoliageInstancedStaticMeshComponent
// 0x0000 (0x0910 - 0x0910)
class UQualityAwareFoliageInstancedStaticMeshComponent final : public UFoliageInstancedStaticMeshComponent
{
public:
	ELightSignificanceLevel                       ShadowsSignificance;                               // 0x0908(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_909[0x7];                                      // 0x0909(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QualityAwareFoliageInstancedStaticMeshComponent">();
	}
	static class UQualityAwareFoliageInstancedStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQualityAwareFoliageInstancedStaticMeshComponent>();
	}
};
static_assert(alignof(UQualityAwareFoliageInstancedStaticMeshComponent) == 0x000010, "Wrong alignment on UQualityAwareFoliageInstancedStaticMeshComponent");
static_assert(sizeof(UQualityAwareFoliageInstancedStaticMeshComponent) == 0x000910, "Wrong size on UQualityAwareFoliageInstancedStaticMeshComponent");
static_assert(offsetof(UQualityAwareFoliageInstancedStaticMeshComponent, ShadowsSignificance) == 0x000908, "Member 'UQualityAwareFoliageInstancedStaticMeshComponent::ShadowsSignificance' has a wrong offset!");

// Class SHProto.SHExtraSettingsPanelWidget
// 0x0028 (0x0360 - 0x0338)
class USHExtraSettingsPanelWidget final : public UExtraSettingsPanelWidget
{
public:
	ESHExtraSettingsType                          PanelType;                                         // 0x0338(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAskDialogWidget*                       Confirmation_dialog;                               // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPanelNeedBackInfoDialog;                          // 0x0348(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPanelNeedFadeOutBeforeBackProcedure;              // 0x0349(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPanelNeedResetOnBackProcedure;                    // 0x034A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPanelNeedRevertOnBackProcedure;                   // 0x034B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       FadeOut_anim;                                      // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadedOut();
	void HideBackInfo();
	void OnHideBackInfo();
	void OnShowBackInfo(class FName Mode);
	void ShowBackInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHExtraSettingsPanelWidget">();
	}
	static class USHExtraSettingsPanelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHExtraSettingsPanelWidget>();
	}
};
static_assert(alignof(USHExtraSettingsPanelWidget) == 0x000008, "Wrong alignment on USHExtraSettingsPanelWidget");
static_assert(sizeof(USHExtraSettingsPanelWidget) == 0x000360, "Wrong size on USHExtraSettingsPanelWidget");
static_assert(offsetof(USHExtraSettingsPanelWidget, PanelType) == 0x000338, "Member 'USHExtraSettingsPanelWidget::PanelType' has a wrong offset!");
static_assert(offsetof(USHExtraSettingsPanelWidget, Confirmation_dialog) == 0x000340, "Member 'USHExtraSettingsPanelWidget::Confirmation_dialog' has a wrong offset!");
static_assert(offsetof(USHExtraSettingsPanelWidget, bPanelNeedBackInfoDialog) == 0x000348, "Member 'USHExtraSettingsPanelWidget::bPanelNeedBackInfoDialog' has a wrong offset!");
static_assert(offsetof(USHExtraSettingsPanelWidget, bPanelNeedFadeOutBeforeBackProcedure) == 0x000349, "Member 'USHExtraSettingsPanelWidget::bPanelNeedFadeOutBeforeBackProcedure' has a wrong offset!");
static_assert(offsetof(USHExtraSettingsPanelWidget, bPanelNeedResetOnBackProcedure) == 0x00034A, "Member 'USHExtraSettingsPanelWidget::bPanelNeedResetOnBackProcedure' has a wrong offset!");
static_assert(offsetof(USHExtraSettingsPanelWidget, bPanelNeedRevertOnBackProcedure) == 0x00034B, "Member 'USHExtraSettingsPanelWidget::bPanelNeedRevertOnBackProcedure' has a wrong offset!");
static_assert(offsetof(USHExtraSettingsPanelWidget, FadeOut_anim) == 0x000350, "Member 'USHExtraSettingsPanelWidget::FadeOut_anim' has a wrong offset!");

// Class SHProto.SHAnimNotify_EnableRagDoll
// 0x0010 (0x0048 - 0x0038)
class USHAnimNotify_EnableRagDoll final : public UAnimNotify
{
public:
	class FName                                   BoneChainName;                                     // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRagDollIsOptionalWhenReducingPhysicsUse;          // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_EnableRagDoll">();
	}
	static class USHAnimNotify_EnableRagDoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_EnableRagDoll>();
	}
};
static_assert(alignof(USHAnimNotify_EnableRagDoll) == 0x000008, "Wrong alignment on USHAnimNotify_EnableRagDoll");
static_assert(sizeof(USHAnimNotify_EnableRagDoll) == 0x000048, "Wrong size on USHAnimNotify_EnableRagDoll");
static_assert(offsetof(USHAnimNotify_EnableRagDoll, BoneChainName) == 0x000038, "Member 'USHAnimNotify_EnableRagDoll::BoneChainName' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_EnableRagDoll, bRagDollIsOptionalWhenReducingPhysicsUse) == 0x000040, "Member 'USHAnimNotify_EnableRagDoll::bRagDollIsOptionalWhenReducingPhysicsUse' has a wrong offset!");

// Class SHProto.SHAnimNotify_DisableRagDoll
// 0x0010 (0x0048 - 0x0038)
class USHAnimNotify_DisableRagDoll final : public UAnimNotify
{
public:
	class FName                                   BoneChainName;                                     // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutCurveBend;                                 // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_DisableRagDoll">();
	}
	static class USHAnimNotify_DisableRagDoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_DisableRagDoll>();
	}
};
static_assert(alignof(USHAnimNotify_DisableRagDoll) == 0x000008, "Wrong alignment on USHAnimNotify_DisableRagDoll");
static_assert(sizeof(USHAnimNotify_DisableRagDoll) == 0x000048, "Wrong size on USHAnimNotify_DisableRagDoll");
static_assert(offsetof(USHAnimNotify_DisableRagDoll, BoneChainName) == 0x000038, "Member 'USHAnimNotify_DisableRagDoll::BoneChainName' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_DisableRagDoll, BlendOutTime) == 0x000040, "Member 'USHAnimNotify_DisableRagDoll::BlendOutTime' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_DisableRagDoll, BlendOutCurveBend) == 0x000044, "Member 'USHAnimNotify_DisableRagDoll::BlendOutCurveBend' has a wrong offset!");

// Class SHProto.SHEnemyHitReactionSelectionStatics
// 0x0000 (0x0028 - 0x0028)
class USHEnemyHitReactionSelectionStatics final : public UBlueprintFunctionLibrary
{
public:
	static struct FSHEnemyHitReactionSelectionAllowedStates MakeAllowedHitReactionsAll();
	static struct FSHEnemyHitReactionSelectionAllowedStates MakeAllowedHitReactionsNone();
	static struct FSHEnemyHitReactionSelectionAllowedStates MakeAllowedHitReactionsSimple(bool AllowKnockdown, bool AllowFalter, bool AllowStagger, bool AllowNormal);
	static struct FSHEnemyHitReactionSelectionAllowedStates MergeAllowedHitReactions(struct FSHEnemyHitReactionSelectionAllowedStates& MergeInto, const struct FSHEnemyHitReactionSelectionAllowedStates& MergeFrom);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEnemyHitReactionSelectionStatics">();
	}
	static class USHEnemyHitReactionSelectionStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEnemyHitReactionSelectionStatics>();
	}
};
static_assert(alignof(USHEnemyHitReactionSelectionStatics) == 0x000008, "Wrong alignment on USHEnemyHitReactionSelectionStatics");
static_assert(sizeof(USHEnemyHitReactionSelectionStatics) == 0x000028, "Wrong size on USHEnemyHitReactionSelectionStatics");

// Class SHProto.SHAnimNotifyState_EnableRagDollInLyingCollision
// 0x0018 (0x0048 - 0x0030)
class USHAnimNotifyState_EnableRagDollInLyingCollision final : public UAnimNotifyState
{
public:
	class FName                                   BoneChainName;                                     // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLyingOnBack;                                      // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnableBelowTopExtensionAlpha;                      // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableBelowBottomExtensionAlpha;                   // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysEnableRagDollAtEnd;                         // 0x0044(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRagDollIsOptionalWhenReducingPhysicsUse;          // 0x0045(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotifyState_EnableRagDollInLyingCollision">();
	}
	static class USHAnimNotifyState_EnableRagDollInLyingCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotifyState_EnableRagDollInLyingCollision>();
	}
};
static_assert(alignof(USHAnimNotifyState_EnableRagDollInLyingCollision) == 0x000008, "Wrong alignment on USHAnimNotifyState_EnableRagDollInLyingCollision");
static_assert(sizeof(USHAnimNotifyState_EnableRagDollInLyingCollision) == 0x000048, "Wrong size on USHAnimNotifyState_EnableRagDollInLyingCollision");
static_assert(offsetof(USHAnimNotifyState_EnableRagDollInLyingCollision, BoneChainName) == 0x000030, "Member 'USHAnimNotifyState_EnableRagDollInLyingCollision::BoneChainName' has a wrong offset!");
static_assert(offsetof(USHAnimNotifyState_EnableRagDollInLyingCollision, bLyingOnBack) == 0x000038, "Member 'USHAnimNotifyState_EnableRagDollInLyingCollision::bLyingOnBack' has a wrong offset!");
static_assert(offsetof(USHAnimNotifyState_EnableRagDollInLyingCollision, EnableBelowTopExtensionAlpha) == 0x00003C, "Member 'USHAnimNotifyState_EnableRagDollInLyingCollision::EnableBelowTopExtensionAlpha' has a wrong offset!");
static_assert(offsetof(USHAnimNotifyState_EnableRagDollInLyingCollision, EnableBelowBottomExtensionAlpha) == 0x000040, "Member 'USHAnimNotifyState_EnableRagDollInLyingCollision::EnableBelowBottomExtensionAlpha' has a wrong offset!");
static_assert(offsetof(USHAnimNotifyState_EnableRagDollInLyingCollision, bAlwaysEnableRagDollAtEnd) == 0x000044, "Member 'USHAnimNotifyState_EnableRagDollInLyingCollision::bAlwaysEnableRagDollAtEnd' has a wrong offset!");
static_assert(offsetof(USHAnimNotifyState_EnableRagDollInLyingCollision, bRagDollIsOptionalWhenReducingPhysicsUse) == 0x000045, "Member 'USHAnimNotifyState_EnableRagDollInLyingCollision::bRagDollIsOptionalWhenReducingPhysicsUse' has a wrong offset!");

// Class SHProto.SHTraversalBaseComponent
// 0x00E8 (0x0188 - 0x00A0)
class USHTraversalBaseComponent : public UActorComponent
{
public:
	ESHTraversalType                              Type;                                              // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnabledBeginPlay;                                 // 0x00A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A2[0x2];                                       // 0x00A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoInvokeMaxDist2D;                               // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bManageOwnerTick;                                  // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             ProximityFoundCharacterPlayBlueprintEvent;         // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             ProximityLostCharacterPlayBlueprintEvent;          // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             TraversalEnableChangedBlueprintEvent;              // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class USphereComponent*                       ProximitySphere;                                   // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       InteractingCharacter;                              // 0x00E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x98];                                      // 0x00F0(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessProximityBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void ProcessProximityEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex);
	void SetEnabled(bool InEnable, class UObject* Object);
	void SetUnavailable(bool InUnavailable, class UObject* Object);
	void SHTraversalBaseEvent__DelegateSignature(class USHTraversalBaseComponent* ComponentPtr);

	bool IsEnabled() const;
	bool IsUnavailable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalBaseComponent">();
	}
	static class USHTraversalBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTraversalBaseComponent>();
	}
};
static_assert(alignof(USHTraversalBaseComponent) == 0x000008, "Wrong alignment on USHTraversalBaseComponent");
static_assert(sizeof(USHTraversalBaseComponent) == 0x000188, "Wrong size on USHTraversalBaseComponent");
static_assert(offsetof(USHTraversalBaseComponent, Type) == 0x0000A0, "Member 'USHTraversalBaseComponent::Type' has a wrong offset!");
static_assert(offsetof(USHTraversalBaseComponent, bEnabledBeginPlay) == 0x0000A1, "Member 'USHTraversalBaseComponent::bEnabledBeginPlay' has a wrong offset!");
static_assert(offsetof(USHTraversalBaseComponent, AutoInvokeMaxDist2D) == 0x0000A4, "Member 'USHTraversalBaseComponent::AutoInvokeMaxDist2D' has a wrong offset!");
static_assert(offsetof(USHTraversalBaseComponent, bManageOwnerTick) == 0x0000A8, "Member 'USHTraversalBaseComponent::bManageOwnerTick' has a wrong offset!");
static_assert(offsetof(USHTraversalBaseComponent, ProximityFoundCharacterPlayBlueprintEvent) == 0x0000B0, "Member 'USHTraversalBaseComponent::ProximityFoundCharacterPlayBlueprintEvent' has a wrong offset!");
static_assert(offsetof(USHTraversalBaseComponent, ProximityLostCharacterPlayBlueprintEvent) == 0x0000C0, "Member 'USHTraversalBaseComponent::ProximityLostCharacterPlayBlueprintEvent' has a wrong offset!");
static_assert(offsetof(USHTraversalBaseComponent, TraversalEnableChangedBlueprintEvent) == 0x0000D0, "Member 'USHTraversalBaseComponent::TraversalEnableChangedBlueprintEvent' has a wrong offset!");
static_assert(offsetof(USHTraversalBaseComponent, ProximitySphere) == 0x0000E0, "Member 'USHTraversalBaseComponent::ProximitySphere' has a wrong offset!");
static_assert(offsetof(USHTraversalBaseComponent, InteractingCharacter) == 0x0000E8, "Member 'USHTraversalBaseComponent::InteractingCharacter' has a wrong offset!");

// Class SHProto.SHTraversalClimbComponent
// 0x0158 (0x02E0 - 0x0188)
class alignas(0x10) USHTraversalClimbComponent final : public USHTraversalBaseComponent
{
public:
	float                                         MaxDistanceToEdge;                                 // 0x0188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAngleToEdge;                                    // 0x018C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USHTraversalClimbAnimInstance> AnimInstanceClass;                                 // 0x0190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceScoreMultiplier;                           // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewScoreMultiplier;                               // 0x019C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StandingOnSplineScoreMuliplier;                    // 0x01A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EdgeHeightCheckOffset;                             // 0x01A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDirectionDistOffset;                            // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraversalDirectionRadiusCheck;                     // 0x01AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HorizontalHeightCheckOffset;                       // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTraversalStarted;                                // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTraversalFinished;                               // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTraversalAborted;                                // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class USHTraversalClimbAnimInstance*          LinkedTraversalAnimGraphInstance;                  // 0x01E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USplineComponent*>               EdgeSplines;                                       // 0x01F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_200[0xE0];                                     // 0x0200(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize(class USphereComponent* InProximitySphere, const TArray<class USplineComponent*>& InEdgeSplines);
	void ProcessEndTraversal();
	void ProcessMovementSnapEnd(bool WasCompleted);
	void ProcessSlideSnapEnd(bool WasCompleted);
	void RegisterSplines(const TArray<class USplineComponent*>& InEdgeSplines);
	void SHClimbComponentEvent__DelegateSignature(ESHDetectionSide DetectionSide);
	void SHClimbEvent__DelegateSignature(class USHTraversalClimbComponent* ComponentPtr);
	void SHClimbWithSideEvent__DelegateSignature(class USHTraversalClimbComponent* ComponentPtr, ESHDetectionSide DetectionSide);
	void UnregisterSplines(const TArray<class USplineComponent*>& InEdgeSplines);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalClimbComponent">();
	}
	static class USHTraversalClimbComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTraversalClimbComponent>();
	}
};
static_assert(alignof(USHTraversalClimbComponent) == 0x000010, "Wrong alignment on USHTraversalClimbComponent");
static_assert(sizeof(USHTraversalClimbComponent) == 0x0002E0, "Wrong size on USHTraversalClimbComponent");
static_assert(offsetof(USHTraversalClimbComponent, MaxDistanceToEdge) == 0x000188, "Member 'USHTraversalClimbComponent::MaxDistanceToEdge' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbComponent, MaxAngleToEdge) == 0x00018C, "Member 'USHTraversalClimbComponent::MaxAngleToEdge' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbComponent, AnimInstanceClass) == 0x000190, "Member 'USHTraversalClimbComponent::AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbComponent, DistanceScoreMultiplier) == 0x000198, "Member 'USHTraversalClimbComponent::DistanceScoreMultiplier' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbComponent, ViewScoreMultiplier) == 0x00019C, "Member 'USHTraversalClimbComponent::ViewScoreMultiplier' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbComponent, StandingOnSplineScoreMuliplier) == 0x0001A0, "Member 'USHTraversalClimbComponent::StandingOnSplineScoreMuliplier' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbComponent, EdgeHeightCheckOffset) == 0x0001A4, "Member 'USHTraversalClimbComponent::EdgeHeightCheckOffset' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbComponent, MaxDirectionDistOffset) == 0x0001A8, "Member 'USHTraversalClimbComponent::MaxDirectionDistOffset' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbComponent, TraversalDirectionRadiusCheck) == 0x0001AC, "Member 'USHTraversalClimbComponent::TraversalDirectionRadiusCheck' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbComponent, HorizontalHeightCheckOffset) == 0x0001B0, "Member 'USHTraversalClimbComponent::HorizontalHeightCheckOffset' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbComponent, OnTraversalStarted) == 0x0001B8, "Member 'USHTraversalClimbComponent::OnTraversalStarted' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbComponent, OnTraversalFinished) == 0x0001C8, "Member 'USHTraversalClimbComponent::OnTraversalFinished' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbComponent, OnTraversalAborted) == 0x0001D8, "Member 'USHTraversalClimbComponent::OnTraversalAborted' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbComponent, LinkedTraversalAnimGraphInstance) == 0x0001E8, "Member 'USHTraversalClimbComponent::LinkedTraversalAnimGraphInstance' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbComponent, EdgeSplines) == 0x0001F0, "Member 'USHTraversalClimbComponent::EdgeSplines' has a wrong offset!");

// Class SHProto.SHAnimNotifyState_DisableRagDollOutOfLyingCollision
// 0x0020 (0x0050 - 0x0030)
class USHAnimNotifyState_DisableRagDollOutOfLyingCollision final : public UAnimNotifyState
{
public:
	class FName                                   BoneChainName;                                     // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutCurveBend;                                 // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLyingOnBack;                                      // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisableAboveTopExtensionAlpha;                     // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisableAboveBottomExtensionAlpha;                  // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysDisableRagDollAtEnd;                        // 0x004C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotifyState_DisableRagDollOutOfLyingCollision">();
	}
	static class USHAnimNotifyState_DisableRagDollOutOfLyingCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotifyState_DisableRagDollOutOfLyingCollision>();
	}
};
static_assert(alignof(USHAnimNotifyState_DisableRagDollOutOfLyingCollision) == 0x000008, "Wrong alignment on USHAnimNotifyState_DisableRagDollOutOfLyingCollision");
static_assert(sizeof(USHAnimNotifyState_DisableRagDollOutOfLyingCollision) == 0x000050, "Wrong size on USHAnimNotifyState_DisableRagDollOutOfLyingCollision");
static_assert(offsetof(USHAnimNotifyState_DisableRagDollOutOfLyingCollision, BoneChainName) == 0x000030, "Member 'USHAnimNotifyState_DisableRagDollOutOfLyingCollision::BoneChainName' has a wrong offset!");
static_assert(offsetof(USHAnimNotifyState_DisableRagDollOutOfLyingCollision, BlendOutTime) == 0x000038, "Member 'USHAnimNotifyState_DisableRagDollOutOfLyingCollision::BlendOutTime' has a wrong offset!");
static_assert(offsetof(USHAnimNotifyState_DisableRagDollOutOfLyingCollision, BlendOutCurveBend) == 0x00003C, "Member 'USHAnimNotifyState_DisableRagDollOutOfLyingCollision::BlendOutCurveBend' has a wrong offset!");
static_assert(offsetof(USHAnimNotifyState_DisableRagDollOutOfLyingCollision, bLyingOnBack) == 0x000040, "Member 'USHAnimNotifyState_DisableRagDollOutOfLyingCollision::bLyingOnBack' has a wrong offset!");
static_assert(offsetof(USHAnimNotifyState_DisableRagDollOutOfLyingCollision, DisableAboveTopExtensionAlpha) == 0x000044, "Member 'USHAnimNotifyState_DisableRagDollOutOfLyingCollision::DisableAboveTopExtensionAlpha' has a wrong offset!");
static_assert(offsetof(USHAnimNotifyState_DisableRagDollOutOfLyingCollision, DisableAboveBottomExtensionAlpha) == 0x000048, "Member 'USHAnimNotifyState_DisableRagDollOutOfLyingCollision::DisableAboveBottomExtensionAlpha' has a wrong offset!");
static_assert(offsetof(USHAnimNotifyState_DisableRagDollOutOfLyingCollision, bAlwaysDisableRagDollAtEnd) == 0x00004C, "Member 'USHAnimNotifyState_DisableRagDollOutOfLyingCollision::bAlwaysDisableRagDollAtEnd' has a wrong offset!");

// Class SHProto.SHBossBaseFXComponent
// 0x0020 (0x0110 - 0x00F0)
class USHBossBaseFXComponent : public USHFXComponent
{
public:
	class USHFXPenetrateSplashSubcompSettings*    PenetrateSplashSettings;                           // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXSplashPuddleSubcompSettings*       SplashPuddleSettings;                              // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXBleedingSubcompSettings*           BleedingSettings;                                  // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXVisualHPSubcompSettings*           VisualHPSettings;                                  // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBossBaseFXComponent">();
	}
	static class USHBossBaseFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBossBaseFXComponent>();
	}
};
static_assert(alignof(USHBossBaseFXComponent) == 0x000008, "Wrong alignment on USHBossBaseFXComponent");
static_assert(sizeof(USHBossBaseFXComponent) == 0x000110, "Wrong size on USHBossBaseFXComponent");
static_assert(offsetof(USHBossBaseFXComponent, PenetrateSplashSettings) == 0x0000F0, "Member 'USHBossBaseFXComponent::PenetrateSplashSettings' has a wrong offset!");
static_assert(offsetof(USHBossBaseFXComponent, SplashPuddleSettings) == 0x0000F8, "Member 'USHBossBaseFXComponent::SplashPuddleSettings' has a wrong offset!");
static_assert(offsetof(USHBossBaseFXComponent, BleedingSettings) == 0x000100, "Member 'USHBossBaseFXComponent::BleedingSettings' has a wrong offset!");
static_assert(offsetof(USHBossBaseFXComponent, VisualHPSettings) == 0x000108, "Member 'USHBossBaseFXComponent::VisualHPSettings' has a wrong offset!");

// Class SHProto.SHMaryBossFXComponent
// 0x0008 (0x0118 - 0x0110)
class USHMaryBossFXComponent final : public USHBossBaseFXComponent
{
public:
	class USHFXWaterInteractionSubcompSettings*   WaterInteractionSettings;                          // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMaryBossFXComponent">();
	}
	static class USHMaryBossFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMaryBossFXComponent>();
	}
};
static_assert(alignof(USHMaryBossFXComponent) == 0x000008, "Wrong alignment on USHMaryBossFXComponent");
static_assert(sizeof(USHMaryBossFXComponent) == 0x000118, "Wrong size on USHMaryBossFXComponent");
static_assert(offsetof(USHMaryBossFXComponent, WaterInteractionSettings) == 0x000110, "Member 'USHMaryBossFXComponent::WaterInteractionSettings' has a wrong offset!");

// Class SHProto.SHAnimNotify_RagDollPhysicsProfile
// 0x0010 (0x0048 - 0x0038)
class USHAnimNotify_RagDollPhysicsProfile final : public UAnimNotify
{
public:
	class FName                                   SetPhysicsProfile;                                 // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SetConstraintsProfile;                             // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_RagDollPhysicsProfile">();
	}
	static class USHAnimNotify_RagDollPhysicsProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_RagDollPhysicsProfile>();
	}
};
static_assert(alignof(USHAnimNotify_RagDollPhysicsProfile) == 0x000008, "Wrong alignment on USHAnimNotify_RagDollPhysicsProfile");
static_assert(sizeof(USHAnimNotify_RagDollPhysicsProfile) == 0x000048, "Wrong size on USHAnimNotify_RagDollPhysicsProfile");
static_assert(offsetof(USHAnimNotify_RagDollPhysicsProfile, SetPhysicsProfile) == 0x000038, "Member 'USHAnimNotify_RagDollPhysicsProfile::SetPhysicsProfile' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_RagDollPhysicsProfile, SetConstraintsProfile) == 0x000040, "Member 'USHAnimNotify_RagDollPhysicsProfile::SetConstraintsProfile' has a wrong offset!");

// Class SHProto.RectLightWithShadowDistance
// 0x0000 (0x02C8 - 0x02C8)
class ARectLightWithShadowDistance final : public ARectLight
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RectLightWithShadowDistance">();
	}
	static class ARectLightWithShadowDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARectLightWithShadowDistance>();
	}
};
static_assert(alignof(ARectLightWithShadowDistance) == 0x000008, "Wrong alignment on ARectLightWithShadowDistance");
static_assert(sizeof(ARectLightWithShadowDistance) == 0x0002C8, "Wrong size on ARectLightWithShadowDistance");

// Class SHProto.SHEnvironmentSwitchVolume
// 0x0050 (0x0338 - 0x02E8)
class ASHEnvironmentSwitchVolume final : public AVolume
{
public:
	TSoftObjectPtr<class UAkSwitchValue>          EnvironmentSwitchValue;                            // 0x02E8(0x0030)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSetEnviromentNoneSwitchOnLeave;                   // 0x0318(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEnabledOnBegin;                                 // 0x0319(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31A[0x1E];                                     // 0x031A(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnabled(const class UObject* Enabler, bool InEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEnvironmentSwitchVolume">();
	}
	static class ASHEnvironmentSwitchVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHEnvironmentSwitchVolume>();
	}
};
static_assert(alignof(ASHEnvironmentSwitchVolume) == 0x000008, "Wrong alignment on ASHEnvironmentSwitchVolume");
static_assert(sizeof(ASHEnvironmentSwitchVolume) == 0x000338, "Wrong size on ASHEnvironmentSwitchVolume");
static_assert(offsetof(ASHEnvironmentSwitchVolume, EnvironmentSwitchValue) == 0x0002E8, "Member 'ASHEnvironmentSwitchVolume::EnvironmentSwitchValue' has a wrong offset!");
static_assert(offsetof(ASHEnvironmentSwitchVolume, bSetEnviromentNoneSwitchOnLeave) == 0x000318, "Member 'ASHEnvironmentSwitchVolume::bSetEnviromentNoneSwitchOnLeave' has a wrong offset!");
static_assert(offsetof(ASHEnvironmentSwitchVolume, bIsEnabledOnBegin) == 0x000319, "Member 'ASHEnvironmentSwitchVolume::bIsEnabledOnBegin' has a wrong offset!");

// Class SHProto.RectLightWithShadowDistanceComponent
// 0x0010 (0x0440 - 0x0430)
class URectLightWithShadowDistanceComponent final : public URectLightComponent
{
public:
	float                                         ShadowMaxDrawDistance;                             // 0x0428(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowMaxDistanceFadeRange;                        // 0x042C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_430[0x10];                                     // 0x0430(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RectLightWithShadowDistanceComponent">();
	}
	static class URectLightWithShadowDistanceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URectLightWithShadowDistanceComponent>();
	}
};
static_assert(alignof(URectLightWithShadowDistanceComponent) == 0x000010, "Wrong alignment on URectLightWithShadowDistanceComponent");
static_assert(sizeof(URectLightWithShadowDistanceComponent) == 0x000440, "Wrong size on URectLightWithShadowDistanceComponent");
static_assert(offsetof(URectLightWithShadowDistanceComponent, ShadowMaxDrawDistance) == 0x000428, "Member 'URectLightWithShadowDistanceComponent::ShadowMaxDrawDistance' has a wrong offset!");
static_assert(offsetof(URectLightWithShadowDistanceComponent, ShadowMaxDistanceFadeRange) == 0x00042C, "Member 'URectLightWithShadowDistanceComponent::ShadowMaxDistanceFadeRange' has a wrong offset!");

// Class SHProto.SpotLightWithShadowDistanceComponent
// 0x0010 (0x0440 - 0x0430)
class USpotLightWithShadowDistanceComponent final : public USpotLightComponent
{
public:
	float                                         ShadowMaxDrawDistance;                             // 0x0428(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowMaxDistanceFadeRange;                        // 0x042C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_430[0x10];                                     // 0x0430(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpotLightWithShadowDistanceComponent">();
	}
	static class USpotLightWithShadowDistanceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpotLightWithShadowDistanceComponent>();
	}
};
static_assert(alignof(USpotLightWithShadowDistanceComponent) == 0x000010, "Wrong alignment on USpotLightWithShadowDistanceComponent");
static_assert(sizeof(USpotLightWithShadowDistanceComponent) == 0x000440, "Wrong size on USpotLightWithShadowDistanceComponent");
static_assert(offsetof(USpotLightWithShadowDistanceComponent, ShadowMaxDrawDistance) == 0x000428, "Member 'USpotLightWithShadowDistanceComponent::ShadowMaxDrawDistance' has a wrong offset!");
static_assert(offsetof(USpotLightWithShadowDistanceComponent, ShadowMaxDistanceFadeRange) == 0x00042C, "Member 'USpotLightWithShadowDistanceComponent::ShadowMaxDistanceFadeRange' has a wrong offset!");

// Class SHProto.SHAnimNotify_ReviveAIEnable
// 0x0000 (0x0038 - 0x0038)
class USHAnimNotify_ReviveAIEnable final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_ReviveAIEnable">();
	}
	static class USHAnimNotify_ReviveAIEnable* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_ReviveAIEnable>();
	}
};
static_assert(alignof(USHAnimNotify_ReviveAIEnable) == 0x000008, "Wrong alignment on USHAnimNotify_ReviveAIEnable");
static_assert(sizeof(USHAnimNotify_ReviveAIEnable) == 0x000038, "Wrong size on USHAnimNotify_ReviveAIEnable");

// Class SHProto.SHFlashlightTransformProcessor
// 0x0008 (0x0030 - 0x0028)
class USHFlashlightTransformProcessor : public UObject
{
public:
	class ASHFlashlight*                          Owner;                                             // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFlashlightTransformProcessor">();
	}
	static class USHFlashlightTransformProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFlashlightTransformProcessor>();
	}
};
static_assert(alignof(USHFlashlightTransformProcessor) == 0x000008, "Wrong alignment on USHFlashlightTransformProcessor");
static_assert(sizeof(USHFlashlightTransformProcessor) == 0x000030, "Wrong size on USHFlashlightTransformProcessor");
static_assert(offsetof(USHFlashlightTransformProcessor, Owner) == 0x000028, "Member 'USHFlashlightTransformProcessor::Owner' has a wrong offset!");

// Class SHProto.SHFlashlightInputRotationTransformProcessor
// 0x0120 (0x0150 - 0x0030)
class USHFlashlightInputRotationTransformProcessor final : public USHFlashlightTransformProcessor
{
public:
	uint8                                         Pad_30[0x120];                                     // 0x0030(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFlashlightInputRotationTransformProcessor">();
	}
	static class USHFlashlightInputRotationTransformProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFlashlightInputRotationTransformProcessor>();
	}
};
static_assert(alignof(USHFlashlightInputRotationTransformProcessor) == 0x000008, "Wrong alignment on USHFlashlightInputRotationTransformProcessor");
static_assert(sizeof(USHFlashlightInputRotationTransformProcessor) == 0x000150, "Wrong size on USHFlashlightInputRotationTransformProcessor");

// Class SHProto.SHAnimNotify_ReviveAIDisable
// 0x0000 (0x0038 - 0x0038)
class USHAnimNotify_ReviveAIDisable final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_ReviveAIDisable">();
	}
	static class USHAnimNotify_ReviveAIDisable* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_ReviveAIDisable>();
	}
};
static_assert(alignof(USHAnimNotify_ReviveAIDisable) == 0x000008, "Wrong alignment on USHAnimNotify_ReviveAIDisable");
static_assert(sizeof(USHAnimNotify_ReviveAIDisable) == 0x000038, "Wrong size on USHAnimNotify_ReviveAIDisable");

// Class SHProto.SHAnimNState_ReviveGetUpAI
// 0x0000 (0x0030 - 0x0030)
class USHAnimNState_ReviveGetUpAI final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNState_ReviveGetUpAI">();
	}
	static class USHAnimNState_ReviveGetUpAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNState_ReviveGetUpAI>();
	}
};
static_assert(alignof(USHAnimNState_ReviveGetUpAI) == 0x000008, "Wrong alignment on USHAnimNState_ReviveGetUpAI");
static_assert(sizeof(USHAnimNState_ReviveGetUpAI) == 0x000030, "Wrong size on USHAnimNState_ReviveGetUpAI");

// Class SHProto.SHFakeDoor
// 0x00A0 (0x0350 - 0x02B0)
class ASHFakeDoor final : public AActor
{
public:
	class UPlaneSideDetectionComponent*           PlaneSideDetector;                                 // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          FakeHitDetector;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkFakeDoorComponent*                 SHAkFakeDoorComponent;                             // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayMapObjectComponent*          GameplayMapObject;                                 // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSHMakeNoiseConfig                     NoiseConfig;                                       // 0x02D0(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USHFakeDoorAnimationsSetData*           AnimationsSetData;                                 // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAutoLockedDoorCheckAnimPlayed;                   // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x48];                                     // 0x0308(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleReceiveDamageEvent(class USHCharacterPlayCombatComponent* CombatComp);
	void OnAutoLockedDoorCheckAnimEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void ProcessFakeHitDetectorBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void SetEnabled(const class UObject* Enabler, bool InEnabled);
	void SHFakeDoorEvent__DelegateSignature(class ASHFakeDoor* FakeDoorPtr);
	void SHFakeDoorEventBP__DelegateSignature(class ASHFakeDoor* FakeDoorPtr);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFakeDoor">();
	}
	static class ASHFakeDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHFakeDoor>();
	}
};
static_assert(alignof(ASHFakeDoor) == 0x000008, "Wrong alignment on ASHFakeDoor");
static_assert(sizeof(ASHFakeDoor) == 0x000350, "Wrong size on ASHFakeDoor");
static_assert(offsetof(ASHFakeDoor, PlaneSideDetector) == 0x0002B0, "Member 'ASHFakeDoor::PlaneSideDetector' has a wrong offset!");
static_assert(offsetof(ASHFakeDoor, FakeHitDetector) == 0x0002B8, "Member 'ASHFakeDoor::FakeHitDetector' has a wrong offset!");
static_assert(offsetof(ASHFakeDoor, SHAkFakeDoorComponent) == 0x0002C0, "Member 'ASHFakeDoor::SHAkFakeDoorComponent' has a wrong offset!");
static_assert(offsetof(ASHFakeDoor, GameplayMapObject) == 0x0002C8, "Member 'ASHFakeDoor::GameplayMapObject' has a wrong offset!");
static_assert(offsetof(ASHFakeDoor, NoiseConfig) == 0x0002D0, "Member 'ASHFakeDoor::NoiseConfig' has a wrong offset!");
static_assert(offsetof(ASHFakeDoor, AnimationsSetData) == 0x0002F0, "Member 'ASHFakeDoor::AnimationsSetData' has a wrong offset!");
static_assert(offsetof(ASHFakeDoor, OnAutoLockedDoorCheckAnimPlayed) == 0x0002F8, "Member 'ASHFakeDoor::OnAutoLockedDoorCheckAnimPlayed' has a wrong offset!");

// Class SHProto.SHAnimNotify_ReviveGetUpStart
// 0x0000 (0x0038 - 0x0038)
class USHAnimNotify_ReviveGetUpStart final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_ReviveGetUpStart">();
	}
	static class USHAnimNotify_ReviveGetUpStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_ReviveGetUpStart>();
	}
};
static_assert(alignof(USHAnimNotify_ReviveGetUpStart) == 0x000008, "Wrong alignment on USHAnimNotify_ReviveGetUpStart");
static_assert(sizeof(USHAnimNotify_ReviveGetUpStart) == 0x000038, "Wrong size on USHAnimNotify_ReviveGetUpStart");

// Class SHProto.ScreenShotComponent
// 0x0050 (0x02F0 - 0x02A0)
class UScreenShotComponent final : public USceneComponent
{
public:
	class USceneCaptureComponent2D*               SShotCapture;                                      // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x38];                                     // 0x02A8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             SShotPostBlendables;                               // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenShotComponent">();
	}
	static class UScreenShotComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenShotComponent>();
	}
};
static_assert(alignof(UScreenShotComponent) == 0x000010, "Wrong alignment on UScreenShotComponent");
static_assert(sizeof(UScreenShotComponent) == 0x0002F0, "Wrong size on UScreenShotComponent");
static_assert(offsetof(UScreenShotComponent, SShotCapture) == 0x0002A0, "Member 'UScreenShotComponent::SShotCapture' has a wrong offset!");
static_assert(offsetof(UScreenShotComponent, SShotPostBlendables) == 0x0002E0, "Member 'UScreenShotComponent::SShotPostBlendables' has a wrong offset!");

// Class SHProto.SHEnemyTransformationState
// 0x00A0 (0x00D0 - 0x0030)
class USHEnemyTransformationState : public UDataAsset
{
public:
	class FName                                   StateName;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TransformationDuration;                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          TransformToLying;                                  // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LyingTransformationDelay;                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ForceLyingTransfirmationUpdate;                    // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LyingCapsuleAnchorPosition;                        // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumLyingCapsuleExtensions;                     // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAvoidCollisionsAfterTransforming;                 // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAvoidCollisionsWhenTransforming;                  // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlignLyingCapsuleToSurface;                       // 0x0052(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPreventControllerRotation;                        // 0x0053(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRotateActorToDesiredMovement;                     // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitReactionsChangeDelay;                           // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHEnemyTransformationStateVariantSettings DefaultVariantFW;                                  // 0x0060(0x0028)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSHEnemyTransformationStateVariant> CustomVariantsFW;                                  // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSHEnemyTransformationStateVariantSettings DefaultVariantOW;                                  // 0x0098(0x0028)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSHEnemyTransformationStateVariant> CustomVariantsOW;                                  // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEnemyTransformationState">();
	}
	static class USHEnemyTransformationState* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEnemyTransformationState>();
	}
};
static_assert(alignof(USHEnemyTransformationState) == 0x000008, "Wrong alignment on USHEnemyTransformationState");
static_assert(sizeof(USHEnemyTransformationState) == 0x0000D0, "Wrong size on USHEnemyTransformationState");
static_assert(offsetof(USHEnemyTransformationState, StateName) == 0x000030, "Member 'USHEnemyTransformationState::StateName' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationState, TransformationDuration) == 0x000038, "Member 'USHEnemyTransformationState::TransformationDuration' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationState, TransformToLying) == 0x00003C, "Member 'USHEnemyTransformationState::TransformToLying' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationState, LyingTransformationDelay) == 0x000040, "Member 'USHEnemyTransformationState::LyingTransformationDelay' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationState, ForceLyingTransfirmationUpdate) == 0x000044, "Member 'USHEnemyTransformationState::ForceLyingTransfirmationUpdate' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationState, LyingCapsuleAnchorPosition) == 0x000048, "Member 'USHEnemyTransformationState::LyingCapsuleAnchorPosition' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationState, MaximumLyingCapsuleExtensions) == 0x00004C, "Member 'USHEnemyTransformationState::MaximumLyingCapsuleExtensions' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationState, bAvoidCollisionsAfterTransforming) == 0x000050, "Member 'USHEnemyTransformationState::bAvoidCollisionsAfterTransforming' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationState, bAvoidCollisionsWhenTransforming) == 0x000051, "Member 'USHEnemyTransformationState::bAvoidCollisionsWhenTransforming' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationState, bAlignLyingCapsuleToSurface) == 0x000052, "Member 'USHEnemyTransformationState::bAlignLyingCapsuleToSurface' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationState, bPreventControllerRotation) == 0x000053, "Member 'USHEnemyTransformationState::bPreventControllerRotation' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationState, bRotateActorToDesiredMovement) == 0x000054, "Member 'USHEnemyTransformationState::bRotateActorToDesiredMovement' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationState, HitReactionsChangeDelay) == 0x000058, "Member 'USHEnemyTransformationState::HitReactionsChangeDelay' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationState, DefaultVariantFW) == 0x000060, "Member 'USHEnemyTransformationState::DefaultVariantFW' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationState, CustomVariantsFW) == 0x000088, "Member 'USHEnemyTransformationState::CustomVariantsFW' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationState, DefaultVariantOW) == 0x000098, "Member 'USHEnemyTransformationState::DefaultVariantOW' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationState, CustomVariantsOW) == 0x0000C0, "Member 'USHEnemyTransformationState::CustomVariantsOW' has a wrong offset!");

// Class SHProto.SH2DPingPongRenderer
// 0x0050 (0x02F0 - 0x02A0)
class USH2DPingPongRenderer final : public USceneComponent
{
public:
	uint8                                         Pad_2A0[0x1D];                                     // 0x02A0(0x001D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          EnabledOnQualityLow;                               // 0x02BD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnabledOnQualityMedium;                            // 0x02BE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnabledOnQualityHigh;                              // 0x02BF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnabledOnQualityEpic;                              // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ProcessPasses;                                     // 0x02C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2[0x6];                                      // 0x02C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCanvasRenderTarget2D*>          RenderTargets;                                     // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTwoDPingPongPass>              Passes;                                            // 0x02D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SH2DPingPongRenderer">();
	}
	static class USH2DPingPongRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USH2DPingPongRenderer>();
	}
};
static_assert(alignof(USH2DPingPongRenderer) == 0x000010, "Wrong alignment on USH2DPingPongRenderer");
static_assert(sizeof(USH2DPingPongRenderer) == 0x0002F0, "Wrong size on USH2DPingPongRenderer");
static_assert(offsetof(USH2DPingPongRenderer, EnabledOnQualityLow) == 0x0002BD, "Member 'USH2DPingPongRenderer::EnabledOnQualityLow' has a wrong offset!");
static_assert(offsetof(USH2DPingPongRenderer, EnabledOnQualityMedium) == 0x0002BE, "Member 'USH2DPingPongRenderer::EnabledOnQualityMedium' has a wrong offset!");
static_assert(offsetof(USH2DPingPongRenderer, EnabledOnQualityHigh) == 0x0002BF, "Member 'USH2DPingPongRenderer::EnabledOnQualityHigh' has a wrong offset!");
static_assert(offsetof(USH2DPingPongRenderer, EnabledOnQualityEpic) == 0x0002C0, "Member 'USH2DPingPongRenderer::EnabledOnQualityEpic' has a wrong offset!");
static_assert(offsetof(USH2DPingPongRenderer, ProcessPasses) == 0x0002C1, "Member 'USH2DPingPongRenderer::ProcessPasses' has a wrong offset!");
static_assert(offsetof(USH2DPingPongRenderer, RenderTargets) == 0x0002C8, "Member 'USH2DPingPongRenderer::RenderTargets' has a wrong offset!");
static_assert(offsetof(USH2DPingPongRenderer, Passes) == 0x0002D8, "Member 'USH2DPingPongRenderer::Passes' has a wrong offset!");

// Class SHProto.SHFlashlightControlVolume
// 0x0118 (0x0400 - 0x02E8)
class ASHFlashlightControlVolume final : public AVolume
{
public:
	float                                         BlendDistance;                                     // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BlendDistanceOnly2D;                               // 0x02EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2ED[0x3];                                      // 0x02ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VolumePriority;                                    // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHFlashlightControlData               FlashlightControlData;                             // 0x02F8(0x00A0)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSHCharacterPlayLightingControlData    CharacterPlayLightingControlData;                  // 0x0398(0x001C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSHCharacterPlayRimLightingControlData CharacterPlayRimLightingControlData;               // 0x03B4(0x002C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSHMariaLightingControlData            MariaLightingControlData;                          // 0x03E0(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x18];                                     // 0x03E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDisabled(const bool bInDisabled, const class UObject* Object);

	bool IsDisabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFlashlightControlVolume">();
	}
	static class ASHFlashlightControlVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHFlashlightControlVolume>();
	}
};
static_assert(alignof(ASHFlashlightControlVolume) == 0x000008, "Wrong alignment on ASHFlashlightControlVolume");
static_assert(sizeof(ASHFlashlightControlVolume) == 0x000400, "Wrong size on ASHFlashlightControlVolume");
static_assert(offsetof(ASHFlashlightControlVolume, BlendDistance) == 0x0002E8, "Member 'ASHFlashlightControlVolume::BlendDistance' has a wrong offset!");
static_assert(offsetof(ASHFlashlightControlVolume, BlendDistanceOnly2D) == 0x0002EC, "Member 'ASHFlashlightControlVolume::BlendDistanceOnly2D' has a wrong offset!");
static_assert(offsetof(ASHFlashlightControlVolume, VolumePriority) == 0x0002F0, "Member 'ASHFlashlightControlVolume::VolumePriority' has a wrong offset!");
static_assert(offsetof(ASHFlashlightControlVolume, FlashlightControlData) == 0x0002F8, "Member 'ASHFlashlightControlVolume::FlashlightControlData' has a wrong offset!");
static_assert(offsetof(ASHFlashlightControlVolume, CharacterPlayLightingControlData) == 0x000398, "Member 'ASHFlashlightControlVolume::CharacterPlayLightingControlData' has a wrong offset!");
static_assert(offsetof(ASHFlashlightControlVolume, CharacterPlayRimLightingControlData) == 0x0003B4, "Member 'ASHFlashlightControlVolume::CharacterPlayRimLightingControlData' has a wrong offset!");
static_assert(offsetof(ASHFlashlightControlVolume, MariaLightingControlData) == 0x0003E0, "Member 'ASHFlashlightControlVolume::MariaLightingControlData' has a wrong offset!");

// Class SHProto.SHEnemyAnimComponent
// 0x0200 (0x0490 - 0x0290)
class USHEnemyAnimComponent : public USHAnimComponent
{
public:
	FMulticastInlineDelegateProperty_             EventDeathHitReactionStarted;                      // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventDeathHitReactionEnded;                        // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventKnockdownHitReactionStarted;                  // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventKnockdownHitReactionEnded;                    // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventFalterHitReactionStarted;                     // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventFalterHitReactionEnded;                       // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventStaggerHitReactionStarted;                    // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventStaggerHitReactionEnded;                      // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventNormalHitReactionStarted;                     // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventNormalHitReactionEnded;                       // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventTwitchHitReactionStarted;                     // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventTwitchHitReactionEnded;                       // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPhysicalAnimationProfileDA*            PhysicalAnimationProfileDA;                        // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHReviveAnimationsDA*                  ReviveAnimationsDA;                                // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHHitReactionsSet*                     HitReactionsSet;                                   // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EMaiAggroStance, TSubclassOf<class USHMonsterLocomotionAnimInstance>> LocomotionAnimInstances;                           // 0x0368(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FSHRagDollSubcompSettings              RagDollSettings;                                   // 0x03B8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSHBonePhysicsControllerSettingsProfile BonePhysicsSettings;                               // 0x03F0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bDrawHitReactionsDebug;                            // 0x0458(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPrintBonePhysicsStates;                           // 0x0459(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawRagdollPose;                                  // 0x045A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45B[0x1];                                      // 0x045B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawStreamedRagdollPoseDuration;                   // 0x045C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawBoneAppliedPhysicsForces;                     // 0x0460(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_461[0x3];                                      // 0x0461(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawBoneAppliedPhysicsForcesScale;                 // 0x0464(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawBoneActivePhysicsForces;                      // 0x0468(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_469[0x3];                                      // 0x0469(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawBoneActivePhysicsForcesScale;                  // 0x046C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             OwnerCharacter;                                    // 0x0470(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AAIController*                          OwnerController;                                   // 0x0478(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHHitReactionSubcomponent*             CachedHitReactionsSubcomponent;                    // 0x0480(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController);
	void ProcessEnemyBehaviorStanceChangedEvent(EMaiAggroStance NewAggroStance);
	bool ProcessHitReactionBonePhysicsRequestEvent(class USHHitReactionSubcomponent* InHitReactionComponent, const struct FSHHitReactionResultBonePhysics& InBonePhysics);
	void ProcessHitReactionStateEndedEvent(class USHHitReactionSubcomponent* InHitReactionComponent, class USHHitReactionState* InHitReactionState);
	void ProcessHitReactionStateStartedEvent(class USHHitReactionSubcomponent* InHitReactionComponent, class USHHitReactionState* InHitReactionState);
	void SetLyingState(bool InIsLying, bool InIsTransforming);

	void GetActiveHitReactionVariants(ESHHitReactionResponseType InHitReactionType, TArray<class FName>* OutHitReactionVariants) const;
	bool IsInDeathState(bool InIncludeFinishing) const;
	bool IsInFalterState(bool InIncludeFinishing) const;
	bool IsInKnockdownState(bool InIncludeFinishing) const;
	bool IsInNormalHitState(bool InIncludeFinishing) const;
	bool IsInStaggerState(bool InIncludeFinishing) const;
	bool IsInTwitchState(bool InIncludeFinishing) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEnemyAnimComponent">();
	}
	static class USHEnemyAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEnemyAnimComponent>();
	}
};
static_assert(alignof(USHEnemyAnimComponent) == 0x000008, "Wrong alignment on USHEnemyAnimComponent");
static_assert(sizeof(USHEnemyAnimComponent) == 0x000490, "Wrong size on USHEnemyAnimComponent");
static_assert(offsetof(USHEnemyAnimComponent, EventDeathHitReactionStarted) == 0x000290, "Member 'USHEnemyAnimComponent::EventDeathHitReactionStarted' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, EventDeathHitReactionEnded) == 0x0002A0, "Member 'USHEnemyAnimComponent::EventDeathHitReactionEnded' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, EventKnockdownHitReactionStarted) == 0x0002B0, "Member 'USHEnemyAnimComponent::EventKnockdownHitReactionStarted' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, EventKnockdownHitReactionEnded) == 0x0002C0, "Member 'USHEnemyAnimComponent::EventKnockdownHitReactionEnded' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, EventFalterHitReactionStarted) == 0x0002D0, "Member 'USHEnemyAnimComponent::EventFalterHitReactionStarted' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, EventFalterHitReactionEnded) == 0x0002E0, "Member 'USHEnemyAnimComponent::EventFalterHitReactionEnded' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, EventStaggerHitReactionStarted) == 0x0002F0, "Member 'USHEnemyAnimComponent::EventStaggerHitReactionStarted' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, EventStaggerHitReactionEnded) == 0x000300, "Member 'USHEnemyAnimComponent::EventStaggerHitReactionEnded' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, EventNormalHitReactionStarted) == 0x000310, "Member 'USHEnemyAnimComponent::EventNormalHitReactionStarted' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, EventNormalHitReactionEnded) == 0x000320, "Member 'USHEnemyAnimComponent::EventNormalHitReactionEnded' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, EventTwitchHitReactionStarted) == 0x000330, "Member 'USHEnemyAnimComponent::EventTwitchHitReactionStarted' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, EventTwitchHitReactionEnded) == 0x000340, "Member 'USHEnemyAnimComponent::EventTwitchHitReactionEnded' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, PhysicalAnimationProfileDA) == 0x000350, "Member 'USHEnemyAnimComponent::PhysicalAnimationProfileDA' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, ReviveAnimationsDA) == 0x000358, "Member 'USHEnemyAnimComponent::ReviveAnimationsDA' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, HitReactionsSet) == 0x000360, "Member 'USHEnemyAnimComponent::HitReactionsSet' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, LocomotionAnimInstances) == 0x000368, "Member 'USHEnemyAnimComponent::LocomotionAnimInstances' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, RagDollSettings) == 0x0003B8, "Member 'USHEnemyAnimComponent::RagDollSettings' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, BonePhysicsSettings) == 0x0003F0, "Member 'USHEnemyAnimComponent::BonePhysicsSettings' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, bDrawHitReactionsDebug) == 0x000458, "Member 'USHEnemyAnimComponent::bDrawHitReactionsDebug' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, bPrintBonePhysicsStates) == 0x000459, "Member 'USHEnemyAnimComponent::bPrintBonePhysicsStates' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, bDrawRagdollPose) == 0x00045A, "Member 'USHEnemyAnimComponent::bDrawRagdollPose' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, DrawStreamedRagdollPoseDuration) == 0x00045C, "Member 'USHEnemyAnimComponent::DrawStreamedRagdollPoseDuration' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, bDrawBoneAppliedPhysicsForces) == 0x000460, "Member 'USHEnemyAnimComponent::bDrawBoneAppliedPhysicsForces' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, DrawBoneAppliedPhysicsForcesScale) == 0x000464, "Member 'USHEnemyAnimComponent::DrawBoneAppliedPhysicsForcesScale' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, bDrawBoneActivePhysicsForces) == 0x000468, "Member 'USHEnemyAnimComponent::bDrawBoneActivePhysicsForces' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, DrawBoneActivePhysicsForcesScale) == 0x00046C, "Member 'USHEnemyAnimComponent::DrawBoneActivePhysicsForcesScale' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, OwnerCharacter) == 0x000470, "Member 'USHEnemyAnimComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, OwnerController) == 0x000478, "Member 'USHEnemyAnimComponent::OwnerController' has a wrong offset!");
static_assert(offsetof(USHEnemyAnimComponent, CachedHitReactionsSubcomponent) == 0x000480, "Member 'USHEnemyAnimComponent::CachedHitReactionsSubcomponent' has a wrong offset!");

// Class SHProto.SHAbstractDaddyAnimComponent
// 0x0000 (0x0490 - 0x0490)
class USHAbstractDaddyAnimComponent final : public USHEnemyAnimComponent
{
public:
	void SetBrakingPoint(const struct FVector& Location, int32 AreaFlags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAbstractDaddyAnimComponent">();
	}
	static class USHAbstractDaddyAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAbstractDaddyAnimComponent>();
	}
};
static_assert(alignof(USHAbstractDaddyAnimComponent) == 0x000008, "Wrong alignment on USHAbstractDaddyAnimComponent");
static_assert(sizeof(USHAbstractDaddyAnimComponent) == 0x000490, "Wrong size on USHAbstractDaddyAnimComponent");

// Class SHProto.SHPendulumComponent
// 0x0040 (0x02E0 - 0x02A0)
class USHPendulumComponent final : public USceneComponent
{
public:
	float                                         Radius;                                            // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DragFactor;                                        // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BeginPlayAngle;                                    // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClampAngles;                                      // 0x02AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AD[0x3];                                      // 0x02AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ClampAnglesValues;                                 // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngleSaved;                                        // 0x02C0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReceiverCurrentAngularVelocity;                    // 0x02C4(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x18];                                     // 0x02C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAngularVelocity(const float InVelocity);
	void SetFreeze(const bool bInFreeze);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPendulumComponent">();
	}
	static class USHPendulumComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPendulumComponent>();
	}
};
static_assert(alignof(USHPendulumComponent) == 0x000010, "Wrong alignment on USHPendulumComponent");
static_assert(sizeof(USHPendulumComponent) == 0x0002E0, "Wrong size on USHPendulumComponent");
static_assert(offsetof(USHPendulumComponent, Radius) == 0x0002A0, "Member 'USHPendulumComponent::Radius' has a wrong offset!");
static_assert(offsetof(USHPendulumComponent, DragFactor) == 0x0002A4, "Member 'USHPendulumComponent::DragFactor' has a wrong offset!");
static_assert(offsetof(USHPendulumComponent, BeginPlayAngle) == 0x0002A8, "Member 'USHPendulumComponent::BeginPlayAngle' has a wrong offset!");
static_assert(offsetof(USHPendulumComponent, bClampAngles) == 0x0002AC, "Member 'USHPendulumComponent::bClampAngles' has a wrong offset!");
static_assert(offsetof(USHPendulumComponent, ClampAnglesValues) == 0x0002B0, "Member 'USHPendulumComponent::ClampAnglesValues' has a wrong offset!");
static_assert(offsetof(USHPendulumComponent, AngleSaved) == 0x0002C0, "Member 'USHPendulumComponent::AngleSaved' has a wrong offset!");
static_assert(offsetof(USHPendulumComponent, ReceiverCurrentAngularVelocity) == 0x0002C4, "Member 'USHPendulumComponent::ReceiverCurrentAngularVelocity' has a wrong offset!");

// Class SHProto.SHDoorLockBaseComponent
// 0x0048 (0x00E8 - 0x00A0)
class USHDoorLockBaseComponent : public UActorComponent
{
public:
	bool                                          bLockedOnBegin;                                    // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnLockStateChange;                                 // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class USHInteractionGenericComponent*         ManagedInteractionGeneric;                         // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionManagerComponent*         ManagedInteractionManager;                         // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       InteractedCharacter;                               // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDoorLocked;                                     // 0x00D0(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x17];                                      // 0x00D1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInteract(class USHInteractionGenericComponent* Generic, class ASHCharacterPlay* Character);
	void SetLocked(bool NewLocked, bool SkipDetectableManagement);
	void SHDoorLockEvent__DelegateSignature(class USHDoorLockBaseComponent* Component);
	void SHDoorLockEventBP__DelegateSignature(class USHDoorLockBaseComponent* Component);

	bool IsLocked() const;
	bool IsLockedOnBegin() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDoorLockBaseComponent">();
	}
	static class USHDoorLockBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDoorLockBaseComponent>();
	}
};
static_assert(alignof(USHDoorLockBaseComponent) == 0x000008, "Wrong alignment on USHDoorLockBaseComponent");
static_assert(sizeof(USHDoorLockBaseComponent) == 0x0000E8, "Wrong size on USHDoorLockBaseComponent");
static_assert(offsetof(USHDoorLockBaseComponent, bLockedOnBegin) == 0x0000A0, "Member 'USHDoorLockBaseComponent::bLockedOnBegin' has a wrong offset!");
static_assert(offsetof(USHDoorLockBaseComponent, OnLockStateChange) == 0x0000A8, "Member 'USHDoorLockBaseComponent::OnLockStateChange' has a wrong offset!");
static_assert(offsetof(USHDoorLockBaseComponent, ManagedInteractionGeneric) == 0x0000B8, "Member 'USHDoorLockBaseComponent::ManagedInteractionGeneric' has a wrong offset!");
static_assert(offsetof(USHDoorLockBaseComponent, ManagedInteractionManager) == 0x0000C0, "Member 'USHDoorLockBaseComponent::ManagedInteractionManager' has a wrong offset!");
static_assert(offsetof(USHDoorLockBaseComponent, InteractedCharacter) == 0x0000C8, "Member 'USHDoorLockBaseComponent::InteractedCharacter' has a wrong offset!");
static_assert(offsetof(USHDoorLockBaseComponent, bIsDoorLocked) == 0x0000D0, "Member 'USHDoorLockBaseComponent::bIsDoorLocked' has a wrong offset!");

// Class SHProto.SHDoorLockComponent
// 0x0000 (0x00E8 - 0x00E8)
class USHDoorLockComponent final : public USHDoorLockBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDoorLockComponent">();
	}
	static class USHDoorLockComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDoorLockComponent>();
	}
};
static_assert(alignof(USHDoorLockComponent) == 0x000008, "Wrong alignment on USHDoorLockComponent");
static_assert(sizeof(USHDoorLockComponent) == 0x0000E8, "Wrong size on USHDoorLockComponent");

// Class SHProto.SHDoorAnimationsBaseComponent
// 0x0028 (0x00C8 - 0x00A0)
class USHDoorAnimationsBaseComponent : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x28];                                      // 0x00A0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleReceiveDamageEvent(class USHCharacterPlayCombatComponent* CombatComp);
	void SHDoorAnimationsBaseEvent__DelegateSignature(class USHDoorAnimationsBaseComponent* Component);
	void SHDoorAnimationsBaseEventBP__DelegateSignature(class USHDoorAnimationsBaseComponent* Component);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDoorAnimationsBaseComponent">();
	}
	static class USHDoorAnimationsBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDoorAnimationsBaseComponent>();
	}
};
static_assert(alignof(USHDoorAnimationsBaseComponent) == 0x000008, "Wrong alignment on USHDoorAnimationsBaseComponent");
static_assert(sizeof(USHDoorAnimationsBaseComponent) == 0x0000C8, "Wrong size on USHDoorAnimationsBaseComponent");

// Class SHProto.SHAbstractDaddyAnimInstance
// 0x0040 (0x0420 - 0x03E0)
class USHAbstractDaddyAnimInstance final : public USHMonsterAnimInstance
{
public:
	float                                         HeadShakeAlpha;                                    // 0x03E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeadShakeSnapshotPoseAlpha;                        // 0x03E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               LookRotation;                                      // 0x03E8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         LookRotationAlpha;                                 // 0x0400(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BrakingPoint;                                      // 0x0408(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetBrakingPoint(const struct FVector& Location);
	void SetOutstretchedArmsActive(bool InOutstretchedArmsActive);
	void StartChargeMovement();
	void StopChargeMovement();

	class USHAbstractDaddyAnimInstanceStateData* GetAbstractDaddyAnimInstanceStateData() const;
	class USHAbstractDaddyLocomotionAnimInstance* GetAbstractDaddyLocomotionAnimInstance(int32 SlotIndex) const;
	struct FVector GetBrakingPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAbstractDaddyAnimInstance">();
	}
	static class USHAbstractDaddyAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAbstractDaddyAnimInstance>();
	}
};
static_assert(alignof(USHAbstractDaddyAnimInstance) == 0x000010, "Wrong alignment on USHAbstractDaddyAnimInstance");
static_assert(sizeof(USHAbstractDaddyAnimInstance) == 0x000420, "Wrong size on USHAbstractDaddyAnimInstance");
static_assert(offsetof(USHAbstractDaddyAnimInstance, HeadShakeAlpha) == 0x0003E0, "Member 'USHAbstractDaddyAnimInstance::HeadShakeAlpha' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyAnimInstance, HeadShakeSnapshotPoseAlpha) == 0x0003E4, "Member 'USHAbstractDaddyAnimInstance::HeadShakeSnapshotPoseAlpha' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyAnimInstance, LookRotation) == 0x0003E8, "Member 'USHAbstractDaddyAnimInstance::LookRotation' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyAnimInstance, LookRotationAlpha) == 0x000400, "Member 'USHAbstractDaddyAnimInstance::LookRotationAlpha' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyAnimInstance, BrakingPoint) == 0x000408, "Member 'USHAbstractDaddyAnimInstance::BrakingPoint' has a wrong offset!");

// Class SHProto.SHNPCAnimInstanceStateData
// 0x0048 (0x0070 - 0x0028)
class USHNPCAnimInstanceStateData : public UObject
{
public:
	uint8                                         Pad_28[0x48];                                      // 0x0028(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetDesiredLocalRotationYaw() const;
	const struct FVector GetDesiredLocalVelocity() const;
	float GetDesiredStrafeAngle() const;
	void GetLookAtRotation(struct FRotator* OutWorldRotation, float* OutRotationAlpha) const;
	float GetStrafeAngle() const;
	float GetTurnInPlaceAngle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHNPCAnimInstanceStateData">();
	}
	static class USHNPCAnimInstanceStateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHNPCAnimInstanceStateData>();
	}
};
static_assert(alignof(USHNPCAnimInstanceStateData) == 0x000008, "Wrong alignment on USHNPCAnimInstanceStateData");
static_assert(sizeof(USHNPCAnimInstanceStateData) == 0x000070, "Wrong size on USHNPCAnimInstanceStateData");

// Class SHProto.SHMonsterAnimInstanceStateData
// 0x0008 (0x0078 - 0x0070)
class USHMonsterAnimInstanceStateData : public USHNPCAnimInstanceStateData
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMonsterAnimInstanceStateData">();
	}
	static class USHMonsterAnimInstanceStateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMonsterAnimInstanceStateData>();
	}
};
static_assert(alignof(USHMonsterAnimInstanceStateData) == 0x000008, "Wrong alignment on USHMonsterAnimInstanceStateData");
static_assert(sizeof(USHMonsterAnimInstanceStateData) == 0x000078, "Wrong size on USHMonsterAnimInstanceStateData");

// Class SHProto.SHAbstractDaddyAnimInstanceStateData
// 0x0020 (0x0098 - 0x0078)
class USHAbstractDaddyAnimInstanceStateData final : public USHMonsterAnimInstanceStateData
{
public:
	uint8                                         Pad_78[0x20];                                      // 0x0078(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetAreOutstretchedArmsActive() const;
	struct FVector GetBrakingSegmentLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAbstractDaddyAnimInstanceStateData">();
	}
	static class USHAbstractDaddyAnimInstanceStateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAbstractDaddyAnimInstanceStateData>();
	}
};
static_assert(alignof(USHAbstractDaddyAnimInstanceStateData) == 0x000008, "Wrong alignment on USHAbstractDaddyAnimInstanceStateData");
static_assert(sizeof(USHAbstractDaddyAnimInstanceStateData) == 0x000098, "Wrong size on USHAbstractDaddyAnimInstanceStateData");

// Class SHProto.SHDoorControlInterface
// 0x0000 (0x0028 - 0x0028)
class ISHDoorControlInterface final : public IInterface
{
public:
	void OnPushedByDoorEvent(class USHDoorMovementComponent* DoorMovementComp, const struct FVector& PushNormal);

	bool CanBePushedByDoor() const;
	bool CanPushDoor() const;
	struct FVector GetPushingVelocity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDoorControlInterface">();
	}
	static class ISHDoorControlInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHDoorControlInterface>();
	}
};
static_assert(alignof(ISHDoorControlInterface) == 0x000008, "Wrong alignment on ISHDoorControlInterface");
static_assert(sizeof(ISHDoorControlInterface) == 0x000028, "Wrong size on ISHDoorControlInterface");

// Class SHProto.SHAbstractDaddyLocomotionAnimInstance
// 0x0020 (0x03D0 - 0x03B0)
#pragma pack(push, 0x1)
class alignas(0x10) USHAbstractDaddyLocomotionAnimInstance : public USHMonsterLocomotionAnimInstance
{
public:
	ESHAbstractDaddyAnimInstanceLocomotionState   LocomotionStateRequest;                            // 0x03A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveChangeLegOnGround;                             // 0x03AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveChangeStrafeAngle;                             // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeAngle;                                       // 0x03B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredStrafeAngle;                                // 0x03B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceAngle;                                  // 0x03BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutstretchedArmsActive;                           // 0x03C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChargeMovementIsActive;                           // 0x03C1(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C2[0x6];                                      // 0x03C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetChargeMovementIsActive(bool NewActive);

	class USHAbstractDaddyAnimInstanceStateData* GetAbstractDaddyAnimInstanceStateData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAbstractDaddyLocomotionAnimInstance">();
	}
	static class USHAbstractDaddyLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAbstractDaddyLocomotionAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(USHAbstractDaddyLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHAbstractDaddyLocomotionAnimInstance");
static_assert(sizeof(USHAbstractDaddyLocomotionAnimInstance) == 0x0003D0, "Wrong size on USHAbstractDaddyLocomotionAnimInstance");
static_assert(offsetof(USHAbstractDaddyLocomotionAnimInstance, LocomotionStateRequest) == 0x0003A8, "Member 'USHAbstractDaddyLocomotionAnimInstance::LocomotionStateRequest' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyLocomotionAnimInstance, MoveChangeLegOnGround) == 0x0003AC, "Member 'USHAbstractDaddyLocomotionAnimInstance::MoveChangeLegOnGround' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyLocomotionAnimInstance, MoveChangeStrafeAngle) == 0x0003B0, "Member 'USHAbstractDaddyLocomotionAnimInstance::MoveChangeStrafeAngle' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyLocomotionAnimInstance, StrafeAngle) == 0x0003B4, "Member 'USHAbstractDaddyLocomotionAnimInstance::StrafeAngle' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyLocomotionAnimInstance, DesiredStrafeAngle) == 0x0003B8, "Member 'USHAbstractDaddyLocomotionAnimInstance::DesiredStrafeAngle' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyLocomotionAnimInstance, TurnInPlaceAngle) == 0x0003BC, "Member 'USHAbstractDaddyLocomotionAnimInstance::TurnInPlaceAngle' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyLocomotionAnimInstance, bOutstretchedArmsActive) == 0x0003C0, "Member 'USHAbstractDaddyLocomotionAnimInstance::bOutstretchedArmsActive' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyLocomotionAnimInstance, bChargeMovementIsActive) == 0x0003C1, "Member 'USHAbstractDaddyLocomotionAnimInstance::bChargeMovementIsActive' has a wrong offset!");

// Class SHProto.SHCenterDotCrosshairWidget
// 0x0000 (0x0298 - 0x0298)
class USHCenterDotCrosshairWidget final : public USHCrosshairWidgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCenterDotCrosshairWidget">();
	}
	static class USHCenterDotCrosshairWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCenterDotCrosshairWidget>();
	}
};
static_assert(alignof(USHCenterDotCrosshairWidget) == 0x000008, "Wrong alignment on USHCenterDotCrosshairWidget");
static_assert(sizeof(USHCenterDotCrosshairWidget) == 0x000298, "Wrong size on USHCenterDotCrosshairWidget");

// Class SHProto.SHAbstractDaddyStandingLocomotionAnimInstance
// 0x00D0 (0x04A0 - 0x03D0)
class USHAbstractDaddyStandingLocomotionAnimInstance final : public USHAbstractDaddyLocomotionAnimInstance
{
public:
	ESHAbstractDaddyAnimInstanceStandingLocomotionState LocomotionState;                                   // 0x03C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C9[0x3];                                      // 0x03C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationToStrafingRatio;                           // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementStopDelay;                                 // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementStopVelocity;                              // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DesiredVelocityIncrementHalfTime;                  // 0x03D8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DesiredVelocityDecrementHalfTime;                  // 0x03F0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetDesiredVelocity;                             // 0x0408(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DesiredYawAdjustmentHalfTime;                      // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetDesiredRotationYaw;                          // 0x0424(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtAlphaIncrementHalfTime;                      // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtAlphaDecrementHalfTime;                      // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrakingVelocity;                                   // 0x0430(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_434[0x4];                                      // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BrakingDistanceFactor;                             // 0x0438(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_450[0x50];                                     // 0x0450(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetSmoothedDesiredRotationYaw(float* OutYaw) const;
	void GetSmoothedDesiredVelocity(struct FVector* OutVelocity) const;
	void GetSmoothedDesiredVelocitySizeAndYaw(float* OutVelocitySize, float* OutVelocityYaw) const;
	void GetSmoothedLookAt(struct FRotator* OutRotation, float* OutAlpha) const;
	void GetTargetDesiredRotationYaw(float* OutYaw) const;
	void GetTargetDesiredVelocity(struct FVector* OutVelocity) const;
	void GetTargetDesiredVelocitySizeAndYaw(float* OutVelocitySize, float* OutVelocityYaw) const;
	void GetTargetLookAtAlpha(float* OutAlpha) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAbstractDaddyStandingLocomotionAnimInstance">();
	}
	static class USHAbstractDaddyStandingLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAbstractDaddyStandingLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHAbstractDaddyStandingLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHAbstractDaddyStandingLocomotionAnimInstance");
static_assert(sizeof(USHAbstractDaddyStandingLocomotionAnimInstance) == 0x0004A0, "Wrong size on USHAbstractDaddyStandingLocomotionAnimInstance");
static_assert(offsetof(USHAbstractDaddyStandingLocomotionAnimInstance, LocomotionState) == 0x0003C8, "Member 'USHAbstractDaddyStandingLocomotionAnimInstance::LocomotionState' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyStandingLocomotionAnimInstance, RotationToStrafingRatio) == 0x0003CC, "Member 'USHAbstractDaddyStandingLocomotionAnimInstance::RotationToStrafingRatio' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyStandingLocomotionAnimInstance, MovementStopDelay) == 0x0003D0, "Member 'USHAbstractDaddyStandingLocomotionAnimInstance::MovementStopDelay' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyStandingLocomotionAnimInstance, MovementStopVelocity) == 0x0003D4, "Member 'USHAbstractDaddyStandingLocomotionAnimInstance::MovementStopVelocity' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyStandingLocomotionAnimInstance, DesiredVelocityIncrementHalfTime) == 0x0003D8, "Member 'USHAbstractDaddyStandingLocomotionAnimInstance::DesiredVelocityIncrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyStandingLocomotionAnimInstance, DesiredVelocityDecrementHalfTime) == 0x0003F0, "Member 'USHAbstractDaddyStandingLocomotionAnimInstance::DesiredVelocityDecrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyStandingLocomotionAnimInstance, TargetDesiredVelocity) == 0x000408, "Member 'USHAbstractDaddyStandingLocomotionAnimInstance::TargetDesiredVelocity' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyStandingLocomotionAnimInstance, DesiredYawAdjustmentHalfTime) == 0x000420, "Member 'USHAbstractDaddyStandingLocomotionAnimInstance::DesiredYawAdjustmentHalfTime' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyStandingLocomotionAnimInstance, TargetDesiredRotationYaw) == 0x000424, "Member 'USHAbstractDaddyStandingLocomotionAnimInstance::TargetDesiredRotationYaw' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyStandingLocomotionAnimInstance, LookAtAlphaIncrementHalfTime) == 0x000428, "Member 'USHAbstractDaddyStandingLocomotionAnimInstance::LookAtAlphaIncrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyStandingLocomotionAnimInstance, LookAtAlphaDecrementHalfTime) == 0x00042C, "Member 'USHAbstractDaddyStandingLocomotionAnimInstance::LookAtAlphaDecrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyStandingLocomotionAnimInstance, BrakingVelocity) == 0x000430, "Member 'USHAbstractDaddyStandingLocomotionAnimInstance::BrakingVelocity' has a wrong offset!");
static_assert(offsetof(USHAbstractDaddyStandingLocomotionAnimInstance, BrakingDistanceFactor) == 0x000438, "Member 'USHAbstractDaddyStandingLocomotionAnimInstance::BrakingDistanceFactor' has a wrong offset!");

// Class SHProto.SHMusicSwitchVolume
// 0x0088 (0x0370 - 0x02E8)
class ASHMusicSwitchVolume final : public AVolume
{
public:
	TSoftObjectPtr<class UAkSwitchValue>          MusicSwitchValue;                                  // 0x02E8(0x0030)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSetMusicSwitchOnLeave;                            // 0x0318(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAkSwitchValue>          OnLeaveMusicSwitchValue;                           // 0x0320(0x0030)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEnabledOnBegin;                                 // 0x0350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x1F];                                     // 0x0351(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnabled(const class UObject* Enabler, bool InEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMusicSwitchVolume">();
	}
	static class ASHMusicSwitchVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHMusicSwitchVolume>();
	}
};
static_assert(alignof(ASHMusicSwitchVolume) == 0x000008, "Wrong alignment on ASHMusicSwitchVolume");
static_assert(sizeof(ASHMusicSwitchVolume) == 0x000370, "Wrong size on ASHMusicSwitchVolume");
static_assert(offsetof(ASHMusicSwitchVolume, MusicSwitchValue) == 0x0002E8, "Member 'ASHMusicSwitchVolume::MusicSwitchValue' has a wrong offset!");
static_assert(offsetof(ASHMusicSwitchVolume, bSetMusicSwitchOnLeave) == 0x000318, "Member 'ASHMusicSwitchVolume::bSetMusicSwitchOnLeave' has a wrong offset!");
static_assert(offsetof(ASHMusicSwitchVolume, OnLeaveMusicSwitchValue) == 0x000320, "Member 'ASHMusicSwitchVolume::OnLeaveMusicSwitchValue' has a wrong offset!");
static_assert(offsetof(ASHMusicSwitchVolume, bIsEnabledOnBegin) == 0x000350, "Member 'ASHMusicSwitchVolume::bIsEnabledOnBegin' has a wrong offset!");

// Class SHProto.SHActorLevelObserverComponent
// 0x00C8 (0x0168 - 0x00A0)
class USHActorLevelObserverComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnObservedActorAvailable;                          // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0xB8];                                      // 0x00B0(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActorLevelObserverEvent__DelegateSignature(class AActor* ObservedActor);
	void RequestObserveActor(TSoftObjectPtr<class AActor> InActorToObserve);
	void RequestStopObserveActor(TSoftObjectPtr<class AActor> ActorToStopObserve);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHActorLevelObserverComponent">();
	}
	static class USHActorLevelObserverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHActorLevelObserverComponent>();
	}
};
static_assert(alignof(USHActorLevelObserverComponent) == 0x000008, "Wrong alignment on USHActorLevelObserverComponent");
static_assert(sizeof(USHActorLevelObserverComponent) == 0x000168, "Wrong size on USHActorLevelObserverComponent");
static_assert(offsetof(USHActorLevelObserverComponent, OnObservedActorAvailable) == 0x0000A0, "Member 'USHActorLevelObserverComponent::OnObservedActorAvailable' has a wrong offset!");

// Class SHProto.SHAnimWholeBodyTranslationSubcomp
// 0x0098 (0x00D0 - 0x0038)
class USHAnimWholeBodyTranslationSubcomp final : public USHAnimSubcomponentBase
{
public:
	struct FWholeBodyTranslation                  AdditionalTranslationTarget;                       // 0x0038(0x0048)(BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FWholeBodyTranslation                  AdditionalTranslation;                             // 0x0080(0x0048)(BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         AdditionalTranslationAlphaTarget;                  // 0x00C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalTranslationAlpha;                        // 0x00CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FWholeBodyTranslation CheckOnGroundAdditionalRotation();
	void ResetAdditionalTranslation();
	void SetAdditionalRotation(const struct FRotator& NewRotation);
	void SetAdditionalTranslation(const struct FWholeBodyTranslation& InAdditionalRotationTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimWholeBodyTranslationSubcomp">();
	}
	static class USHAnimWholeBodyTranslationSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimWholeBodyTranslationSubcomp>();
	}
};
static_assert(alignof(USHAnimWholeBodyTranslationSubcomp) == 0x000008, "Wrong alignment on USHAnimWholeBodyTranslationSubcomp");
static_assert(sizeof(USHAnimWholeBodyTranslationSubcomp) == 0x0000D0, "Wrong size on USHAnimWholeBodyTranslationSubcomp");
static_assert(offsetof(USHAnimWholeBodyTranslationSubcomp, AdditionalTranslationTarget) == 0x000038, "Member 'USHAnimWholeBodyTranslationSubcomp::AdditionalTranslationTarget' has a wrong offset!");
static_assert(offsetof(USHAnimWholeBodyTranslationSubcomp, AdditionalTranslation) == 0x000080, "Member 'USHAnimWholeBodyTranslationSubcomp::AdditionalTranslation' has a wrong offset!");
static_assert(offsetof(USHAnimWholeBodyTranslationSubcomp, AdditionalTranslationAlphaTarget) == 0x0000C8, "Member 'USHAnimWholeBodyTranslationSubcomp::AdditionalTranslationAlphaTarget' has a wrong offset!");
static_assert(offsetof(USHAnimWholeBodyTranslationSubcomp, AdditionalTranslationAlpha) == 0x0000CC, "Member 'USHAnimWholeBodyTranslationSubcomp::AdditionalTranslationAlpha' has a wrong offset!");

// Class SHProto.SHActorsManagementBaseControllerActor
// 0x0008 (0x02B8 - 0x02B0)
class ASHActorsManagementBaseControllerActor : public AActor
{
public:
	class USHSafeBeginPlayComponent*              SafeBeginPlayComponent;                            // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHActorsManagementBaseControllerActor">();
	}
	static class ASHActorsManagementBaseControllerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHActorsManagementBaseControllerActor>();
	}
};
static_assert(alignof(ASHActorsManagementBaseControllerActor) == 0x000008, "Wrong alignment on ASHActorsManagementBaseControllerActor");
static_assert(sizeof(ASHActorsManagementBaseControllerActor) == 0x0002B8, "Wrong size on ASHActorsManagementBaseControllerActor");
static_assert(offsetof(ASHActorsManagementBaseControllerActor, SafeBeginPlayComponent) == 0x0002B0, "Member 'ASHActorsManagementBaseControllerActor::SafeBeginPlayComponent' has a wrong offset!");

// Class SHProto.SHActorsManagementControllableInterface
// 0x0000 (0x0028 - 0x0028)
class ISHActorsManagementControllableInterface final : public IInterface
{
public:
	bool ApplyShouldBeActive(class ASHActorsManagementBaseControllerActor* InControllerActor, const bool InShouldBeActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHActorsManagementControllableInterface">();
	}
	static class ISHActorsManagementControllableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHActorsManagementControllableInterface>();
	}
};
static_assert(alignof(ISHActorsManagementControllableInterface) == 0x000008, "Wrong alignment on ISHActorsManagementControllableInterface");
static_assert(sizeof(ISHActorsManagementControllableInterface) == 0x000028, "Wrong size on ISHActorsManagementControllableInterface");

// Class SHProto.SHLookAtTypeID
// 0x0000 (0x0028 - 0x0028)
class USHLookAtTypeID : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLookAtTypeID">();
	}
	static class USHLookAtTypeID* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLookAtTypeID>();
	}
};
static_assert(alignof(USHLookAtTypeID) == 0x000008, "Wrong alignment on USHLookAtTypeID");
static_assert(sizeof(USHLookAtTypeID) == 0x000028, "Wrong size on USHLookAtTypeID");

// Class SHProto.Trivial_LookAtType
// 0x0000 (0x0028 - 0x0028)
class UTrivial_LookAtType final : public USHLookAtTypeID
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Trivial_LookAtType">();
	}
	static class UTrivial_LookAtType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrivial_LookAtType>();
	}
};
static_assert(alignof(UTrivial_LookAtType) == 0x000008, "Wrong alignment on UTrivial_LookAtType");
static_assert(sizeof(UTrivial_LookAtType) == 0x000028, "Wrong size on UTrivial_LookAtType");

// Class SHProto.SHAIAction_Sync
// 0x0140 (0x0650 - 0x0510)
#pragma pack(push, 0x1)
class alignas(0x10) USHAIAction_Sync : public UMaiAction_SyncAnimations
{
public:
	bool                                          _HideWeapon;                                       // 0x0510(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _HardLockTokens;                                   // 0x0511(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ReleaseOtherOnFinish;                             // 0x0512(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ChangeCamera;                                     // 0x0513(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_514[0x4];                                      // 0x0514(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHViewLookOperationSettings           _CameraChangeSettings;                             // 0x0518(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FString                                 _CustomCameraName;                                 // 0x0550(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSHCameraDataStruct                    _CustomCameraData;                                 // 0x0560(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSHCameraDataStruct                    _CustomCollisionData;                              // 0x05B8(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         _RotationScale;                                    // 0x0610(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _LookOperationZOffset;                             // 0x0614(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _LookOperationDuration;                            // 0x0618(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _BlendCameraFOV;                                   // 0x061C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61D[0x3];                                      // 0x061D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _BlendCameraFOVValue;                              // 0x0620(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_624[0x4];                                      // 0x0624(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHBlendData                           _BlendCameraFOVConfig;                             // 0x0628(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void StopCameraChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAIAction_Sync">();
	}
	static class USHAIAction_Sync* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAIAction_Sync>();
	}
};
#pragma pack(pop)
static_assert(alignof(USHAIAction_Sync) == 0x000010, "Wrong alignment on USHAIAction_Sync");
static_assert(sizeof(USHAIAction_Sync) == 0x000650, "Wrong size on USHAIAction_Sync");
static_assert(offsetof(USHAIAction_Sync, _HideWeapon) == 0x000510, "Member 'USHAIAction_Sync::_HideWeapon' has a wrong offset!");
static_assert(offsetof(USHAIAction_Sync, _HardLockTokens) == 0x000511, "Member 'USHAIAction_Sync::_HardLockTokens' has a wrong offset!");
static_assert(offsetof(USHAIAction_Sync, _ReleaseOtherOnFinish) == 0x000512, "Member 'USHAIAction_Sync::_ReleaseOtherOnFinish' has a wrong offset!");
static_assert(offsetof(USHAIAction_Sync, _ChangeCamera) == 0x000513, "Member 'USHAIAction_Sync::_ChangeCamera' has a wrong offset!");
static_assert(offsetof(USHAIAction_Sync, _CameraChangeSettings) == 0x000518, "Member 'USHAIAction_Sync::_CameraChangeSettings' has a wrong offset!");
static_assert(offsetof(USHAIAction_Sync, _CustomCameraName) == 0x000550, "Member 'USHAIAction_Sync::_CustomCameraName' has a wrong offset!");
static_assert(offsetof(USHAIAction_Sync, _CustomCameraData) == 0x000560, "Member 'USHAIAction_Sync::_CustomCameraData' has a wrong offset!");
static_assert(offsetof(USHAIAction_Sync, _CustomCollisionData) == 0x0005B8, "Member 'USHAIAction_Sync::_CustomCollisionData' has a wrong offset!");
static_assert(offsetof(USHAIAction_Sync, _RotationScale) == 0x000610, "Member 'USHAIAction_Sync::_RotationScale' has a wrong offset!");
static_assert(offsetof(USHAIAction_Sync, _LookOperationZOffset) == 0x000614, "Member 'USHAIAction_Sync::_LookOperationZOffset' has a wrong offset!");
static_assert(offsetof(USHAIAction_Sync, _LookOperationDuration) == 0x000618, "Member 'USHAIAction_Sync::_LookOperationDuration' has a wrong offset!");
static_assert(offsetof(USHAIAction_Sync, _BlendCameraFOV) == 0x00061C, "Member 'USHAIAction_Sync::_BlendCameraFOV' has a wrong offset!");
static_assert(offsetof(USHAIAction_Sync, _BlendCameraFOVValue) == 0x000620, "Member 'USHAIAction_Sync::_BlendCameraFOVValue' has a wrong offset!");
static_assert(offsetof(USHAIAction_Sync, _BlendCameraFOVConfig) == 0x000628, "Member 'USHAIAction_Sync::_BlendCameraFOVConfig' has a wrong offset!");

// Class SHProto.SHPlayerDeathVolume
// 0x0008 (0x02F0 - 0x02E8)
class ASHPlayerDeathVolume final : public AVolume
{
public:
	int32                                         VolumePriority;                                    // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPlayerDeathVolume">();
	}
	static class ASHPlayerDeathVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHPlayerDeathVolume>();
	}
};
static_assert(alignof(ASHPlayerDeathVolume) == 0x000008, "Wrong alignment on ASHPlayerDeathVolume");
static_assert(sizeof(ASHPlayerDeathVolume) == 0x0002F0, "Wrong size on ASHPlayerDeathVolume");
static_assert(offsetof(ASHPlayerDeathVolume, VolumePriority) == 0x0002E8, "Member 'ASHPlayerDeathVolume::VolumePriority' has a wrong offset!");

// Class SHProto.SHAIAction_Finisher
// 0x0000 (0x0650 - 0x0650)
class USHAIAction_Finisher final : public USHAIAction_Sync
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAIAction_Finisher">();
	}
	static class USHAIAction_Finisher* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAIAction_Finisher>();
	}
};
static_assert(alignof(USHAIAction_Finisher) == 0x000010, "Wrong alignment on USHAIAction_Finisher");
static_assert(sizeof(USHAIAction_Finisher) == 0x000650, "Wrong size on USHAIAction_Finisher");

// Class SHProto.SHCaterpillarCapsuleComponent
// 0x01B0 (0x0720 - 0x0570)
class USHCaterpillarCapsuleComponent final : public UCapsuleComponent
{
public:
	uint8                                         Pad_570[0x10];                                     // 0x0570(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CapsuleParentAttachmentScalars;                    // 0x0580(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CapsuleParentAttachmentOffset;                     // 0x0598(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               CapsuleParentAttachmentRotationInActorSpace;       // 0x05B0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         CapsuleAnchorHeightScalar;                         // 0x05C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCapsuleStartsActivated;                           // 0x05CC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCapsuleAvoidCollisions;                           // 0x05CD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5CE[0x2];                                      // 0x05CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TracingInitialLiftAngleHACK;                       // 0x05D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              InitialCollisionPullbackRotation;                  // 0x05D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              InitialCollisionPullbackRotationOnPawns;           // 0x05E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              TraceEndPoints;                                    // 0x05F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceDensity;                                      // 0x0608(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSnapBackToCollision;                              // 0x060C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCapsuleAlignToSurface;                            // 0x060D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60E[0x2];                                      // 0x060E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CapsuleSurfaceAlignmentMargin;                     // 0x0610(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleSurfaceAlignmentIgnoreAnglesPast;           // 0x0614(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsulSurfaceAlignmentTraceAtHeight;               // 0x0618(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61C[0x4];                                      // 0x061C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CapsuleSurfaceAlignmentTraceVector;                // 0x0620(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleSurfaceAlignmentTraceVectorPullback;        // 0x0638(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCapsuleAlignToSurfaceIgnorePawnChannel;           // 0x063C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCapsuleAlignToSurfaceIgnorePawns;                 // 0x063D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCapsuleSurfaceAlignmentTraceForStairs;            // 0x063E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_63F[0x1];                                      // 0x063F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CapsuleSurfaceAlignmentTraceVectorExtensionForStairs; // 0x0640(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleSurfaceAlignmentInterpolationHalfTime;      // 0x0644(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInterpolateCapsuleRotation;                       // 0x0648(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableIdleRotation;                               // 0x0649(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64A[0x2];                                      // 0x064A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CapsuleRotationIdleInterpolationHalfTime;          // 0x064C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableMovementRotation;                           // 0x0650(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_651[0x3];                                      // 0x0651(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CapsuleRotationMinimumInterpolationHalfTime;       // 0x0654(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleRotationMaximumInterpolationHalfTime;       // 0x0658(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleRotationAtMinimumVelocity;                  // 0x065C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleRotationAtMaximumVelocity;                  // 0x0660(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_664[0x4];                                      // 0x0664(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CapsuleRotationVelocityMeasurementScale;           // 0x0668(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleExtensionScalar;                            // 0x0680(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleExtensionSafetyMargin;                      // 0x0684(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleRadiusSafetyMargin;                         // 0x0688(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawCollisionDebug;                               // 0x068C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawSurfaceAlignmentDebug;                        // 0x068D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68E[0x2];                                      // 0x068E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USHCaterpillarCapsuleComponent*> ConnectedCapsules;                                 // 0x0690(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         P_CachedConnectedCapsulesBaseLength;               // 0x06A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         P_BaseCapsuleHalfHeightWithoutHemisphere;          // 0x06A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A8[0x8];                                      // 0x06A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  P_CapsuleParentAttachmentRotationInActorSpaceQuat; // 0x06B0(0x0020)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FQuat                                  P_CapsuleParentAttachmentRelativeRotationQuat;     // 0x06D0(0x0020)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FQuat                                  P_CapsuleTraceInitialLiftRotationQuat;             // 0x06F0(0x0020)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_710[0x10];                                     // 0x0710(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExpandCapsule();
	bool ReExpandCapsuleAtDesiredLocationAndRotation();
	void RetractCapsule();
	void SetBaseHalfHeightWithoutHemisphere(float InHalfHeightWithoutHemisphere);
	void SetCapsuleActivated(bool InActivated);
	void SetCapsuleAnchorHeightScalar(float InAnchorScalar);
	void SetCapsuleAvoidCollisions(bool InAvoidCollisions);
	void SetCapsuleDesiredExtensionScalar(float InScalar);
	void SetCapsuleIdleRotationEnabled(bool InEnableIdleRotation);
	void SetCapsuleInterpolatingRotation(bool InInterpolate);
	bool SetCapsuleLocationAndRotation(const struct FVector& InAnchorLocation, const struct FRotator& InCapsuleRotation, bool InSweepCollisions, float InPullbackRotationMultiplier);
	bool SetCapsuleLocationAndRotationToDesired(bool InSweepCollisions);
	void SetCapsuleParentAttachmentOffset(const struct FVector& InAttachmentOffset);
	void SetCapsuleParentAttachmentScalars(const struct FVector& InAttachmentScalars);
	void SetCapsuleSurfaceAlignmentEnabled(bool InEnableAlignment);
	bool TraceCapsuleLocationAndRotationChange(const struct FVector& InTargetAnchorLocation, const struct FRotator& InTargetCapsuleRotation, float InPullbackRotationMultiplier, struct FVector* OutCapsuleLocation, struct FQuat* OutCapsuleRotation, struct FHitResult* OutHitResult);

	float GetCapsuleCurrentExtensionScalar() const;
	float GetCapsuleDesiredHalfHeightWithoutHemisphere() const;
	float GetCapsuleExtensionSafetyMargin() const;
	void GetCapsuleExtensionScalarsFromAnchor(float* OutTopScalar, float* OutBottomScalar, bool InClamped) const;
	bool GetCapsuleIdleRotationEnabled() const;
	bool GetCapsuleIsActivated() const;
	bool GetCapsuleIsAvoidingCollisions() const;
	bool GetCapsuleIsInterpolatingRotation() const;
	struct FQuat GetCapsuleLyingRotation() const;
	struct FQuat GetCapsuleParentAttachmentDesiredRotationInActorSpace() const;
	float GetCapsuleRadiusSafetyMargin() const;
	bool GetCapsuleSurfaceAlignmentEnabled() const;
	float GetCapsuleTargetAnchorScalar() const;
	struct FVector GetCapsuleTargetAnchorWorldLocation() const;
	struct FQuat GetCapsuleTargetAnchorWorldRotation() const;
	struct FQuat GetCapsuleUnlyingWorldRotation() const;
	float GetDesiredCapsuleBottomDistanceFromAnchor() const;
	float GetDesiredCapsuleTopDistanceFromAnchor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCaterpillarCapsuleComponent">();
	}
	static class USHCaterpillarCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCaterpillarCapsuleComponent>();
	}
};
static_assert(alignof(USHCaterpillarCapsuleComponent) == 0x000010, "Wrong alignment on USHCaterpillarCapsuleComponent");
static_assert(sizeof(USHCaterpillarCapsuleComponent) == 0x000720, "Wrong size on USHCaterpillarCapsuleComponent");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleParentAttachmentScalars) == 0x000580, "Member 'USHCaterpillarCapsuleComponent::CapsuleParentAttachmentScalars' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleParentAttachmentOffset) == 0x000598, "Member 'USHCaterpillarCapsuleComponent::CapsuleParentAttachmentOffset' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleParentAttachmentRotationInActorSpace) == 0x0005B0, "Member 'USHCaterpillarCapsuleComponent::CapsuleParentAttachmentRotationInActorSpace' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleAnchorHeightScalar) == 0x0005C8, "Member 'USHCaterpillarCapsuleComponent::CapsuleAnchorHeightScalar' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, bCapsuleStartsActivated) == 0x0005CC, "Member 'USHCaterpillarCapsuleComponent::bCapsuleStartsActivated' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, bCapsuleAvoidCollisions) == 0x0005CD, "Member 'USHCaterpillarCapsuleComponent::bCapsuleAvoidCollisions' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, TracingInitialLiftAngleHACK) == 0x0005D0, "Member 'USHCaterpillarCapsuleComponent::TracingInitialLiftAngleHACK' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, InitialCollisionPullbackRotation) == 0x0005D8, "Member 'USHCaterpillarCapsuleComponent::InitialCollisionPullbackRotation' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, InitialCollisionPullbackRotationOnPawns) == 0x0005E8, "Member 'USHCaterpillarCapsuleComponent::InitialCollisionPullbackRotationOnPawns' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, TraceEndPoints) == 0x0005F8, "Member 'USHCaterpillarCapsuleComponent::TraceEndPoints' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, TraceDensity) == 0x000608, "Member 'USHCaterpillarCapsuleComponent::TraceDensity' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, bSnapBackToCollision) == 0x00060C, "Member 'USHCaterpillarCapsuleComponent::bSnapBackToCollision' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, bCapsuleAlignToSurface) == 0x00060D, "Member 'USHCaterpillarCapsuleComponent::bCapsuleAlignToSurface' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleSurfaceAlignmentMargin) == 0x000610, "Member 'USHCaterpillarCapsuleComponent::CapsuleSurfaceAlignmentMargin' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleSurfaceAlignmentIgnoreAnglesPast) == 0x000614, "Member 'USHCaterpillarCapsuleComponent::CapsuleSurfaceAlignmentIgnoreAnglesPast' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsulSurfaceAlignmentTraceAtHeight) == 0x000618, "Member 'USHCaterpillarCapsuleComponent::CapsulSurfaceAlignmentTraceAtHeight' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleSurfaceAlignmentTraceVector) == 0x000620, "Member 'USHCaterpillarCapsuleComponent::CapsuleSurfaceAlignmentTraceVector' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleSurfaceAlignmentTraceVectorPullback) == 0x000638, "Member 'USHCaterpillarCapsuleComponent::CapsuleSurfaceAlignmentTraceVectorPullback' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, bCapsuleAlignToSurfaceIgnorePawnChannel) == 0x00063C, "Member 'USHCaterpillarCapsuleComponent::bCapsuleAlignToSurfaceIgnorePawnChannel' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, bCapsuleAlignToSurfaceIgnorePawns) == 0x00063D, "Member 'USHCaterpillarCapsuleComponent::bCapsuleAlignToSurfaceIgnorePawns' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, bCapsuleSurfaceAlignmentTraceForStairs) == 0x00063E, "Member 'USHCaterpillarCapsuleComponent::bCapsuleSurfaceAlignmentTraceForStairs' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleSurfaceAlignmentTraceVectorExtensionForStairs) == 0x000640, "Member 'USHCaterpillarCapsuleComponent::CapsuleSurfaceAlignmentTraceVectorExtensionForStairs' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleSurfaceAlignmentInterpolationHalfTime) == 0x000644, "Member 'USHCaterpillarCapsuleComponent::CapsuleSurfaceAlignmentInterpolationHalfTime' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, bInterpolateCapsuleRotation) == 0x000648, "Member 'USHCaterpillarCapsuleComponent::bInterpolateCapsuleRotation' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, bEnableIdleRotation) == 0x000649, "Member 'USHCaterpillarCapsuleComponent::bEnableIdleRotation' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleRotationIdleInterpolationHalfTime) == 0x00064C, "Member 'USHCaterpillarCapsuleComponent::CapsuleRotationIdleInterpolationHalfTime' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, bEnableMovementRotation) == 0x000650, "Member 'USHCaterpillarCapsuleComponent::bEnableMovementRotation' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleRotationMinimumInterpolationHalfTime) == 0x000654, "Member 'USHCaterpillarCapsuleComponent::CapsuleRotationMinimumInterpolationHalfTime' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleRotationMaximumInterpolationHalfTime) == 0x000658, "Member 'USHCaterpillarCapsuleComponent::CapsuleRotationMaximumInterpolationHalfTime' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleRotationAtMinimumVelocity) == 0x00065C, "Member 'USHCaterpillarCapsuleComponent::CapsuleRotationAtMinimumVelocity' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleRotationAtMaximumVelocity) == 0x000660, "Member 'USHCaterpillarCapsuleComponent::CapsuleRotationAtMaximumVelocity' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleRotationVelocityMeasurementScale) == 0x000668, "Member 'USHCaterpillarCapsuleComponent::CapsuleRotationVelocityMeasurementScale' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleExtensionScalar) == 0x000680, "Member 'USHCaterpillarCapsuleComponent::CapsuleExtensionScalar' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleExtensionSafetyMargin) == 0x000684, "Member 'USHCaterpillarCapsuleComponent::CapsuleExtensionSafetyMargin' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, CapsuleRadiusSafetyMargin) == 0x000688, "Member 'USHCaterpillarCapsuleComponent::CapsuleRadiusSafetyMargin' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, bDrawCollisionDebug) == 0x00068C, "Member 'USHCaterpillarCapsuleComponent::bDrawCollisionDebug' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, bDrawSurfaceAlignmentDebug) == 0x00068D, "Member 'USHCaterpillarCapsuleComponent::bDrawSurfaceAlignmentDebug' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, ConnectedCapsules) == 0x000690, "Member 'USHCaterpillarCapsuleComponent::ConnectedCapsules' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, P_CachedConnectedCapsulesBaseLength) == 0x0006A0, "Member 'USHCaterpillarCapsuleComponent::P_CachedConnectedCapsulesBaseLength' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, P_BaseCapsuleHalfHeightWithoutHemisphere) == 0x0006A4, "Member 'USHCaterpillarCapsuleComponent::P_BaseCapsuleHalfHeightWithoutHemisphere' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, P_CapsuleParentAttachmentRotationInActorSpaceQuat) == 0x0006B0, "Member 'USHCaterpillarCapsuleComponent::P_CapsuleParentAttachmentRotationInActorSpaceQuat' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, P_CapsuleParentAttachmentRelativeRotationQuat) == 0x0006D0, "Member 'USHCaterpillarCapsuleComponent::P_CapsuleParentAttachmentRelativeRotationQuat' has a wrong offset!");
static_assert(offsetof(USHCaterpillarCapsuleComponent, P_CapsuleTraceInitialLiftRotationQuat) == 0x0006F0, "Member 'USHCaterpillarCapsuleComponent::P_CapsuleTraceInitialLiftRotationQuat' has a wrong offset!");

// Class SHProto.SHAIAction_Struggle
// 0x0020 (0x0670 - 0x0650)
class USHAIAction_Struggle final : public USHAIAction_Sync
{
public:
	uint8                                         _LoopCount;                                        // 0x0648(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_649[0x3];                                      // 0x0649(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _DecayPerSecond;                                   // 0x064C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _PointsPerClick;                                   // 0x0650(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _PointsPerHoldSecond;                              // 0x0654(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _LoopsToDo;                                        // 0x0658(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_659[0x7];                                      // 0x0659(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USHStruggleCmbSubcomp*                  _StruggleSubcomp;                                  // 0x0660(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Escaped;                                          // 0x0668(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _IsInLoop;                                         // 0x0669(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66A[0x6];                                      // 0x066A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAIAction_Struggle">();
	}
	static class USHAIAction_Struggle* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAIAction_Struggle>();
	}
};
static_assert(alignof(USHAIAction_Struggle) == 0x000010, "Wrong alignment on USHAIAction_Struggle");
static_assert(sizeof(USHAIAction_Struggle) == 0x000670, "Wrong size on USHAIAction_Struggle");
static_assert(offsetof(USHAIAction_Struggle, _LoopCount) == 0x000648, "Member 'USHAIAction_Struggle::_LoopCount' has a wrong offset!");
static_assert(offsetof(USHAIAction_Struggle, _DecayPerSecond) == 0x00064C, "Member 'USHAIAction_Struggle::_DecayPerSecond' has a wrong offset!");
static_assert(offsetof(USHAIAction_Struggle, _PointsPerClick) == 0x000650, "Member 'USHAIAction_Struggle::_PointsPerClick' has a wrong offset!");
static_assert(offsetof(USHAIAction_Struggle, _PointsPerHoldSecond) == 0x000654, "Member 'USHAIAction_Struggle::_PointsPerHoldSecond' has a wrong offset!");
static_assert(offsetof(USHAIAction_Struggle, _LoopsToDo) == 0x000658, "Member 'USHAIAction_Struggle::_LoopsToDo' has a wrong offset!");
static_assert(offsetof(USHAIAction_Struggle, _StruggleSubcomp) == 0x000660, "Member 'USHAIAction_Struggle::_StruggleSubcomp' has a wrong offset!");
static_assert(offsetof(USHAIAction_Struggle, _Escaped) == 0x000668, "Member 'USHAIAction_Struggle::_Escaped' has a wrong offset!");
static_assert(offsetof(USHAIAction_Struggle, _IsInLoop) == 0x000669, "Member 'USHAIAction_Struggle::_IsInLoop' has a wrong offset!");

// Class SHProto.SHAnimNotify_CheckStruggleState
// 0x0000 (0x0038 - 0x0038)
class USHAnimNotify_CheckStruggleState final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_CheckStruggleState">();
	}
	static class USHAnimNotify_CheckStruggleState* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_CheckStruggleState>();
	}
};
static_assert(alignof(USHAnimNotify_CheckStruggleState) == 0x000008, "Wrong alignment on USHAnimNotify_CheckStruggleState");
static_assert(sizeof(USHAnimNotify_CheckStruggleState) == 0x000038, "Wrong size on USHAnimNotify_CheckStruggleState");

// Class SHProto.SHAICharacter
// 0x00B0 (0x09A0 - 0x08F0)
class ASHAICharacter final : public AMaiCharacter
{
public:
	uint8                                         Pad_8F0[0x10];                                     // 0x08F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USHEnemyCameraOverlapHandleComponent*   PlayerCameraOverlapHandlerComponent;               // 0x0900(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAIWeaponManagerComponent*            AIWeaponManagerComponent;                          // 0x0908(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXComponent*                         FXComponent;                                       // 0x0910(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        HardStoredObjects;                                 // 0x0918(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             _FinishersTable;                                   // 0x0928(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAnimComponent*                       AnimComponent;                                     // 0x0930(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaiHealth*                             HealthComponent;                                   // 0x0938(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaiReincarnationComponent*             ReincarnationComponent;                            // 0x0940(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USkeletalMesh>           _SoftCustomMesh;                                   // 0x0948(0x0030)(SaveGame, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_978[0x28];                                     // 0x0978(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Die();
	void DrawDeathSequenceDebug(float DeltaSeconds, TSoftClassPtr<class UClass> DeathPlayerSoftClass);
	void OnPlayerSnap(float SnapDuration, TSubclassOf<class UDamageType> DamageType);
	bool PlayDeathSequenceRequest(class APawn* Slayer, TSoftClassPtr<class UClass> DeathPlayerSoftClass);
	void ResetPawn();
	void Revive();
	void SetAudioStopWhenDespawned(bool bStopAudioStopWhenDespawned);
	void SetCustomMesh(TSoftObjectPtr<class USkeletalMesh> CustomMesh);
	void SetDisabledPushedByPlayer(const bool bInDisable, const class UObject* Object);

	bool AllowDeath() const;
	bool AllowFinisher() const;
	bool CanBeSteppedOn() const;
	bool EnforceFinisher() const;
	struct FVector GetActorLocationAsMeleeTarget() const;
	TArray<TSoftObjectPtr<class UObject>> GetAssetsToHardStore() const;
	TArray<class USceneComponent*> GetAutoAimTargets() const;
	struct FDataTableRowHandle GetFinisherParams(class AActor* Victim, const struct FGameplayTagContainer& TagFilters) const;
	struct FGameplayTagContainer GetFinisherTags(class AActor* Victim) const;
	class USceneComponent* GetFlashlightTarget() const;
	float GetOffsetForEnvironmentTrace() const;
	bool IsKnockedDown() const;
	bool IsLying() const;
	bool IsPrimaryEnemy() const;
	bool IsPushedByPlayerDisabled() const;
	bool IsPushedByPlayerDisabledBy(const class UObject* Object) const;
	bool IsUnderEnemy() const;
	bool IsUnderObstacle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAICharacter">();
	}
	static class ASHAICharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHAICharacter>();
	}
};
static_assert(alignof(ASHAICharacter) == 0x000010, "Wrong alignment on ASHAICharacter");
static_assert(sizeof(ASHAICharacter) == 0x0009A0, "Wrong size on ASHAICharacter");
static_assert(offsetof(ASHAICharacter, PlayerCameraOverlapHandlerComponent) == 0x000900, "Member 'ASHAICharacter::PlayerCameraOverlapHandlerComponent' has a wrong offset!");
static_assert(offsetof(ASHAICharacter, AIWeaponManagerComponent) == 0x000908, "Member 'ASHAICharacter::AIWeaponManagerComponent' has a wrong offset!");
static_assert(offsetof(ASHAICharacter, FXComponent) == 0x000910, "Member 'ASHAICharacter::FXComponent' has a wrong offset!");
static_assert(offsetof(ASHAICharacter, HardStoredObjects) == 0x000918, "Member 'ASHAICharacter::HardStoredObjects' has a wrong offset!");
static_assert(offsetof(ASHAICharacter, _FinishersTable) == 0x000928, "Member 'ASHAICharacter::_FinishersTable' has a wrong offset!");
static_assert(offsetof(ASHAICharacter, AnimComponent) == 0x000930, "Member 'ASHAICharacter::AnimComponent' has a wrong offset!");
static_assert(offsetof(ASHAICharacter, HealthComponent) == 0x000938, "Member 'ASHAICharacter::HealthComponent' has a wrong offset!");
static_assert(offsetof(ASHAICharacter, ReincarnationComponent) == 0x000940, "Member 'ASHAICharacter::ReincarnationComponent' has a wrong offset!");
static_assert(offsetof(ASHAICharacter, _SoftCustomMesh) == 0x000948, "Member 'ASHAICharacter::_SoftCustomMesh' has a wrong offset!");

// Class SHProto.NurseBlockableOWDamage
// 0x0000 (0x0068 - 0x0068)
class UNurseBlockableOWDamage final : public UMeleeDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NurseBlockableOWDamage">();
	}
	static class UNurseBlockableOWDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNurseBlockableOWDamage>();
	}
};
static_assert(alignof(UNurseBlockableOWDamage) == 0x000008, "Wrong alignment on UNurseBlockableOWDamage");
static_assert(sizeof(UNurseBlockableOWDamage) == 0x000068, "Wrong size on UNurseBlockableOWDamage");

// Class SHProto.SHAICharacterMovementComponent
// 0x0000 (0x11E0 - 0x11E0)
class USHAICharacterMovementComponent final : public UMaiCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAICharacterMovementComponent">();
	}
	static class USHAICharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAICharacterMovementComponent>();
	}
};
static_assert(alignof(USHAICharacterMovementComponent) == 0x000010, "Wrong alignment on USHAICharacterMovementComponent");
static_assert(sizeof(USHAICharacterMovementComponent) == 0x0011E0, "Wrong size on USHAICharacterMovementComponent");

// Class SHProto.SHBlissEndingFactor
// 0x0008 (0x0038 - 0x0030)
class USHBlissEndingFactor final : public USHEndingFactor
{
public:
	bool                                          bIsAllowedToAddValue;                              // 0x0030(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bValue;                                            // 0x0031(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Character_Endings_Factors_BlissEnding_SetDebugIsAllowedToAddValue(bool bInValue);
	void SHDebug_Character_Endings_Factors_BlissEnding_SetDebugValue(bool bInValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBlissEndingFactor">();
	}
	static class USHBlissEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBlissEndingFactor>();
	}
};
static_assert(alignof(USHBlissEndingFactor) == 0x000008, "Wrong alignment on USHBlissEndingFactor");
static_assert(sizeof(USHBlissEndingFactor) == 0x000038, "Wrong size on USHBlissEndingFactor");
static_assert(offsetof(USHBlissEndingFactor, bIsAllowedToAddValue) == 0x000030, "Member 'USHBlissEndingFactor::bIsAllowedToAddValue' has a wrong offset!");
static_assert(offsetof(USHBlissEndingFactor, bValue) == 0x000031, "Member 'USHBlissEndingFactor::bValue' has a wrong offset!");

// Class SHProto.SHAIController
// 0x0028 (0x0900 - 0x08D8)
class ASHAIController final : public AMaiControllerExt
{
public:
	ESHAIBehaviors                                _BehaviorType;                                     // 0x08D8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D9[0x3];                                      // 0x08D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _ChanceToBeAttacked;                               // 0x08DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaiAggroMeter*                         AggroMeterComponent;                               // 0x08E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E8[0x18];                                     // 0x08E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeLockedState(const bool bNewLockedState, const class UObject* Object);
	void ClearBehaviorType(ESHAIBehaviors Behavior);
	void SetBehaviorType(ESHAIBehaviors Behavior);

	ESHAIBehaviors GetBehaviorType() const;
	bool IsInLockedState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAIController">();
	}
	static class ASHAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHAIController>();
	}
};
static_assert(alignof(ASHAIController) == 0x000008, "Wrong alignment on ASHAIController");
static_assert(sizeof(ASHAIController) == 0x000900, "Wrong size on ASHAIController");
static_assert(offsetof(ASHAIController, _BehaviorType) == 0x0008D8, "Member 'ASHAIController::_BehaviorType' has a wrong offset!");
static_assert(offsetof(ASHAIController, _ChanceToBeAttacked) == 0x0008DC, "Member 'ASHAIController::_ChanceToBeAttacked' has a wrong offset!");
static_assert(offsetof(ASHAIController, AggroMeterComponent) == 0x0008E0, "Member 'ASHAIController::AggroMeterComponent' has a wrong offset!");

// Class SHProto.SHAIDeathVolume
// 0x0008 (0x02F0 - 0x02E8)
class ASHAIDeathVolume final : public AVolume
{
public:
	int32                                         _VolumePriority;                                   // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAIDeathVolume">();
	}
	static class ASHAIDeathVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHAIDeathVolume>();
	}
};
static_assert(alignof(ASHAIDeathVolume) == 0x000008, "Wrong alignment on ASHAIDeathVolume");
static_assert(sizeof(ASHAIDeathVolume) == 0x0002F0, "Wrong size on ASHAIDeathVolume");
static_assert(offsetof(ASHAIDeathVolume, _VolumePriority) == 0x0002E8, "Member 'ASHAIDeathVolume::_VolumePriority' has a wrong offset!");

// Class SHProto.SHAspectAwareSpacer
// 0x0010 (0x0180 - 0x0170)
class USHAspectAwareSpacer final : public USpacer
{
public:
	uint8                                         Pad_170[0xC];                                      // 0x0170(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	ESHAspectAwareFrameType                       FillInType;                                        // 0x017C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D[0x3];                                      // 0x017D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAspectAwareSpacer">();
	}
	static class USHAspectAwareSpacer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAspectAwareSpacer>();
	}
};
static_assert(alignof(USHAspectAwareSpacer) == 0x000008, "Wrong alignment on USHAspectAwareSpacer");
static_assert(sizeof(USHAspectAwareSpacer) == 0x000180, "Wrong size on USHAspectAwareSpacer");
static_assert(offsetof(USHAspectAwareSpacer, FillInType) == 0x00017C, "Member 'USHAspectAwareSpacer::FillInType' has a wrong offset!");

// Class SHProto.SHAIDeathVolumeService
// 0x0010 (0x0040 - 0x0030)
class USHAIDeathVolumeService final : public UWorldSubsystem
{
public:
	TArray<class ASHAIDeathVolume*>               _WorldDeathVolumes;                                // 0x0030(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAIDeathVolumeService">();
	}
	static class USHAIDeathVolumeService* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAIDeathVolumeService>();
	}
};
static_assert(alignof(USHAIDeathVolumeService) == 0x000008, "Wrong alignment on USHAIDeathVolumeService");
static_assert(sizeof(USHAIDeathVolumeService) == 0x000040, "Wrong size on USHAIDeathVolumeService");
static_assert(offsetof(USHAIDeathVolumeService, _WorldDeathVolumes) == 0x000030, "Member 'USHAIDeathVolumeService::_WorldDeathVolumes' has a wrong offset!");

// Class SHProto.SHPlaythroughStompedDeadEnemiesEndingFactor
// 0x0000 (0x0088 - 0x0088)
class USHPlaythroughStompedDeadEnemiesEndingFactor final : public USHIntEndingFactor
{
public:
	void SHDebug_Character_Endings_PlaythroughStompedDeadEnemiesEndingFactor_SetDebugValue(int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPlaythroughStompedDeadEnemiesEndingFactor">();
	}
	static class USHPlaythroughStompedDeadEnemiesEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPlaythroughStompedDeadEnemiesEndingFactor>();
	}
};
static_assert(alignof(USHPlaythroughStompedDeadEnemiesEndingFactor) == 0x000008, "Wrong alignment on USHPlaythroughStompedDeadEnemiesEndingFactor");
static_assert(sizeof(USHPlaythroughStompedDeadEnemiesEndingFactor) == 0x000088, "Wrong size on USHPlaythroughStompedDeadEnemiesEndingFactor");

// Class SHProto.SHAIHostileAttackers
// 0x0050 (0x1440 - 0x13F0)
class USHAIHostileAttackers final : public UMaiHostileAttackers
{
public:
	TMap<TSoftClassPtr<class UClass>, int32>      _MaxCount;                                         // 0x13F0(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAIHostileAttackers">();
	}
	static class USHAIHostileAttackers* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAIHostileAttackers>();
	}
};
static_assert(alignof(USHAIHostileAttackers) == 0x000008, "Wrong alignment on USHAIHostileAttackers");
static_assert(sizeof(USHAIHostileAttackers) == 0x001440, "Wrong size on USHAIHostileAttackers");
static_assert(offsetof(USHAIHostileAttackers, _MaxCount) == 0x0013F0, "Member 'USHAIHostileAttackers::_MaxCount' has a wrong offset!");

// Class SHProto.SHAnimPhysicalSubcomp
// 0x00A0 (0x00D8 - 0x0038)
class USHAnimPhysicalSubcomp final : public USHAnimSubcomponentBase
{
public:
	class UPhysicalAnimationComponent*            PhysicalAnimation;                                 // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalAnimationProfileDA*            PhysicalAnimationProfilesDA;                       // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPhysicalAnimationBlender              PhysicalAnimationBlender;                          // 0x0048(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FConstraintMotorBlender                ConstraintMotorBlender;                            // 0x0098(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x18];                                      // 0x00C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPhysicalAnimationWeight(float PhysicalAnimationWeight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimPhysicalSubcomp">();
	}
	static class USHAnimPhysicalSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimPhysicalSubcomp>();
	}
};
static_assert(alignof(USHAnimPhysicalSubcomp) == 0x000008, "Wrong alignment on USHAnimPhysicalSubcomp");
static_assert(sizeof(USHAnimPhysicalSubcomp) == 0x0000D8, "Wrong size on USHAnimPhysicalSubcomp");
static_assert(offsetof(USHAnimPhysicalSubcomp, PhysicalAnimation) == 0x000038, "Member 'USHAnimPhysicalSubcomp::PhysicalAnimation' has a wrong offset!");
static_assert(offsetof(USHAnimPhysicalSubcomp, PhysicalAnimationProfilesDA) == 0x000040, "Member 'USHAnimPhysicalSubcomp::PhysicalAnimationProfilesDA' has a wrong offset!");
static_assert(offsetof(USHAnimPhysicalSubcomp, PhysicalAnimationBlender) == 0x000048, "Member 'USHAnimPhysicalSubcomp::PhysicalAnimationBlender' has a wrong offset!");
static_assert(offsetof(USHAnimPhysicalSubcomp, ConstraintMotorBlender) == 0x000098, "Member 'USHAnimPhysicalSubcomp::ConstraintMotorBlender' has a wrong offset!");

// Class SHProto.SHAIIsMoveLineToEnemyClearStat
// 0x0000 (0x0128 - 0x0128)
class USHAIIsMoveLineToEnemyClearStat final : public UMaiIsMoveLineToEnemyClearStat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAIIsMoveLineToEnemyClearStat">();
	}
	static class USHAIIsMoveLineToEnemyClearStat* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAIIsMoveLineToEnemyClearStat>();
	}
};
static_assert(alignof(USHAIIsMoveLineToEnemyClearStat) == 0x000008, "Wrong alignment on USHAIIsMoveLineToEnemyClearStat");
static_assert(sizeof(USHAIIsMoveLineToEnemyClearStat) == 0x000128, "Wrong size on USHAIIsMoveLineToEnemyClearStat");

// Class SHProto.SHAIIsShootLineToEnemyClearStat
// 0x0000 (0x0128 - 0x0128)
class USHAIIsShootLineToEnemyClearStat : public UMaiIsShootLineToEnemyClearStat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAIIsShootLineToEnemyClearStat">();
	}
	static class USHAIIsShootLineToEnemyClearStat* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAIIsShootLineToEnemyClearStat>();
	}
};
static_assert(alignof(USHAIIsShootLineToEnemyClearStat) == 0x000008, "Wrong alignment on USHAIIsShootLineToEnemyClearStat");
static_assert(sizeof(USHAIIsShootLineToEnemyClearStat) == 0x000128, "Wrong size on USHAIIsShootLineToEnemyClearStat");

// Class SHProto.SHBaseStagedAnimInstance
// 0x0060 (0x03B0 - 0x0350)
class USHBaseStagedAnimInstance final : public UAnimInstance
{
public:
	bool                                          bPlayInteraction;                                  // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAdvanceStage;                                     // 0x0349(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayFinish;                                       // 0x034A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34B[0x65];                                     // 0x034B(0x0065)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyInteractionBlendingOut();
	void ApplyInteractionFinished();
	void ApplyInteractionStarted();
	void ApplyStageAdvanced();

	bool CanAdvanceStage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBaseStagedAnimInstance">();
	}
	static class USHBaseStagedAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBaseStagedAnimInstance>();
	}
};
static_assert(alignof(USHBaseStagedAnimInstance) == 0x000010, "Wrong alignment on USHBaseStagedAnimInstance");
static_assert(sizeof(USHBaseStagedAnimInstance) == 0x0003B0, "Wrong size on USHBaseStagedAnimInstance");
static_assert(offsetof(USHBaseStagedAnimInstance, bPlayInteraction) == 0x000348, "Member 'USHBaseStagedAnimInstance::bPlayInteraction' has a wrong offset!");
static_assert(offsetof(USHBaseStagedAnimInstance, bAdvanceStage) == 0x000349, "Member 'USHBaseStagedAnimInstance::bAdvanceStage' has a wrong offset!");
static_assert(offsetof(USHBaseStagedAnimInstance, bPlayFinish) == 0x00034A, "Member 'USHBaseStagedAnimInstance::bPlayFinish' has a wrong offset!");

// Class SHProto.SHAIIsShootLineToEneLocClearStat
// 0x0000 (0x0128 - 0x0128)
class USHAIIsShootLineToEneLocClearStat final : public USHAIIsShootLineToEnemyClearStat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAIIsShootLineToEneLocClearStat">();
	}
	static class USHAIIsShootLineToEneLocClearStat* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAIIsShootLineToEneLocClearStat>();
	}
};
static_assert(alignof(USHAIIsShootLineToEneLocClearStat) == 0x000008, "Wrong alignment on USHAIIsShootLineToEneLocClearStat");
static_assert(sizeof(USHAIIsShootLineToEneLocClearStat) == 0x000128, "Wrong size on USHAIIsShootLineToEneLocClearStat");

// Class SHProto.SHSaveSlotsListWidget
// 0x0028 (0x03A0 - 0x0378)
class USHSaveSlotsListWidget final : public USaveSlotsListWidget
{
public:
	class UWidget*                                Ask_Panel;                                         // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             SavePointInfos;                                    // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInAskPanelConfirmOnSaveKey;                       // 0x0388(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_389[0x17];                                     // 0x0389(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Filter(ESavePointFilterId FilterId) const;
	void OnSlotHovered(const struct FGameSaveSlotInfo& SaveSlot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSaveSlotsListWidget">();
	}
	static class USHSaveSlotsListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSaveSlotsListWidget>();
	}
};
static_assert(alignof(USHSaveSlotsListWidget) == 0x000008, "Wrong alignment on USHSaveSlotsListWidget");
static_assert(sizeof(USHSaveSlotsListWidget) == 0x0003A0, "Wrong size on USHSaveSlotsListWidget");
static_assert(offsetof(USHSaveSlotsListWidget, Ask_Panel) == 0x000378, "Member 'USHSaveSlotsListWidget::Ask_Panel' has a wrong offset!");
static_assert(offsetof(USHSaveSlotsListWidget, SavePointInfos) == 0x000380, "Member 'USHSaveSlotsListWidget::SavePointInfos' has a wrong offset!");
static_assert(offsetof(USHSaveSlotsListWidget, bInAskPanelConfirmOnSaveKey) == 0x000388, "Member 'USHSaveSlotsListWidget::bInAskPanelConfirmOnSaveKey' has a wrong offset!");

// Class SHProto.SHAILitByAFlashlight
// 0x0058 (0x00F8 - 0x00A0)
class USHAILitByAFlashlight final : public UActorComponent
{
public:
	float                                         _ChargingDuration;                                 // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _ChargingTime;                                     // 0x00A4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _DecayCooldown;                                    // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _DecaySpeed;                                       // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _DecayTime;                                        // 0x00B0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _IsFullyLit;                                       // 0x00B4(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _AngleCurve;                                       // 0x00B8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _RangeCurve;                                       // 0x00C0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLightEnter;                                      // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLightExit;                                       // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         _AngleAlpha;                                       // 0x00E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _RangeAlpha;                                       // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsPointLitByAFlashlight(class AActor* Owner, const struct FVector& Point, float* AngleAlpha, float* RangeAlpha);

	void DebugPrint();
	bool IsLitByAFlashlight();

	bool IsFullyLit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAILitByAFlashlight">();
	}
	static class USHAILitByAFlashlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAILitByAFlashlight>();
	}
};
static_assert(alignof(USHAILitByAFlashlight) == 0x000008, "Wrong alignment on USHAILitByAFlashlight");
static_assert(sizeof(USHAILitByAFlashlight) == 0x0000F8, "Wrong size on USHAILitByAFlashlight");
static_assert(offsetof(USHAILitByAFlashlight, _ChargingDuration) == 0x0000A0, "Member 'USHAILitByAFlashlight::_ChargingDuration' has a wrong offset!");
static_assert(offsetof(USHAILitByAFlashlight, _ChargingTime) == 0x0000A4, "Member 'USHAILitByAFlashlight::_ChargingTime' has a wrong offset!");
static_assert(offsetof(USHAILitByAFlashlight, _DecayCooldown) == 0x0000A8, "Member 'USHAILitByAFlashlight::_DecayCooldown' has a wrong offset!");
static_assert(offsetof(USHAILitByAFlashlight, _DecaySpeed) == 0x0000AC, "Member 'USHAILitByAFlashlight::_DecaySpeed' has a wrong offset!");
static_assert(offsetof(USHAILitByAFlashlight, _DecayTime) == 0x0000B0, "Member 'USHAILitByAFlashlight::_DecayTime' has a wrong offset!");
static_assert(offsetof(USHAILitByAFlashlight, _IsFullyLit) == 0x0000B4, "Member 'USHAILitByAFlashlight::_IsFullyLit' has a wrong offset!");
static_assert(offsetof(USHAILitByAFlashlight, _AngleCurve) == 0x0000B8, "Member 'USHAILitByAFlashlight::_AngleCurve' has a wrong offset!");
static_assert(offsetof(USHAILitByAFlashlight, _RangeCurve) == 0x0000C0, "Member 'USHAILitByAFlashlight::_RangeCurve' has a wrong offset!");
static_assert(offsetof(USHAILitByAFlashlight, OnLightEnter) == 0x0000C8, "Member 'USHAILitByAFlashlight::OnLightEnter' has a wrong offset!");
static_assert(offsetof(USHAILitByAFlashlight, OnLightExit) == 0x0000D8, "Member 'USHAILitByAFlashlight::OnLightExit' has a wrong offset!");
static_assert(offsetof(USHAILitByAFlashlight, _AngleAlpha) == 0x0000E8, "Member 'USHAILitByAFlashlight::_AngleAlpha' has a wrong offset!");
static_assert(offsetof(USHAILitByAFlashlight, _RangeAlpha) == 0x0000EC, "Member 'USHAILitByAFlashlight::_RangeAlpha' has a wrong offset!");

// Class SHProto.SHVehicleMovementProcessor
// 0x0008 (0x0030 - 0x0028)
class USHVehicleMovementProcessor : public UObject
{
public:
	class USHVehicleComponent*                    VehicleComponent;                                  // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHVehicleMovementProcessor">();
	}
	static class USHVehicleMovementProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHVehicleMovementProcessor>();
	}
};
static_assert(alignof(USHVehicleMovementProcessor) == 0x000008, "Wrong alignment on USHVehicleMovementProcessor");
static_assert(sizeof(USHVehicleMovementProcessor) == 0x000030, "Wrong size on USHVehicleMovementProcessor");
static_assert(offsetof(USHVehicleMovementProcessor, VehicleComponent) == 0x000028, "Member 'USHVehicleMovementProcessor::VehicleComponent' has a wrong offset!");

// Class SHProto.SHAimDistruptorComponent
// 0x0048 (0x00E8 - 0x00A0)
class USHAimDistruptorComponent final : public UActorComponent
{
public:
	bool                                          bWantDistrupt;                                     // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReachFullEffectSeconds;                            // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrosshairDisplacementPixels;                       // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraShake_FrequencyScale;                        // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraShake_DisplacementScale;                     // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              FocusPrepassMapping;                               // 0x00B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x20];                                      // 0x00C8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnabled(const bool bInEnabled, const class UObject* Object);

	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAimDistruptorComponent">();
	}
	static class USHAimDistruptorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAimDistruptorComponent>();
	}
};
static_assert(alignof(USHAimDistruptorComponent) == 0x000008, "Wrong alignment on USHAimDistruptorComponent");
static_assert(sizeof(USHAimDistruptorComponent) == 0x0000E8, "Wrong size on USHAimDistruptorComponent");
static_assert(offsetof(USHAimDistruptorComponent, bWantDistrupt) == 0x0000A0, "Member 'USHAimDistruptorComponent::bWantDistrupt' has a wrong offset!");
static_assert(offsetof(USHAimDistruptorComponent, ReachFullEffectSeconds) == 0x0000A4, "Member 'USHAimDistruptorComponent::ReachFullEffectSeconds' has a wrong offset!");
static_assert(offsetof(USHAimDistruptorComponent, CrosshairDisplacementPixels) == 0x0000A8, "Member 'USHAimDistruptorComponent::CrosshairDisplacementPixels' has a wrong offset!");
static_assert(offsetof(USHAimDistruptorComponent, CameraShake_FrequencyScale) == 0x0000AC, "Member 'USHAimDistruptorComponent::CameraShake_FrequencyScale' has a wrong offset!");
static_assert(offsetof(USHAimDistruptorComponent, CameraShake_DisplacementScale) == 0x0000B0, "Member 'USHAimDistruptorComponent::CameraShake_DisplacementScale' has a wrong offset!");
static_assert(offsetof(USHAimDistruptorComponent, FocusPrepassMapping) == 0x0000B8, "Member 'USHAimDistruptorComponent::FocusPrepassMapping' has a wrong offset!");

// Class SHProto.SHBlockingVolume
// 0x0018 (0x0318 - 0x0300)
class ASHBlockingVolume final : public ANavModifierVolume
{
public:
	uint8                                         bOverrideWalkableSlopeOnInstance : 1;              // 0x0300(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWalkableSlopeOverride                 WalkableSlopeOverride;                             // 0x0304(0x0010)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBlockingVolume">();
	}
	static class ASHBlockingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHBlockingVolume>();
	}
};
static_assert(alignof(ASHBlockingVolume) == 0x000008, "Wrong alignment on ASHBlockingVolume");
static_assert(sizeof(ASHBlockingVolume) == 0x000318, "Wrong size on ASHBlockingVolume");
static_assert(offsetof(ASHBlockingVolume, WalkableSlopeOverride) == 0x000304, "Member 'ASHBlockingVolume::WalkableSlopeOverride' has a wrong offset!");

// Class SHProto.SHAIWeapon
// 0x0070 (0x0320 - 0x02B0)
class ASHAIWeapon : public AActor
{
public:
	class UMeshComponent*                         MeshComponent;                                     // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   EquipSocketName;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             EquipTransform;                                    // 0x02C0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAIWeapon">();
	}
	static class ASHAIWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHAIWeapon>();
	}
};
static_assert(alignof(ASHAIWeapon) == 0x000010, "Wrong alignment on ASHAIWeapon");
static_assert(sizeof(ASHAIWeapon) == 0x000320, "Wrong size on ASHAIWeapon");
static_assert(offsetof(ASHAIWeapon, MeshComponent) == 0x0002B0, "Member 'ASHAIWeapon::MeshComponent' has a wrong offset!");
static_assert(offsetof(ASHAIWeapon, EquipSocketName) == 0x0002B8, "Member 'ASHAIWeapon::EquipSocketName' has a wrong offset!");
static_assert(offsetof(ASHAIWeapon, EquipTransform) == 0x0002C0, "Member 'ASHAIWeapon::EquipTransform' has a wrong offset!");

// Class SHProto.SHProjectSettings
// 0x0000 (0x0038 - 0x0038)
class USHProjectSettings final : public UDeveloperSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHProjectSettings">();
	}
	static class USHProjectSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHProjectSettings>();
	}
};
static_assert(alignof(USHProjectSettings) == 0x000008, "Wrong alignment on USHProjectSettings");
static_assert(sizeof(USHProjectSettings) == 0x000038, "Wrong size on USHProjectSettings");

// Class SHProto.SHAIMeleeWeapon
// 0x0030 (0x0350 - 0x0320)
class ASHAIMeleeWeapon final : public ASHAIWeapon
{
public:
	float                                         EnvDamageValue;                                    // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                EnvDamageTypeClass;                                // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UShapeComponent*>                EnvCollisionShapes;                                // 0x0330(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x10];                                     // 0x0340(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMeshComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

	TArray<class UShapeComponent*> BlueprintGetEnvCollisionShapes() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAIMeleeWeapon">();
	}
	static class ASHAIMeleeWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHAIMeleeWeapon>();
	}
};
static_assert(alignof(ASHAIMeleeWeapon) == 0x000010, "Wrong alignment on ASHAIMeleeWeapon");
static_assert(sizeof(ASHAIMeleeWeapon) == 0x000350, "Wrong size on ASHAIMeleeWeapon");
static_assert(offsetof(ASHAIMeleeWeapon, EnvDamageValue) == 0x000320, "Member 'ASHAIMeleeWeapon::EnvDamageValue' has a wrong offset!");
static_assert(offsetof(ASHAIMeleeWeapon, EnvDamageTypeClass) == 0x000328, "Member 'ASHAIMeleeWeapon::EnvDamageTypeClass' has a wrong offset!");
static_assert(offsetof(ASHAIMeleeWeapon, EnvCollisionShapes) == 0x000330, "Member 'ASHAIMeleeWeapon::EnvCollisionShapes' has a wrong offset!");

// Class SHProto.SHBaseDoorAttachment
// 0x0020 (0x02D0 - 0x02B0)
class ASHBaseDoorAttachment : public AActor
{
public:
	class USphereComponent*                       ProximitySphere;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldManageDoorDetectable;                       // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 DoorActor;                                         // 0x02C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnsureDoorActorClosed();
	void OnParentInteracted();
	void OnParentModified();
	void ProcessOnDoorLockStateChanged(class USHDoorLockBaseComponent* DoorLockComponent);
	void ProcessProximityBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void ProcessProximityEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex);
	void RefreshVisuals();
	bool RegisterDoorActor(class AActor* InActor);
	void SetDoorActorFrozen(bool Inset);

	struct FSHKeyAttachmentDataStruct GetKeyAttachmentData(class FName KeyAttachmentName) const;
	class ASHCharacterPlay* GetProximityCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBaseDoorAttachment">();
	}
	static class ASHBaseDoorAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHBaseDoorAttachment>();
	}
};
static_assert(alignof(ASHBaseDoorAttachment) == 0x000008, "Wrong alignment on ASHBaseDoorAttachment");
static_assert(sizeof(ASHBaseDoorAttachment) == 0x0002D0, "Wrong size on ASHBaseDoorAttachment");
static_assert(offsetof(ASHBaseDoorAttachment, ProximitySphere) == 0x0002B0, "Member 'ASHBaseDoorAttachment::ProximitySphere' has a wrong offset!");
static_assert(offsetof(ASHBaseDoorAttachment, bShouldManageDoorDetectable) == 0x0002B8, "Member 'ASHBaseDoorAttachment::bShouldManageDoorDetectable' has a wrong offset!");
static_assert(offsetof(ASHBaseDoorAttachment, DoorActor) == 0x0002C0, "Member 'ASHBaseDoorAttachment::DoorActor' has a wrong offset!");

// Class SHProto.SHAimOffsetAnimInstance
// 0x0010 (0x0360 - 0x0350)
class USHAimOffsetAnimInstance : public UAnimInstance
{
public:
	struct FVector2D                              HeadRotation;                                      // 0x0348(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtAlpha;                                       // 0x0358(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAiming;                                          // 0x035C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasLookAtTarget;                                   // 0x035D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35E[0x2];                                      // 0x035E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ESHHealthStateEnum GetHealthState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAimOffsetAnimInstance">();
	}
	static class USHAimOffsetAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAimOffsetAnimInstance>();
	}
};
static_assert(alignof(USHAimOffsetAnimInstance) == 0x000010, "Wrong alignment on USHAimOffsetAnimInstance");
static_assert(sizeof(USHAimOffsetAnimInstance) == 0x000360, "Wrong size on USHAimOffsetAnimInstance");
static_assert(offsetof(USHAimOffsetAnimInstance, HeadRotation) == 0x000348, "Member 'USHAimOffsetAnimInstance::HeadRotation' has a wrong offset!");
static_assert(offsetof(USHAimOffsetAnimInstance, LookAtAlpha) == 0x000358, "Member 'USHAimOffsetAnimInstance::LookAtAlpha' has a wrong offset!");
static_assert(offsetof(USHAimOffsetAnimInstance, IsAiming) == 0x00035C, "Member 'USHAimOffsetAnimInstance::IsAiming' has a wrong offset!");
static_assert(offsetof(USHAimOffsetAnimInstance, HasLookAtTarget) == 0x00035D, "Member 'USHAimOffsetAnimInstance::HasLookAtTarget' has a wrong offset!");

// Class SHProto.SHAIRangedWeapon
// 0x0000 (0x0320 - 0x0320)
class ASHAIRangedWeapon : public ASHAIWeapon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAIRangedWeapon">();
	}
	static class ASHAIRangedWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHAIRangedWeapon>();
	}
};
static_assert(alignof(ASHAIRangedWeapon) == 0x000010, "Wrong alignment on ASHAIRangedWeapon");
static_assert(sizeof(ASHAIRangedWeapon) == 0x000320, "Wrong size on ASHAIRangedWeapon");

// Class SHProto.SHVehicleInputReceiver
// 0x0008 (0x0030 - 0x0028)
class USHVehicleInputReceiver : public UObject
{
public:
	class USHVehicleSpotComponent*                OwnerSpot;                                         // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHVehicleInputReceiver">();
	}
	static class USHVehicleInputReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHVehicleInputReceiver>();
	}
};
static_assert(alignof(USHVehicleInputReceiver) == 0x000008, "Wrong alignment on USHVehicleInputReceiver");
static_assert(sizeof(USHVehicleInputReceiver) == 0x000030, "Wrong size on USHVehicleInputReceiver");
static_assert(offsetof(USHVehicleInputReceiver, OwnerSpot) == 0x000028, "Member 'USHVehicleInputReceiver::OwnerSpot' has a wrong offset!");

// Class SHProto.SHAISpawner
// 0x0010 (0x0490 - 0x0480)
class ASHAISpawner final : public AMaiSingleSpawner
{
public:
	bool                                          bUseCustomWeaponClass;                             // 0x0480(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_481[0x7];                                      // 0x0481(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ASHAIWeapon>                CustomWeaponClass;                                 // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAISpawner">();
	}
	static class ASHAISpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHAISpawner>();
	}
};
static_assert(alignof(ASHAISpawner) == 0x000008, "Wrong alignment on ASHAISpawner");
static_assert(sizeof(ASHAISpawner) == 0x000490, "Wrong size on ASHAISpawner");
static_assert(offsetof(ASHAISpawner, bUseCustomWeaponClass) == 0x000480, "Member 'ASHAISpawner::bUseCustomWeaponClass' has a wrong offset!");
static_assert(offsetof(ASHAISpawner, CustomWeaponClass) == 0x000488, "Member 'ASHAISpawner::CustomWeaponClass' has a wrong offset!");

// Class SHProto.SHSearchFocusAnimInstance
// 0x0020 (0x0370 - 0x0350)
class USHSearchFocusAnimInstance final : public UAnimInstance
{
public:
	bool                                          bPlayInteraction;                                  // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAdvanceStage;                                     // 0x0349(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34A[0x26];                                     // 0x034A(0x0026)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyFinalStageReached();
	void ApplyInteractionStarted();
	void ApplyInteractionStartedAndItsFinalStage();
	void ApplyStageAdvanced();
	void SHSearchFocusAnimInstanceEvent__DelegateSignature(class USHSearchFocusAnimInstance* AnimInst);

	bool CanReceiveInput() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSearchFocusAnimInstance">();
	}
	static class USHSearchFocusAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSearchFocusAnimInstance>();
	}
};
static_assert(alignof(USHSearchFocusAnimInstance) == 0x000010, "Wrong alignment on USHSearchFocusAnimInstance");
static_assert(sizeof(USHSearchFocusAnimInstance) == 0x000370, "Wrong size on USHSearchFocusAnimInstance");
static_assert(offsetof(USHSearchFocusAnimInstance, bPlayInteraction) == 0x000348, "Member 'USHSearchFocusAnimInstance::bPlayInteraction' has a wrong offset!");
static_assert(offsetof(USHSearchFocusAnimInstance, bAdvanceStage) == 0x000349, "Member 'USHSearchFocusAnimInstance::bAdvanceStage' has a wrong offset!");

// Class SHProto.SHAIUnderObstacleInterface
// 0x0000 (0x0028 - 0x0028)
class ISHAIUnderObstacleInterface final : public IInterface
{
public:
	TArray<class UPrimitiveComponent*> GetObstaclePrimitivesToIgnore() const;
	class UPrimitiveComponent* GetObstaclePrimitiveToOverlap() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAIUnderObstacleInterface">();
	}
	static class ISHAIUnderObstacleInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHAIUnderObstacleInterface>();
	}
};
static_assert(alignof(ISHAIUnderObstacleInterface) == 0x000008, "Wrong alignment on ISHAIUnderObstacleInterface");
static_assert(sizeof(ISHAIUnderObstacleInterface) == 0x000028, "Wrong size on ISHAIUnderObstacleInterface");

// Class SHProto.SHBreakableActor
// 0x00C0 (0x0370 - 0x02B0)
class ASHBreakableActor : public AActor
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bManualDamageTaking;                               // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BreakablePlaneLocalDirection;                      // 0x02C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BreakablePlaneOffset;                              // 0x02D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BreakableBoundsExtend;                             // 0x02F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BreakableBoundsSafePadding;                        // 0x0308(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAllowedDistanceToHitPoint2D;                    // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinRequiredDirectionsDotProduct;                   // 0x0324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    SecondaryAttackDataRowHandle;                      // 0x0328(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	ESHSecondaryTargetType                        SecondaryTargetType;                               // 0x0338(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DamageTakenEvent;                                  // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsBroken;                                         // 0x0350(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x1F];                                     // 0x0351(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignRuntimeSecondaryAttackRowName(const class FName& InRowName);
	void ManualDamageTaken();
	void ProcessApplyState();
	void ProcessDamageTaken();
	void SHBreakableActorEvent__DelegateSignature(class ASHBreakableActor* Actor);

	bool IsBroken() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBreakableActor">();
	}
	static class ASHBreakableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHBreakableActor>();
	}
};
static_assert(alignof(ASHBreakableActor) == 0x000008, "Wrong alignment on ASHBreakableActor");
static_assert(sizeof(ASHBreakableActor) == 0x000370, "Wrong size on ASHBreakableActor");
static_assert(offsetof(ASHBreakableActor, bManualDamageTaking) == 0x0002B8, "Member 'ASHBreakableActor::bManualDamageTaking' has a wrong offset!");
static_assert(offsetof(ASHBreakableActor, BreakablePlaneLocalDirection) == 0x0002C0, "Member 'ASHBreakableActor::BreakablePlaneLocalDirection' has a wrong offset!");
static_assert(offsetof(ASHBreakableActor, BreakablePlaneOffset) == 0x0002D8, "Member 'ASHBreakableActor::BreakablePlaneOffset' has a wrong offset!");
static_assert(offsetof(ASHBreakableActor, BreakableBoundsExtend) == 0x0002F0, "Member 'ASHBreakableActor::BreakableBoundsExtend' has a wrong offset!");
static_assert(offsetof(ASHBreakableActor, BreakableBoundsSafePadding) == 0x000308, "Member 'ASHBreakableActor::BreakableBoundsSafePadding' has a wrong offset!");
static_assert(offsetof(ASHBreakableActor, MaxAllowedDistanceToHitPoint2D) == 0x000320, "Member 'ASHBreakableActor::MaxAllowedDistanceToHitPoint2D' has a wrong offset!");
static_assert(offsetof(ASHBreakableActor, MinRequiredDirectionsDotProduct) == 0x000324, "Member 'ASHBreakableActor::MinRequiredDirectionsDotProduct' has a wrong offset!");
static_assert(offsetof(ASHBreakableActor, SecondaryAttackDataRowHandle) == 0x000328, "Member 'ASHBreakableActor::SecondaryAttackDataRowHandle' has a wrong offset!");
static_assert(offsetof(ASHBreakableActor, SecondaryTargetType) == 0x000338, "Member 'ASHBreakableActor::SecondaryTargetType' has a wrong offset!");
static_assert(offsetof(ASHBreakableActor, DamageTakenEvent) == 0x000340, "Member 'ASHBreakableActor::DamageTakenEvent' has a wrong offset!");
static_assert(offsetof(ASHBreakableActor, bIsBroken) == 0x000350, "Member 'ASHBreakableActor::bIsBroken' has a wrong offset!");

// Class SHProto.SHAIUnderObstacle
// 0x0050 (0x00F0 - 0x00A0)
class USHAIUnderObstacle final : public UActorComponent
{
public:
	TArray<class UCapsuleComponent*>              _OwnerCapsules;                                    // 0x00A0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         _UnderObstacles;                                   // 0x00B0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         _ExitObstacles;                                    // 0x00C0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnterObstacle;                                   // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExitObstacle;                                    // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ConditionalExitUnderObstacle(class AActor* Obstacle);
	void EnterUnderObctacle(class AActor* Obstacle);
	void ExitAllObstacles();
	void OnActorEndOvelap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

	bool IsUnderAnyObstacle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAIUnderObstacle">();
	}
	static class USHAIUnderObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAIUnderObstacle>();
	}
};
static_assert(alignof(USHAIUnderObstacle) == 0x000008, "Wrong alignment on USHAIUnderObstacle");
static_assert(sizeof(USHAIUnderObstacle) == 0x0000F0, "Wrong size on USHAIUnderObstacle");
static_assert(offsetof(USHAIUnderObstacle, _OwnerCapsules) == 0x0000A0, "Member 'USHAIUnderObstacle::_OwnerCapsules' has a wrong offset!");
static_assert(offsetof(USHAIUnderObstacle, _UnderObstacles) == 0x0000B0, "Member 'USHAIUnderObstacle::_UnderObstacles' has a wrong offset!");
static_assert(offsetof(USHAIUnderObstacle, _ExitObstacles) == 0x0000C0, "Member 'USHAIUnderObstacle::_ExitObstacles' has a wrong offset!");
static_assert(offsetof(USHAIUnderObstacle, OnEnterObstacle) == 0x0000D0, "Member 'USHAIUnderObstacle::OnEnterObstacle' has a wrong offset!");
static_assert(offsetof(USHAIUnderObstacle, OnExitObstacle) == 0x0000E0, "Member 'USHAIUnderObstacle::OnExitObstacle' has a wrong offset!");

// Class SHProto.SHAIWeaponManagerComponent
// 0x0030 (0x00D0 - 0x00A0)
class USHAIWeaponManagerComponent final : public UActorComponent
{
public:
	bool                                          bAutoSpawn;                                        // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ASHAIWeapon>                WeaponClassToSpawn;                                // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnWeaponSpawned;                                   // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class ASHAIWeapon*                            SpawnedWeapon;                                     // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessSpawnerAfterSpawn(class AActor* Actor);
	void SHAIWeaponManagerEvent__DelegateSignature(class USHAIWeaponManagerComponent* Component);
	void SHAIWeaponManagerEventWithWeaponContext__DelegateSignature(class USHAIWeaponManagerComponent* Component, class ASHAIWeapon* WeaponContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAIWeaponManagerComponent">();
	}
	static class USHAIWeaponManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAIWeaponManagerComponent>();
	}
};
static_assert(alignof(USHAIWeaponManagerComponent) == 0x000008, "Wrong alignment on USHAIWeaponManagerComponent");
static_assert(sizeof(USHAIWeaponManagerComponent) == 0x0000D0, "Wrong size on USHAIWeaponManagerComponent");
static_assert(offsetof(USHAIWeaponManagerComponent, bAutoSpawn) == 0x0000A0, "Member 'USHAIWeaponManagerComponent::bAutoSpawn' has a wrong offset!");
static_assert(offsetof(USHAIWeaponManagerComponent, WeaponClassToSpawn) == 0x0000A8, "Member 'USHAIWeaponManagerComponent::WeaponClassToSpawn' has a wrong offset!");
static_assert(offsetof(USHAIWeaponManagerComponent, OnWeaponSpawned) == 0x0000B0, "Member 'USHAIWeaponManagerComponent::OnWeaponSpawned' has a wrong offset!");
static_assert(offsetof(USHAIWeaponManagerComponent, SpawnedWeapon) == 0x0000C0, "Member 'USHAIWeaponManagerComponent::SpawnedWeapon' has a wrong offset!");

// Class SHProto.SHAkPortalComponent
// 0x0000 (0x0390 - 0x0390)
class USHAkPortalComponent : public UBlooberAkPortalComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkPortalComponent">();
	}
	static class USHAkPortalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkPortalComponent>();
	}
};
static_assert(alignof(USHAkPortalComponent) == 0x000010, "Wrong alignment on USHAkPortalComponent");
static_assert(sizeof(USHAkPortalComponent) == 0x000390, "Wrong size on USHAkPortalComponent");

// Class SHProto.SHWeaponFXComponent
// 0x0000 (0x00A0 - 0x00A0)
class USHWeaponFXComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHWeaponFXComponent">();
	}
	static class USHWeaponFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHWeaponFXComponent>();
	}
};
static_assert(alignof(USHWeaponFXComponent) == 0x000008, "Wrong alignment on USHWeaponFXComponent");
static_assert(sizeof(USHWeaponFXComponent) == 0x0000A0, "Wrong size on USHWeaponFXComponent");

// Class SHProto.SHMeleeWeaponFXComponent
// 0x0000 (0x00A0 - 0x00A0)
class USHMeleeWeaponFXComponent final : public USHWeaponFXComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMeleeWeaponFXComponent">();
	}
	static class USHMeleeWeaponFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMeleeWeaponFXComponent>();
	}
};
static_assert(alignof(USHMeleeWeaponFXComponent) == 0x000008, "Wrong alignment on USHMeleeWeaponFXComponent");
static_assert(sizeof(USHMeleeWeaponFXComponent) == 0x0000A0, "Wrong size on USHMeleeWeaponFXComponent");

// Class SHProto.SHAkAcousticPortal
// 0x0000 (0x02F8 - 0x02F8)
class ASHAkAcousticPortal : public ABlooberAkAcousticPortal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkAcousticPortal">();
	}
	static class ASHAkAcousticPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHAkAcousticPortal>();
	}
};
static_assert(alignof(ASHAkAcousticPortal) == 0x000008, "Wrong alignment on ASHAkAcousticPortal");
static_assert(sizeof(ASHAkAcousticPortal) == 0x0002F8, "Wrong size on ASHAkAcousticPortal");

// Class SHProto.SHBlueprintEventsBaseComponent
// 0x0008 (0x00A8 - 0x00A0)
class USHBlueprintEventsBaseComponent : public UActorComponent
{
public:
	class ASHCharacterPlay*                       Character;                                         // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBlueprintEventsBaseComponent">();
	}
	static class USHBlueprintEventsBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBlueprintEventsBaseComponent>();
	}
};
static_assert(alignof(USHBlueprintEventsBaseComponent) == 0x000008, "Wrong alignment on USHBlueprintEventsBaseComponent");
static_assert(sizeof(USHBlueprintEventsBaseComponent) == 0x0000A8, "Wrong size on USHBlueprintEventsBaseComponent");
static_assert(offsetof(USHBlueprintEventsBaseComponent, Character) == 0x0000A0, "Member 'USHBlueprintEventsBaseComponent::Character' has a wrong offset!");

// Class SHProto.SHAkAcousticPortalBreakableGlass
// 0x0058 (0x0350 - 0x02F8)
class ASHAkAcousticPortalBreakableGlass final : public ASHAkAcousticPortal
{
public:
	class USHActorLevelObserverComponent*         ActorLevelObserverComponent;                       // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class AActor>                  BreakableGlassActor;                               // 0x0300(0x0030)(Edit, BlueprintVisible, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMultipleGlassSupport;                          // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class AActor>>          MultipleBreakableGlassActors;                      // 0x0338(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bFullOpenOnBreak;                                  // 0x0348(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessBreakableGlassOnBreakEvent(class USHBreakableGlassComponent* BreakableGlassComponent);
	void ProcessOnObservedActorAvailable(class AActor* AvailableActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkAcousticPortalBreakableGlass">();
	}
	static class ASHAkAcousticPortalBreakableGlass* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHAkAcousticPortalBreakableGlass>();
	}
};
static_assert(alignof(ASHAkAcousticPortalBreakableGlass) == 0x000008, "Wrong alignment on ASHAkAcousticPortalBreakableGlass");
static_assert(sizeof(ASHAkAcousticPortalBreakableGlass) == 0x000350, "Wrong size on ASHAkAcousticPortalBreakableGlass");
static_assert(offsetof(ASHAkAcousticPortalBreakableGlass, ActorLevelObserverComponent) == 0x0002F8, "Member 'ASHAkAcousticPortalBreakableGlass::ActorLevelObserverComponent' has a wrong offset!");
static_assert(offsetof(ASHAkAcousticPortalBreakableGlass, BreakableGlassActor) == 0x000300, "Member 'ASHAkAcousticPortalBreakableGlass::BreakableGlassActor' has a wrong offset!");
static_assert(offsetof(ASHAkAcousticPortalBreakableGlass, bUseMultipleGlassSupport) == 0x000330, "Member 'ASHAkAcousticPortalBreakableGlass::bUseMultipleGlassSupport' has a wrong offset!");
static_assert(offsetof(ASHAkAcousticPortalBreakableGlass, MultipleBreakableGlassActors) == 0x000338, "Member 'ASHAkAcousticPortalBreakableGlass::MultipleBreakableGlassActors' has a wrong offset!");
static_assert(offsetof(ASHAkAcousticPortalBreakableGlass, bFullOpenOnBreak) == 0x000348, "Member 'ASHAkAcousticPortalBreakableGlass::bFullOpenOnBreak' has a wrong offset!");

// Class SHProto.SHAkPortalDoorComponent
// 0x0020 (0x03B0 - 0x0390)
class USHAkPortalDoorComponent final : public USHAkPortalComponent
{
public:
	uint8                                         Pad_390[0x20];                                     // 0x0390(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessDoorAlphaChangedEvent(class USHDoorMovementBaseComponent* DummyComponent);
	void SetInitialState(EAkAcousticPortalState InState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkPortalDoorComponent">();
	}
	static class USHAkPortalDoorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkPortalDoorComponent>();
	}
};
static_assert(alignof(USHAkPortalDoorComponent) == 0x000010, "Wrong alignment on USHAkPortalDoorComponent");
static_assert(sizeof(USHAkPortalDoorComponent) == 0x0003B0, "Wrong size on USHAkPortalDoorComponent");

// Class SHProto.SHAkAmbientSound
// 0x0010 (0x0308 - 0x02F8)
class ASHAkAmbientSound final : public ABlooberAkAmbientSound
{
public:
	bool                                          bEnableSoundCullDistance;                          // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, SimpleDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F9[0x3];                                      // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SoundCullDistance;                                 // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, SimpleDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkAmbientSound">();
	}
	static class ASHAkAmbientSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHAkAmbientSound>();
	}
};
static_assert(alignof(ASHAkAmbientSound) == 0x000008, "Wrong alignment on ASHAkAmbientSound");
static_assert(sizeof(ASHAkAmbientSound) == 0x000308, "Wrong size on ASHAkAmbientSound");
static_assert(offsetof(ASHAkAmbientSound, bEnableSoundCullDistance) == 0x0002F8, "Member 'ASHAkAmbientSound::bEnableSoundCullDistance' has a wrong offset!");
static_assert(offsetof(ASHAkAmbientSound, SoundCullDistance) == 0x0002FC, "Member 'ASHAkAmbientSound::SoundCullDistance' has a wrong offset!");

// Class SHProto.SHFloatEndingFactor
// 0x0058 (0x0088 - 0x0030)
class USHFloatEndingFactor : public USHEndingFactor
{
public:
	TMap<struct FSHFloatCondition, struct FSHEndingScoreChanger> ConditionToScoreChangeMap;                         // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0080(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFloatEndingFactor">();
	}
	static class USHFloatEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFloatEndingFactor>();
	}
};
static_assert(alignof(USHFloatEndingFactor) == 0x000008, "Wrong alignment on USHFloatEndingFactor");
static_assert(sizeof(USHFloatEndingFactor) == 0x000088, "Wrong size on USHFloatEndingFactor");
static_assert(offsetof(USHFloatEndingFactor, ConditionToScoreChangeMap) == 0x000030, "Member 'USHFloatEndingFactor::ConditionToScoreChangeMap' has a wrong offset!");
static_assert(offsetof(USHFloatEndingFactor, Value) == 0x000080, "Member 'USHFloatEndingFactor::Value' has a wrong offset!");

// Class SHProto.SHPlaythroughBadHealthEndingFactor
// 0x0000 (0x0088 - 0x0088)
class USHPlaythroughBadHealthEndingFactor final : public USHFloatEndingFactor
{
public:
	void SHDebug_Character_Endings_PlaythroughBadHealthEndingFactor_SetDebugValue(float InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPlaythroughBadHealthEndingFactor">();
	}
	static class USHPlaythroughBadHealthEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPlaythroughBadHealthEndingFactor>();
	}
};
static_assert(alignof(USHPlaythroughBadHealthEndingFactor) == 0x000008, "Wrong alignment on USHPlaythroughBadHealthEndingFactor");
static_assert(sizeof(USHPlaythroughBadHealthEndingFactor) == 0x000088, "Wrong size on USHPlaythroughBadHealthEndingFactor");

// Class SHProto.SHAkComponent
// 0x0000 (0x04B0 - 0x04B0)
#pragma pack(push, 0x1)
class alignas(0x10) USHAkComponent : public UBlooberAkComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkComponent">();
	}
	static class USHAkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(USHAkComponent) == 0x000010, "Wrong alignment on USHAkComponent");
static_assert(sizeof(USHAkComponent) == 0x0004B0, "Wrong size on USHAkComponent");

// Class SHProto.SHBreakableWallActor
// 0x0058 (0x0308 - 0x02B0)
class ASHBreakableWallActor final : public AActor
{
public:
	class USHBreakableMeshComponent*              BreakableMeshMainComponent;                        // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHSecondaryTargetComponent*            SecondaryTargetFrontComponent;                     // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHSecondaryTargetComponent*            SecondaryTargetBackComponent;                      // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkDynamicTickComponent*              AkSoundComponent;                                  // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          PortalBoundsBoxComponent;                          // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkPortalOpenableComponent*           AkPortalOpenableComponent;                         // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        VisualMeshesPivotComponent;                        // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    LastHitSecondaryAttackDataRowHandle;               // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          BreakStepAudioEvent;                               // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          LastBreakAudioEvent;                               // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ProcessBreakableMeshMainComponentBreakEvent(class USHBreakableMeshComponent* InComponentPtr);

	bool IsBroken() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBreakableWallActor">();
	}
	static class ASHBreakableWallActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHBreakableWallActor>();
	}
};
static_assert(alignof(ASHBreakableWallActor) == 0x000008, "Wrong alignment on ASHBreakableWallActor");
static_assert(sizeof(ASHBreakableWallActor) == 0x000308, "Wrong size on ASHBreakableWallActor");
static_assert(offsetof(ASHBreakableWallActor, BreakableMeshMainComponent) == 0x0002B0, "Member 'ASHBreakableWallActor::BreakableMeshMainComponent' has a wrong offset!");
static_assert(offsetof(ASHBreakableWallActor, SecondaryTargetFrontComponent) == 0x0002B8, "Member 'ASHBreakableWallActor::SecondaryTargetFrontComponent' has a wrong offset!");
static_assert(offsetof(ASHBreakableWallActor, SecondaryTargetBackComponent) == 0x0002C0, "Member 'ASHBreakableWallActor::SecondaryTargetBackComponent' has a wrong offset!");
static_assert(offsetof(ASHBreakableWallActor, AkSoundComponent) == 0x0002C8, "Member 'ASHBreakableWallActor::AkSoundComponent' has a wrong offset!");
static_assert(offsetof(ASHBreakableWallActor, PortalBoundsBoxComponent) == 0x0002D0, "Member 'ASHBreakableWallActor::PortalBoundsBoxComponent' has a wrong offset!");
static_assert(offsetof(ASHBreakableWallActor, AkPortalOpenableComponent) == 0x0002D8, "Member 'ASHBreakableWallActor::AkPortalOpenableComponent' has a wrong offset!");
static_assert(offsetof(ASHBreakableWallActor, VisualMeshesPivotComponent) == 0x0002E0, "Member 'ASHBreakableWallActor::VisualMeshesPivotComponent' has a wrong offset!");
static_assert(offsetof(ASHBreakableWallActor, LastHitSecondaryAttackDataRowHandle) == 0x0002E8, "Member 'ASHBreakableWallActor::LastHitSecondaryAttackDataRowHandle' has a wrong offset!");
static_assert(offsetof(ASHBreakableWallActor, BreakStepAudioEvent) == 0x0002F8, "Member 'ASHBreakableWallActor::BreakStepAudioEvent' has a wrong offset!");
static_assert(offsetof(ASHBreakableWallActor, LastBreakAudioEvent) == 0x000300, "Member 'ASHBreakableWallActor::LastBreakAudioEvent' has a wrong offset!");

// Class SHProto.SHAkAmbientSoundComponent
// 0x0000 (0x04B0 - 0x04B0)
class USHAkAmbientSoundComponent final : public USHAkComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkAmbientSoundComponent">();
	}
	static class USHAkAmbientSoundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkAmbientSoundComponent>();
	}
};
static_assert(alignof(USHAkAmbientSoundComponent) == 0x000010, "Wrong alignment on USHAkAmbientSoundComponent");
static_assert(sizeof(USHAkAmbientSoundComponent) == 0x0004B0, "Wrong size on USHAkAmbientSoundComponent");

// Class SHProto.SHAkAmbientSoundManagerComponent
// 0x0018 (0x00B8 - 0x00A0)
class USHAkAmbientSoundManagerComponent final : public UActorComponent
{
public:
	TArray<class ASHAkAmbientSound*>              RegisteredAkAmbientSounds;                         // 0x00A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Ak_AmbientSoundManager_DrawDebug();
	void SHDebug_Ak_AmbientSoundManager_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkAmbientSoundManagerComponent">();
	}
	static class USHAkAmbientSoundManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkAmbientSoundManagerComponent>();
	}
};
static_assert(alignof(USHAkAmbientSoundManagerComponent) == 0x000008, "Wrong alignment on USHAkAmbientSoundManagerComponent");
static_assert(sizeof(USHAkAmbientSoundManagerComponent) == 0x0000B8, "Wrong size on USHAkAmbientSoundManagerComponent");
static_assert(offsetof(USHAkAmbientSoundManagerComponent, RegisteredAkAmbientSounds) == 0x0000A0, "Member 'USHAkAmbientSoundManagerComponent::RegisteredAkAmbientSounds' has a wrong offset!");

// Class SHProto.SHCharacter
// 0x0010 (0x0650 - 0x0640)
class ASHCharacter : public ACharacter
{
public:
	uint8                                         Pad_638[0x18];                                     // 0x0638(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacter">();
	}
	static class ASHCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHCharacter>();
	}
};
static_assert(alignof(ASHCharacter) == 0x000010, "Wrong alignment on ASHCharacter");
static_assert(sizeof(ASHCharacter) == 0x000650, "Wrong size on ASHCharacter");

// Class SHProto.SHCharacterPlay
// 0x0220 (0x0870 - 0x0650)
class ASHCharacterPlay final : public ASHCharacter
{
public:
	class USHCharacterPlayDLCSkinStaticMeshComponent* DLCSkinStaticMesh;                                 // 0x0650(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayViewComponent*          View;                                              // 0x0658(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlaySpringArmComponent*     SpringArm;                                         // 0x0660(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayCameraComponent*        Camera;                                            // 0x0668(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayBreathNoiseComponent*   BreathNoise;                                       // 0x0670(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkCharacterAudioComponent*           AudioComponent;                                    // 0x0678(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkMusicComponent*                    MusicComponent;                                    // 0x0680(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayMovementComponent*      Movement;                                          // 0x0688(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayInputComponent*         Input;                                             // 0x0690(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayRaycastDetectorComponent* RaycastDetector;                                   // 0x0698(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayGenericInteractionSlotComponent* GenericSlot;                                       // 0x06A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayBrainComponent*         Brain;                                             // 0x06A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayLightsComponent*        Lights;                                            // 0x06B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayHealthComponent*        Health;                                            // 0x06B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayItemsComponent*         Items;                                             // 0x06C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayCombatComponent*        Combat;                                            // 0x06C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayMapComponent*           MapData;                                           // 0x06D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayAnimComponent*          Animation;                                         // 0x06D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicalAnimationComponent*            PhysicalAnimation;                                 // 0x06E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayLookAtLogicComponent*   LookAtLogic;                                       // 0x06E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayUIComponent*            UIComponent;                                       // 0x06F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayImpactDetectionComponent* ImpactDetection;                                   // 0x06F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayMPCGameplayComponent*   GameplayMPC;                                       // 0x0700(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayTraversalComponent*     Traversal;                                         // 0x0708(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayTutorialsComponent*     TutorialsComponent;                                // 0x0710(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayAdaptiveTriggersManager* AdaptiveTriggersManager;                           // 0x0718(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayCameraOverlapHandleComponent* CameraOverlapHandler;                              // 0x0720(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayEndingsComponent*       EndingsComponent;                                  // 0x0728(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayFXComponent*            FXComponent;                                       // 0x0730(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayStairsDetectionComponent* StairsDetectionComponent;                          // 0x0738(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayStatisticsComponent*    StatisticsComponent;                               // 0x0740(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DefaultMeshRelPosition;                            // 0x0748(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               DefaultMeshRelRotation;                            // 0x0760(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<TScriptInterface<class ISHInteractionSlot>> InteractionSlots;                                  // 0x0778(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_788[0xE8];                                     // 0x0788(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ESHGameplayInputModeEnum GetGameplayInputMode();
	void SetCharacterPlayVisibility(const bool Hide, const bool SkipFlashlight);
	void SetGameplayInputMode(const ESHGameplayInputModeEnum NewGameplayInputMode);
	void SHDebug_Character_Difficulties_SetCombatDifficulty(int32 InValue);
	void SHDebug_Character_Difficulties_SetPuzzlesDifficulty(int32 InValue);
	void SHDebug_Character_GameplayInputMode_ValuesDebug();
	void SHDebug_Character_ToggleVisibility();
	void SHDebug_Custom(const class FString& DebugCommand, int32 Value);
	void SHDebug_Temporal_SetHasEverFinishedGame(bool bInValue);

	TArray<class AActor*> GetAllAttachedActors() const;
	bool HasInputComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlay">();
	}
	static class ASHCharacterPlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHCharacterPlay>();
	}
};
static_assert(alignof(ASHCharacterPlay) == 0x000010, "Wrong alignment on ASHCharacterPlay");
static_assert(sizeof(ASHCharacterPlay) == 0x000870, "Wrong size on ASHCharacterPlay");
static_assert(offsetof(ASHCharacterPlay, DLCSkinStaticMesh) == 0x000650, "Member 'ASHCharacterPlay::DLCSkinStaticMesh' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, View) == 0x000658, "Member 'ASHCharacterPlay::View' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, SpringArm) == 0x000660, "Member 'ASHCharacterPlay::SpringArm' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, Camera) == 0x000668, "Member 'ASHCharacterPlay::Camera' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, BreathNoise) == 0x000670, "Member 'ASHCharacterPlay::BreathNoise' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, AudioComponent) == 0x000678, "Member 'ASHCharacterPlay::AudioComponent' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, MusicComponent) == 0x000680, "Member 'ASHCharacterPlay::MusicComponent' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, Movement) == 0x000688, "Member 'ASHCharacterPlay::Movement' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, Input) == 0x000690, "Member 'ASHCharacterPlay::Input' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, RaycastDetector) == 0x000698, "Member 'ASHCharacterPlay::RaycastDetector' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, GenericSlot) == 0x0006A0, "Member 'ASHCharacterPlay::GenericSlot' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, Brain) == 0x0006A8, "Member 'ASHCharacterPlay::Brain' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, Lights) == 0x0006B0, "Member 'ASHCharacterPlay::Lights' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, Health) == 0x0006B8, "Member 'ASHCharacterPlay::Health' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, Items) == 0x0006C0, "Member 'ASHCharacterPlay::Items' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, Combat) == 0x0006C8, "Member 'ASHCharacterPlay::Combat' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, MapData) == 0x0006D0, "Member 'ASHCharacterPlay::MapData' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, Animation) == 0x0006D8, "Member 'ASHCharacterPlay::Animation' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, PhysicalAnimation) == 0x0006E0, "Member 'ASHCharacterPlay::PhysicalAnimation' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, LookAtLogic) == 0x0006E8, "Member 'ASHCharacterPlay::LookAtLogic' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, UIComponent) == 0x0006F0, "Member 'ASHCharacterPlay::UIComponent' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, ImpactDetection) == 0x0006F8, "Member 'ASHCharacterPlay::ImpactDetection' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, GameplayMPC) == 0x000700, "Member 'ASHCharacterPlay::GameplayMPC' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, Traversal) == 0x000708, "Member 'ASHCharacterPlay::Traversal' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, TutorialsComponent) == 0x000710, "Member 'ASHCharacterPlay::TutorialsComponent' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, AdaptiveTriggersManager) == 0x000718, "Member 'ASHCharacterPlay::AdaptiveTriggersManager' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, CameraOverlapHandler) == 0x000720, "Member 'ASHCharacterPlay::CameraOverlapHandler' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, EndingsComponent) == 0x000728, "Member 'ASHCharacterPlay::EndingsComponent' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, FXComponent) == 0x000730, "Member 'ASHCharacterPlay::FXComponent' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, StairsDetectionComponent) == 0x000738, "Member 'ASHCharacterPlay::StairsDetectionComponent' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, StatisticsComponent) == 0x000740, "Member 'ASHCharacterPlay::StatisticsComponent' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, DefaultMeshRelPosition) == 0x000748, "Member 'ASHCharacterPlay::DefaultMeshRelPosition' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, DefaultMeshRelRotation) == 0x000760, "Member 'ASHCharacterPlay::DefaultMeshRelRotation' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlay, InteractionSlots) == 0x000778, "Member 'ASHCharacterPlay::InteractionSlots' has a wrong offset!");

// Class SHProto.SHAkCharacterAudioComponent
// 0x00D0 (0x0580 - 0x04B0)
class USHAkCharacterAudioComponent final : public USHAkComponent
{
public:
	class UAkAudioEvent*                          ReverbTestSoundEvent;                              // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketAttachName;                                  // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAudioStatesComponentSettings*        AudioStatesSettings;                               // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHEnvironmentComponentSettings*        EnvironmentSettings;                               // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAudioSpaceSettings*                  AudioSpaceSettings;                                // 0x04C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAudioBreathingSettings*              AudioBreathingSettings;                            // 0x04D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAudioHealthSettings*                 AudioHealthSettings;                               // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAudioInteractionSettings*            AudioInteractionSettings;                          // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x04E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class USHCharacterAudioSubcomponentBase*> OwnedSubcomponents;                                // 0x04F0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_540[0x40];                                     // 0x0540(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Character_Audio_AVDebug();
	void SHDebug_Character_Audio_PortalsDebug();
	void SHDebug_Character_Audio_ReverbTestSound();
	void SHDebug_Character_Audio_SetBossState(bool bEnable);
	void SHDebug_Character_Audio_SetCutsceneState(bool bEnable);
	void SHDebug_Character_Audio_SetDangerState(int32 InDangerMode);
	void SHDebug_Character_Audio_StatesDebug();
	void SHDebug_Character_Audio_ValuesDebug();

	class USHCharacterAudioSubcomponentBase* FindSubcomponentByClass(const TSubclassOf<class USHCharacterAudioSubcomponentBase> SubcomponentClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkCharacterAudioComponent">();
	}
	static class USHAkCharacterAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkCharacterAudioComponent>();
	}
};
static_assert(alignof(USHAkCharacterAudioComponent) == 0x000010, "Wrong alignment on USHAkCharacterAudioComponent");
static_assert(sizeof(USHAkCharacterAudioComponent) == 0x000580, "Wrong size on USHAkCharacterAudioComponent");
static_assert(offsetof(USHAkCharacterAudioComponent, ReverbTestSoundEvent) == 0x0004A8, "Member 'USHAkCharacterAudioComponent::ReverbTestSoundEvent' has a wrong offset!");
static_assert(offsetof(USHAkCharacterAudioComponent, SocketAttachName) == 0x0004B0, "Member 'USHAkCharacterAudioComponent::SocketAttachName' has a wrong offset!");
static_assert(offsetof(USHAkCharacterAudioComponent, AudioStatesSettings) == 0x0004B8, "Member 'USHAkCharacterAudioComponent::AudioStatesSettings' has a wrong offset!");
static_assert(offsetof(USHAkCharacterAudioComponent, EnvironmentSettings) == 0x0004C0, "Member 'USHAkCharacterAudioComponent::EnvironmentSettings' has a wrong offset!");
static_assert(offsetof(USHAkCharacterAudioComponent, AudioSpaceSettings) == 0x0004C8, "Member 'USHAkCharacterAudioComponent::AudioSpaceSettings' has a wrong offset!");
static_assert(offsetof(USHAkCharacterAudioComponent, AudioBreathingSettings) == 0x0004D0, "Member 'USHAkCharacterAudioComponent::AudioBreathingSettings' has a wrong offset!");
static_assert(offsetof(USHAkCharacterAudioComponent, AudioHealthSettings) == 0x0004D8, "Member 'USHAkCharacterAudioComponent::AudioHealthSettings' has a wrong offset!");
static_assert(offsetof(USHAkCharacterAudioComponent, AudioInteractionSettings) == 0x0004E0, "Member 'USHAkCharacterAudioComponent::AudioInteractionSettings' has a wrong offset!");
static_assert(offsetof(USHAkCharacterAudioComponent, OwnerCharacter) == 0x0004E8, "Member 'USHAkCharacterAudioComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHAkCharacterAudioComponent, OwnedSubcomponents) == 0x0004F0, "Member 'USHAkCharacterAudioComponent::OwnedSubcomponents' has a wrong offset!");

// Class SHProto.SHAkComponentsPoolManagerComponent
// 0x0028 (0x00C8 - 0x00A0)
class USHAkComponentsPoolManagerComponent final : public UActorComponent
{
public:
	TArray<class UAkComponent*>                   AvailableComponentsPool;                           // 0x00A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UAkComponent*>                   TakenComponentsPool;                               // 0x00B0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void PostPooledAkEvent(class UObject* WorldContextObject, class USceneComponent* InComp, class FName InSocket, class UAkAudioEvent* AudioEvent);

	void SHDebug_Ak_ComponentsPoolManager_DrawDebug();
	void SHDebug_Ak_ComponentsPoolManager_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkComponentsPoolManagerComponent">();
	}
	static class USHAkComponentsPoolManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkComponentsPoolManagerComponent>();
	}
};
static_assert(alignof(USHAkComponentsPoolManagerComponent) == 0x000008, "Wrong alignment on USHAkComponentsPoolManagerComponent");
static_assert(sizeof(USHAkComponentsPoolManagerComponent) == 0x0000C8, "Wrong size on USHAkComponentsPoolManagerComponent");
static_assert(offsetof(USHAkComponentsPoolManagerComponent, AvailableComponentsPool) == 0x0000A0, "Member 'USHAkComponentsPoolManagerComponent::AvailableComponentsPool' has a wrong offset!");
static_assert(offsetof(USHAkComponentsPoolManagerComponent, TakenComponentsPool) == 0x0000B0, "Member 'USHAkComponentsPoolManagerComponent::TakenComponentsPool' has a wrong offset!");

// Class SHProto.SHBreakableGlassSettings
// 0x0090 (0x00C8 - 0x0038)
class USHBreakableGlassSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class USHBreakableGlassFXData> MainGlassFX;                                       // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSHBreakableGlassNoiseConfig           MainGlassNoiseConfig;                              // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USHBreakableGlassFXData> ShardGlassFX;                                      // 0x0080(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSHBreakableGlassNoiseConfig           ShardGlassNoiseConfig;                             // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBreakableGlassSettings">();
	}
	static class USHBreakableGlassSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBreakableGlassSettings>();
	}
};
static_assert(alignof(USHBreakableGlassSettings) == 0x000008, "Wrong alignment on USHBreakableGlassSettings");
static_assert(sizeof(USHBreakableGlassSettings) == 0x0000C8, "Wrong size on USHBreakableGlassSettings");
static_assert(offsetof(USHBreakableGlassSettings, MainGlassFX) == 0x000038, "Member 'USHBreakableGlassSettings::MainGlassFX' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassSettings, MainGlassNoiseConfig) == 0x000068, "Member 'USHBreakableGlassSettings::MainGlassNoiseConfig' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassSettings, ShardGlassFX) == 0x000080, "Member 'USHBreakableGlassSettings::ShardGlassFX' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassSettings, ShardGlassNoiseConfig) == 0x0000B0, "Member 'USHBreakableGlassSettings::ShardGlassNoiseConfig' has a wrong offset!");

// Class SHProto.SHAkDoorBaseComponent
// 0x0020 (0x04D0 - 0x04B0)
class USHAkDoorBaseComponent : public USHAkComponent
{
public:
	class UAkSwitchValue*                         DoorTypeSwitch;                                    // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         DoorLockState_Locked;                              // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         DoorLockState_Unlocked;                            // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C0[0x8];                                      // 0x04C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USHDoorMovementBaseComponent*           ManagedDoorMovement;                               // 0x04C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ProcessOnAutoLockedDoorCheckAnimPlayed(class USHDoorAnimationsComponent* DoorAnimComponent);
	void ProcessOnDoorLockStateChanged(class USHDoorLockBaseComponent* LockComponent);
	void ProcessOnLockAnimPlayed(class USHDoorAnimationsComponent* DoorAnimComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkDoorBaseComponent">();
	}
	static class USHAkDoorBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkDoorBaseComponent>();
	}
};
static_assert(alignof(USHAkDoorBaseComponent) == 0x000010, "Wrong alignment on USHAkDoorBaseComponent");
static_assert(sizeof(USHAkDoorBaseComponent) == 0x0004D0, "Wrong size on USHAkDoorBaseComponent");
static_assert(offsetof(USHAkDoorBaseComponent, DoorTypeSwitch) == 0x0004A8, "Member 'USHAkDoorBaseComponent::DoorTypeSwitch' has a wrong offset!");
static_assert(offsetof(USHAkDoorBaseComponent, DoorLockState_Locked) == 0x0004B0, "Member 'USHAkDoorBaseComponent::DoorLockState_Locked' has a wrong offset!");
static_assert(offsetof(USHAkDoorBaseComponent, DoorLockState_Unlocked) == 0x0004B8, "Member 'USHAkDoorBaseComponent::DoorLockState_Unlocked' has a wrong offset!");
static_assert(offsetof(USHAkDoorBaseComponent, ManagedDoorMovement) == 0x0004C8, "Member 'USHAkDoorBaseComponent::ManagedDoorMovement' has a wrong offset!");

// Class SHProto.SHPOVDetectorComponent
// 0x0050 (0x00F0 - 0x00A0)
class USHPOVDetectorComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnPointsAlignedBP;                                 // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          DrawLineDebug;                                     // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DrawProximityDebug;                                // 0x00B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 AlignColorBad;                                     // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 AlignColorGood;                                    // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngleThreshold;                                    // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProximityThreshold;                                // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USceneComponent*>                LinePoints;                                        // 0x00C8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSHPOVDetectorProximityPoints>  ProximityPoints;                                   // 0x00D8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PointsAligned__DelegateSignature(bool Aligned);
	void SetLinePoints(const class USceneComponent* Point0, const class USceneComponent* Point1, const class USceneComponent* Point2);
	void SetManyProximityPoints(const TArray<class USceneComponent*>& NewPoints);
	void SetProximityPoints(const class USceneComponent* Point0, const class USceneComponent* Point1);

	bool ArePointsAligned() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPOVDetectorComponent">();
	}
	static class USHPOVDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPOVDetectorComponent>();
	}
};
static_assert(alignof(USHPOVDetectorComponent) == 0x000008, "Wrong alignment on USHPOVDetectorComponent");
static_assert(sizeof(USHPOVDetectorComponent) == 0x0000F0, "Wrong size on USHPOVDetectorComponent");
static_assert(offsetof(USHPOVDetectorComponent, OnPointsAlignedBP) == 0x0000A0, "Member 'USHPOVDetectorComponent::OnPointsAlignedBP' has a wrong offset!");
static_assert(offsetof(USHPOVDetectorComponent, DrawLineDebug) == 0x0000B0, "Member 'USHPOVDetectorComponent::DrawLineDebug' has a wrong offset!");
static_assert(offsetof(USHPOVDetectorComponent, DrawProximityDebug) == 0x0000B1, "Member 'USHPOVDetectorComponent::DrawProximityDebug' has a wrong offset!");
static_assert(offsetof(USHPOVDetectorComponent, AlignColorBad) == 0x0000B4, "Member 'USHPOVDetectorComponent::AlignColorBad' has a wrong offset!");
static_assert(offsetof(USHPOVDetectorComponent, AlignColorGood) == 0x0000B8, "Member 'USHPOVDetectorComponent::AlignColorGood' has a wrong offset!");
static_assert(offsetof(USHPOVDetectorComponent, AngleThreshold) == 0x0000BC, "Member 'USHPOVDetectorComponent::AngleThreshold' has a wrong offset!");
static_assert(offsetof(USHPOVDetectorComponent, ProximityThreshold) == 0x0000C0, "Member 'USHPOVDetectorComponent::ProximityThreshold' has a wrong offset!");
static_assert(offsetof(USHPOVDetectorComponent, LinePoints) == 0x0000C8, "Member 'USHPOVDetectorComponent::LinePoints' has a wrong offset!");
static_assert(offsetof(USHPOVDetectorComponent, ProximityPoints) == 0x0000D8, "Member 'USHPOVDetectorComponent::ProximityPoints' has a wrong offset!");

// Class SHProto.SHAkDoorComponent
// 0x0050 (0x0520 - 0x04D0)
class USHAkDoorComponent final : public USHAkDoorBaseComponent
{
public:
	class UAkRtpc*                                VelocityRTPCParam;                                 // 0x04D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         DoorMovementStateSwitch_Closed;                    // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         DoorMovementStateSwitch_FakeClose;                 // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         DoorMovementStateSwitch_Interupted;                // 0x04E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         DoorMovementStateSwitch_MiddleOpened;              // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         DoorMovementStateSwitch_Opened;                    // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugValue;                                       // 0x0500(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_501[0x1F];                                     // 0x0501(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessDoorFakeMovementComplete(class USHDoorMovementComponent* MovementComponent);
	void ProcessDoorFakeMovementInterupted(class USHDoorMovementComponent* MovementComponent);
	void ProcessDoorFakeMovementStart(class USHDoorMovementComponent* MovementComponent);
	void ProcessDoorPhysicMovementComplete(class USHDoorMovementComponent* MovementComponent);
	void ProcessDoorPhysicMovementInterupted(class USHDoorMovementComponent* MovementComponent);
	void ProcessDoorPhysicMovementStart(class USHDoorMovementComponent* MovementComponent);
	void ProcessDoorSmashOpened(class USHDoorMovementComponent* MovementComponent);
	void ProcessOnDoorAngleChanged(class USHDoorMovementComponent* MovementComponent);
	void RequestBlockAudio(const bool bLock, const class UObject* Object);

	bool IsAudioBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkDoorComponent">();
	}
	static class USHAkDoorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkDoorComponent>();
	}
};
static_assert(alignof(USHAkDoorComponent) == 0x000010, "Wrong alignment on USHAkDoorComponent");
static_assert(sizeof(USHAkDoorComponent) == 0x000520, "Wrong size on USHAkDoorComponent");
static_assert(offsetof(USHAkDoorComponent, VelocityRTPCParam) == 0x0004D0, "Member 'USHAkDoorComponent::VelocityRTPCParam' has a wrong offset!");
static_assert(offsetof(USHAkDoorComponent, DoorMovementStateSwitch_Closed) == 0x0004D8, "Member 'USHAkDoorComponent::DoorMovementStateSwitch_Closed' has a wrong offset!");
static_assert(offsetof(USHAkDoorComponent, DoorMovementStateSwitch_FakeClose) == 0x0004E0, "Member 'USHAkDoorComponent::DoorMovementStateSwitch_FakeClose' has a wrong offset!");
static_assert(offsetof(USHAkDoorComponent, DoorMovementStateSwitch_Interupted) == 0x0004E8, "Member 'USHAkDoorComponent::DoorMovementStateSwitch_Interupted' has a wrong offset!");
static_assert(offsetof(USHAkDoorComponent, DoorMovementStateSwitch_MiddleOpened) == 0x0004F0, "Member 'USHAkDoorComponent::DoorMovementStateSwitch_MiddleOpened' has a wrong offset!");
static_assert(offsetof(USHAkDoorComponent, DoorMovementStateSwitch_Opened) == 0x0004F8, "Member 'USHAkDoorComponent::DoorMovementStateSwitch_Opened' has a wrong offset!");
static_assert(offsetof(USHAkDoorComponent, bDebugValue) == 0x000500, "Member 'USHAkDoorComponent::bDebugValue' has a wrong offset!");

// Class SHProto.SHCameraAnimationSequence
// 0x0000 (0x0220 - 0x0220)
class USHCameraAnimationSequence final : public ULevelSequence
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCameraAnimationSequence">();
	}
	static class USHCameraAnimationSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCameraAnimationSequence>();
	}
};
static_assert(alignof(USHCameraAnimationSequence) == 0x000008, "Wrong alignment on USHCameraAnimationSequence");
static_assert(sizeof(USHCameraAnimationSequence) == 0x000220, "Wrong size on USHCameraAnimationSequence");

// Class SHProto.SHAkDynamicTickComponent
// 0x0000 (0x04B0 - 0x04B0)
#pragma pack(push, 0x1)
class alignas(0x10) USHAkDynamicTickComponent : public USHAkComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkDynamicTickComponent">();
	}
	static class USHAkDynamicTickComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkDynamicTickComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(USHAkDynamicTickComponent) == 0x000010, "Wrong alignment on USHAkDynamicTickComponent");
static_assert(sizeof(USHAkDynamicTickComponent) == 0x0004B0, "Wrong size on USHAkDynamicTickComponent");

// Class SHProto.SHElevatorEngine
// 0x0160 (0x0410 - 0x02B0)
class ASHElevatorEngine : public AActor
{
public:
	class USceneComponent*                        MovingComponent;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteriorAreaComponent;                             // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          SafeAreaComponent;                                 // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkComponent*                         MainAkComponent;                                   // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkElevatorEngineComponent*           SHAkElevatorEngine;                                // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ElevatorSpeed;                                     // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BeginPlayFloor;                                    // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, struct FSHElevatorFloorConfig>    FloorsConfigs;                                     // 0x02E0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bKeepDoorStayOpened;                               // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResetOrdersOnDoorBlock;                           // 0x0331(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_332[0x2];                                      // 0x0332(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoorStayOpenedTime;                                // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DoorsOpenCloseTime;                                // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnOrderCompleted;                                  // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnOrdersQueueChange;                               // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDoorNewRequest;                                  // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDoorCollisionInterupt;                           // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnMovementAlphaChanged;                            // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDoorAlphaChanged;                                // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentFloor;                                      // 0x03A0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A4[0x6C];                                     // 0x03A4(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOrder(const int32 FloorOrder);
	bool AreDoorsBlocked();
	void ClearOrders();
	bool IsInteriorReady();
	void ProcessDoorAlphaChanged(float ALPHA);
	bool RequestDoorClose(bool bInInstant);
	bool RequestDoorCustom(float CustomOpenessAlpha, bool bInInstant);
	bool RequestDoorOpen(bool bInInstant);
	void SetCloseDoorsBlocked(const bool Blocked, const class UObject* Object);
	void SetReceiveOrdersBlocked(const bool Blocked, const class UObject* Object);
	void SHElevatorEngineBaseEvent__DelegateSignature(class ASHElevatorEngine* ElevatorEngine);
	void SHElevatorEngineFloatEvent__DelegateSignature(class ASHElevatorEngine* ElevatorEngine, float Value);
	void TryAbortActiveOrder();

	struct FSHElevatorOrderData GetActiveOrder() const;
	class USceneComponent* GetBackDoorsPivot() const;
	int32 GetCurrentDisplayFloor() const;
	int32 GetCurrentFloor() const;
	class USceneComponent* GetFrontDoorsPivot() const;
	TArray<int32> GetOrdersQueue() const;
	bool HasActiveOrder() const;
	bool IsCloseDoorsBlocked() const;
	bool IsDoorClosed() const;
	bool IsDoorOpened() const;
	bool IsKeepingDoorStayOpened() const;
	bool IsPawnInElevator(class APawn* InCheckedPawn) const;
	bool IsReceiveOrdersBlocked() const;
	bool TraceForBlockedDoor(float InDoorOpenOffset, float InTraceSphereRadius, const struct FVector& InPivotWorldOffset) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHElevatorEngine">();
	}
	static class ASHElevatorEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHElevatorEngine>();
	}
};
static_assert(alignof(ASHElevatorEngine) == 0x000008, "Wrong alignment on ASHElevatorEngine");
static_assert(sizeof(ASHElevatorEngine) == 0x000410, "Wrong size on ASHElevatorEngine");
static_assert(offsetof(ASHElevatorEngine, MovingComponent) == 0x0002B0, "Member 'ASHElevatorEngine::MovingComponent' has a wrong offset!");
static_assert(offsetof(ASHElevatorEngine, InteriorAreaComponent) == 0x0002B8, "Member 'ASHElevatorEngine::InteriorAreaComponent' has a wrong offset!");
static_assert(offsetof(ASHElevatorEngine, SafeAreaComponent) == 0x0002C0, "Member 'ASHElevatorEngine::SafeAreaComponent' has a wrong offset!");
static_assert(offsetof(ASHElevatorEngine, MainAkComponent) == 0x0002C8, "Member 'ASHElevatorEngine::MainAkComponent' has a wrong offset!");
static_assert(offsetof(ASHElevatorEngine, SHAkElevatorEngine) == 0x0002D0, "Member 'ASHElevatorEngine::SHAkElevatorEngine' has a wrong offset!");
static_assert(offsetof(ASHElevatorEngine, ElevatorSpeed) == 0x0002D8, "Member 'ASHElevatorEngine::ElevatorSpeed' has a wrong offset!");
static_assert(offsetof(ASHElevatorEngine, BeginPlayFloor) == 0x0002DC, "Member 'ASHElevatorEngine::BeginPlayFloor' has a wrong offset!");
static_assert(offsetof(ASHElevatorEngine, FloorsConfigs) == 0x0002E0, "Member 'ASHElevatorEngine::FloorsConfigs' has a wrong offset!");
static_assert(offsetof(ASHElevatorEngine, bKeepDoorStayOpened) == 0x000330, "Member 'ASHElevatorEngine::bKeepDoorStayOpened' has a wrong offset!");
static_assert(offsetof(ASHElevatorEngine, bResetOrdersOnDoorBlock) == 0x000331, "Member 'ASHElevatorEngine::bResetOrdersOnDoorBlock' has a wrong offset!");
static_assert(offsetof(ASHElevatorEngine, DoorStayOpenedTime) == 0x000334, "Member 'ASHElevatorEngine::DoorStayOpenedTime' has a wrong offset!");
static_assert(offsetof(ASHElevatorEngine, DoorsOpenCloseTime) == 0x000338, "Member 'ASHElevatorEngine::DoorsOpenCloseTime' has a wrong offset!");
static_assert(offsetof(ASHElevatorEngine, OnOrderCompleted) == 0x000340, "Member 'ASHElevatorEngine::OnOrderCompleted' has a wrong offset!");
static_assert(offsetof(ASHElevatorEngine, OnOrdersQueueChange) == 0x000350, "Member 'ASHElevatorEngine::OnOrdersQueueChange' has a wrong offset!");
static_assert(offsetof(ASHElevatorEngine, OnDoorNewRequest) == 0x000360, "Member 'ASHElevatorEngine::OnDoorNewRequest' has a wrong offset!");
static_assert(offsetof(ASHElevatorEngine, OnDoorCollisionInterupt) == 0x000370, "Member 'ASHElevatorEngine::OnDoorCollisionInterupt' has a wrong offset!");
static_assert(offsetof(ASHElevatorEngine, OnMovementAlphaChanged) == 0x000380, "Member 'ASHElevatorEngine::OnMovementAlphaChanged' has a wrong offset!");
static_assert(offsetof(ASHElevatorEngine, OnDoorAlphaChanged) == 0x000390, "Member 'ASHElevatorEngine::OnDoorAlphaChanged' has a wrong offset!");
static_assert(offsetof(ASHElevatorEngine, CurrentFloor) == 0x0003A0, "Member 'ASHElevatorEngine::CurrentFloor' has a wrong offset!");

// Class SHProto.SHWorldSettings
// 0x0000 (0x04E0 - 0x04E0)
class ASHWorldSettings : public AAtmosphereCtrlWorldSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHWorldSettings">();
	}
	static class ASHWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHWorldSettings>();
	}
};
static_assert(alignof(ASHWorldSettings) == 0x000008, "Wrong alignment on ASHWorldSettings");
static_assert(sizeof(ASHWorldSettings) == 0x0004E0, "Wrong size on ASHWorldSettings");

// Class SHProto.SHSecondaryTargetTutorialHandler
// 0x0010 (0x0048 - 0x0038)
class USHSecondaryTargetTutorialHandler : public USHTutorialHandlerBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSecondaryTargetTutorialHandler">();
	}
	static class USHSecondaryTargetTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSecondaryTargetTutorialHandler>();
	}
};
static_assert(alignof(USHSecondaryTargetTutorialHandler) == 0x000008, "Wrong alignment on USHSecondaryTargetTutorialHandler");
static_assert(sizeof(USHSecondaryTargetTutorialHandler) == 0x000048, "Wrong size on USHSecondaryTargetTutorialHandler");

// Class SHProto.SHBreakGlassTutorialHandler
// 0x0000 (0x0048 - 0x0048)
class USHBreakGlassTutorialHandler final : public USHSecondaryTargetTutorialHandler
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBreakGlassTutorialHandler">();
	}
	static class USHBreakGlassTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBreakGlassTutorialHandler>();
	}
};
static_assert(alignof(USHBreakGlassTutorialHandler) == 0x000008, "Wrong alignment on USHBreakGlassTutorialHandler");
static_assert(sizeof(USHBreakGlassTutorialHandler) == 0x000048, "Wrong size on USHBreakGlassTutorialHandler");

// Class SHProto.SHAkElevatorEngineComponent
// 0x0010 (0x04C0 - 0x04B0)
class USHAkElevatorEngineComponent final : public USHAkComponent
{
public:
	class UAkAudioEvent*                          AudioEvent_MoveStarted;                            // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AudioEvent_MoveFinished;                           // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         AudioSwitch_ElevatorType;                          // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PlayMoveFinishAudio();
	void PlayMoveStartAudio();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkElevatorEngineComponent">();
	}
	static class USHAkElevatorEngineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkElevatorEngineComponent>();
	}
};
static_assert(alignof(USHAkElevatorEngineComponent) == 0x000010, "Wrong alignment on USHAkElevatorEngineComponent");
static_assert(sizeof(USHAkElevatorEngineComponent) == 0x0004C0, "Wrong size on USHAkElevatorEngineComponent");
static_assert(offsetof(USHAkElevatorEngineComponent, AudioEvent_MoveStarted) == 0x0004A8, "Member 'USHAkElevatorEngineComponent::AudioEvent_MoveStarted' has a wrong offset!");
static_assert(offsetof(USHAkElevatorEngineComponent, AudioEvent_MoveFinished) == 0x0004B0, "Member 'USHAkElevatorEngineComponent::AudioEvent_MoveFinished' has a wrong offset!");
static_assert(offsetof(USHAkElevatorEngineComponent, AudioSwitch_ElevatorType) == 0x0004B8, "Member 'USHAkElevatorEngineComponent::AudioSwitch_ElevatorType' has a wrong offset!");

// Class SHProto.SHElevatorFloorDoor
// 0x0070 (0x0320 - 0x02B0)
class ASHElevatorFloorDoor final : public AActor
{
public:
	class USHInteractionGenericComponent*         InteractionGeneric;                                // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractionProximitySphere;                        // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            InteractionIcon;                                   // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHRaycastDetectableComponent*          InteractionDetectable;                             // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractionDetectableShape;                        // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkElevatorFloorDoorComponent*        SHAkElevatorFloorDoor;                             // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionManagerComponent*         InteractionManager;                                // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AssignedFloor;                                     // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class ASHElevatorEngine>       EngineSoftPtr;                                     // 0x02F0(0x0030)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleDoorAlphaChanged(class ASHElevatorEngine* InElevatorEnginePtr, float Value);
	void HandleDoorCollisionInterupted(class ASHElevatorEngine* InElevatorEnginePtr);
	void HandleDoorNewRequest(class ASHElevatorEngine* InElevatorEnginePtr);
	void HandleEngineDestroy(class AActor* DestroyedActor);
	void HandleInteract(class USHInteractionGenericComponent* Generic, class ASHCharacterPlay* Character);
	void HandleOrderCompleted(class ASHElevatorEngine* InElevatorEnginePtr);
	void HandleOrdersQueueChange(class ASHElevatorEngine* InElevatorEnginePtr);
	void ProcessDoorAlphaChanged(float ALPHA);
	void ProcessInteractionManagerInitialized(class USHInteractionManagerComponent* Manager);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHElevatorFloorDoor">();
	}
	static class ASHElevatorFloorDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHElevatorFloorDoor>();
	}
};
static_assert(alignof(ASHElevatorFloorDoor) == 0x000008, "Wrong alignment on ASHElevatorFloorDoor");
static_assert(sizeof(ASHElevatorFloorDoor) == 0x000320, "Wrong size on ASHElevatorFloorDoor");
static_assert(offsetof(ASHElevatorFloorDoor, InteractionGeneric) == 0x0002B0, "Member 'ASHElevatorFloorDoor::InteractionGeneric' has a wrong offset!");
static_assert(offsetof(ASHElevatorFloorDoor, InteractionProximitySphere) == 0x0002B8, "Member 'ASHElevatorFloorDoor::InteractionProximitySphere' has a wrong offset!");
static_assert(offsetof(ASHElevatorFloorDoor, InteractionIcon) == 0x0002C0, "Member 'ASHElevatorFloorDoor::InteractionIcon' has a wrong offset!");
static_assert(offsetof(ASHElevatorFloorDoor, InteractionDetectable) == 0x0002C8, "Member 'ASHElevatorFloorDoor::InteractionDetectable' has a wrong offset!");
static_assert(offsetof(ASHElevatorFloorDoor, InteractionDetectableShape) == 0x0002D0, "Member 'ASHElevatorFloorDoor::InteractionDetectableShape' has a wrong offset!");
static_assert(offsetof(ASHElevatorFloorDoor, SHAkElevatorFloorDoor) == 0x0002D8, "Member 'ASHElevatorFloorDoor::SHAkElevatorFloorDoor' has a wrong offset!");
static_assert(offsetof(ASHElevatorFloorDoor, InteractionManager) == 0x0002E0, "Member 'ASHElevatorFloorDoor::InteractionManager' has a wrong offset!");
static_assert(offsetof(ASHElevatorFloorDoor, AssignedFloor) == 0x0002E8, "Member 'ASHElevatorFloorDoor::AssignedFloor' has a wrong offset!");
static_assert(offsetof(ASHElevatorFloorDoor, EngineSoftPtr) == 0x0002F0, "Member 'ASHElevatorFloorDoor::EngineSoftPtr' has a wrong offset!");

// Class SHProto.SHBreakableGlassComponent
// 0x0100 (0x0700 - 0x0600)
class USHBreakableGlassComponent final : public UStaticMeshComponent
{
public:
	uint8                                         Pad_5F8[0x8];                                      // 0x05F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBrokenOnBeginPlay;                                // 0x0600(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_601[0x7];                                      // 0x0601(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GlassPlaneLocalDirection;                          // 0x0608(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                GlassPlaneOffset;                                  // 0x0620(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCustomFXData;                                  // 0x0638(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_639[0x7];                                      // 0x0639(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USHBreakableGlassFXData> CustomFXData;                                      // 0x0640(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRegisterAsMeleeAttackSecondaryTarget;             // 0x0670(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_671[0x3];                                      // 0x0671(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAllowedHeightDelta;                             // 0x0674(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAllowedDistanceToHitPoint2D;                    // 0x0678(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDirectionalOneSideOnly;                         // 0x067C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67D[0x3];                                      // 0x067D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRequiredDirectionsDotProduct;                   // 0x0680(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_684[0x4];                                      // 0x0684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    SecondaryAttackDataRowHandle;                      // 0x0688(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              PointToHitBorderDeadZone;                          // 0x0698(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCustomGlassPlaneLocalDirectionsWhitelist;      // 0x06A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A9[0x7];                                      // 0x06A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        CustomGlassPlaneLocalDirectionsWhitelist;          // 0x06B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FEffectHandle                          LightEffect;                                       // 0x06C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnBreakEvent;                                      // 0x06C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class USHBrokenGlassShardsContainerComponent* BrokenShardsContainer;                             // 0x06D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E0[0x20];                                     // 0x06E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FakeBreak(class AController* EventInstigator, const struct FVector& InHitDir);
	void SHBreakableGlassEvent__DelegateSignature(class USHBreakableGlassComponent* Component);

	bool IsBroken() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBreakableGlassComponent">();
	}
	static class USHBreakableGlassComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBreakableGlassComponent>();
	}
};
static_assert(alignof(USHBreakableGlassComponent) == 0x000010, "Wrong alignment on USHBreakableGlassComponent");
static_assert(sizeof(USHBreakableGlassComponent) == 0x000700, "Wrong size on USHBreakableGlassComponent");
static_assert(offsetof(USHBreakableGlassComponent, bBrokenOnBeginPlay) == 0x000600, "Member 'USHBreakableGlassComponent::bBrokenOnBeginPlay' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassComponent, GlassPlaneLocalDirection) == 0x000608, "Member 'USHBreakableGlassComponent::GlassPlaneLocalDirection' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassComponent, GlassPlaneOffset) == 0x000620, "Member 'USHBreakableGlassComponent::GlassPlaneOffset' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassComponent, bUseCustomFXData) == 0x000638, "Member 'USHBreakableGlassComponent::bUseCustomFXData' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassComponent, CustomFXData) == 0x000640, "Member 'USHBreakableGlassComponent::CustomFXData' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassComponent, bRegisterAsMeleeAttackSecondaryTarget) == 0x000670, "Member 'USHBreakableGlassComponent::bRegisterAsMeleeAttackSecondaryTarget' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassComponent, MaxAllowedHeightDelta) == 0x000674, "Member 'USHBreakableGlassComponent::MaxAllowedHeightDelta' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassComponent, MaxAllowedDistanceToHitPoint2D) == 0x000678, "Member 'USHBreakableGlassComponent::MaxAllowedDistanceToHitPoint2D' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassComponent, bIsDirectionalOneSideOnly) == 0x00067C, "Member 'USHBreakableGlassComponent::bIsDirectionalOneSideOnly' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassComponent, MinRequiredDirectionsDotProduct) == 0x000680, "Member 'USHBreakableGlassComponent::MinRequiredDirectionsDotProduct' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassComponent, SecondaryAttackDataRowHandle) == 0x000688, "Member 'USHBreakableGlassComponent::SecondaryAttackDataRowHandle' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassComponent, PointToHitBorderDeadZone) == 0x000698, "Member 'USHBreakableGlassComponent::PointToHitBorderDeadZone' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassComponent, bUseCustomGlassPlaneLocalDirectionsWhitelist) == 0x0006A8, "Member 'USHBreakableGlassComponent::bUseCustomGlassPlaneLocalDirectionsWhitelist' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassComponent, CustomGlassPlaneLocalDirectionsWhitelist) == 0x0006B0, "Member 'USHBreakableGlassComponent::CustomGlassPlaneLocalDirectionsWhitelist' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassComponent, LightEffect) == 0x0006C0, "Member 'USHBreakableGlassComponent::LightEffect' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassComponent, OnBreakEvent) == 0x0006C8, "Member 'USHBreakableGlassComponent::OnBreakEvent' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassComponent, BrokenShardsContainer) == 0x0006D8, "Member 'USHBreakableGlassComponent::BrokenShardsContainer' has a wrong offset!");

// Class SHProto.SHAkElevatorFloorDoorComponent
// 0x0040 (0x04F0 - 0x04B0)
class USHAkElevatorFloorDoorComponent final : public USHAkComponent
{
public:
	class UAkAudioEvent*                          AudioEvent_ButtonClicked;                          // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AudioEvent_MoveStarted;                            // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AudioEvent_MoveFinished;                           // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         AudioSwitch_DoorType;                              // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         AudioSwitch_DoorState_Opened;                      // 0x04C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         AudioSwitch_DoorState_Middle;                      // 0x04D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         AudioSwitch_DoorState_Closed;                      // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E0[0x10];                                     // 0x04E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayButtonClickAudio(class USceneComponent* ButtonClickedLocationSceneComponent);
	void PlayDoorMovementFinishAudio(bool IsDoorOpened);
	void PlayDoorMovementInteruptedAudio();
	void PlayDoorMovementStartAudio();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkElevatorFloorDoorComponent">();
	}
	static class USHAkElevatorFloorDoorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkElevatorFloorDoorComponent>();
	}
};
static_assert(alignof(USHAkElevatorFloorDoorComponent) == 0x000010, "Wrong alignment on USHAkElevatorFloorDoorComponent");
static_assert(sizeof(USHAkElevatorFloorDoorComponent) == 0x0004F0, "Wrong size on USHAkElevatorFloorDoorComponent");
static_assert(offsetof(USHAkElevatorFloorDoorComponent, AudioEvent_ButtonClicked) == 0x0004A8, "Member 'USHAkElevatorFloorDoorComponent::AudioEvent_ButtonClicked' has a wrong offset!");
static_assert(offsetof(USHAkElevatorFloorDoorComponent, AudioEvent_MoveStarted) == 0x0004B0, "Member 'USHAkElevatorFloorDoorComponent::AudioEvent_MoveStarted' has a wrong offset!");
static_assert(offsetof(USHAkElevatorFloorDoorComponent, AudioEvent_MoveFinished) == 0x0004B8, "Member 'USHAkElevatorFloorDoorComponent::AudioEvent_MoveFinished' has a wrong offset!");
static_assert(offsetof(USHAkElevatorFloorDoorComponent, AudioSwitch_DoorType) == 0x0004C0, "Member 'USHAkElevatorFloorDoorComponent::AudioSwitch_DoorType' has a wrong offset!");
static_assert(offsetof(USHAkElevatorFloorDoorComponent, AudioSwitch_DoorState_Opened) == 0x0004C8, "Member 'USHAkElevatorFloorDoorComponent::AudioSwitch_DoorState_Opened' has a wrong offset!");
static_assert(offsetof(USHAkElevatorFloorDoorComponent, AudioSwitch_DoorState_Middle) == 0x0004D0, "Member 'USHAkElevatorFloorDoorComponent::AudioSwitch_DoorState_Middle' has a wrong offset!");
static_assert(offsetof(USHAkElevatorFloorDoorComponent, AudioSwitch_DoorState_Closed) == 0x0004D8, "Member 'USHAkElevatorFloorDoorComponent::AudioSwitch_DoorState_Closed' has a wrong offset!");

// Class SHProto.SHElevatorInsidePanel
// 0x00B8 (0x0368 - 0x02B0)
class ASHElevatorInsidePanel final : public AActor
{
public:
	class UCameraComponent*                       Camera;                                            // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionGenericComponent*         InteractionGeneric;                                // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractionProximitySphere;                        // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CharacterPlayTeleportToSpot;                       // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      MariaTeleportToSpot;                               // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            InteractionIcon;                                   // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHRaycastDetectableComponent*          InteractionDetectable;                             // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractionDetectableShape;                        // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkElevatorInsidePanelComponent*      SHAkElevatorInsidePanel;                           // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionManagerComponent*         InteractionManager;                                // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFocusableComponent*                  FocusableManager;                                  // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyOneTaskAtTimeMode;                            // 0x0308(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRotateCharacterToDoors;                           // 0x0309(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30A[0x2];                                      // 0x030A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateCharacterToDoorsSnapDuration;                // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class ASHElevatorEngine>       EngineSoftPtr;                                     // 0x0310(0x0030)(Edit, BlueprintVisible, DisableEditOnTemplate, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AttachmentHeight;                                  // 0x0340(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_344[0x24];                                     // 0x0344(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessFocusableShown();
	void ProcessInteractionManagerInitialized(class USHInteractionManagerComponent* Manager);
	void ProcessOrderCompleted(class ASHElevatorEngine* InElevatorEnginePtr);
	void ProcessOrdersQueueChange(class ASHElevatorEngine* InElevatorEnginePtr);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHElevatorInsidePanel">();
	}
	static class ASHElevatorInsidePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHElevatorInsidePanel>();
	}
};
static_assert(alignof(ASHElevatorInsidePanel) == 0x000008, "Wrong alignment on ASHElevatorInsidePanel");
static_assert(sizeof(ASHElevatorInsidePanel) == 0x000368, "Wrong size on ASHElevatorInsidePanel");
static_assert(offsetof(ASHElevatorInsidePanel, Camera) == 0x0002B0, "Member 'ASHElevatorInsidePanel::Camera' has a wrong offset!");
static_assert(offsetof(ASHElevatorInsidePanel, InteractionGeneric) == 0x0002B8, "Member 'ASHElevatorInsidePanel::InteractionGeneric' has a wrong offset!");
static_assert(offsetof(ASHElevatorInsidePanel, InteractionProximitySphere) == 0x0002C0, "Member 'ASHElevatorInsidePanel::InteractionProximitySphere' has a wrong offset!");
static_assert(offsetof(ASHElevatorInsidePanel, CharacterPlayTeleportToSpot) == 0x0002C8, "Member 'ASHElevatorInsidePanel::CharacterPlayTeleportToSpot' has a wrong offset!");
static_assert(offsetof(ASHElevatorInsidePanel, MariaTeleportToSpot) == 0x0002D0, "Member 'ASHElevatorInsidePanel::MariaTeleportToSpot' has a wrong offset!");
static_assert(offsetof(ASHElevatorInsidePanel, InteractionIcon) == 0x0002D8, "Member 'ASHElevatorInsidePanel::InteractionIcon' has a wrong offset!");
static_assert(offsetof(ASHElevatorInsidePanel, InteractionDetectable) == 0x0002E0, "Member 'ASHElevatorInsidePanel::InteractionDetectable' has a wrong offset!");
static_assert(offsetof(ASHElevatorInsidePanel, InteractionDetectableShape) == 0x0002E8, "Member 'ASHElevatorInsidePanel::InteractionDetectableShape' has a wrong offset!");
static_assert(offsetof(ASHElevatorInsidePanel, SHAkElevatorInsidePanel) == 0x0002F0, "Member 'ASHElevatorInsidePanel::SHAkElevatorInsidePanel' has a wrong offset!");
static_assert(offsetof(ASHElevatorInsidePanel, InteractionManager) == 0x0002F8, "Member 'ASHElevatorInsidePanel::InteractionManager' has a wrong offset!");
static_assert(offsetof(ASHElevatorInsidePanel, FocusableManager) == 0x000300, "Member 'ASHElevatorInsidePanel::FocusableManager' has a wrong offset!");
static_assert(offsetof(ASHElevatorInsidePanel, bOnlyOneTaskAtTimeMode) == 0x000308, "Member 'ASHElevatorInsidePanel::bOnlyOneTaskAtTimeMode' has a wrong offset!");
static_assert(offsetof(ASHElevatorInsidePanel, bRotateCharacterToDoors) == 0x000309, "Member 'ASHElevatorInsidePanel::bRotateCharacterToDoors' has a wrong offset!");
static_assert(offsetof(ASHElevatorInsidePanel, RotateCharacterToDoorsSnapDuration) == 0x00030C, "Member 'ASHElevatorInsidePanel::RotateCharacterToDoorsSnapDuration' has a wrong offset!");
static_assert(offsetof(ASHElevatorInsidePanel, EngineSoftPtr) == 0x000310, "Member 'ASHElevatorInsidePanel::EngineSoftPtr' has a wrong offset!");
static_assert(offsetof(ASHElevatorInsidePanel, AttachmentHeight) == 0x000340, "Member 'ASHElevatorInsidePanel::AttachmentHeight' has a wrong offset!");

// Class SHProto.SHCameraActor
// 0x0010 (0x09F0 - 0x09E0)
class ASHCameraActor final : public ACameraActor
{
public:
	uint8                                         Pad_9E0[0x10];                                     // 0x09E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USHCameraComponent* GetSHCameraComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCameraActor">();
	}
	static class ASHCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHCameraActor>();
	}
};
static_assert(alignof(ASHCameraActor) == 0x000010, "Wrong alignment on ASHCameraActor");
static_assert(sizeof(ASHCameraActor) == 0x0009F0, "Wrong size on ASHCameraActor");

// Class SHProto.SHAkElevatorInsidePanelComponent
// 0x0000 (0x04B0 - 0x04B0)
class USHAkElevatorInsidePanelComponent final : public USHAkComponent
{
public:
	class UAkAudioEvent*                          AudioEvent_ButtonClicked;                          // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PlayButtonClickAudio();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkElevatorInsidePanelComponent">();
	}
	static class USHAkElevatorInsidePanelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkElevatorInsidePanelComponent>();
	}
};
static_assert(alignof(USHAkElevatorInsidePanelComponent) == 0x000010, "Wrong alignment on USHAkElevatorInsidePanelComponent");
static_assert(sizeof(USHAkElevatorInsidePanelComponent) == 0x0004B0, "Wrong size on USHAkElevatorInsidePanelComponent");
static_assert(offsetof(USHAkElevatorInsidePanelComponent, AudioEvent_ButtonClicked) == 0x0004A8, "Member 'USHAkElevatorInsidePanelComponent::AudioEvent_ButtonClicked' has a wrong offset!");

// Class SHProto.SHMathHelperStatics
// 0x0000 (0x0028 - 0x0028)
class USHMathHelperStatics final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector2D AngleAndLengthToVector2D(float Angle, float Length);
	static struct FVector2D AngleToVector2D(float Angle);
	static void AverageOfFloatArray(const TArray<float>& FloatArray, float* AverageValue);
	static float FindAngleBetweenNormals(const struct FVector& A, const struct FVector& B, bool SignedAngle);
	static float FindAngleBetweenVectors(const struct FVector& A, const struct FVector& B, bool SignedAngle);
	static float HalfTimeInterp(float Current, float Target, float HalfTime, float DeltaTime, float Precision);
	static struct FVector HalfTimeInterpVector(const struct FVector& Current, const struct FVector& Target, float HalfTime, float DeltaTime, float Precision);
	static struct FVector2D HalfTimeInterpVector2D(const struct FVector2D& Current, const struct FVector2D& Target, float HalfTime, float DeltaTime, float Precision);
	static float IfZero(float Value, float ZeroValue);
	static float MaxWithoutSign(float ValueA, float ValueB);
	static float MinWithoutSign(float ValueA, float ValueB);
	static float PlaneDot(const struct FPlane& Plane, const struct FVector& Location);
	static float SignNonZero(float Value, float ZeroValue);
	static float Vector2DToAngle(const struct FVector2D& Vector, float ZeroVectorAngle);
	static void Vector2DToAngleAndLength(float* OutAngle, float* OutLength, const struct FVector2D& Vector, float ZeroVectorAngle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMathHelperStatics">();
	}
	static class USHMathHelperStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMathHelperStatics>();
	}
};
static_assert(alignof(USHMathHelperStatics) == 0x000008, "Wrong alignment on USHMathHelperStatics");
static_assert(sizeof(USHMathHelperStatics) == 0x000028, "Wrong size on USHMathHelperStatics");

// Class SHProto.SHAkFakeAttachmentComponent
// 0x0010 (0x04C0 - 0x04B0)
class USHAkFakeAttachmentComponent final : public USHAkComponent
{
public:
	uint8                                         Pad_4A8[0x18];                                     // 0x04A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkFakeAttachmentComponent">();
	}
	static class USHAkFakeAttachmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkFakeAttachmentComponent>();
	}
};
static_assert(alignof(USHAkFakeAttachmentComponent) == 0x000010, "Wrong alignment on USHAkFakeAttachmentComponent");
static_assert(sizeof(USHAkFakeAttachmentComponent) == 0x0004C0, "Wrong size on USHAkFakeAttachmentComponent");

// Class SHProto.SHBlenderBase
// 0x0050 (0x0078 - 0x0028)
class USHBlenderBase : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Requester;                                         // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            BlendInAlphaCurve;                                 // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            BlendOutAlphaCurve;                                // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetBlendAlpha() const;
	bool IsBlendingInEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBlenderBase">();
	}
	static class USHBlenderBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBlenderBase>();
	}
};
static_assert(alignof(USHBlenderBase) == 0x000008, "Wrong alignment on USHBlenderBase");
static_assert(sizeof(USHBlenderBase) == 0x000078, "Wrong size on USHBlenderBase");
static_assert(offsetof(USHBlenderBase, Requester) == 0x000038, "Member 'USHBlenderBase::Requester' has a wrong offset!");
static_assert(offsetof(USHBlenderBase, BlendInAlphaCurve) == 0x000040, "Member 'USHBlenderBase::BlendInAlphaCurve' has a wrong offset!");
static_assert(offsetof(USHBlenderBase, BlendOutAlphaCurve) == 0x000048, "Member 'USHBlenderBase::BlendOutAlphaCurve' has a wrong offset!");

// Class SHProto.SHCameraPostProcessBlender
// 0x0708 (0x0780 - 0x0078)
class USHCameraPostProcessBlender final : public USHBlenderBase
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   BlendedData;                                       // 0x0080(0x0700)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCameraPostProcessBlender">();
	}
	static class USHCameraPostProcessBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCameraPostProcessBlender>();
	}
};
static_assert(alignof(USHCameraPostProcessBlender) == 0x000010, "Wrong alignment on USHCameraPostProcessBlender");
static_assert(sizeof(USHCameraPostProcessBlender) == 0x000780, "Wrong size on USHCameraPostProcessBlender");
static_assert(offsetof(USHCameraPostProcessBlender, BlendedData) == 0x000080, "Member 'USHCameraPostProcessBlender::BlendedData' has a wrong offset!");

// Class SHProto.SHAkFakeDoorComponent
// 0x0010 (0x04C0 - 0x04B0)
class USHAkFakeDoorComponent final : public USHAkComponent
{
public:
	class UAkSwitchValue*                         DoorTypeSwitch;                                    // 0x04A8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         DoorLockState_Locked;                              // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkFakeDoorComponent">();
	}
	static class USHAkFakeDoorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkFakeDoorComponent>();
	}
};
static_assert(alignof(USHAkFakeDoorComponent) == 0x000010, "Wrong alignment on USHAkFakeDoorComponent");
static_assert(sizeof(USHAkFakeDoorComponent) == 0x0004C0, "Wrong size on USHAkFakeDoorComponent");
static_assert(offsetof(USHAkFakeDoorComponent, DoorTypeSwitch) == 0x0004A8, "Member 'USHAkFakeDoorComponent::DoorTypeSwitch' has a wrong offset!");
static_assert(offsetof(USHAkFakeDoorComponent, DoorLockState_Locked) == 0x0004B0, "Member 'USHAkFakeDoorComponent::DoorLockState_Locked' has a wrong offset!");

// Class SHProto.SHItemEquipable
// 0x00B0 (0x0360 - 0x02B0)
class ASHItemEquipable : public AActor
{
public:
	class UMeshComponent*                         Mesh;                                              // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UStreamableRenderAsset>  MeshAsset;                                         // 0x02B8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   EquipAttachSocket;                                 // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                EquipRelativeLocation;                             // 0x02F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                EquipRelativeRotation;                             // 0x0308(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             OwnerCharacter;                                    // 0x0320(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x38];                                     // 0x0328(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintAfterEquip();
	void BlueprintBeforeUnequip();

	class FName GetItemDataRowName() const;
	class ACharacter* GetOwnerCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemEquipable">();
	}
	static class ASHItemEquipable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHItemEquipable>();
	}
};
static_assert(alignof(ASHItemEquipable) == 0x000008, "Wrong alignment on ASHItemEquipable");
static_assert(sizeof(ASHItemEquipable) == 0x000360, "Wrong size on ASHItemEquipable");
static_assert(offsetof(ASHItemEquipable, Mesh) == 0x0002B0, "Member 'ASHItemEquipable::Mesh' has a wrong offset!");
static_assert(offsetof(ASHItemEquipable, MeshAsset) == 0x0002B8, "Member 'ASHItemEquipable::MeshAsset' has a wrong offset!");
static_assert(offsetof(ASHItemEquipable, EquipAttachSocket) == 0x0002E8, "Member 'ASHItemEquipable::EquipAttachSocket' has a wrong offset!");
static_assert(offsetof(ASHItemEquipable, EquipRelativeLocation) == 0x0002F0, "Member 'ASHItemEquipable::EquipRelativeLocation' has a wrong offset!");
static_assert(offsetof(ASHItemEquipable, EquipRelativeRotation) == 0x000308, "Member 'ASHItemEquipable::EquipRelativeRotation' has a wrong offset!");
static_assert(offsetof(ASHItemEquipable, OwnerCharacter) == 0x000320, "Member 'ASHItemEquipable::OwnerCharacter' has a wrong offset!");

// Class SHProto.SHAnimNotify_SaveSnapshot
// 0x0008 (0x0040 - 0x0038)
class USHAnimNotify_SaveSnapshot final : public UAnimNotify
{
public:
	class FName                                   SnapshotName;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_SaveSnapshot">();
	}
	static class USHAnimNotify_SaveSnapshot* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_SaveSnapshot>();
	}
};
static_assert(alignof(USHAnimNotify_SaveSnapshot) == 0x000008, "Wrong alignment on USHAnimNotify_SaveSnapshot");
static_assert(sizeof(USHAnimNotify_SaveSnapshot) == 0x000040, "Wrong size on USHAnimNotify_SaveSnapshot");
static_assert(offsetof(USHAnimNotify_SaveSnapshot, SnapshotName) == 0x000038, "Member 'USHAnimNotify_SaveSnapshot::SnapshotName' has a wrong offset!");

// Class SHProto.SHCameraProfilesData
// 0x0050 (0x0080 - 0x0030)
class USHCameraProfilesData final : public UDataAsset
{
public:
	TMap<ESHCameraProfile, struct FSHCameraDataStruct> Profiles;                                          // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCameraProfilesData">();
	}
	static class USHCameraProfilesData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCameraProfilesData>();
	}
};
static_assert(alignof(USHCameraProfilesData) == 0x000008, "Wrong alignment on USHCameraProfilesData");
static_assert(sizeof(USHCameraProfilesData) == 0x000080, "Wrong size on USHCameraProfilesData");
static_assert(offsetof(USHCameraProfilesData, Profiles) == 0x000030, "Member 'USHCameraProfilesData::Profiles' has a wrong offset!");

// Class SHProto.SHItemEquipment
// 0x0030 (0x0390 - 0x0360)
class ASHItemEquipment : public ASHItemEquipable
{
public:
	uint8                                         Pad_360[0x30];                                     // 0x0360(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ToggleRequest();
	void TurnOffRequest();
	void TurnOnRequest();

	bool IsTurnOn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemEquipment">();
	}
	static class ASHItemEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHItemEquipment>();
	}
};
static_assert(alignof(ASHItemEquipment) == 0x000008, "Wrong alignment on ASHItemEquipment");
static_assert(sizeof(ASHItemEquipment) == 0x000390, "Wrong size on ASHItemEquipment");

// Class SHProto.SHFlashlight
// 0x0A88 (0x0E18 - 0x0390)
class ASHFlashlight final : public ASHItemEquipment
{
public:
	class UStaticMeshComponent*                   Lightshaft;                                        // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpotLightComponent*                    LightMain;                                         // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URectLightComponent*                    BackLight;                                         // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPointLightComponent*                   CloseLight;                                        // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpotLightComponent*                    VeryCloseSpotlight;                                // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaiLightEmitter*                       MaiLightEmitter;                                   // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkFlashlightComponent*               SHAkFlashlightComponent;                           // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 DefaultLightsColor;                                // 0x03C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultGlobalIntensity;                            // 0x03CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MainLightIntensityMultiplier;                      // 0x03D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BackLightIntensityMultiplier;                      // 0x03D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloseLightIntensityMultiplier;                     // 0x03D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeryCloseSpotlightIntensityMultiplier;             // 0x03DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSHMaterialPropertyControlData         LightshaftMaterial0EdgeColorPropertyConfig;        // 0x03E0(0x0100)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           DefaultLightshaftMaterial0EdgeColor;               // 0x04E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSHMaterialPropertyControlData         LightshaftMaterial0TintEmissionPropertyConfig;     // 0x04F0(0x0100)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           DefaultLightshaftMaterial0TintEmission;            // 0x05F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSHMaterialPropertyControlData         LightshaftMaterial1EdgeColorPropertyConfig;        // 0x0600(0x0100)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           DefaultLightshaftMaterial1EdgeColor;               // 0x0700(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSHMaterialPropertyControlData         LightshaftMaterial1TintEmissionPropertyConfig;     // 0x0710(0x0100)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           DefaultLightshaftMaterial1TintEmission;            // 0x0810(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharacterControlRotationInterpSpeed;               // 0x0820(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_824[0x4];                                      // 0x0824(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MainLightOffset;                                   // 0x0828(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DirectionInterpSpeed;                              // 0x0840(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimationMultiplayer;                              // 0x0844(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraDistanceInterpSpeed;                         // 0x0848(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84C[0x4];                                      // 0x084C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CameraDistanceInterpModRanged;                     // 0x0850(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinCameraDistance;                                 // 0x0860(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLightIntensityWithCurve;                          // 0x0864(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_865[0x3];                                      // 0x0865(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnOnTime;                                        // 0x0868(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnOffTime;                                       // 0x086C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LightAtMonsterMainLightIntensityAddativeMod;       // 0x0870(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LightAtMonsterCalmTime;                            // 0x0874(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            LightAtMonsterFlickerCurve;                        // 0x0878(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LightAtMonsterFlickerCooldownTime;                 // 0x0880(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceMax;                                          // 0x0884(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketName;                                        // 0x0888(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpotUmbra;                                         // 0x0890(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpotPenumbra;                                      // 0x0894(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           ParametersCollection;                              // 0x0898(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFlashlightTransformProcessor*        TransformProcessor;                                // 0x08A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USHFlashlightMainLightOffsetBlender*> MainLightOffsetBlenders;                           // 0x08A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            LightIntensityCurve;                               // 0x08B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimeline                              LightIntensityTimeline;                            // 0x08C0(0x0098)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTimeline                              LightIntensityModTimeline;                         // 0x0958(0x0098)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FSHFlashlightDynamicDataContainer      CurrentDynamicData;                                // 0x09F0(0x0070)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSHFlashlightDefaultDataContainer      DefaultReferenceData;                              // 0x0A60(0x0020)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A80[0x398];                                    // 0x0A80(0x0398)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginsLightAtMonster(class AActor* Monster);
	void ClearMainLightOffsetSource();
	void DisableLookAt(bool InstantViewRotation, float AwaitTime);
	void EnableLookAtComponent(class USceneComponent* NewLookAtRef, const struct FSHFlashlightLookAtSettings& InLookAtSettings);
	void EndLightAtMonster(class AActor* Monster);
	void OnTurnedOff();
	void OnTurnedOn();
	bool PlayLightIntensityModAnimation(class UCurveFloat* IntensityModCurve);
	void ProcessLightOff();
	void ProcessLightOn();
	void SetLightIntensityModProgress(float ModValue);
	void SetLightIntensityProgress(float ProgressValue);
	void SetMainLightOffsetSource(class USceneComponent* NewMainLightOffsetSource);
	void UpdateDustMaterial(class UMaterialInstanceDynamic* InDustMaterial);
	void UpdateDustNiagara(class UNiagaraComponent* InDustNiagara);
	void UpdateLightAtMonster(class AActor* Monster, float InLightingAlpha);

	float GetIntensityAlpha() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFlashlight">();
	}
	static class ASHFlashlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHFlashlight>();
	}
};
static_assert(alignof(ASHFlashlight) == 0x000008, "Wrong alignment on ASHFlashlight");
static_assert(sizeof(ASHFlashlight) == 0x000E18, "Wrong size on ASHFlashlight");
static_assert(offsetof(ASHFlashlight, Lightshaft) == 0x000390, "Member 'ASHFlashlight::Lightshaft' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, LightMain) == 0x000398, "Member 'ASHFlashlight::LightMain' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, BackLight) == 0x0003A0, "Member 'ASHFlashlight::BackLight' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, CloseLight) == 0x0003A8, "Member 'ASHFlashlight::CloseLight' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, VeryCloseSpotlight) == 0x0003B0, "Member 'ASHFlashlight::VeryCloseSpotlight' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, MaiLightEmitter) == 0x0003B8, "Member 'ASHFlashlight::MaiLightEmitter' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, SHAkFlashlightComponent) == 0x0003C0, "Member 'ASHFlashlight::SHAkFlashlightComponent' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, DefaultLightsColor) == 0x0003C8, "Member 'ASHFlashlight::DefaultLightsColor' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, DefaultGlobalIntensity) == 0x0003CC, "Member 'ASHFlashlight::DefaultGlobalIntensity' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, MainLightIntensityMultiplier) == 0x0003D0, "Member 'ASHFlashlight::MainLightIntensityMultiplier' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, BackLightIntensityMultiplier) == 0x0003D4, "Member 'ASHFlashlight::BackLightIntensityMultiplier' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, CloseLightIntensityMultiplier) == 0x0003D8, "Member 'ASHFlashlight::CloseLightIntensityMultiplier' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, VeryCloseSpotlightIntensityMultiplier) == 0x0003DC, "Member 'ASHFlashlight::VeryCloseSpotlightIntensityMultiplier' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, LightshaftMaterial0EdgeColorPropertyConfig) == 0x0003E0, "Member 'ASHFlashlight::LightshaftMaterial0EdgeColorPropertyConfig' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, DefaultLightshaftMaterial0EdgeColor) == 0x0004E0, "Member 'ASHFlashlight::DefaultLightshaftMaterial0EdgeColor' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, LightshaftMaterial0TintEmissionPropertyConfig) == 0x0004F0, "Member 'ASHFlashlight::LightshaftMaterial0TintEmissionPropertyConfig' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, DefaultLightshaftMaterial0TintEmission) == 0x0005F0, "Member 'ASHFlashlight::DefaultLightshaftMaterial0TintEmission' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, LightshaftMaterial1EdgeColorPropertyConfig) == 0x000600, "Member 'ASHFlashlight::LightshaftMaterial1EdgeColorPropertyConfig' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, DefaultLightshaftMaterial1EdgeColor) == 0x000700, "Member 'ASHFlashlight::DefaultLightshaftMaterial1EdgeColor' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, LightshaftMaterial1TintEmissionPropertyConfig) == 0x000710, "Member 'ASHFlashlight::LightshaftMaterial1TintEmissionPropertyConfig' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, DefaultLightshaftMaterial1TintEmission) == 0x000810, "Member 'ASHFlashlight::DefaultLightshaftMaterial1TintEmission' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, CharacterControlRotationInterpSpeed) == 0x000820, "Member 'ASHFlashlight::CharacterControlRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, MainLightOffset) == 0x000828, "Member 'ASHFlashlight::MainLightOffset' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, DirectionInterpSpeed) == 0x000840, "Member 'ASHFlashlight::DirectionInterpSpeed' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, AnimationMultiplayer) == 0x000844, "Member 'ASHFlashlight::AnimationMultiplayer' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, CameraDistanceInterpSpeed) == 0x000848, "Member 'ASHFlashlight::CameraDistanceInterpSpeed' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, CameraDistanceInterpModRanged) == 0x000850, "Member 'ASHFlashlight::CameraDistanceInterpModRanged' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, MinCameraDistance) == 0x000860, "Member 'ASHFlashlight::MinCameraDistance' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, bLightIntensityWithCurve) == 0x000864, "Member 'ASHFlashlight::bLightIntensityWithCurve' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, TurnOnTime) == 0x000868, "Member 'ASHFlashlight::TurnOnTime' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, TurnOffTime) == 0x00086C, "Member 'ASHFlashlight::TurnOffTime' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, LightAtMonsterMainLightIntensityAddativeMod) == 0x000870, "Member 'ASHFlashlight::LightAtMonsterMainLightIntensityAddativeMod' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, LightAtMonsterCalmTime) == 0x000874, "Member 'ASHFlashlight::LightAtMonsterCalmTime' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, LightAtMonsterFlickerCurve) == 0x000878, "Member 'ASHFlashlight::LightAtMonsterFlickerCurve' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, LightAtMonsterFlickerCooldownTime) == 0x000880, "Member 'ASHFlashlight::LightAtMonsterFlickerCooldownTime' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, TraceMax) == 0x000884, "Member 'ASHFlashlight::TraceMax' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, SocketName) == 0x000888, "Member 'ASHFlashlight::SocketName' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, SpotUmbra) == 0x000890, "Member 'ASHFlashlight::SpotUmbra' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, SpotPenumbra) == 0x000894, "Member 'ASHFlashlight::SpotPenumbra' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, ParametersCollection) == 0x000898, "Member 'ASHFlashlight::ParametersCollection' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, TransformProcessor) == 0x0008A0, "Member 'ASHFlashlight::TransformProcessor' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, MainLightOffsetBlenders) == 0x0008A8, "Member 'ASHFlashlight::MainLightOffsetBlenders' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, LightIntensityCurve) == 0x0008B8, "Member 'ASHFlashlight::LightIntensityCurve' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, LightIntensityTimeline) == 0x0008C0, "Member 'ASHFlashlight::LightIntensityTimeline' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, LightIntensityModTimeline) == 0x000958, "Member 'ASHFlashlight::LightIntensityModTimeline' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, CurrentDynamicData) == 0x0009F0, "Member 'ASHFlashlight::CurrentDynamicData' has a wrong offset!");
static_assert(offsetof(ASHFlashlight, DefaultReferenceData) == 0x000A60, "Member 'ASHFlashlight::DefaultReferenceData' has a wrong offset!");

// Class SHProto.SHBuoyancyMimicComponent
// 0x0030 (0x00D0 - 0x00A0)
class USHBuoyancyMimicComponent final : public UActorComponent
{
public:
	TArray<struct FSHBuoyancyMimicWave>           WavesData;                                         // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         RotationScale;                                     // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisplacementScale;                                 // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableDebug;                                      // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x17];                                      // 0x00B9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize(class USceneComponent* InManagedComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBuoyancyMimicComponent">();
	}
	static class USHBuoyancyMimicComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBuoyancyMimicComponent>();
	}
};
static_assert(alignof(USHBuoyancyMimicComponent) == 0x000008, "Wrong alignment on USHBuoyancyMimicComponent");
static_assert(sizeof(USHBuoyancyMimicComponent) == 0x0000D0, "Wrong size on USHBuoyancyMimicComponent");
static_assert(offsetof(USHBuoyancyMimicComponent, WavesData) == 0x0000A0, "Member 'USHBuoyancyMimicComponent::WavesData' has a wrong offset!");
static_assert(offsetof(USHBuoyancyMimicComponent, RotationScale) == 0x0000B0, "Member 'USHBuoyancyMimicComponent::RotationScale' has a wrong offset!");
static_assert(offsetof(USHBuoyancyMimicComponent, DisplacementScale) == 0x0000B4, "Member 'USHBuoyancyMimicComponent::DisplacementScale' has a wrong offset!");
static_assert(offsetof(USHBuoyancyMimicComponent, bEnableDebug) == 0x0000B8, "Member 'USHBuoyancyMimicComponent::bEnableDebug' has a wrong offset!");

// Class SHProto.SHAkFlashlightComponent
// 0x0030 (0x04E0 - 0x04B0)
class USHAkFlashlightComponent final : public USHAkComponent
{
public:
	float                                         FlickerOffEventAlphaIntensityThreshold;            // 0x04A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlickerOnEventAlphaIntensityThreshold;             // 0x04AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AudioEvent_FlashlightOn;                           // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AudioEvent_FlashlightOff;                          // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AudioEvent_Flashlight_Flicker_Off;                 // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AudioEvent_Flashlight_Flicker_On;                  // 0x04C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AudioEvent_Flashlight_Flicker_Buzz;                // 0x04D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                RTPC_Flicker_Intensity;                            // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkFlashlightComponent">();
	}
	static class USHAkFlashlightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkFlashlightComponent>();
	}
};
static_assert(alignof(USHAkFlashlightComponent) == 0x000010, "Wrong alignment on USHAkFlashlightComponent");
static_assert(sizeof(USHAkFlashlightComponent) == 0x0004E0, "Wrong size on USHAkFlashlightComponent");
static_assert(offsetof(USHAkFlashlightComponent, FlickerOffEventAlphaIntensityThreshold) == 0x0004A8, "Member 'USHAkFlashlightComponent::FlickerOffEventAlphaIntensityThreshold' has a wrong offset!");
static_assert(offsetof(USHAkFlashlightComponent, FlickerOnEventAlphaIntensityThreshold) == 0x0004AC, "Member 'USHAkFlashlightComponent::FlickerOnEventAlphaIntensityThreshold' has a wrong offset!");
static_assert(offsetof(USHAkFlashlightComponent, AudioEvent_FlashlightOn) == 0x0004B0, "Member 'USHAkFlashlightComponent::AudioEvent_FlashlightOn' has a wrong offset!");
static_assert(offsetof(USHAkFlashlightComponent, AudioEvent_FlashlightOff) == 0x0004B8, "Member 'USHAkFlashlightComponent::AudioEvent_FlashlightOff' has a wrong offset!");
static_assert(offsetof(USHAkFlashlightComponent, AudioEvent_Flashlight_Flicker_Off) == 0x0004C0, "Member 'USHAkFlashlightComponent::AudioEvent_Flashlight_Flicker_Off' has a wrong offset!");
static_assert(offsetof(USHAkFlashlightComponent, AudioEvent_Flashlight_Flicker_On) == 0x0004C8, "Member 'USHAkFlashlightComponent::AudioEvent_Flashlight_Flicker_On' has a wrong offset!");
static_assert(offsetof(USHAkFlashlightComponent, AudioEvent_Flashlight_Flicker_Buzz) == 0x0004D0, "Member 'USHAkFlashlightComponent::AudioEvent_Flashlight_Flicker_Buzz' has a wrong offset!");
static_assert(offsetof(USHAkFlashlightComponent, RTPC_Flicker_Intensity) == 0x0004D8, "Member 'USHAkFlashlightComponent::RTPC_Flicker_Intensity' has a wrong offset!");

// Class SHProto.SHHookedMeatBase
// 0x0040 (0x02F0 - 0x02B0)
class ASHHookedMeatBase final : public AActor
{
public:
	class USkeletalMeshComponent*                 MainSkeletalMesh;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkHookedMeatComponent*               SHAkHookedMeatComponent;                           // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSHHookedMeatBoneworkHandler           BoneworkHandler;                                   // 0x02C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         RenderTargetAtlasIndex;                            // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SplineDistance;                                    // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionOffset;                                      // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceLength;                                       // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceOffset;                                       // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPushedByEddie;                                  // 0x02EC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bObliterateOnAnyDamage;                            // 0x02ED(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EE[0x2];                                      // 0x02EE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ApplyDamageToBone(const class FName& InBoneName, const struct FVector& HitFromDirection, const TSubclassOf<class UDamageType>& InDamageTypeClass);
	void BreakAllBones();
	float GetBoneDefaultHealth(const class FName& InBoneName);
	float GetDamageValueFromTypeClass(TSubclassOf<class UDamageType> InDamageTypeClass);
	float GetForceValueFromTypeClass(TSubclassOf<class UDamageType> InDamageTypeClass);
	void OnMeatPush(bool IsGoingForward);

	struct FVector GetDesiredEddieMeatPushPosition(const class AActor* EddieActor) const;
	struct FVector GetEddieCoverPosition(const class AActor* Target) const;
	TArray<class FName> GetExistingChildBones(const class FName& InParentBoneName) const;
	bool IsFullyDestroyed() const;
	bool ShouldPushLeft(const class AActor* Target, const struct FVector& AttackPosition) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHookedMeatBase">();
	}
	static class ASHHookedMeatBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHHookedMeatBase>();
	}
};
static_assert(alignof(ASHHookedMeatBase) == 0x000008, "Wrong alignment on ASHHookedMeatBase");
static_assert(sizeof(ASHHookedMeatBase) == 0x0002F0, "Wrong size on ASHHookedMeatBase");
static_assert(offsetof(ASHHookedMeatBase, MainSkeletalMesh) == 0x0002B0, "Member 'ASHHookedMeatBase::MainSkeletalMesh' has a wrong offset!");
static_assert(offsetof(ASHHookedMeatBase, SHAkHookedMeatComponent) == 0x0002B8, "Member 'ASHHookedMeatBase::SHAkHookedMeatComponent' has a wrong offset!");
static_assert(offsetof(ASHHookedMeatBase, BoneworkHandler) == 0x0002C0, "Member 'ASHHookedMeatBase::BoneworkHandler' has a wrong offset!");
static_assert(offsetof(ASHHookedMeatBase, RenderTargetAtlasIndex) == 0x0002D8, "Member 'ASHHookedMeatBase::RenderTargetAtlasIndex' has a wrong offset!");
static_assert(offsetof(ASHHookedMeatBase, SplineDistance) == 0x0002DC, "Member 'ASHHookedMeatBase::SplineDistance' has a wrong offset!");
static_assert(offsetof(ASHHookedMeatBase, ActionOffset) == 0x0002E0, "Member 'ASHHookedMeatBase::ActionOffset' has a wrong offset!");
static_assert(offsetof(ASHHookedMeatBase, TraceLength) == 0x0002E4, "Member 'ASHHookedMeatBase::TraceLength' has a wrong offset!");
static_assert(offsetof(ASHHookedMeatBase, TraceOffset) == 0x0002E8, "Member 'ASHHookedMeatBase::TraceOffset' has a wrong offset!");
static_assert(offsetof(ASHHookedMeatBase, bIsPushedByEddie) == 0x0002EC, "Member 'ASHHookedMeatBase::bIsPushedByEddie' has a wrong offset!");
static_assert(offsetof(ASHHookedMeatBase, bObliterateOnAnyDamage) == 0x0002ED, "Member 'ASHHookedMeatBase::bObliterateOnAnyDamage' has a wrong offset!");

// Class SHProto.SHCameraMAARLBlender
// 0x0008 (0x0080 - 0x0078)
class USHCameraMAARLBlender final : public USHBlenderBase
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCameraMAARLBlender">();
	}
	static class USHCameraMAARLBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCameraMAARLBlender>();
	}
};
static_assert(alignof(USHCameraMAARLBlender) == 0x000008, "Wrong alignment on USHCameraMAARLBlender");
static_assert(sizeof(USHCameraMAARLBlender) == 0x000080, "Wrong size on USHCameraMAARLBlender");

// Class SHProto.SHAkHookedMeatComponent
// 0x0030 (0x04E0 - 0x04B0)
class USHAkHookedMeatComponent final : public USHAkDynamicTickComponent
{
public:
	class UAkAudioEvent*                          BurstAudioEvent;                                   // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          SwingAudioEvent;                                   // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                VelocityRTPC;                                      // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebug;                                            // 0x04C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C1[0x1F];                                     // 0x04C1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSkeletalComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void PlayBurstAudioEvent();
	void PlaySwingAudio();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkHookedMeatComponent">();
	}
	static class USHAkHookedMeatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkHookedMeatComponent>();
	}
};
static_assert(alignof(USHAkHookedMeatComponent) == 0x000010, "Wrong alignment on USHAkHookedMeatComponent");
static_assert(sizeof(USHAkHookedMeatComponent) == 0x0004E0, "Wrong size on USHAkHookedMeatComponent");
static_assert(offsetof(USHAkHookedMeatComponent, BurstAudioEvent) == 0x0004A8, "Member 'USHAkHookedMeatComponent::BurstAudioEvent' has a wrong offset!");
static_assert(offsetof(USHAkHookedMeatComponent, SwingAudioEvent) == 0x0004B0, "Member 'USHAkHookedMeatComponent::SwingAudioEvent' has a wrong offset!");
static_assert(offsetof(USHAkHookedMeatComponent, VelocityRTPC) == 0x0004B8, "Member 'USHAkHookedMeatComponent::VelocityRTPC' has a wrong offset!");
static_assert(offsetof(USHAkHookedMeatComponent, bDebug) == 0x0004C0, "Member 'USHAkHookedMeatComponent::bDebug' has a wrong offset!");

// Class SHProto.SHMovementAnimationsSetData
// 0x0008 (0x0038 - 0x0030)
class USHMovementAnimationsSetData final : public UDataAsset
{
public:
	TSubclassOf<class UAnimInstance>              LocomotionAnimationBP;                             // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMovementAnimationsSetData">();
	}
	static class USHMovementAnimationsSetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMovementAnimationsSetData>();
	}
};
static_assert(alignof(USHMovementAnimationsSetData) == 0x000008, "Wrong alignment on USHMovementAnimationsSetData");
static_assert(sizeof(USHMovementAnimationsSetData) == 0x000038, "Wrong size on USHMovementAnimationsSetData");
static_assert(offsetof(USHMovementAnimationsSetData, LocomotionAnimationBP) == 0x000030, "Member 'USHMovementAnimationsSetData::LocomotionAnimationBP' has a wrong offset!");

// Class SHProto.SHAkItemWeaponBaseAudioComponent
// 0x0000 (0x04B0 - 0x04B0)
class USHAkItemWeaponBaseAudioComponent : public USHAkComponent
{
public:
	class UAkSwitchValue*                         WeaponSwitch;                                      // 0x04A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BlueprintAfterEquip();
	void BlueprintBeforeUnequip();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkItemWeaponBaseAudioComponent">();
	}
	static class USHAkItemWeaponBaseAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkItemWeaponBaseAudioComponent>();
	}
};
static_assert(alignof(USHAkItemWeaponBaseAudioComponent) == 0x000010, "Wrong alignment on USHAkItemWeaponBaseAudioComponent");
static_assert(sizeof(USHAkItemWeaponBaseAudioComponent) == 0x0004B0, "Wrong size on USHAkItemWeaponBaseAudioComponent");
static_assert(offsetof(USHAkItemWeaponBaseAudioComponent, WeaponSwitch) == 0x0004A8, "Member 'USHAkItemWeaponBaseAudioComponent::WeaponSwitch' has a wrong offset!");

// Class SHProto.SHCharacterImpactInteraction
// 0x0000 (0x0028 - 0x0028)
class ISHCharacterImpactInteraction final : public IInterface
{
public:
	void TryStartInteraction(const struct FHitEvent& HitData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterImpactInteraction">();
	}
	static class ISHCharacterImpactInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHCharacterImpactInteraction>();
	}
};
static_assert(alignof(ISHCharacterImpactInteraction) == 0x000008, "Wrong alignment on ISHCharacterImpactInteraction");
static_assert(sizeof(ISHCharacterImpactInteraction) == 0x000028, "Wrong size on ISHCharacterImpactInteraction");

// Class SHProto.SHAkItemWeaponMeleeAudioComponent
// 0x0000 (0x04B0 - 0x04B0)
class USHAkItemWeaponMeleeAudioComponent final : public USHAkItemWeaponBaseAudioComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkItemWeaponMeleeAudioComponent">();
	}
	static class USHAkItemWeaponMeleeAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkItemWeaponMeleeAudioComponent>();
	}
};
static_assert(alignof(USHAkItemWeaponMeleeAudioComponent) == 0x000010, "Wrong alignment on USHAkItemWeaponMeleeAudioComponent");
static_assert(sizeof(USHAkItemWeaponMeleeAudioComponent) == 0x0004B0, "Wrong size on USHAkItemWeaponMeleeAudioComponent");

// Class SHProto.SHAkItemWeaponRangedAudioComponent
// 0x0050 (0x0500 - 0x04B0)
class USHAkItemWeaponRangedAudioComponent final : public USHAkItemWeaponBaseAudioComponent
{
public:
	class UAkAudioEvent*                          ShootAudioEvent;                                   // 0x04B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          OutOfAmmoAudioEvent;                               // 0x04B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ReloadAudioEvent;                                  // 0x04C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AimStartActionAudioEvent;                          // 0x04C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          FireReadyAimStopActionAudioEvent;                  // 0x04D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          StopAnimAudioNotifiesAudioEvent_Reload;            // 0x04D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkCharacterAudioComponent*           CharacterAudioComponent;                           // 0x04E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E8[0x18];                                     // 0x04E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessOwnerCharacterCombatInputModeChanged(class USHCharacterPlayCombatComponent* CombatComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkItemWeaponRangedAudioComponent">();
	}
	static class USHAkItemWeaponRangedAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkItemWeaponRangedAudioComponent>();
	}
};
static_assert(alignof(USHAkItemWeaponRangedAudioComponent) == 0x000010, "Wrong alignment on USHAkItemWeaponRangedAudioComponent");
static_assert(sizeof(USHAkItemWeaponRangedAudioComponent) == 0x000500, "Wrong size on USHAkItemWeaponRangedAudioComponent");
static_assert(offsetof(USHAkItemWeaponRangedAudioComponent, ShootAudioEvent) == 0x0004B0, "Member 'USHAkItemWeaponRangedAudioComponent::ShootAudioEvent' has a wrong offset!");
static_assert(offsetof(USHAkItemWeaponRangedAudioComponent, OutOfAmmoAudioEvent) == 0x0004B8, "Member 'USHAkItemWeaponRangedAudioComponent::OutOfAmmoAudioEvent' has a wrong offset!");
static_assert(offsetof(USHAkItemWeaponRangedAudioComponent, ReloadAudioEvent) == 0x0004C0, "Member 'USHAkItemWeaponRangedAudioComponent::ReloadAudioEvent' has a wrong offset!");
static_assert(offsetof(USHAkItemWeaponRangedAudioComponent, AimStartActionAudioEvent) == 0x0004C8, "Member 'USHAkItemWeaponRangedAudioComponent::AimStartActionAudioEvent' has a wrong offset!");
static_assert(offsetof(USHAkItemWeaponRangedAudioComponent, FireReadyAimStopActionAudioEvent) == 0x0004D0, "Member 'USHAkItemWeaponRangedAudioComponent::FireReadyAimStopActionAudioEvent' has a wrong offset!");
static_assert(offsetof(USHAkItemWeaponRangedAudioComponent, StopAnimAudioNotifiesAudioEvent_Reload) == 0x0004D8, "Member 'USHAkItemWeaponRangedAudioComponent::StopAnimAudioNotifiesAudioEvent_Reload' has a wrong offset!");
static_assert(offsetof(USHAkItemWeaponRangedAudioComponent, CharacterAudioComponent) == 0x0004E0, "Member 'USHAkItemWeaponRangedAudioComponent::CharacterAudioComponent' has a wrong offset!");

// Class SHProto.SHCarDriverInputReceiver
// 0x0030 (0x0060 - 0x0030)
class USHCarDriverInputReceiver final : public USHVehicleInputReceiver
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCarDriverInputReceiver">();
	}
	static class USHCarDriverInputReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCarDriverInputReceiver>();
	}
};
static_assert(alignof(USHCarDriverInputReceiver) == 0x000008, "Wrong alignment on USHCarDriverInputReceiver");
static_assert(sizeof(USHCarDriverInputReceiver) == 0x000060, "Wrong size on USHCarDriverInputReceiver");

// Class SHProto.SHAkLateReverbComponent
// 0x0000 (0x0330 - 0x0330)
class USHAkLateReverbComponent final : public UBlooberAkLateReverbComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkLateReverbComponent">();
	}
	static class USHAkLateReverbComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkLateReverbComponent>();
	}
};
static_assert(alignof(USHAkLateReverbComponent) == 0x000010, "Wrong alignment on USHAkLateReverbComponent");
static_assert(sizeof(USHAkLateReverbComponent) == 0x000330, "Wrong size on USHAkLateReverbComponent");

// Class SHProto.SHPlaythroughPersistentData
// 0x0010 (0x0050 - 0x0040)
class USHPlaythroughPersistentData final : public UPlaythroughPersistentData
{
public:
	bool                                          bIsNewGamePlus;                                    // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DeathCount;                                        // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasStartedEddieBossfight;                         // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPlaythroughPersistentData">();
	}
	static class USHPlaythroughPersistentData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPlaythroughPersistentData>();
	}
};
static_assert(alignof(USHPlaythroughPersistentData) == 0x000008, "Wrong alignment on USHPlaythroughPersistentData");
static_assert(sizeof(USHPlaythroughPersistentData) == 0x000050, "Wrong size on USHPlaythroughPersistentData");
static_assert(offsetof(USHPlaythroughPersistentData, bIsNewGamePlus) == 0x000040, "Member 'USHPlaythroughPersistentData::bIsNewGamePlus' has a wrong offset!");
static_assert(offsetof(USHPlaythroughPersistentData, DeathCount) == 0x000044, "Member 'USHPlaythroughPersistentData::DeathCount' has a wrong offset!");
static_assert(offsetof(USHPlaythroughPersistentData, bHasStartedEddieBossfight) == 0x000048, "Member 'USHPlaythroughPersistentData::bHasStartedEddieBossfight' has a wrong offset!");

// Class SHProto.SHMusicComponentSettings
// 0x0020 (0x0050 - 0x0030)
class USHMusicComponentSettings final : public UDataAsset
{
public:
	TArray<struct FSHSwitchesPrioritiesMusicData> SwitchesPrioritiesData;                            // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_PlayMusic;                              // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_StopMusic;                              // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMusicComponentSettings">();
	}
	static class USHMusicComponentSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMusicComponentSettings>();
	}
};
static_assert(alignof(USHMusicComponentSettings) == 0x000008, "Wrong alignment on USHMusicComponentSettings");
static_assert(sizeof(USHMusicComponentSettings) == 0x000050, "Wrong size on USHMusicComponentSettings");
static_assert(offsetof(USHMusicComponentSettings, SwitchesPrioritiesData) == 0x000030, "Member 'USHMusicComponentSettings::SwitchesPrioritiesData' has a wrong offset!");
static_assert(offsetof(USHMusicComponentSettings, AudioEvent_PlayMusic) == 0x000040, "Member 'USHMusicComponentSettings::AudioEvent_PlayMusic' has a wrong offset!");
static_assert(offsetof(USHMusicComponentSettings, AudioEvent_StopMusic) == 0x000048, "Member 'USHMusicComponentSettings::AudioEvent_StopMusic' has a wrong offset!");

// Class SHProto.SHCameraFOVBlender
// 0x0008 (0x0080 - 0x0078)
class USHCameraFOVBlender final : public USHBlenderBase
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetAssignedValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCameraFOVBlender">();
	}
	static class USHCameraFOVBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCameraFOVBlender>();
	}
};
static_assert(alignof(USHCameraFOVBlender) == 0x000008, "Wrong alignment on USHCameraFOVBlender");
static_assert(sizeof(USHCameraFOVBlender) == 0x000080, "Wrong size on USHCameraFOVBlender");

// Class SHProto.SHAkMusicComponent
// 0x00B0 (0x0560 - 0x04B0)
class USHAkMusicComponent final : public USHAkComponent
{
public:
	class USHMusicComponentSettings*              ComponentSettings;                                 // 0x04A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ASHMusicSwitchVolume*>           MusicVolumes;                                      // 0x04B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ASHMusicRTPCVolume*>             MusicRTPCVolumes;                                  // 0x04C0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkSwitchValue>          CurrentPlayingMusicSwitch;                         // 0x04D0(0x0030)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAkRtpc*>                        CurrentMusicRTPCs;                                 // 0x0500(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkSwitchValue>          MusicOnLeaveSwitch;                                // 0x0510(0x0030)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_540[0x20];                                     // 0x0540(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReleaseRequestedMusicSwitch(class UObject* InContext);
	void RequestMusicSwitch(class UObject* InContext, class UAkSwitchValue* InSwitch);
	void SHDebug_Character_Music_DrawDebug();
	void SHDebug_Character_Music_StopMusic();
	void SHDebug_Character_Music_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkMusicComponent">();
	}
	static class USHAkMusicComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkMusicComponent>();
	}
};
static_assert(alignof(USHAkMusicComponent) == 0x000010, "Wrong alignment on USHAkMusicComponent");
static_assert(sizeof(USHAkMusicComponent) == 0x000560, "Wrong size on USHAkMusicComponent");
static_assert(offsetof(USHAkMusicComponent, ComponentSettings) == 0x0004A8, "Member 'USHAkMusicComponent::ComponentSettings' has a wrong offset!");
static_assert(offsetof(USHAkMusicComponent, MusicVolumes) == 0x0004B0, "Member 'USHAkMusicComponent::MusicVolumes' has a wrong offset!");
static_assert(offsetof(USHAkMusicComponent, MusicRTPCVolumes) == 0x0004C0, "Member 'USHAkMusicComponent::MusicRTPCVolumes' has a wrong offset!");
static_assert(offsetof(USHAkMusicComponent, CurrentPlayingMusicSwitch) == 0x0004D0, "Member 'USHAkMusicComponent::CurrentPlayingMusicSwitch' has a wrong offset!");
static_assert(offsetof(USHAkMusicComponent, CurrentMusicRTPCs) == 0x000500, "Member 'USHAkMusicComponent::CurrentMusicRTPCs' has a wrong offset!");
static_assert(offsetof(USHAkMusicComponent, MusicOnLeaveSwitch) == 0x000510, "Member 'USHAkMusicComponent::MusicOnLeaveSwitch' has a wrong offset!");

// Class SHProto.SHFXSubcomponent
// 0x0010 (0x0038 - 0x0028)
class USHFXSubcomponent : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXSubcomponent">();
	}
	static class USHFXSubcomponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXSubcomponent>();
	}
};
static_assert(alignof(USHFXSubcomponent) == 0x000008, "Wrong alignment on USHFXSubcomponent");
static_assert(sizeof(USHFXSubcomponent) == 0x000038, "Wrong size on USHFXSubcomponent");

// Class SHProto.SHFXBloodPuddleSubcomp
// 0x0040 (0x0078 - 0x0038)
class USHFXBloodPuddleSubcomp final : public USHFXSubcomponent
{
public:
	class USHFXBloodPuddleSubcompSettings*        Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHBloodPuddle*                         CurrentBloodPuddle;                                // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x30];                                      // 0x0048(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BloodPuddleSpawned();
	void ProcessOwnerDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* HitComponent, class FName BoneName, const struct FVector& ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCauser);
	void ProcessOwnerDead();
	void ProcessOwnerRevive();
	void SetBloodPuddleBlocked(const bool IsBlock, const class UObject* Object);

	class ASHBloodPuddle* GetCurrentBloodPuddle() const;
	bool IsBloodPuddleBlocked() const;
	bool IsBloodPuddleBlockedBy(const class UObject* Object) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXBloodPuddleSubcomp">();
	}
	static class USHFXBloodPuddleSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXBloodPuddleSubcomp>();
	}
};
static_assert(alignof(USHFXBloodPuddleSubcomp) == 0x000008, "Wrong alignment on USHFXBloodPuddleSubcomp");
static_assert(sizeof(USHFXBloodPuddleSubcomp) == 0x000078, "Wrong size on USHFXBloodPuddleSubcomp");
static_assert(offsetof(USHFXBloodPuddleSubcomp, Settings) == 0x000038, "Member 'USHFXBloodPuddleSubcomp::Settings' has a wrong offset!");
static_assert(offsetof(USHFXBloodPuddleSubcomp, CurrentBloodPuddle) == 0x000040, "Member 'USHFXBloodPuddleSubcomp::CurrentBloodPuddle' has a wrong offset!");

// Class SHProto.SHAkPortalManagerComponent
// 0x0010 (0x00B0 - 0x00A0)
class USHAkPortalManagerComponent final : public UActorComponent
{
public:
	TArray<class USHAkPortalComponent*>           RegisteredAkPortals;                               // 0x00A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkPortalManagerComponent">();
	}
	static class USHAkPortalManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkPortalManagerComponent>();
	}
};
static_assert(alignof(USHAkPortalManagerComponent) == 0x000008, "Wrong alignment on USHAkPortalManagerComponent");
static_assert(sizeof(USHAkPortalManagerComponent) == 0x0000B0, "Wrong size on USHAkPortalManagerComponent");
static_assert(offsetof(USHAkPortalManagerComponent, RegisteredAkPortals) == 0x0000A0, "Member 'USHAkPortalManagerComponent::RegisteredAkPortals' has a wrong offset!");

// Class SHProto.SHStairsDetectionComponent
// 0x0000 (0x00A0 - 0x00A0)
class USHStairsDetectionComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHStairsDetectionComponent">();
	}
	static class USHStairsDetectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHStairsDetectionComponent>();
	}
};
static_assert(alignof(USHStairsDetectionComponent) == 0x000008, "Wrong alignment on USHStairsDetectionComponent");
static_assert(sizeof(USHStairsDetectionComponent) == 0x0000A0, "Wrong size on USHStairsDetectionComponent");

// Class SHProto.SHCharacterPlayStairsDetectionComponent
// 0x0000 (0x00A0 - 0x00A0)
class USHCharacterPlayStairsDetectionComponent final : public USHStairsDetectionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayStairsDetectionComponent">();
	}
	static class USHCharacterPlayStairsDetectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayStairsDetectionComponent>();
	}
};
static_assert(alignof(USHCharacterPlayStairsDetectionComponent) == 0x000008, "Wrong alignment on USHCharacterPlayStairsDetectionComponent");
static_assert(sizeof(USHCharacterPlayStairsDetectionComponent) == 0x0000A0, "Wrong size on USHCharacterPlayStairsDetectionComponent");

// Class SHProto.SHAkPortalOpenableComponent
// 0x0000 (0x0390 - 0x0390)
class USHAkPortalOpenableComponent final : public USHAkPortalComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkPortalOpenableComponent">();
	}
	static class USHAkPortalOpenableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkPortalOpenableComponent>();
	}
};
static_assert(alignof(USHAkPortalOpenableComponent) == 0x000010, "Wrong alignment on USHAkPortalOpenableComponent");
static_assert(sizeof(USHAkPortalOpenableComponent) == 0x000390, "Wrong size on USHAkPortalOpenableComponent");

// Class SHProto.SHRainManagerComponent
// 0x0040 (0x00E0 - 0x00A0)
class USHRainManagerComponent final : public UActorComponent
{
public:
	TArray<class ASHGameplayRainVolume*>          RegisteredRainVolumes;                             // 0x00A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x30];                                      // 0x00B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetRainingBlocked(const bool IsBlock, const class UObject* Object);
	void SetRainSplashesBlocked(const bool IsBlock, const class UObject* Object);

	class ASHGameplayRainVolume* GetEncompassedRainVolume(const struct FVector& InLocation) const;
	int32 GetRegisteredRainVolumeCount() const;
	bool IsRainingBlocked() const;
	bool IsRainingBlockedBy(const class UObject* Object) const;
	bool IsRainSplashesBlocked() const;
	bool IsRainSplashesBlockedBy(const class UObject* Object) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHRainManagerComponent">();
	}
	static class USHRainManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHRainManagerComponent>();
	}
};
static_assert(alignof(USHRainManagerComponent) == 0x000008, "Wrong alignment on USHRainManagerComponent");
static_assert(sizeof(USHRainManagerComponent) == 0x0000E0, "Wrong size on USHRainManagerComponent");
static_assert(offsetof(USHRainManagerComponent, RegisteredRainVolumes) == 0x0000A0, "Member 'USHRainManagerComponent::RegisteredRainVolumes' has a wrong offset!");

// Class SHProto.SHAkReverbVolume
// 0x0000 (0x0320 - 0x0320)
class ASHAkReverbVolume final : public ABlooberAkReverbVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkReverbVolume">();
	}
	static class ASHAkReverbVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHAkReverbVolume>();
	}
};
static_assert(alignof(ASHAkReverbVolume) == 0x000008, "Wrong alignment on ASHAkReverbVolume");
static_assert(sizeof(ASHAkReverbVolume) == 0x000320, "Wrong size on ASHAkReverbVolume");

// Class SHProto.SHCharacterPlayAdaptiveTriggersManager
// 0x0030 (0x00D0 - 0x00A0)
class USHCharacterPlayAdaptiveTriggersManager final : public UActorComponent
{
public:
	class USHAdaptiveTriggersManagerSettings*     AdaptiveTriggersSettings;                          // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnabled(bool InEnable, class UObject* Object);
	void SHDebug_Character_Controller_ValuesDebug();

	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayAdaptiveTriggersManager">();
	}
	static class USHCharacterPlayAdaptiveTriggersManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayAdaptiveTriggersManager>();
	}
};
static_assert(alignof(USHCharacterPlayAdaptiveTriggersManager) == 0x000008, "Wrong alignment on USHCharacterPlayAdaptiveTriggersManager");
static_assert(sizeof(USHCharacterPlayAdaptiveTriggersManager) == 0x0000D0, "Wrong size on USHCharacterPlayAdaptiveTriggersManager");
static_assert(offsetof(USHCharacterPlayAdaptiveTriggersManager, AdaptiveTriggersSettings) == 0x0000A0, "Member 'USHCharacterPlayAdaptiveTriggersManager::AdaptiveTriggersSettings' has a wrong offset!");

// Class SHProto.SHAkRoomComponent
// 0x0000 (0x0300 - 0x0300)
class USHAkRoomComponent final : public UBlooberAkRoomComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkRoomComponent">();
	}
	static class USHAkRoomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkRoomComponent>();
	}
};
static_assert(alignof(USHAkRoomComponent) == 0x000010, "Wrong alignment on USHAkRoomComponent");
static_assert(sizeof(USHAkRoomComponent) == 0x000300, "Wrong size on USHAkRoomComponent");

// Class SHProto.SHAkSlidingDoorComponent
// 0x0000 (0x04D0 - 0x04D0)
class USHAkSlidingDoorComponent final : public USHAkDoorBaseComponent
{
public:
	void ProcessOnLockedAnimPlayedNative(class USHSlidingDoorAnimationsComponent* SlidingDoorAnimComponent);
	void ProcessOnOpenAnimPlayedNative(class USHSlidingDoorAnimationsComponent* SlidingDoorAnimComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkSlidingDoorComponent">();
	}
	static class USHAkSlidingDoorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkSlidingDoorComponent>();
	}
};
static_assert(alignof(USHAkSlidingDoorComponent) == 0x000010, "Wrong alignment on USHAkSlidingDoorComponent");
static_assert(sizeof(USHAkSlidingDoorComponent) == 0x0004D0, "Wrong size on USHAkSlidingDoorComponent");

// Class SHProto.SHCharacterPlayTutorialsComponent
// 0x0120 (0x01C0 - 0x00A0)
class USHCharacterPlayTutorialsComponent final : public UActorComponent
{
public:
	float                                         ConsumeQueueDelayValue;                            // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USHGameplayTutorialsDatabase*           TutorialsDatabase;                                 // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USHTutorialHandlerBase*>         TutorialHandlers;                                  // 0x00B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<ESHGameplayTutorialEnum>               RegisteredTutorialActions;                         // 0x00C0(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0xF0];                                      // 0x00D0(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessTutorialWidgetHideEvent();
	void SHDebug_Character_Tutorials_RequestShowTutorial(int32 TutorialEnumAsInt);
	void SHDebug_Character_Tutorials_ResetRegisterActions();
	void SHDebug_Character_Tutorials_ValuesDebug();

	bool IsTutorialActionRegistered(const ESHGameplayTutorialEnum InTutorialEnum) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayTutorialsComponent">();
	}
	static class USHCharacterPlayTutorialsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayTutorialsComponent>();
	}
};
static_assert(alignof(USHCharacterPlayTutorialsComponent) == 0x000008, "Wrong alignment on USHCharacterPlayTutorialsComponent");
static_assert(sizeof(USHCharacterPlayTutorialsComponent) == 0x0001C0, "Wrong size on USHCharacterPlayTutorialsComponent");
static_assert(offsetof(USHCharacterPlayTutorialsComponent, ConsumeQueueDelayValue) == 0x0000A0, "Member 'USHCharacterPlayTutorialsComponent::ConsumeQueueDelayValue' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayTutorialsComponent, TutorialsDatabase) == 0x0000A8, "Member 'USHCharacterPlayTutorialsComponent::TutorialsDatabase' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayTutorialsComponent, TutorialHandlers) == 0x0000B0, "Member 'USHCharacterPlayTutorialsComponent::TutorialHandlers' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayTutorialsComponent, RegisteredTutorialActions) == 0x0000C0, "Member 'USHCharacterPlayTutorialsComponent::RegisteredTutorialActions' has a wrong offset!");

// Class SHProto.SHAkSpatialAudioVolume
// 0x0008 (0x0308 - 0x0300)
class ASHAkSpatialAudioVolume final : public ABlooberAkSpatialAudioVolume
{
public:
	ESHAudioCubatureEnum                          IndoorOutdoorState;                                // 0x0300(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESHAudioWorldEnum                             AudioWorldState;                                   // 0x0301(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_302[0x6];                                      // 0x0302(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkSpatialAudioVolume">();
	}
	static class ASHAkSpatialAudioVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHAkSpatialAudioVolume>();
	}
};
static_assert(alignof(ASHAkSpatialAudioVolume) == 0x000008, "Wrong alignment on ASHAkSpatialAudioVolume");
static_assert(sizeof(ASHAkSpatialAudioVolume) == 0x000308, "Wrong size on ASHAkSpatialAudioVolume");
static_assert(offsetof(ASHAkSpatialAudioVolume, IndoorOutdoorState) == 0x000300, "Member 'ASHAkSpatialAudioVolume::IndoorOutdoorState' has a wrong offset!");
static_assert(offsetof(ASHAkSpatialAudioVolume, AudioWorldState) == 0x000301, "Member 'ASHAkSpatialAudioVolume::AudioWorldState' has a wrong offset!");

// Class SHProto.SHGammaSettingsPanelWidget
// 0x0008 (0x04C8 - 0x04C0)
class USHGammaSettingsPanelWidget final : public USettingsPanelWidget
{
public:
	class UImage*                                 GammaView_img;                                     // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGammaSettingsPanelWidget">();
	}
	static class USHGammaSettingsPanelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGammaSettingsPanelWidget>();
	}
};
static_assert(alignof(USHGammaSettingsPanelWidget) == 0x000008, "Wrong alignment on USHGammaSettingsPanelWidget");
static_assert(sizeof(USHGammaSettingsPanelWidget) == 0x0004C8, "Wrong size on USHGammaSettingsPanelWidget");
static_assert(offsetof(USHGammaSettingsPanelWidget, GammaView_img) == 0x0004C0, "Member 'USHGammaSettingsPanelWidget::GammaView_img' has a wrong offset!");

// Class SHProto.SHAkSpatialAudioVolumeManagerComponent
// 0x0010 (0x00B0 - 0x00A0)
class USHAkSpatialAudioVolumeManagerComponent final : public UActorComponent
{
public:
	TArray<class ASHAkSpatialAudioVolume*>        RegisteredAkSpatialAudioVolumes;                   // 0x00A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkSpatialAudioVolumeManagerComponent">();
	}
	static class USHAkSpatialAudioVolumeManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkSpatialAudioVolumeManagerComponent>();
	}
};
static_assert(alignof(USHAkSpatialAudioVolumeManagerComponent) == 0x000008, "Wrong alignment on USHAkSpatialAudioVolumeManagerComponent");
static_assert(sizeof(USHAkSpatialAudioVolumeManagerComponent) == 0x0000B0, "Wrong size on USHAkSpatialAudioVolumeManagerComponent");
static_assert(offsetof(USHAkSpatialAudioVolumeManagerComponent, RegisteredAkSpatialAudioVolumes) == 0x0000A0, "Member 'USHAkSpatialAudioVolumeManagerComponent::RegisteredAkSpatialAudioVolumes' has a wrong offset!");

// Class SHProto.SHCharacterPlaySpringArmComponent
// 0x0160 (0x0500 - 0x03A0)
class USHCharacterPlaySpringArmComponent final : public USpringArmComponent
{
public:
	class USHCameraProfilesData*                  ProfilesData;                                      // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CollisionBlendOutDelay;                            // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CollisionBlendInSpeeds;                            // 0x03B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmLengthMin;                                      // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableTargetOffsetExtraHeightFromPitch;           // 0x03C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C5[0x3];                                      // 0x03C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetOffsetExtraHeightFromPitchLowInfluenceValue; // 0x03C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CC[0x4];                                      // 0x03CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TargetOffsetExtraHeightFromPitchValuesRange;       // 0x03D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0x18];                                     // 0x03E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x03F8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCameraDataBlender*                   ExteriorSprintCameraBlender;                       // 0x0400(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCameraDataBlender*                   InteriorCameraBlender;                             // 0x0408(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCameraDataBlender*                   InteriorSprintCameraBlender;                       // 0x0410(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USHCameraDataBlender*>           CustomCameraBlenders;                              // 0x0418(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_428[0xD8];                                     // 0x0428(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearCustomCameraData(const class UObject* Object, const bool Instant);
	bool ReneableCustomCameraData(const class UObject* Object, const class FString& InCustomCameraName);
	void RequestRefreshState(const class UObject* Requester);
	void SetCustomCameraData(const class UObject* Object, const class FString& InCustomCameraName, const struct FSHCameraDataStruct& InCustomCameraData, const struct FSHCameraDataStruct& InCustomCollisionData);
	void SHDebug_Character_Camera_BlendsDebug();
	void SHDebug_Character_Camera_ContinousReadData();
	void SHDebug_Character_Camera_DrawDebug();
	void SHDebug_Character_Camera_ValuesDebug();

	float GetCustomCameraBlendAlpha(const class UObject* Object) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlaySpringArmComponent">();
	}
	static class USHCharacterPlaySpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlaySpringArmComponent>();
	}
};
static_assert(alignof(USHCharacterPlaySpringArmComponent) == 0x000010, "Wrong alignment on USHCharacterPlaySpringArmComponent");
static_assert(sizeof(USHCharacterPlaySpringArmComponent) == 0x000500, "Wrong size on USHCharacterPlaySpringArmComponent");
static_assert(offsetof(USHCharacterPlaySpringArmComponent, ProfilesData) == 0x0003A0, "Member 'USHCharacterPlaySpringArmComponent::ProfilesData' has a wrong offset!");
static_assert(offsetof(USHCharacterPlaySpringArmComponent, CollisionBlendOutDelay) == 0x0003A8, "Member 'USHCharacterPlaySpringArmComponent::CollisionBlendOutDelay' has a wrong offset!");
static_assert(offsetof(USHCharacterPlaySpringArmComponent, CollisionBlendInSpeeds) == 0x0003B0, "Member 'USHCharacterPlaySpringArmComponent::CollisionBlendInSpeeds' has a wrong offset!");
static_assert(offsetof(USHCharacterPlaySpringArmComponent, ArmLengthMin) == 0x0003C0, "Member 'USHCharacterPlaySpringArmComponent::ArmLengthMin' has a wrong offset!");
static_assert(offsetof(USHCharacterPlaySpringArmComponent, bEnableTargetOffsetExtraHeightFromPitch) == 0x0003C4, "Member 'USHCharacterPlaySpringArmComponent::bEnableTargetOffsetExtraHeightFromPitch' has a wrong offset!");
static_assert(offsetof(USHCharacterPlaySpringArmComponent, TargetOffsetExtraHeightFromPitchLowInfluenceValue) == 0x0003C8, "Member 'USHCharacterPlaySpringArmComponent::TargetOffsetExtraHeightFromPitchLowInfluenceValue' has a wrong offset!");
static_assert(offsetof(USHCharacterPlaySpringArmComponent, TargetOffsetExtraHeightFromPitchValuesRange) == 0x0003D0, "Member 'USHCharacterPlaySpringArmComponent::TargetOffsetExtraHeightFromPitchValuesRange' has a wrong offset!");
static_assert(offsetof(USHCharacterPlaySpringArmComponent, OwnerCharacter) == 0x0003F8, "Member 'USHCharacterPlaySpringArmComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHCharacterPlaySpringArmComponent, ExteriorSprintCameraBlender) == 0x000400, "Member 'USHCharacterPlaySpringArmComponent::ExteriorSprintCameraBlender' has a wrong offset!");
static_assert(offsetof(USHCharacterPlaySpringArmComponent, InteriorCameraBlender) == 0x000408, "Member 'USHCharacterPlaySpringArmComponent::InteriorCameraBlender' has a wrong offset!");
static_assert(offsetof(USHCharacterPlaySpringArmComponent, InteriorSprintCameraBlender) == 0x000410, "Member 'USHCharacterPlaySpringArmComponent::InteriorSprintCameraBlender' has a wrong offset!");
static_assert(offsetof(USHCharacterPlaySpringArmComponent, CustomCameraBlenders) == 0x000418, "Member 'USHCharacterPlaySpringArmComponent::CustomCameraBlenders' has a wrong offset!");

// Class SHProto.SHFXBloodPuddleSubcompSettings
// 0x0048 (0x0078 - 0x0030)
class USHFXBloodPuddleSubcompSettings final : public UDataAsset
{
public:
	bool                                          EnableBloodPuddle;                                 // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   BloodPuddleClass;                                  // 0x0038(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayToSpawnPuddle;                                // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAddsToPuddleValue;                           // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OverridePuddleFadeAway;                            // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PuddleFadeAwayTime;                                // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXBloodPuddleSubcompSettings">();
	}
	static class USHFXBloodPuddleSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXBloodPuddleSubcompSettings>();
	}
};
static_assert(alignof(USHFXBloodPuddleSubcompSettings) == 0x000008, "Wrong alignment on USHFXBloodPuddleSubcompSettings");
static_assert(sizeof(USHFXBloodPuddleSubcompSettings) == 0x000078, "Wrong size on USHFXBloodPuddleSubcompSettings");
static_assert(offsetof(USHFXBloodPuddleSubcompSettings, EnableBloodPuddle) == 0x000030, "Member 'USHFXBloodPuddleSubcompSettings::EnableBloodPuddle' has a wrong offset!");
static_assert(offsetof(USHFXBloodPuddleSubcompSettings, BloodPuddleClass) == 0x000038, "Member 'USHFXBloodPuddleSubcompSettings::BloodPuddleClass' has a wrong offset!");
static_assert(offsetof(USHFXBloodPuddleSubcompSettings, DelayToSpawnPuddle) == 0x000068, "Member 'USHFXBloodPuddleSubcompSettings::DelayToSpawnPuddle' has a wrong offset!");
static_assert(offsetof(USHFXBloodPuddleSubcompSettings, DamageAddsToPuddleValue) == 0x00006C, "Member 'USHFXBloodPuddleSubcompSettings::DamageAddsToPuddleValue' has a wrong offset!");
static_assert(offsetof(USHFXBloodPuddleSubcompSettings, OverridePuddleFadeAway) == 0x000070, "Member 'USHFXBloodPuddleSubcompSettings::OverridePuddleFadeAway' has a wrong offset!");
static_assert(offsetof(USHFXBloodPuddleSubcompSettings, PuddleFadeAwayTime) == 0x000074, "Member 'USHFXBloodPuddleSubcompSettings::PuddleFadeAwayTime' has a wrong offset!");

// Class SHProto.SHAkSpotReflector
// 0x0000 (0x02E8 - 0x02E8)
class ASHAkSpotReflector final : public ABlooberAkSpotReflector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkSpotReflector">();
	}
	static class ASHAkSpotReflector* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHAkSpotReflector>();
	}
};
static_assert(alignof(ASHAkSpotReflector) == 0x000008, "Wrong alignment on ASHAkSpotReflector");
static_assert(sizeof(ASHAkSpotReflector) == 0x0002E8, "Wrong size on ASHAkSpotReflector");

// Class SHProto.SHFXNurseHeadShakeSubcompSettings
// 0x0020 (0x0050 - 0x0030)
class USHFXNurseHeadShakeSubcompSettings final : public UDataAsset
{
public:
	bool                                          EnableHeadShake;                                   // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HeadSocketName;                                    // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetScale;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMovement;                                     // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitAccelerationMultiply;                         // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXNurseHeadShakeSubcompSettings">();
	}
	static class USHFXNurseHeadShakeSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXNurseHeadShakeSubcompSettings>();
	}
};
static_assert(alignof(USHFXNurseHeadShakeSubcompSettings) == 0x000008, "Wrong alignment on USHFXNurseHeadShakeSubcompSettings");
static_assert(sizeof(USHFXNurseHeadShakeSubcompSettings) == 0x000050, "Wrong size on USHFXNurseHeadShakeSubcompSettings");
static_assert(offsetof(USHFXNurseHeadShakeSubcompSettings, EnableHeadShake) == 0x000030, "Member 'USHFXNurseHeadShakeSubcompSettings::EnableHeadShake' has a wrong offset!");
static_assert(offsetof(USHFXNurseHeadShakeSubcompSettings, HeadSocketName) == 0x000034, "Member 'USHFXNurseHeadShakeSubcompSettings::HeadSocketName' has a wrong offset!");
static_assert(offsetof(USHFXNurseHeadShakeSubcompSettings, MaterialIndex) == 0x00003C, "Member 'USHFXNurseHeadShakeSubcompSettings::MaterialIndex' has a wrong offset!");
static_assert(offsetof(USHFXNurseHeadShakeSubcompSettings, OffsetScale) == 0x000040, "Member 'USHFXNurseHeadShakeSubcompSettings::OffsetScale' has a wrong offset!");
static_assert(offsetof(USHFXNurseHeadShakeSubcompSettings, Magnitude) == 0x000044, "Member 'USHFXNurseHeadShakeSubcompSettings::Magnitude' has a wrong offset!");
static_assert(offsetof(USHFXNurseHeadShakeSubcompSettings, ClampMovement) == 0x000048, "Member 'USHFXNurseHeadShakeSubcompSettings::ClampMovement' has a wrong offset!");
static_assert(offsetof(USHFXNurseHeadShakeSubcompSettings, LimitAccelerationMultiply) == 0x00004C, "Member 'USHFXNurseHeadShakeSubcompSettings::LimitAccelerationMultiply' has a wrong offset!");

// Class SHProto.SHValve
// 0x00E8 (0x0398 - 0x02B0)
class ASHValve : public AActor
{
public:
	class USceneComponent*                        ValveMeshPivot;                                    // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ValveMesh;                                         // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCineCameraComponent*                 FocusCamera;                                       // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionGenericComponent*         InteractionGeneric;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractionProximitySphere;                        // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            InteractionIcon;                                   // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHRaycastDetectableComponent*          InteractionDetectable;                             // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractionDetectableShape;                        // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      InteractionAnimSpot;                               // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        FlashlightFocusSpot;                               // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkValveComponent*                    SHAkValve;                                         // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionManagerComponent*         InteractionManager;                                // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFocusableComponent*                  FocusableComponent;                                // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RequiredRotatedAngle;                              // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   AnimInstanceClass;                                 // 0x0320(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               ValveMeshAngleCurveEffector;                       // 0x0350(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ValveTurnFirstPhaseAngleCurve;                     // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ValveTurnSecondPhaseAngleCurve;                    // 0x0370(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             InteractingCharacter;                              // 0x0378(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHValveAnimInstance*                   LinkedAnimGraphInstance;                           // 0x0380(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TotalRotatedAngle;                                 // 0x0388(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0xC];                                      // 0x038C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessAnimInstBeginFinishInteraction(class USHValveAnimInstance* AnimInstPtr);
	void ProcessAnimInstChangedProgressPhase(class USHValveAnimInstance* AnimInstPtr, int32 InPhaseNumber, bool bHasStarted);
	void ProcessAnimInstFinishedInteraction(class USHValveAnimInstance* AnimInstPtr);
	void ProcessAnimInstStartedInteraction(class USHValveAnimInstance* AnimInstPtr);
	void ProcessFocusableInputActionEvent(ESHFocusableInputActionTypeEnum InputActionType, float KeyValue);
	void ProcessInteractingCharacterCombatInputModeChanged(class USHCharacterPlayCombatComponent* CombatComp);
	void ProcessInteractingCharacterReceiveDamage(class USHCharacterPlayCombatComponent* CombatComp);
	void ProcessInteractionGenericGrabbed(class USHInteractionGenericComponent* Generic, class ASHCharacterPlay* Character);
	void ProcessInteractionManagerInitialized(class USHInteractionManagerComponent* Manager);
	void ProcessMoveCharacterToSpotFinished(bool WasCompleted);
	void ProcessProximityBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void ProcessProximityEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex);
	void RequestAbortInteraction();

	int32 GetCurrentPhaseNumber() const;
	float GetTotalRotatedAngle() const;
	bool IsCompleted() const;
	bool IsInInteraction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHValve">();
	}
	static class ASHValve* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHValve>();
	}
};
static_assert(alignof(ASHValve) == 0x000008, "Wrong alignment on ASHValve");
static_assert(sizeof(ASHValve) == 0x000398, "Wrong size on ASHValve");
static_assert(offsetof(ASHValve, ValveMeshPivot) == 0x0002B0, "Member 'ASHValve::ValveMeshPivot' has a wrong offset!");
static_assert(offsetof(ASHValve, ValveMesh) == 0x0002B8, "Member 'ASHValve::ValveMesh' has a wrong offset!");
static_assert(offsetof(ASHValve, FocusCamera) == 0x0002C0, "Member 'ASHValve::FocusCamera' has a wrong offset!");
static_assert(offsetof(ASHValve, InteractionGeneric) == 0x0002C8, "Member 'ASHValve::InteractionGeneric' has a wrong offset!");
static_assert(offsetof(ASHValve, InteractionProximitySphere) == 0x0002D0, "Member 'ASHValve::InteractionProximitySphere' has a wrong offset!");
static_assert(offsetof(ASHValve, InteractionIcon) == 0x0002D8, "Member 'ASHValve::InteractionIcon' has a wrong offset!");
static_assert(offsetof(ASHValve, InteractionDetectable) == 0x0002E0, "Member 'ASHValve::InteractionDetectable' has a wrong offset!");
static_assert(offsetof(ASHValve, InteractionDetectableShape) == 0x0002E8, "Member 'ASHValve::InteractionDetectableShape' has a wrong offset!");
static_assert(offsetof(ASHValve, InteractionAnimSpot) == 0x0002F0, "Member 'ASHValve::InteractionAnimSpot' has a wrong offset!");
static_assert(offsetof(ASHValve, FlashlightFocusSpot) == 0x0002F8, "Member 'ASHValve::FlashlightFocusSpot' has a wrong offset!");
static_assert(offsetof(ASHValve, SHAkValve) == 0x000300, "Member 'ASHValve::SHAkValve' has a wrong offset!");
static_assert(offsetof(ASHValve, InteractionManager) == 0x000308, "Member 'ASHValve::InteractionManager' has a wrong offset!");
static_assert(offsetof(ASHValve, FocusableComponent) == 0x000310, "Member 'ASHValve::FocusableComponent' has a wrong offset!");
static_assert(offsetof(ASHValve, RequiredRotatedAngle) == 0x000318, "Member 'ASHValve::RequiredRotatedAngle' has a wrong offset!");
static_assert(offsetof(ASHValve, AnimInstanceClass) == 0x000320, "Member 'ASHValve::AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(ASHValve, ValveMeshAngleCurveEffector) == 0x000350, "Member 'ASHValve::ValveMeshAngleCurveEffector' has a wrong offset!");
static_assert(offsetof(ASHValve, ValveTurnFirstPhaseAngleCurve) == 0x000368, "Member 'ASHValve::ValveTurnFirstPhaseAngleCurve' has a wrong offset!");
static_assert(offsetof(ASHValve, ValveTurnSecondPhaseAngleCurve) == 0x000370, "Member 'ASHValve::ValveTurnSecondPhaseAngleCurve' has a wrong offset!");
static_assert(offsetof(ASHValve, InteractingCharacter) == 0x000378, "Member 'ASHValve::InteractingCharacter' has a wrong offset!");
static_assert(offsetof(ASHValve, LinkedAnimGraphInstance) == 0x000380, "Member 'ASHValve::LinkedAnimGraphInstance' has a wrong offset!");
static_assert(offsetof(ASHValve, TotalRotatedAngle) == 0x000388, "Member 'ASHValve::TotalRotatedAngle' has a wrong offset!");

// Class SHProto.CharacterPlay_LookAtType
// 0x0000 (0x0028 - 0x0028)
class UCharacterPlay_LookAtType final : public USHLookAtTypeID
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterPlay_LookAtType">();
	}
	static class UCharacterPlay_LookAtType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterPlay_LookAtType>();
	}
};
static_assert(alignof(UCharacterPlay_LookAtType) == 0x000008, "Wrong alignment on UCharacterPlay_LookAtType");
static_assert(sizeof(UCharacterPlay_LookAtType) == 0x000028, "Wrong size on UCharacterPlay_LookAtType");

// Class SHProto.SHAkValveComponent
// 0x0010 (0x04C0 - 0x04B0)
class USHAkValveComponent final : public USHAkComponent
{
public:
	class UAkAudioEvent*                          ValveStart_AudioEvent;                             // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ValveStop_AudioEvent;                              // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ValveFinalPush_AudioEvent;                         // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAkValveComponent">();
	}
	static class USHAkValveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAkValveComponent>();
	}
};
static_assert(alignof(USHAkValveComponent) == 0x000010, "Wrong alignment on USHAkValveComponent");
static_assert(sizeof(USHAkValveComponent) == 0x0004C0, "Wrong size on USHAkValveComponent");
static_assert(offsetof(USHAkValveComponent, ValveStart_AudioEvent) == 0x0004A8, "Member 'USHAkValveComponent::ValveStart_AudioEvent' has a wrong offset!");
static_assert(offsetof(USHAkValveComponent, ValveStop_AudioEvent) == 0x0004B0, "Member 'USHAkValveComponent::ValveStop_AudioEvent' has a wrong offset!");
static_assert(offsetof(USHAkValveComponent, ValveFinalPush_AudioEvent) == 0x0004B8, "Member 'USHAkValveComponent::ValveFinalPush_AudioEvent' has a wrong offset!");

// Class SHProto.RetroModeDataAsset
// 0x0020 (0x0050 - 0x0030)
class URetroModeDataAsset final : public UDataAsset
{
public:
	TArray<class UMaterialInterface*>             MaterialsChain;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FConsoleOverrideData>           ConsoleOverrides;                                  // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RetroModeDataAsset">();
	}
	static class URetroModeDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URetroModeDataAsset>();
	}
};
static_assert(alignof(URetroModeDataAsset) == 0x000008, "Wrong alignment on URetroModeDataAsset");
static_assert(sizeof(URetroModeDataAsset) == 0x000050, "Wrong size on URetroModeDataAsset");
static_assert(offsetof(URetroModeDataAsset, MaterialsChain) == 0x000030, "Member 'URetroModeDataAsset::MaterialsChain' has a wrong offset!");
static_assert(offsetof(URetroModeDataAsset, ConsoleOverrides) == 0x000040, "Member 'URetroModeDataAsset::ConsoleOverrides' has a wrong offset!");

// Class SHProto.SHMeleeBaseDamage
// 0x0028 (0x0090 - 0x0068)
class USHMeleeBaseDamage final : public UMeleeDamage
{
public:
	struct FRotator                               HitDirection;                                      // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         HitRotationRatio;                                  // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGroundHit;                                      // 0x0084(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageMultiplier;                                  // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMeleeBaseDamage">();
	}
	static class USHMeleeBaseDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMeleeBaseDamage>();
	}
};
static_assert(alignof(USHMeleeBaseDamage) == 0x000008, "Wrong alignment on USHMeleeBaseDamage");
static_assert(sizeof(USHMeleeBaseDamage) == 0x000090, "Wrong size on USHMeleeBaseDamage");
static_assert(offsetof(USHMeleeBaseDamage, HitDirection) == 0x000068, "Member 'USHMeleeBaseDamage::HitDirection' has a wrong offset!");
static_assert(offsetof(USHMeleeBaseDamage, HitRotationRatio) == 0x000080, "Member 'USHMeleeBaseDamage::HitRotationRatio' has a wrong offset!");
static_assert(offsetof(USHMeleeBaseDamage, bIsGroundHit) == 0x000084, "Member 'USHMeleeBaseDamage::bIsGroundHit' has a wrong offset!");
static_assert(offsetof(USHMeleeBaseDamage, DamageMultiplier) == 0x000088, "Member 'USHMeleeBaseDamage::DamageMultiplier' has a wrong offset!");

// Class SHProto.SHAlreadySeenEndingsEndingFactor
// 0x0000 (0x0030 - 0x0030)
class USHAlreadySeenEndingsEndingFactor final : public USHEndingFactor
{
public:
	void SHDebug_Character_Endings_Factors_AlreadySeenEndings_SetDebugValue(int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAlreadySeenEndingsEndingFactor">();
	}
	static class USHAlreadySeenEndingsEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAlreadySeenEndingsEndingFactor>();
	}
};
static_assert(alignof(USHAlreadySeenEndingsEndingFactor) == 0x000008, "Wrong alignment on USHAlreadySeenEndingsEndingFactor");
static_assert(sizeof(USHAlreadySeenEndingsEndingFactor) == 0x000030, "Wrong size on USHAlreadySeenEndingsEndingFactor");

// Class SHProto.SHAngelaAnimComponent
// 0x0048 (0x02D8 - 0x0290)
class USHAngelaAnimComponent final : public USHAnimComponent
{
public:
	struct FSHAnimHeadRotationBaseSubcompSettings HeadRotationSettings;                              // 0x0290(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAngelaAnimComponent">();
	}
	static class USHAngelaAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAngelaAnimComponent>();
	}
};
static_assert(alignof(USHAngelaAnimComponent) == 0x000008, "Wrong alignment on USHAngelaAnimComponent");
static_assert(sizeof(USHAngelaAnimComponent) == 0x0002D8, "Wrong size on USHAngelaAnimComponent");
static_assert(offsetof(USHAngelaAnimComponent, HeadRotationSettings) == 0x000290, "Member 'USHAngelaAnimComponent::HeadRotationSettings' has a wrong offset!");

// Class SHProto.SHFirearmAimOffsetAnimInstance
// 0x00E0 (0x0430 - 0x0350)
class USHFirearmAimOffsetAnimInstance : public UAnimInstance
{
public:
	bool                                          bIsAiming;                                         // 0x0348(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasAmmo;                                          // 0x0349(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34A[0x6];                                      // 0x034A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              HeadRotation;                                      // 0x0350(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AimOffsetArms;                                     // 0x0360(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAngleToAnimationRangeMap              Offset_NoHead_Vertical_Range;                      // 0x0370(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAngleToAnimationRangeMap              Offset_Head_Vertical_Range;                        // 0x0384(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAngleToAnimationRangeMap              Offset_Hands_Vertical_Range;                       // 0x0398(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAngleToAnimationRangeMap              Offset_NoHead_Horizontal_Range;                    // 0x03AC(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAngleToAnimationRangeMap              Offset_Head_Horizontal_Range;                      // 0x03C0(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAngleToAnimationRangeMap              Offset_Hands_Horizontal_Range;                     // 0x03D4(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          NearWallAimPoseAnimation;                          // 0x03E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AimObstacleTraceProfileName;                       // 0x03F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Offset_NoHead_Vertical_Animation;                  // 0x03F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Offset_Head_Vertical_Animation;                    // 0x0400(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Offset_Hands_Vertical_Animation;                   // 0x0408(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Offset_NoHead_Horizontal_Animation;                // 0x0410(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Offset_Head_Horizontal_Animation;                  // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Offset_Hands_Horizontal_Animation;                 // 0x0420(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float MapRangeClampedWithZeroInTheMidle(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB);

	void InterruptEquipToAim(float BlendOutTime);

	class ASHItemWeapon* GetWeapon() const;
	bool IsAimOffsetEnabled() const;
	bool LongWeaponAimObstacleRangeCheck(const struct FLongWeaponAimObstacleCheckPayload& Payload) const;
	bool LongWeaponAimObstacleSingleCheck(const struct FLongWeaponAimObstacleCheckPayload& Payload) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFirearmAimOffsetAnimInstance">();
	}
	static class USHFirearmAimOffsetAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFirearmAimOffsetAnimInstance>();
	}
};
static_assert(alignof(USHFirearmAimOffsetAnimInstance) == 0x000010, "Wrong alignment on USHFirearmAimOffsetAnimInstance");
static_assert(sizeof(USHFirearmAimOffsetAnimInstance) == 0x000430, "Wrong size on USHFirearmAimOffsetAnimInstance");
static_assert(offsetof(USHFirearmAimOffsetAnimInstance, bIsAiming) == 0x000348, "Member 'USHFirearmAimOffsetAnimInstance::bIsAiming' has a wrong offset!");
static_assert(offsetof(USHFirearmAimOffsetAnimInstance, bHasAmmo) == 0x000349, "Member 'USHFirearmAimOffsetAnimInstance::bHasAmmo' has a wrong offset!");
static_assert(offsetof(USHFirearmAimOffsetAnimInstance, HeadRotation) == 0x000350, "Member 'USHFirearmAimOffsetAnimInstance::HeadRotation' has a wrong offset!");
static_assert(offsetof(USHFirearmAimOffsetAnimInstance, AimOffsetArms) == 0x000360, "Member 'USHFirearmAimOffsetAnimInstance::AimOffsetArms' has a wrong offset!");
static_assert(offsetof(USHFirearmAimOffsetAnimInstance, Offset_NoHead_Vertical_Range) == 0x000370, "Member 'USHFirearmAimOffsetAnimInstance::Offset_NoHead_Vertical_Range' has a wrong offset!");
static_assert(offsetof(USHFirearmAimOffsetAnimInstance, Offset_Head_Vertical_Range) == 0x000384, "Member 'USHFirearmAimOffsetAnimInstance::Offset_Head_Vertical_Range' has a wrong offset!");
static_assert(offsetof(USHFirearmAimOffsetAnimInstance, Offset_Hands_Vertical_Range) == 0x000398, "Member 'USHFirearmAimOffsetAnimInstance::Offset_Hands_Vertical_Range' has a wrong offset!");
static_assert(offsetof(USHFirearmAimOffsetAnimInstance, Offset_NoHead_Horizontal_Range) == 0x0003AC, "Member 'USHFirearmAimOffsetAnimInstance::Offset_NoHead_Horizontal_Range' has a wrong offset!");
static_assert(offsetof(USHFirearmAimOffsetAnimInstance, Offset_Head_Horizontal_Range) == 0x0003C0, "Member 'USHFirearmAimOffsetAnimInstance::Offset_Head_Horizontal_Range' has a wrong offset!");
static_assert(offsetof(USHFirearmAimOffsetAnimInstance, Offset_Hands_Horizontal_Range) == 0x0003D4, "Member 'USHFirearmAimOffsetAnimInstance::Offset_Hands_Horizontal_Range' has a wrong offset!");
static_assert(offsetof(USHFirearmAimOffsetAnimInstance, NearWallAimPoseAnimation) == 0x0003E8, "Member 'USHFirearmAimOffsetAnimInstance::NearWallAimPoseAnimation' has a wrong offset!");
static_assert(offsetof(USHFirearmAimOffsetAnimInstance, AimObstacleTraceProfileName) == 0x0003F0, "Member 'USHFirearmAimOffsetAnimInstance::AimObstacleTraceProfileName' has a wrong offset!");
static_assert(offsetof(USHFirearmAimOffsetAnimInstance, Offset_NoHead_Vertical_Animation) == 0x0003F8, "Member 'USHFirearmAimOffsetAnimInstance::Offset_NoHead_Vertical_Animation' has a wrong offset!");
static_assert(offsetof(USHFirearmAimOffsetAnimInstance, Offset_Head_Vertical_Animation) == 0x000400, "Member 'USHFirearmAimOffsetAnimInstance::Offset_Head_Vertical_Animation' has a wrong offset!");
static_assert(offsetof(USHFirearmAimOffsetAnimInstance, Offset_Hands_Vertical_Animation) == 0x000408, "Member 'USHFirearmAimOffsetAnimInstance::Offset_Hands_Vertical_Animation' has a wrong offset!");
static_assert(offsetof(USHFirearmAimOffsetAnimInstance, Offset_NoHead_Horizontal_Animation) == 0x000410, "Member 'USHFirearmAimOffsetAnimInstance::Offset_NoHead_Horizontal_Animation' has a wrong offset!");
static_assert(offsetof(USHFirearmAimOffsetAnimInstance, Offset_Head_Horizontal_Animation) == 0x000418, "Member 'USHFirearmAimOffsetAnimInstance::Offset_Head_Horizontal_Animation' has a wrong offset!");
static_assert(offsetof(USHFirearmAimOffsetAnimInstance, Offset_Hands_Horizontal_Animation) == 0x000420, "Member 'USHFirearmAimOffsetAnimInstance::Offset_Hands_Horizontal_Animation' has a wrong offset!");

// Class SHProto.SHCharacterPlayAimOffsetMatchingTool
// 0x0000 (0x0430 - 0x0430)
class USHCharacterPlayAimOffsetMatchingTool final : public USHFirearmAimOffsetAnimInstance
{
public:
	static void DrawMuzzleAimTrace(const class UObject* WorldContextObject);

	void FakeAimInput(bool Pressed);
	void FakeRotationInput(float X, float Y);

	float GetCameraPitch() const;
	struct FVector GetCrosshairAimLocation() const;
	struct FVector GetMuzzleAimLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayAimOffsetMatchingTool">();
	}
	static class USHCharacterPlayAimOffsetMatchingTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayAimOffsetMatchingTool>();
	}
};
static_assert(alignof(USHCharacterPlayAimOffsetMatchingTool) == 0x000010, "Wrong alignment on USHCharacterPlayAimOffsetMatchingTool");
static_assert(sizeof(USHCharacterPlayAimOffsetMatchingTool) == 0x000430, "Wrong size on USHCharacterPlayAimOffsetMatchingTool");

// Class SHProto.SHSpawnPoint
// 0x0000 (0x0308 - 0x0308)
class ASHSpawnPoint final : public ASpawnPoint
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSpawnPoint">();
	}
	static class ASHSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHSpawnPoint>();
	}
};
static_assert(alignof(ASHSpawnPoint) == 0x000008, "Wrong alignment on ASHSpawnPoint");
static_assert(sizeof(ASHSpawnPoint) == 0x000308, "Wrong size on ASHSpawnPoint");

// Class SHProto.SHAngelaLookAtLogicComponent
// 0x0010 (0x0190 - 0x0180)
class USHAngelaLookAtLogicComponent final : public USHCharacterLookAtLogicComponent
{
public:
	uint8                                         Pad_180[0x10];                                     // 0x0180(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAngelaLookAtLogicComponent">();
	}
	static class USHAngelaLookAtLogicComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAngelaLookAtLogicComponent>();
	}
};
static_assert(alignof(USHAngelaLookAtLogicComponent) == 0x000008, "Wrong alignment on USHAngelaLookAtLogicComponent");
static_assert(sizeof(USHAngelaLookAtLogicComponent) == 0x000190, "Wrong size on USHAngelaLookAtLogicComponent");

// Class SHProto.InteractionObject_LookAtType
// 0x0000 (0x0028 - 0x0028)
class UInteractionObject_LookAtType final : public USHLookAtTypeID
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionObject_LookAtType">();
	}
	static class UInteractionObject_LookAtType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionObject_LookAtType>();
	}
};
static_assert(alignof(UInteractionObject_LookAtType) == 0x000008, "Wrong alignment on UInteractionObject_LookAtType");
static_assert(sizeof(UInteractionObject_LookAtType) == 0x000028, "Wrong size on UInteractionObject_LookAtType");

// Class SHProto.SHFXNiagaraDecalComponent
// 0x0020 (0x0320 - 0x0300)
class USHFXNiagaraDecalComponent final : public UDecalComponent
{
public:
	class FName                                   ErosionParameterName;                              // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeAwayTime;                                      // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsErosionEnabled;                                  // 0x0304(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseErosionInvert;                                  // 0x0305(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_306[0x2];                                      // 0x0306(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               DecalMaterialDynamic;                              // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetInitialErode(const float InitialErode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXNiagaraDecalComponent">();
	}
	static class USHFXNiagaraDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXNiagaraDecalComponent>();
	}
};
static_assert(alignof(USHFXNiagaraDecalComponent) == 0x000010, "Wrong alignment on USHFXNiagaraDecalComponent");
static_assert(sizeof(USHFXNiagaraDecalComponent) == 0x000320, "Wrong size on USHFXNiagaraDecalComponent");
static_assert(offsetof(USHFXNiagaraDecalComponent, ErosionParameterName) == 0x0002F8, "Member 'USHFXNiagaraDecalComponent::ErosionParameterName' has a wrong offset!");
static_assert(offsetof(USHFXNiagaraDecalComponent, FadeAwayTime) == 0x000300, "Member 'USHFXNiagaraDecalComponent::FadeAwayTime' has a wrong offset!");
static_assert(offsetof(USHFXNiagaraDecalComponent, IsErosionEnabled) == 0x000304, "Member 'USHFXNiagaraDecalComponent::IsErosionEnabled' has a wrong offset!");
static_assert(offsetof(USHFXNiagaraDecalComponent, UseErosionInvert) == 0x000305, "Member 'USHFXNiagaraDecalComponent::UseErosionInvert' has a wrong offset!");
static_assert(offsetof(USHFXNiagaraDecalComponent, DecalMaterialDynamic) == 0x000308, "Member 'USHFXNiagaraDecalComponent::DecalMaterialDynamic' has a wrong offset!");

// Class SHProto.SHLookAtTargetProvider
// 0x0040 (0x0068 - 0x0028)
class USHLookAtTargetProvider : public UObject
{
public:
	float                                         BlendInSpeed;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutSpeed;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHCharacterLookAtLogicComponent*       LookAtLogic;                                       // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   LookAtTypeID;                                      // 0x0038(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLookAtTargetProvider">();
	}
	static class USHLookAtTargetProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLookAtTargetProvider>();
	}
};
static_assert(alignof(USHLookAtTargetProvider) == 0x000008, "Wrong alignment on USHLookAtTargetProvider");
static_assert(sizeof(USHLookAtTargetProvider) == 0x000068, "Wrong size on USHLookAtTargetProvider");
static_assert(offsetof(USHLookAtTargetProvider, BlendInSpeed) == 0x000028, "Member 'USHLookAtTargetProvider::BlendInSpeed' has a wrong offset!");
static_assert(offsetof(USHLookAtTargetProvider, BlendOutSpeed) == 0x00002C, "Member 'USHLookAtTargetProvider::BlendOutSpeed' has a wrong offset!");
static_assert(offsetof(USHLookAtTargetProvider, LookAtLogic) == 0x000030, "Member 'USHLookAtTargetProvider::LookAtLogic' has a wrong offset!");
static_assert(offsetof(USHLookAtTargetProvider, LookAtTypeID) == 0x000038, "Member 'USHLookAtTargetProvider::LookAtTypeID' has a wrong offset!");

// Class SHProto.SHFXPukePuddleDamageSubcompSettings
// 0x0010 (0x0040 - 0x0030)
class USHFXPukePuddleDamageSubcompSettings final : public UDataAsset
{
public:
	bool                                          EnablePukeDamage;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PukePuddleDamageCooldown;                          // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableFootstepDamageBlock;                         // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootstepDamageBlockCooldown;                       // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXPukePuddleDamageSubcompSettings">();
	}
	static class USHFXPukePuddleDamageSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXPukePuddleDamageSubcompSettings>();
	}
};
static_assert(alignof(USHFXPukePuddleDamageSubcompSettings) == 0x000008, "Wrong alignment on USHFXPukePuddleDamageSubcompSettings");
static_assert(sizeof(USHFXPukePuddleDamageSubcompSettings) == 0x000040, "Wrong size on USHFXPukePuddleDamageSubcompSettings");
static_assert(offsetof(USHFXPukePuddleDamageSubcompSettings, EnablePukeDamage) == 0x000030, "Member 'USHFXPukePuddleDamageSubcompSettings::EnablePukeDamage' has a wrong offset!");
static_assert(offsetof(USHFXPukePuddleDamageSubcompSettings, PukePuddleDamageCooldown) == 0x000034, "Member 'USHFXPukePuddleDamageSubcompSettings::PukePuddleDamageCooldown' has a wrong offset!");
static_assert(offsetof(USHFXPukePuddleDamageSubcompSettings, EnableFootstepDamageBlock) == 0x000038, "Member 'USHFXPukePuddleDamageSubcompSettings::EnableFootstepDamageBlock' has a wrong offset!");
static_assert(offsetof(USHFXPukePuddleDamageSubcompSettings, FootstepDamageBlockCooldown) == 0x00003C, "Member 'USHFXPukePuddleDamageSubcompSettings::FootstepDamageBlockCooldown' has a wrong offset!");

// Class SHProto.SHAngelaLookAtTargetProvider
// 0x0008 (0x0070 - 0x0068)
class USHAngelaLookAtTargetProvider final : public USHLookAtTargetProvider
{
public:
	float                                         MaxDistance;                                       // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle;                                          // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAngelaLookAtTargetProvider">();
	}
	static class USHAngelaLookAtTargetProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAngelaLookAtTargetProvider>();
	}
};
static_assert(alignof(USHAngelaLookAtTargetProvider) == 0x000008, "Wrong alignment on USHAngelaLookAtTargetProvider");
static_assert(sizeof(USHAngelaLookAtTargetProvider) == 0x000070, "Wrong size on USHAngelaLookAtTargetProvider");
static_assert(offsetof(USHAngelaLookAtTargetProvider, MaxDistance) == 0x000068, "Member 'USHAngelaLookAtTargetProvider::MaxDistance' has a wrong offset!");
static_assert(offsetof(USHAngelaLookAtTargetProvider, MaxAngle) == 0x00006C, "Member 'USHAngelaLookAtTargetProvider::MaxAngle' has a wrong offset!");

// Class SHProto.SHUndefindedDamage
// 0x0000 (0x0040 - 0x0040)
class USHUndefindedDamage final : public UDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHUndefindedDamage">();
	}
	static class USHUndefindedDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHUndefindedDamage>();
	}
};
static_assert(alignof(USHUndefindedDamage) == 0x000008, "Wrong alignment on USHUndefindedDamage");
static_assert(sizeof(USHUndefindedDamage) == 0x000040, "Wrong size on USHUndefindedDamage");

// Class SHProto.SHTraversalLadderAnimInstance
// 0x00A0 (0x03F0 - 0x0350)
class USHTraversalLadderAnimInstance final : public UAnimInstance
{
public:
	bool                                          bHasLadderEvenNumberOfSteps;                       // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESHDetectionSide                              CharacterTraversalSide;                            // 0x0349(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayStartTraversal;                               // 0x034A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayEndTraversal;                                 // 0x034B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurrentInputValue;                                 // 0x0350(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      EndAnimAbove;                                      // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      EndAnimBelow;                                      // 0x0370(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      StartAnimAbove_OddNumberOfSteps;                   // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      StartAnimAbove_EvenNumberOfSteps;                  // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      StartAnimBelow;                                    // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              CharacterViewRotation;                             // 0x0390(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StepDelta;                                         // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TraversalPathOffsetRelativeToSteps;                // 0x03A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AboveFloorRelativeToStep;                          // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BelowFloorRelativeToStep;                          // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x30];                                     // 0x03C0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastEndOfTraversalFinish();
	void BroadcastEndOfTraversalStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalLadderAnimInstance">();
	}
	static class USHTraversalLadderAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTraversalLadderAnimInstance>();
	}
};
static_assert(alignof(USHTraversalLadderAnimInstance) == 0x000010, "Wrong alignment on USHTraversalLadderAnimInstance");
static_assert(sizeof(USHTraversalLadderAnimInstance) == 0x0003F0, "Wrong size on USHTraversalLadderAnimInstance");
static_assert(offsetof(USHTraversalLadderAnimInstance, bHasLadderEvenNumberOfSteps) == 0x000348, "Member 'USHTraversalLadderAnimInstance::bHasLadderEvenNumberOfSteps' has a wrong offset!");
static_assert(offsetof(USHTraversalLadderAnimInstance, CharacterTraversalSide) == 0x000349, "Member 'USHTraversalLadderAnimInstance::CharacterTraversalSide' has a wrong offset!");
static_assert(offsetof(USHTraversalLadderAnimInstance, bPlayStartTraversal) == 0x00034A, "Member 'USHTraversalLadderAnimInstance::bPlayStartTraversal' has a wrong offset!");
static_assert(offsetof(USHTraversalLadderAnimInstance, bPlayEndTraversal) == 0x00034B, "Member 'USHTraversalLadderAnimInstance::bPlayEndTraversal' has a wrong offset!");
static_assert(offsetof(USHTraversalLadderAnimInstance, CurrentInputValue) == 0x000350, "Member 'USHTraversalLadderAnimInstance::CurrentInputValue' has a wrong offset!");
static_assert(offsetof(USHTraversalLadderAnimInstance, EndAnimAbove) == 0x000368, "Member 'USHTraversalLadderAnimInstance::EndAnimAbove' has a wrong offset!");
static_assert(offsetof(USHTraversalLadderAnimInstance, EndAnimBelow) == 0x000370, "Member 'USHTraversalLadderAnimInstance::EndAnimBelow' has a wrong offset!");
static_assert(offsetof(USHTraversalLadderAnimInstance, StartAnimAbove_OddNumberOfSteps) == 0x000378, "Member 'USHTraversalLadderAnimInstance::StartAnimAbove_OddNumberOfSteps' has a wrong offset!");
static_assert(offsetof(USHTraversalLadderAnimInstance, StartAnimAbove_EvenNumberOfSteps) == 0x000380, "Member 'USHTraversalLadderAnimInstance::StartAnimAbove_EvenNumberOfSteps' has a wrong offset!");
static_assert(offsetof(USHTraversalLadderAnimInstance, StartAnimBelow) == 0x000388, "Member 'USHTraversalLadderAnimInstance::StartAnimBelow' has a wrong offset!");
static_assert(offsetof(USHTraversalLadderAnimInstance, CharacterViewRotation) == 0x000390, "Member 'USHTraversalLadderAnimInstance::CharacterViewRotation' has a wrong offset!");
static_assert(offsetof(USHTraversalLadderAnimInstance, StepDelta) == 0x0003A0, "Member 'USHTraversalLadderAnimInstance::StepDelta' has a wrong offset!");
static_assert(offsetof(USHTraversalLadderAnimInstance, TraversalPathOffsetRelativeToSteps) == 0x0003A8, "Member 'USHTraversalLadderAnimInstance::TraversalPathOffsetRelativeToSteps' has a wrong offset!");
static_assert(offsetof(USHTraversalLadderAnimInstance, AboveFloorRelativeToStep) == 0x0003B8, "Member 'USHTraversalLadderAnimInstance::AboveFloorRelativeToStep' has a wrong offset!");
static_assert(offsetof(USHTraversalLadderAnimInstance, BelowFloorRelativeToStep) == 0x0003BC, "Member 'USHTraversalLadderAnimInstance::BelowFloorRelativeToStep' has a wrong offset!");

// Class SHProto.SHAngelasKnifeInvestigationEndingFactor
// 0x0000 (0x0088 - 0x0088)
class USHAngelasKnifeInvestigationEndingFactor final : public USHIntEndingFactor
{
public:
	void SHDebug_Character_Endings_AngelasKnifeInvestigationEndingFactor_SetDebugValue(int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAngelasKnifeInvestigationEndingFactor">();
	}
	static class USHAngelasKnifeInvestigationEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAngelasKnifeInvestigationEndingFactor>();
	}
};
static_assert(alignof(USHAngelasKnifeInvestigationEndingFactor) == 0x000008, "Wrong alignment on USHAngelasKnifeInvestigationEndingFactor");
static_assert(sizeof(USHAngelasKnifeInvestigationEndingFactor) == 0x000088, "Wrong size on USHAngelasKnifeInvestigationEndingFactor");

// Class SHProto.SHDeathPlayer
// 0x0050 (0x0300 - 0x02B0)
class ASHDeathPlayer : public AActor
{
public:
	struct FSHDeathPlayerFinishPostProcessData    FinishPostProcessData;                             // 0x02B0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPlayerCharacterEnsureNoEquippedWeapon;            // 0x02D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHMaterialPropertyControlHandler> FinishPostProcessMaterialHandlers;                 // 0x02E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleCameraAnimBlendOut();
	void HandleCameraAnimStopped();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDeathPlayer">();
	}
	static class ASHDeathPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHDeathPlayer>();
	}
};
static_assert(alignof(ASHDeathPlayer) == 0x000008, "Wrong alignment on ASHDeathPlayer");
static_assert(sizeof(ASHDeathPlayer) == 0x000300, "Wrong size on ASHDeathPlayer");
static_assert(offsetof(ASHDeathPlayer, FinishPostProcessData) == 0x0002B0, "Member 'ASHDeathPlayer::FinishPostProcessData' has a wrong offset!");
static_assert(offsetof(ASHDeathPlayer, bPlayerCharacterEnsureNoEquippedWeapon) == 0x0002D8, "Member 'ASHDeathPlayer::bPlayerCharacterEnsureNoEquippedWeapon' has a wrong offset!");
static_assert(offsetof(ASHDeathPlayer, FinishPostProcessMaterialHandlers) == 0x0002E0, "Member 'ASHDeathPlayer::FinishPostProcessMaterialHandlers' has a wrong offset!");

// Class SHProto.SHAnimActionExecutiveBase
// 0x0040 (0x0068 - 0x0028)
class USHAnimActionExecutiveBase : public UObject
{
public:
	FMulticastInlineDelegateProperty_             EndPlayEvent;                                      // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class ACharacter*                             OwnerCharacter;                                    // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Abort();
	void AnimActionExeBaseBlueprintEvent__DelegateSignature(class USHAnimActionExecutiveBase* AnimActionExePtr);
	void Finish(bool Success);
	void OnBreak();
	void OnFinish();
	void OnStart();
	void OnTick(float DeltaSeconds);
	void Start();

	class UObject* GetContextObject() const;
	class ACharacter* GetOwnerCharacter() const;
	TArray<TSoftObjectPtr<class UObject>> GetSoftAssets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimActionExecutiveBase">();
	}
	static class USHAnimActionExecutiveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimActionExecutiveBase>();
	}
};
static_assert(alignof(USHAnimActionExecutiveBase) == 0x000008, "Wrong alignment on USHAnimActionExecutiveBase");
static_assert(sizeof(USHAnimActionExecutiveBase) == 0x000068, "Wrong size on USHAnimActionExecutiveBase");
static_assert(offsetof(USHAnimActionExecutiveBase, EndPlayEvent) == 0x000028, "Member 'USHAnimActionExecutiveBase::EndPlayEvent' has a wrong offset!");
static_assert(offsetof(USHAnimActionExecutiveBase, OwnerCharacter) == 0x000038, "Member 'USHAnimActionExecutiveBase::OwnerCharacter' has a wrong offset!");

// Class SHProto.SHAnimActionExecutive
// 0x0008 (0x0070 - 0x0068)
class USHAnimActionExecutive : public USHAnimActionExecutiveBase
{
public:
	class USHAnimMontagePlayer*                   AnimPlayer;                                        // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class USHAnimMontagePlayer* GetAnimPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimActionExecutive">();
	}
	static class USHAnimActionExecutive* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimActionExecutive>();
	}
};
static_assert(alignof(USHAnimActionExecutive) == 0x000008, "Wrong alignment on USHAnimActionExecutive");
static_assert(sizeof(USHAnimActionExecutive) == 0x000070, "Wrong size on USHAnimActionExecutive");
static_assert(offsetof(USHAnimActionExecutive, AnimPlayer) == 0x000068, "Member 'USHAnimActionExecutive::AnimPlayer' has a wrong offset!");

// Class SHProto.SHCharacterPlayBrainComponent
// 0x0078 (0x0118 - 0x00A0)
class USHCharacterPlayBrainComponent final : public UActorComponent
{
public:
	float                                         InventoryMapHoldValue;                             // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x68];                                      // 0x00B0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearControlRotationInterpSpeed(const class UObject* Object);
	void SetControlRotationInterpSpeed(const float Speed, const class UObject* Object);
	void SetGameplayMenuBlocked(const bool Blocked, const class UObject* Object);
	void SetUpdateControlRotationBlocked(const bool Blocked, const class UObject* Object);
	void SetUpdateControlRotationWhenIsNotMoving(const bool Update, const class UObject* Object);
	void SHDebug_Character_Input_FreezeControlRotation();
	void SHDebug_Character_Input_ValuesDebug();

	bool GetUpdateControlRotationWhenIsNotMoving() const;
	bool IsGameplayMenuBlocked() const;
	bool IsUpdateControlRotationBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayBrainComponent">();
	}
	static class USHCharacterPlayBrainComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayBrainComponent>();
	}
};
static_assert(alignof(USHCharacterPlayBrainComponent) == 0x000008, "Wrong alignment on USHCharacterPlayBrainComponent");
static_assert(sizeof(USHCharacterPlayBrainComponent) == 0x000118, "Wrong size on USHCharacterPlayBrainComponent");
static_assert(offsetof(USHCharacterPlayBrainComponent, InventoryMapHoldValue) == 0x0000A0, "Member 'USHCharacterPlayBrainComponent::InventoryMapHoldValue' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayBrainComponent, OwnerCharacter) == 0x0000A8, "Member 'USHCharacterPlayBrainComponent::OwnerCharacter' has a wrong offset!");

// Class SHProto.SHItemUseExecutive
// 0x0090 (0x00B8 - 0x0028)
class USHItemUseExecutive : public UObject
{
public:
	bool                                          bUseCustomSetupData;                               // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHItemUseExeCustomSetupData>   OverrideDataRows;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllowCombatInterupt;                              // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtAlphaBlendInSpeed;                           // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtAlphaBlendOutSpeed;                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowHoldingWeapons;                              // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowSprint;                                      // 0x004D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCustomMovementData;                            // 0x004E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F[0x1];                                       // 0x004F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHMovementDataStruct                  MovementData;                                      // 0x0050(0x0028)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class ACharacter*                             OwnerCharacter;                                    // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x38];                                      // 0x0080(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyItem();
	void Finish(ESHUseFinishType FinishType);
	void OnItemSpawn(class ASHItemBase* ItemPtr);
	void OnUse();
	void PreItemDespawn(class ASHItemBase* ItemPtr);
	void UseBreak();

	class ASHItemBase* GetItem(int32 ForIndex) const;
	const class FName GetItemContext() const;
	const struct FSHItemDataStruct GetItemData() const;
	class ACharacter* GetOwnerCharacter() const;
	bool WasBreakRequested() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemUseExecutive">();
	}
	static class USHItemUseExecutive* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHItemUseExecutive>();
	}
};
static_assert(alignof(USHItemUseExecutive) == 0x000008, "Wrong alignment on USHItemUseExecutive");
static_assert(sizeof(USHItemUseExecutive) == 0x0000B8, "Wrong size on USHItemUseExecutive");
static_assert(offsetof(USHItemUseExecutive, bUseCustomSetupData) == 0x000028, "Member 'USHItemUseExecutive::bUseCustomSetupData' has a wrong offset!");
static_assert(offsetof(USHItemUseExecutive, OverrideDataRows) == 0x000030, "Member 'USHItemUseExecutive::OverrideDataRows' has a wrong offset!");
static_assert(offsetof(USHItemUseExecutive, bAllowCombatInterupt) == 0x000040, "Member 'USHItemUseExecutive::bAllowCombatInterupt' has a wrong offset!");
static_assert(offsetof(USHItemUseExecutive, LookAtAlphaBlendInSpeed) == 0x000044, "Member 'USHItemUseExecutive::LookAtAlphaBlendInSpeed' has a wrong offset!");
static_assert(offsetof(USHItemUseExecutive, LookAtAlphaBlendOutSpeed) == 0x000048, "Member 'USHItemUseExecutive::LookAtAlphaBlendOutSpeed' has a wrong offset!");
static_assert(offsetof(USHItemUseExecutive, bAllowHoldingWeapons) == 0x00004C, "Member 'USHItemUseExecutive::bAllowHoldingWeapons' has a wrong offset!");
static_assert(offsetof(USHItemUseExecutive, bAllowSprint) == 0x00004D, "Member 'USHItemUseExecutive::bAllowSprint' has a wrong offset!");
static_assert(offsetof(USHItemUseExecutive, bUseCustomMovementData) == 0x00004E, "Member 'USHItemUseExecutive::bUseCustomMovementData' has a wrong offset!");
static_assert(offsetof(USHItemUseExecutive, MovementData) == 0x000050, "Member 'USHItemUseExecutive::MovementData' has a wrong offset!");
static_assert(offsetof(USHItemUseExecutive, OwnerCharacter) == 0x000078, "Member 'USHItemUseExecutive::OwnerCharacter' has a wrong offset!");

// Class SHProto.SHStealthModeCmbSubcompSettings
// 0x0058 (0x0088 - 0x0030)
class USHStealthModeCmbSubcompSettings final : public UDataAsset
{
public:
	float                                         RotationInputScale;                                // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlRotationInterpSpeed;                        // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSHMovementDataStruct                  MovementData;                                      // 0x0038(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FOVValue;                                          // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHBlendData                           FOVBlend;                                          // 0x0068(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHStealthModeCmbSubcompSettings">();
	}
	static class USHStealthModeCmbSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHStealthModeCmbSubcompSettings>();
	}
};
static_assert(alignof(USHStealthModeCmbSubcompSettings) == 0x000008, "Wrong alignment on USHStealthModeCmbSubcompSettings");
static_assert(sizeof(USHStealthModeCmbSubcompSettings) == 0x000088, "Wrong size on USHStealthModeCmbSubcompSettings");
static_assert(offsetof(USHStealthModeCmbSubcompSettings, RotationInputScale) == 0x000030, "Member 'USHStealthModeCmbSubcompSettings::RotationInputScale' has a wrong offset!");
static_assert(offsetof(USHStealthModeCmbSubcompSettings, ControlRotationInterpSpeed) == 0x000034, "Member 'USHStealthModeCmbSubcompSettings::ControlRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(USHStealthModeCmbSubcompSettings, MovementData) == 0x000038, "Member 'USHStealthModeCmbSubcompSettings::MovementData' has a wrong offset!");
static_assert(offsetof(USHStealthModeCmbSubcompSettings, FOVValue) == 0x000060, "Member 'USHStealthModeCmbSubcompSettings::FOVValue' has a wrong offset!");
static_assert(offsetof(USHStealthModeCmbSubcompSettings, FOVBlend) == 0x000068, "Member 'USHStealthModeCmbSubcompSettings::FOVBlend' has a wrong offset!");

// Class SHProto.SHAnimatedItemUseExecutive
// 0x00B8 (0x0170 - 0x00B8)
class USHAnimatedItemUseExecutive : public USHItemUseExecutive
{
public:
	struct FPlayAnimationData                     AnimationToPlay;                                   // 0x00B8(0x00B0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class USHAnimMontagePlayer*                   AnimPlayer;                                        // 0x0168(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ProcessAnimationEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimatedItemUseExecutive">();
	}
	static class USHAnimatedItemUseExecutive* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimatedItemUseExecutive>();
	}
};
static_assert(alignof(USHAnimatedItemUseExecutive) == 0x000008, "Wrong alignment on USHAnimatedItemUseExecutive");
static_assert(sizeof(USHAnimatedItemUseExecutive) == 0x000170, "Wrong size on USHAnimatedItemUseExecutive");
static_assert(offsetof(USHAnimatedItemUseExecutive, AnimationToPlay) == 0x0000B8, "Member 'USHAnimatedItemUseExecutive::AnimationToPlay' has a wrong offset!");
static_assert(offsetof(USHAnimatedItemUseExecutive, AnimPlayer) == 0x000168, "Member 'USHAnimatedItemUseExecutive::AnimPlayer' has a wrong offset!");

// Class SHProto.SHCharacterPlayAnimActionExe
// 0x0008 (0x0078 - 0x0070)
class USHCharacterPlayAnimActionExe final : public USHAnimActionExecutive
{
public:
	bool                                          bBlockMovement;                                    // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlockViewRotation;                                // 0x0071(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowCombatActions;                               // 0x0072(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_73[0x5];                                       // 0x0073(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessCharacterCombatInputModeChangedEvent(class USHCharacterPlayCombatComponent* CombatComp);
	void ProcessCharacterReceivedHitEvent(class USHCharacterPlayCombatComponent* CombatComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayAnimActionExe">();
	}
	static class USHCharacterPlayAnimActionExe* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayAnimActionExe>();
	}
};
static_assert(alignof(USHCharacterPlayAnimActionExe) == 0x000008, "Wrong alignment on USHCharacterPlayAnimActionExe");
static_assert(sizeof(USHCharacterPlayAnimActionExe) == 0x000078, "Wrong size on USHCharacterPlayAnimActionExe");
static_assert(offsetof(USHCharacterPlayAnimActionExe, bBlockMovement) == 0x000070, "Member 'USHCharacterPlayAnimActionExe::bBlockMovement' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayAnimActionExe, bBlockViewRotation) == 0x000071, "Member 'USHCharacterPlayAnimActionExe::bBlockViewRotation' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayAnimActionExe, bAllowCombatActions) == 0x000072, "Member 'USHCharacterPlayAnimActionExe::bAllowCombatActions' has a wrong offset!");

// Class SHProto.SHFXPukeExplosionSubcomp
// 0x0028 (0x0060 - 0x0038)
class USHFXPukeExplosionSubcomp : public USHFXSubcomponent
{
public:
	class USHFXPukeExplosionSubcompSettings*      Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPukeExplosion();
	void StartPukeExplosion();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXPukeExplosionSubcomp">();
	}
	static class USHFXPukeExplosionSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXPukeExplosionSubcomp>();
	}
};
static_assert(alignof(USHFXPukeExplosionSubcomp) == 0x000008, "Wrong alignment on USHFXPukeExplosionSubcomp");
static_assert(sizeof(USHFXPukeExplosionSubcomp) == 0x000060, "Wrong size on USHFXPukeExplosionSubcomp");
static_assert(offsetof(USHFXPukeExplosionSubcomp, Settings) == 0x000038, "Member 'USHFXPukeExplosionSubcomp::Settings' has a wrong offset!");

// Class SHProto.SHFXAtackPukeExplosionSubcomp
// 0x0000 (0x0060 - 0x0060)
class USHFXAtackPukeExplosionSubcomp final : public USHFXPukeExplosionSubcomp
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXAtackPukeExplosionSubcomp">();
	}
	static class USHFXAtackPukeExplosionSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXAtackPukeExplosionSubcomp>();
	}
};
static_assert(alignof(USHFXAtackPukeExplosionSubcomp) == 0x000008, "Wrong alignment on USHFXAtackPukeExplosionSubcomp");
static_assert(sizeof(USHFXAtackPukeExplosionSubcomp) == 0x000060, "Wrong size on USHFXAtackPukeExplosionSubcomp");

// Class SHProto.SHAnimationStatics
// 0x0000 (0x0028 - 0x0028)
class USHAnimationStatics final : public UBlueprintFunctionLibrary
{
public:
	static float FindAveragePlayTimeOfBlendSpace(class UBlendSpace* InBlendSpace);
	static float FindMaximumPlayTimeOfBlendSpace(class UBlendSpace* InBlendSpace);
	static float FindMinimumPlayTimeOfBlendSpace(class UBlendSpace* InBlendSpace);
	static float FindPlayTimeOfBlendSpaceForInput(class UBlendSpace* InBlendSpace, const struct FVector& InInput);
	static bool HasActiveRotateInPlaceCurve(class UAnimInstance* InAnimInstance);
	static bool VerifyBlendSpaceSamplesDifference(class UBlendSpace* InBlendSpace, float InMaximumAllowedDifference, const class FString& InDebugWarningMessage);
	static bool VerifyBlendSpaceSamplesMaximumDuration(class UBlendSpace* InBlendSpace, float InMaximumAllowedDuration, const class FString& InDebugWarningMessage);
	static bool VerifyBlendSpaceSamplesMinimumDuration(class UBlendSpace* InBlendSpace, float InMinimumAllowedDuration, const class FString& InDebugWarningMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimationStatics">();
	}
	static class USHAnimationStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimationStatics>();
	}
};
static_assert(alignof(USHAnimationStatics) == 0x000008, "Wrong alignment on USHAnimationStatics");
static_assert(sizeof(USHAnimationStatics) == 0x000028, "Wrong size on USHAnimationStatics");

// Class SHProto.SHFXSwarmSubcompSettings
// 0x0008 (0x0038 - 0x0030)
class USHFXSwarmSubcompSettings final : public UDataAsset
{
public:
	bool                                          EnableSwarmVolumesVisibility;                      // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckVisibilityDelay;                              // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXSwarmSubcompSettings">();
	}
	static class USHFXSwarmSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXSwarmSubcompSettings>();
	}
};
static_assert(alignof(USHFXSwarmSubcompSettings) == 0x000008, "Wrong alignment on USHFXSwarmSubcompSettings");
static_assert(sizeof(USHFXSwarmSubcompSettings) == 0x000038, "Wrong size on USHFXSwarmSubcompSettings");
static_assert(offsetof(USHFXSwarmSubcompSettings, EnableSwarmVolumesVisibility) == 0x000030, "Member 'USHFXSwarmSubcompSettings::EnableSwarmVolumesVisibility' has a wrong offset!");
static_assert(offsetof(USHFXSwarmSubcompSettings, CheckVisibilityDelay) == 0x000034, "Member 'USHFXSwarmSubcompSettings::CheckVisibilityDelay' has a wrong offset!");

// Class SHProto.SHFXBleedingSubcompSettings
// 0x0028 (0x0058 - 0x0030)
class USHFXBleedingSubcompSettings final : public UDataAsset
{
public:
	bool                                          EnableBleeding;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BleedingShowBelowHP;                               // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BleedingDelaySpawnWhenMaxHP;                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BleedingDelaySpawnWhenMinHP;                       // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BleedingDistanceToCount;                           // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         BleedingParticleTemplate;                          // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BleedingRootSocketName;                            // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXBleedingSubcompSettings">();
	}
	static class USHFXBleedingSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXBleedingSubcompSettings>();
	}
};
static_assert(alignof(USHFXBleedingSubcompSettings) == 0x000008, "Wrong alignment on USHFXBleedingSubcompSettings");
static_assert(sizeof(USHFXBleedingSubcompSettings) == 0x000058, "Wrong size on USHFXBleedingSubcompSettings");
static_assert(offsetof(USHFXBleedingSubcompSettings, EnableBleeding) == 0x000030, "Member 'USHFXBleedingSubcompSettings::EnableBleeding' has a wrong offset!");
static_assert(offsetof(USHFXBleedingSubcompSettings, BleedingShowBelowHP) == 0x000034, "Member 'USHFXBleedingSubcompSettings::BleedingShowBelowHP' has a wrong offset!");
static_assert(offsetof(USHFXBleedingSubcompSettings, BleedingDelaySpawnWhenMaxHP) == 0x000038, "Member 'USHFXBleedingSubcompSettings::BleedingDelaySpawnWhenMaxHP' has a wrong offset!");
static_assert(offsetof(USHFXBleedingSubcompSettings, BleedingDelaySpawnWhenMinHP) == 0x00003C, "Member 'USHFXBleedingSubcompSettings::BleedingDelaySpawnWhenMinHP' has a wrong offset!");
static_assert(offsetof(USHFXBleedingSubcompSettings, BleedingDistanceToCount) == 0x000040, "Member 'USHFXBleedingSubcompSettings::BleedingDistanceToCount' has a wrong offset!");
static_assert(offsetof(USHFXBleedingSubcompSettings, BleedingParticleTemplate) == 0x000048, "Member 'USHFXBleedingSubcompSettings::BleedingParticleTemplate' has a wrong offset!");
static_assert(offsetof(USHFXBleedingSubcompSettings, BleedingRootSocketName) == 0x000050, "Member 'USHFXBleedingSubcompSettings::BleedingRootSocketName' has a wrong offset!");

// Class SHProto.SHPlayerCameraOverlapReceiveComponent
// 0x0028 (0x00C8 - 0x00A0)
class USHPlayerCameraOverlapReceiveComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnOverlapStarted;                                  // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnOverlapEnded;                                    // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPlayerCameraOverlapReceiveComponent">();
	}
	static class USHPlayerCameraOverlapReceiveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPlayerCameraOverlapReceiveComponent>();
	}
};
static_assert(alignof(USHPlayerCameraOverlapReceiveComponent) == 0x000008, "Wrong alignment on USHPlayerCameraOverlapReceiveComponent");
static_assert(sizeof(USHPlayerCameraOverlapReceiveComponent) == 0x0000C8, "Wrong size on USHPlayerCameraOverlapReceiveComponent");
static_assert(offsetof(USHPlayerCameraOverlapReceiveComponent, OnOverlapStarted) == 0x0000A0, "Member 'USHPlayerCameraOverlapReceiveComponent::OnOverlapStarted' has a wrong offset!");
static_assert(offsetof(USHPlayerCameraOverlapReceiveComponent, OnOverlapEnded) == 0x0000B0, "Member 'USHPlayerCameraOverlapReceiveComponent::OnOverlapEnded' has a wrong offset!");

// Class SHProto.SHCharacterPlayCameraOverlapHandleComponent
// 0x0038 (0x0100 - 0x00C8)
class USHCharacterPlayCameraOverlapHandleComponent final : public USHPlayerCameraOverlapReceiveComponent
{
public:
	float                                         MinimumHiddenTime;                                 // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASHCharacterPlay*                       OwnerCharacterPlay;                                // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x28];                                      // 0x00D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Character_CameraOverlapHandler_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayCameraOverlapHandleComponent">();
	}
	static class USHCharacterPlayCameraOverlapHandleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayCameraOverlapHandleComponent>();
	}
};
static_assert(alignof(USHCharacterPlayCameraOverlapHandleComponent) == 0x000008, "Wrong alignment on USHCharacterPlayCameraOverlapHandleComponent");
static_assert(sizeof(USHCharacterPlayCameraOverlapHandleComponent) == 0x000100, "Wrong size on USHCharacterPlayCameraOverlapHandleComponent");
static_assert(offsetof(USHCharacterPlayCameraOverlapHandleComponent, MinimumHiddenTime) == 0x0000C8, "Member 'USHCharacterPlayCameraOverlapHandleComponent::MinimumHiddenTime' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayCameraOverlapHandleComponent, OwnerCharacterPlay) == 0x0000D0, "Member 'USHCharacterPlayCameraOverlapHandleComponent::OwnerCharacterPlay' has a wrong offset!");

// Class SHProto.SHAnimCombatSubcomp
// 0x0060 (0x0098 - 0x0038)
class USHAnimCombatSubcomp final : public USHAnimSubcomponentBase
{
public:
	class USHAnimMontagePlayer*                   ReciveHit;                                         // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAnimMontagePlayer*                   WeaponShow;                                        // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAnimMontagePlayer*                   WeaponHide;                                        // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAnimMontagePlayer*                   WeaponChange;                                      // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAnimMontagePlayer*                   Attack;                                            // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAnimMontagePlayer*                   RangedFire;                                        // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAnimMontagePlayer*                   RangedReload;                                      // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAnimMontagePlayer*                   Dodge;                                             // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x20];                                      // 0x0078(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimCombatSubcomp">();
	}
	static class USHAnimCombatSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimCombatSubcomp>();
	}
};
static_assert(alignof(USHAnimCombatSubcomp) == 0x000008, "Wrong alignment on USHAnimCombatSubcomp");
static_assert(sizeof(USHAnimCombatSubcomp) == 0x000098, "Wrong size on USHAnimCombatSubcomp");
static_assert(offsetof(USHAnimCombatSubcomp, ReciveHit) == 0x000038, "Member 'USHAnimCombatSubcomp::ReciveHit' has a wrong offset!");
static_assert(offsetof(USHAnimCombatSubcomp, WeaponShow) == 0x000040, "Member 'USHAnimCombatSubcomp::WeaponShow' has a wrong offset!");
static_assert(offsetof(USHAnimCombatSubcomp, WeaponHide) == 0x000048, "Member 'USHAnimCombatSubcomp::WeaponHide' has a wrong offset!");
static_assert(offsetof(USHAnimCombatSubcomp, WeaponChange) == 0x000050, "Member 'USHAnimCombatSubcomp::WeaponChange' has a wrong offset!");
static_assert(offsetof(USHAnimCombatSubcomp, Attack) == 0x000058, "Member 'USHAnimCombatSubcomp::Attack' has a wrong offset!");
static_assert(offsetof(USHAnimCombatSubcomp, RangedFire) == 0x000060, "Member 'USHAnimCombatSubcomp::RangedFire' has a wrong offset!");
static_assert(offsetof(USHAnimCombatSubcomp, RangedReload) == 0x000068, "Member 'USHAnimCombatSubcomp::RangedReload' has a wrong offset!");
static_assert(offsetof(USHAnimCombatSubcomp, Dodge) == 0x000070, "Member 'USHAnimCombatSubcomp::Dodge' has a wrong offset!");

// Class SHProto.SHTraversalVaultTutorialHandler
// 0x0000 (0x0048 - 0x0048)
class USHTraversalVaultTutorialHandler final : public USHTraversalTutorialHandler
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalVaultTutorialHandler">();
	}
	static class USHTraversalVaultTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTraversalVaultTutorialHandler>();
	}
};
static_assert(alignof(USHTraversalVaultTutorialHandler) == 0x000008, "Wrong alignment on USHTraversalVaultTutorialHandler");
static_assert(sizeof(USHTraversalVaultTutorialHandler) == 0x000048, "Wrong size on USHTraversalVaultTutorialHandler");

// Class SHProto.SHAnimDoorSubcomp
// 0x0040 (0x0078 - 0x0038)
class USHAnimDoorSubcomp final : public USHAnimSubcomponentBase
{
public:
	class USHAnimMontagePlayer*                   Open;                                              // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAnimMontagePlayer*                   Action;                                            // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHDoorLockBaseComponent*               InteractingDoorLockComponent;                      // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHDoorAnimationsBaseComponent*         InteractingDoorAnimsComponent;                     // 0x0050(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHDoorAttachment*                      InteractingDoorAttachmentActor;                    // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x18];                                      // 0x0060(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActionBlendingOut(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void OnActionEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimDoorSubcomp">();
	}
	static class USHAnimDoorSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimDoorSubcomp>();
	}
};
static_assert(alignof(USHAnimDoorSubcomp) == 0x000008, "Wrong alignment on USHAnimDoorSubcomp");
static_assert(sizeof(USHAnimDoorSubcomp) == 0x000078, "Wrong size on USHAnimDoorSubcomp");
static_assert(offsetof(USHAnimDoorSubcomp, Open) == 0x000038, "Member 'USHAnimDoorSubcomp::Open' has a wrong offset!");
static_assert(offsetof(USHAnimDoorSubcomp, Action) == 0x000040, "Member 'USHAnimDoorSubcomp::Action' has a wrong offset!");
static_assert(offsetof(USHAnimDoorSubcomp, InteractingDoorLockComponent) == 0x000048, "Member 'USHAnimDoorSubcomp::InteractingDoorLockComponent' has a wrong offset!");
static_assert(offsetof(USHAnimDoorSubcomp, InteractingDoorAnimsComponent) == 0x000050, "Member 'USHAnimDoorSubcomp::InteractingDoorAnimsComponent' has a wrong offset!");
static_assert(offsetof(USHAnimDoorSubcomp, InteractingDoorAttachmentActor) == 0x000058, "Member 'USHAnimDoorSubcomp::InteractingDoorAttachmentActor' has a wrong offset!");

// Class SHProto.EnviroHitReactionEvent
// 0x0030 (0x0058 - 0x0028)
class UEnviroHitReactionEvent : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAngleCurveWithScaleGetter             AngleToAdd;                                        // 0x0030(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       Character;                                         // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnviroHitReactionEvent">();
	}
	static class UEnviroHitReactionEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnviroHitReactionEvent>();
	}
};
static_assert(alignof(UEnviroHitReactionEvent) == 0x000008, "Wrong alignment on UEnviroHitReactionEvent");
static_assert(sizeof(UEnviroHitReactionEvent) == 0x000058, "Wrong size on UEnviroHitReactionEvent");
static_assert(offsetof(UEnviroHitReactionEvent, AngleToAdd) == 0x000030, "Member 'UEnviroHitReactionEvent::AngleToAdd' has a wrong offset!");
static_assert(offsetof(UEnviroHitReactionEvent, Character) == 0x000048, "Member 'UEnviroHitReactionEvent::Character' has a wrong offset!");

// Class SHProto.SHCharacterPlayEnviroSideHitEvent
// 0x0010 (0x0068 - 0x0058)
class USHCharacterPlayEnviroSideHitEvent final : public UEnviroHitReactionEvent
{
public:
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayEnviroSideHitEvent">();
	}
	static class USHCharacterPlayEnviroSideHitEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayEnviroSideHitEvent>();
	}
};
static_assert(alignof(USHCharacterPlayEnviroSideHitEvent) == 0x000008, "Wrong alignment on USHCharacterPlayEnviroSideHitEvent");
static_assert(sizeof(USHCharacterPlayEnviroSideHitEvent) == 0x000068, "Wrong size on USHCharacterPlayEnviroSideHitEvent");

// Class SHProto.SHAnimEnviroHitReactionsSubcomp
// 0x0108 (0x0140 - 0x0038)
class USHAnimEnviroHitReactionsSubcomp final : public USHAnimSubcomponentBase
{
public:
	struct FSHAnimEnviroHitReactionsSubcompSettings Settings;                                          // 0x0038(0x00E0)(Protected, NativeAccessSpecifierProtected)
	class UEnviroHitReactionEvent*                FrontHitEvent;                                     // 0x0118(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnviroHitReactionEvent*                SideHitEvent;                                      // 0x0120(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x18];                                     // 0x0128(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlockAnimEnviroHitReactions(const bool Blocked, const class UObject* Object);
	void BlockAnimEnviroHitSlideSnap(const bool Blocked, const class UObject* Object);
	void SHDebug_Character_AnimEnviroHitReactions_DrawDebug();
	void SHDebug_Character_AnimEnviroHitReactions_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimEnviroHitReactionsSubcomp">();
	}
	static class USHAnimEnviroHitReactionsSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimEnviroHitReactionsSubcomp>();
	}
};
static_assert(alignof(USHAnimEnviroHitReactionsSubcomp) == 0x000008, "Wrong alignment on USHAnimEnviroHitReactionsSubcomp");
static_assert(sizeof(USHAnimEnviroHitReactionsSubcomp) == 0x000140, "Wrong size on USHAnimEnviroHitReactionsSubcomp");
static_assert(offsetof(USHAnimEnviroHitReactionsSubcomp, Settings) == 0x000038, "Member 'USHAnimEnviroHitReactionsSubcomp::Settings' has a wrong offset!");
static_assert(offsetof(USHAnimEnviroHitReactionsSubcomp, FrontHitEvent) == 0x000118, "Member 'USHAnimEnviroHitReactionsSubcomp::FrontHitEvent' has a wrong offset!");
static_assert(offsetof(USHAnimEnviroHitReactionsSubcomp, SideHitEvent) == 0x000120, "Member 'USHAnimEnviroHitReactionsSubcomp::SideHitEvent' has a wrong offset!");

// Class SHProto.SHAnimFootIKSubcomp
// 0x00D0 (0x0108 - 0x0038)
class USHAnimFootIKSubcomp : public USHAnimSubcomponentBase
{
public:
	struct FVector                                PelvisOffset;                                      // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSHAnimFootIKSubcompSettings           Settings;                                          // 0x0050(0x0070)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x48];                                      // 0x00C0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetIK();
	void SetFeetAllIKEnabled(bool bEnable, float InterpSpeed);
	void SetFeetRotationOffsetEnabled(bool NewIsEnable);
	void SetFootIKEnabled(bool bEnable, int32 Index_0, float InterpSpeed);
	void SetIKEnabled(bool NewIsEnabled);
	void SetPelvisIKEnabled(bool NewIsEnable, float PelvisInterpSpeed);
	void SHDebug_Shared_Anim_FootIK_Enabled(bool Enabled);
	void SHDebug_Shared_Anim_FootIK_PelvisOffsetInterpSpeed(float InterpSpeed);

	struct FFootIKData GetFootIK(int32 Index_0) const;
	bool GetIsIKEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimFootIKSubcomp">();
	}
	static class USHAnimFootIKSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimFootIKSubcomp>();
	}
};
static_assert(alignof(USHAnimFootIKSubcomp) == 0x000008, "Wrong alignment on USHAnimFootIKSubcomp");
static_assert(sizeof(USHAnimFootIKSubcomp) == 0x000108, "Wrong size on USHAnimFootIKSubcomp");
static_assert(offsetof(USHAnimFootIKSubcomp, PelvisOffset) == 0x000038, "Member 'USHAnimFootIKSubcomp::PelvisOffset' has a wrong offset!");
static_assert(offsetof(USHAnimFootIKSubcomp, Settings) == 0x000050, "Member 'USHAnimFootIKSubcomp::Settings' has a wrong offset!");

// Class SHProto.SHDLCSkinSettingsDataAsset
// 0x0050 (0x0080 - 0x0030)
class USHDLCSkinSettingsDataAsset final : public UDataAsset
{
public:
	TMap<EPlayerSkin, TSoftObjectPtr<class UStaticMesh>> SkinToStaticMeshAssetMap;                          // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDLCSkinSettingsDataAsset">();
	}
	static class USHDLCSkinSettingsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDLCSkinSettingsDataAsset>();
	}
};
static_assert(alignof(USHDLCSkinSettingsDataAsset) == 0x000008, "Wrong alignment on USHDLCSkinSettingsDataAsset");
static_assert(sizeof(USHDLCSkinSettingsDataAsset) == 0x000080, "Wrong size on USHDLCSkinSettingsDataAsset");
static_assert(offsetof(USHDLCSkinSettingsDataAsset, SkinToStaticMeshAssetMap) == 0x000030, "Member 'USHDLCSkinSettingsDataAsset::SkinToStaticMeshAssetMap' has a wrong offset!");

// Class SHProto.SHAnimHandIKSubcomp
// 0x0048 (0x0080 - 0x0038)
class USHAnimHandIKSubcomp final : public USHAnimSubcomponentBase
{
public:
	uint8                                         Pad_38[0x48];                                      // 0x0038(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetLeftHandLocation(const struct FVector& InLoc, float InterpSpeed, bool SetFullAlpha);
	void SetRightHandLocation(const struct FVector& InLoc, float InterpSpeed, bool SetFullAlpha);
	void StopBothIK(float InterpSpeed);
	void StopLeftHandIK(float InterpSpeed);
	void StopRightHandIK(float InterpSpeed);

	float GetLeftHandAlpha() const;
	struct FVector GetLeftHandLocation() const;
	float GetRightHandAlpha() const;
	struct FVector GetRightHandLocation() const;
	bool IsLeftHandIKEnabled() const;
	bool IsRightHandIKEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimHandIKSubcomp">();
	}
	static class USHAnimHandIKSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimHandIKSubcomp>();
	}
};
static_assert(alignof(USHAnimHandIKSubcomp) == 0x000008, "Wrong alignment on USHAnimHandIKSubcomp");
static_assert(sizeof(USHAnimHandIKSubcomp) == 0x000080, "Wrong size on USHAnimHandIKSubcomp");

// Class SHProto.SHPushableLimiter
// 0x0000 (0x02B0 - 0x02B0)
class ASHPushableLimiter final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPushableLimiter">();
	}
	static class ASHPushableLimiter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHPushableLimiter>();
	}
};
static_assert(alignof(ASHPushableLimiter) == 0x000008, "Wrong alignment on ASHPushableLimiter");
static_assert(sizeof(ASHPushableLimiter) == 0x0002B0, "Wrong size on ASHPushableLimiter");

// Class SHProto.SHAnimHeadRotationBaseSubcomp
// 0x0078 (0x00B0 - 0x0038)
class USHAnimHeadRotationBaseSubcomp : public USHAnimSubcomponentBase
{
public:
	class USHAimOffsetAnimInstance*               AimOffsetAnimInstanceCurrent;                      // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ManualLookAtTarget(class USceneComponent* InTargetComponent, float InBlendInSpeed, float InBlendOutSpeed);
	void SetHeadRotationEnabled(const bool bInEnabled, float InBlendSpeed, const class UObject* Object);
	void SetNewAimOffsetAnimInstance(TSubclassOf<class USHAimOffsetAnimInstance> NewAimOffset);
	void SHDebug_Shared_Anim_HeadRotation_SetLookAtEnabled(bool bInEnabled);

	class USceneComponent* GetCurrentLookAtTarget() const;
	bool IsHeadRotationEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimHeadRotationBaseSubcomp">();
	}
	static class USHAnimHeadRotationBaseSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimHeadRotationBaseSubcomp>();
	}
};
static_assert(alignof(USHAnimHeadRotationBaseSubcomp) == 0x000008, "Wrong alignment on USHAnimHeadRotationBaseSubcomp");
static_assert(sizeof(USHAnimHeadRotationBaseSubcomp) == 0x0000B0, "Wrong size on USHAnimHeadRotationBaseSubcomp");
static_assert(offsetof(USHAnimHeadRotationBaseSubcomp, AimOffsetAnimInstanceCurrent) == 0x000038, "Member 'USHAnimHeadRotationBaseSubcomp::AimOffsetAnimInstanceCurrent' has a wrong offset!");

// Class SHProto.SHCameraComponent
// 0x0000 (0x0A50 - 0x0A50)
class USHCameraComponent : public UCameraComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCameraComponent">();
	}
	static class USHCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCameraComponent>();
	}
};
static_assert(alignof(USHCameraComponent) == 0x000010, "Wrong alignment on USHCameraComponent");
static_assert(sizeof(USHCameraComponent) == 0x000A50, "Wrong size on USHCameraComponent");

// Class SHProto.SHCharacterPlayCameraComponent
// 0x00A0 (0x0AF0 - 0x0A50)
class USHCharacterPlayCameraComponent final : public USHCameraComponent
{
public:
	float                                         TargetFOV;                                         // 0x0A50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FOVInterpSpeed;                                    // 0x0A54(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableHideOwnerIfTooClose;                        // 0x0A58(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A59[0x7];                                      // 0x0A59(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x0A60(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class UObject*, float>                   FOVAdditiveMapings;                                // 0x0A68(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class USHCameraFOVBlender*>            FOVBlenders;                                       // 0x0AB8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class USHCameraPostProcessBlender*>    PostProcessBlenders;                               // 0x0AC8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSHMaterialPropertyControlHandler> SimpleBlendableEffects;                            // 0x0AD8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_AE8[0x8];                                      // 0x0AE8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const class USHCameraFOVBlender* AddFOVBlend(const class UObject* Object, const class FString& BlendName, const struct FSHBlendData& BlendConfig, const float FOVValue);
	struct FRotator CalcLookingAtDelta(const struct FVector& InWorldLoc);
	bool IsLookingAt(const struct FVector& InWorldLoc, float PitchAngleTolerance, float YawAngleTolerance);
	class UMaterialInstanceDynamic* PlaySimpleBlendableEffect(const class UObject* Object, class UMaterialInterface* InPostprocessMaterial, class FName InEffectMaterialParamName, float InEffectTime);
	bool RemoveFOVBlend(const class UObject* Object, const bool Instant);
	void SHDebug_Character_CameraComponent_ValuesDebug();

	const class USHCameraFOVBlender* FindFOVBlender(const class UObject* Object) const;
	bool HasFOVBlend(const class UObject* Object) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayCameraComponent">();
	}
	static class USHCharacterPlayCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayCameraComponent>();
	}
};
static_assert(alignof(USHCharacterPlayCameraComponent) == 0x000010, "Wrong alignment on USHCharacterPlayCameraComponent");
static_assert(sizeof(USHCharacterPlayCameraComponent) == 0x000AF0, "Wrong size on USHCharacterPlayCameraComponent");
static_assert(offsetof(USHCharacterPlayCameraComponent, TargetFOV) == 0x000A50, "Member 'USHCharacterPlayCameraComponent::TargetFOV' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayCameraComponent, FOVInterpSpeed) == 0x000A54, "Member 'USHCharacterPlayCameraComponent::FOVInterpSpeed' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayCameraComponent, bEnableHideOwnerIfTooClose) == 0x000A58, "Member 'USHCharacterPlayCameraComponent::bEnableHideOwnerIfTooClose' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayCameraComponent, OwnerCharacter) == 0x000A60, "Member 'USHCharacterPlayCameraComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayCameraComponent, FOVAdditiveMapings) == 0x000A68, "Member 'USHCharacterPlayCameraComponent::FOVAdditiveMapings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayCameraComponent, FOVBlenders) == 0x000AB8, "Member 'USHCharacterPlayCameraComponent::FOVBlenders' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayCameraComponent, PostProcessBlenders) == 0x000AC8, "Member 'USHCharacterPlayCameraComponent::PostProcessBlenders' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayCameraComponent, SimpleBlendableEffects) == 0x000AD8, "Member 'USHCharacterPlayCameraComponent::SimpleBlendableEffects' has a wrong offset!");

// Class SHProto.SHFXSplashPuddleSubcomp
// 0x0120 (0x0158 - 0x0038)
class USHFXSplashPuddleSubcomp final : public USHFXSubcomponent
{
public:
	class USHFXSplashPuddleSubcompSettings*       Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x118];                                     // 0x0040(0x0118)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessOwnerDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* HitComponent, class FName BoneName, const struct FVector& ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXSplashPuddleSubcomp">();
	}
	static class USHFXSplashPuddleSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXSplashPuddleSubcomp>();
	}
};
static_assert(alignof(USHFXSplashPuddleSubcomp) == 0x000008, "Wrong alignment on USHFXSplashPuddleSubcomp");
static_assert(sizeof(USHFXSplashPuddleSubcomp) == 0x000158, "Wrong size on USHFXSplashPuddleSubcomp");
static_assert(offsetof(USHFXSplashPuddleSubcomp, Settings) == 0x000038, "Member 'USHFXSplashPuddleSubcomp::Settings' has a wrong offset!");

// Class SHProto.SHAnimHeadRotationSubcomp
// 0x0038 (0x00E8 - 0x00B0)
class USHAnimHeadRotationSubcomp final : public USHAnimHeadRotationBaseSubcomp
{
public:
	uint8                                         Pad_B0[0x38];                                      // 0x00B0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Character_Anim_HeadRotation_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimHeadRotationSubcomp">();
	}
	static class USHAnimHeadRotationSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimHeadRotationSubcomp>();
	}
};
static_assert(alignof(USHAnimHeadRotationSubcomp) == 0x000008, "Wrong alignment on USHAnimHeadRotationSubcomp");
static_assert(sizeof(USHAnimHeadRotationSubcomp) == 0x0000E8, "Wrong size on USHAnimHeadRotationSubcomp");

// Class SHProto.SHAnimItemInteractionSubcomp
// 0x0288 (0x02C0 - 0x0038)
class USHAnimItemInteractionSubcomp final : public USHAnimSubcomponentBase
{
public:
	EItemInteractionType                          InteractionType;                                   // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InvestigationItemLocation;                         // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ReachHandLocation;                                 // 0x0058(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InvestigationFlipSide;                             // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemInvestigationAnimationData        ItemInvestigationAnimationsData;                   // 0x0078(0x0100)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FItemQuickGrabAnimationData            ItemQuickGrabAnimationsData;                       // 0x0178(0x0060)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class USHItemInteractionAnimInstance*         ItemInteractionAnimInstance;                       // 0x01D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHItemBase*                            InvestigationItem;                                 // 0x01E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHWeaponManageCmbSubcomp*              WeaponManageSubcomp;                               // 0x01E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F0[0xD0];                                     // 0x01F0(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleInvestigationFinishAnimEndEvent();
	void HandleInvestigationFlipAnimEndNotify(float AnimationTime, int32 FlipSide);
	void HandleInvestigationSetupAnimEndEvent();
	void HandlePostInvestigationAnimEndEvent();
	void HandlePreInvestigationAnimEndEvent();
	void InvestigationSetHandLocationFAB();
	void PlayPreInvestigationAnimation();
	void TakeItemAnimationEnd();
	void TakeItemSetDirection(bool bSetProperHand);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimItemInteractionSubcomp">();
	}
	static class USHAnimItemInteractionSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimItemInteractionSubcomp>();
	}
};
static_assert(alignof(USHAnimItemInteractionSubcomp) == 0x000008, "Wrong alignment on USHAnimItemInteractionSubcomp");
static_assert(sizeof(USHAnimItemInteractionSubcomp) == 0x0002C0, "Wrong size on USHAnimItemInteractionSubcomp");
static_assert(offsetof(USHAnimItemInteractionSubcomp, InteractionType) == 0x000038, "Member 'USHAnimItemInteractionSubcomp::InteractionType' has a wrong offset!");
static_assert(offsetof(USHAnimItemInteractionSubcomp, InvestigationItemLocation) == 0x000040, "Member 'USHAnimItemInteractionSubcomp::InvestigationItemLocation' has a wrong offset!");
static_assert(offsetof(USHAnimItemInteractionSubcomp, ReachHandLocation) == 0x000058, "Member 'USHAnimItemInteractionSubcomp::ReachHandLocation' has a wrong offset!");
static_assert(offsetof(USHAnimItemInteractionSubcomp, InvestigationFlipSide) == 0x000070, "Member 'USHAnimItemInteractionSubcomp::InvestigationFlipSide' has a wrong offset!");
static_assert(offsetof(USHAnimItemInteractionSubcomp, ItemInvestigationAnimationsData) == 0x000078, "Member 'USHAnimItemInteractionSubcomp::ItemInvestigationAnimationsData' has a wrong offset!");
static_assert(offsetof(USHAnimItemInteractionSubcomp, ItemQuickGrabAnimationsData) == 0x000178, "Member 'USHAnimItemInteractionSubcomp::ItemQuickGrabAnimationsData' has a wrong offset!");
static_assert(offsetof(USHAnimItemInteractionSubcomp, ItemInteractionAnimInstance) == 0x0001D8, "Member 'USHAnimItemInteractionSubcomp::ItemInteractionAnimInstance' has a wrong offset!");
static_assert(offsetof(USHAnimItemInteractionSubcomp, InvestigationItem) == 0x0001E0, "Member 'USHAnimItemInteractionSubcomp::InvestigationItem' has a wrong offset!");
static_assert(offsetof(USHAnimItemInteractionSubcomp, WeaponManageSubcomp) == 0x0001E8, "Member 'USHAnimItemInteractionSubcomp::WeaponManageSubcomp' has a wrong offset!");

// Class SHProto.SHBossfightItemsManagerConfigDataAsset
// 0x0050 (0x0080 - 0x0030)
class USHBossfightItemsManagerConfigDataAsset final : public UDataAsset
{
public:
	TMap<int32, struct FSHBossfightItemsManagerPhaseSetup> PhaseToSetupMap;                                   // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBossfightItemsManagerConfigDataAsset">();
	}
	static class USHBossfightItemsManagerConfigDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBossfightItemsManagerConfigDataAsset>();
	}
};
static_assert(alignof(USHBossfightItemsManagerConfigDataAsset) == 0x000008, "Wrong alignment on USHBossfightItemsManagerConfigDataAsset");
static_assert(sizeof(USHBossfightItemsManagerConfigDataAsset) == 0x000080, "Wrong size on USHBossfightItemsManagerConfigDataAsset");
static_assert(offsetof(USHBossfightItemsManagerConfigDataAsset, PhaseToSetupMap) == 0x000030, "Member 'USHBossfightItemsManagerConfigDataAsset::PhaseToSetupMap' has a wrong offset!");

// Class SHProto.SHAnimItemUseableSubcomp
// 0x0000 (0x0038 - 0x0038)
class USHAnimItemUseableSubcomp final : public USHAnimSubcomponentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimItemUseableSubcomp">();
	}
	static class USHAnimItemUseableSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimItemUseableSubcomp>();
	}
};
static_assert(alignof(USHAnimItemUseableSubcomp) == 0x000008, "Wrong alignment on USHAnimItemUseableSubcomp");
static_assert(sizeof(USHAnimItemUseableSubcomp) == 0x000038, "Wrong size on USHAnimItemUseableSubcomp");

// Class SHProto.SHDoorAnimationsBaseSetData
// 0x0000 (0x0030 - 0x0030)
class USHDoorAnimationsBaseSetData : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDoorAnimationsBaseSetData">();
	}
	static class USHDoorAnimationsBaseSetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDoorAnimationsBaseSetData>();
	}
};
static_assert(alignof(USHDoorAnimationsBaseSetData) == 0x000008, "Wrong alignment on USHDoorAnimationsBaseSetData");
static_assert(sizeof(USHDoorAnimationsBaseSetData) == 0x000030, "Wrong size on USHDoorAnimationsBaseSetData");

// Class SHProto.SHSlidingDoorAnimationsSetData
// 0x0160 (0x0190 - 0x0030)
class USHSlidingDoorAnimationsSetData final : public USHDoorAnimationsBaseSetData
{
public:
	struct FPlayAnimationData                     Locked;                                            // 0x0030(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPlayAnimationData                     Open;                                              // 0x00E0(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSlidingDoorAnimationsSetData">();
	}
	static class USHSlidingDoorAnimationsSetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSlidingDoorAnimationsSetData>();
	}
};
static_assert(alignof(USHSlidingDoorAnimationsSetData) == 0x000008, "Wrong alignment on USHSlidingDoorAnimationsSetData");
static_assert(sizeof(USHSlidingDoorAnimationsSetData) == 0x000190, "Wrong size on USHSlidingDoorAnimationsSetData");
static_assert(offsetof(USHSlidingDoorAnimationsSetData, Locked) == 0x000030, "Member 'USHSlidingDoorAnimationsSetData::Locked' has a wrong offset!");
static_assert(offsetof(USHSlidingDoorAnimationsSetData, Open) == 0x0000E0, "Member 'USHSlidingDoorAnimationsSetData::Open' has a wrong offset!");

// Class SHProto.SHAnimKnockDownSubcomp
// 0x0008 (0x0040 - 0x0038)
class USHAnimKnockDownSubcomp final : public USHAnimSubcomponentBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const EKnockDownState GetKnockDownState();
	void SetKnockDownState(EKnockDownState NewKnockDownState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimKnockDownSubcomp">();
	}
	static class USHAnimKnockDownSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimKnockDownSubcomp>();
	}
};
static_assert(alignof(USHAnimKnockDownSubcomp) == 0x000008, "Wrong alignment on USHAnimKnockDownSubcomp");
static_assert(sizeof(USHAnimKnockDownSubcomp) == 0x000040, "Wrong size on USHAnimKnockDownSubcomp");

// Class SHProto.SHCharacterPlayHealthSettings
// 0x02C0 (0x02F0 - 0x0030)
class USHCharacterPlayHealthSettings final : public UDataAsset
{
public:
	float                                         LowInjuryThreshold;                                // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeavyInjuryThreshold;                              // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalnjuryThreshold;                            // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    TapHealingItem;                                    // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ActionHealingRequiredHoldTime;                     // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    HoldHealingItem;                                   // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     HealthMaterial;                                    // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSHMaterialPropertyControlData> HealthMaterialPropertyControlsConfigs;             // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSHReceiveDamagePostProcessConfig      DefaultReceiveDamagePostProcess;                   // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UBeingDamage>, struct FSHReceiveDamageCustomPostProcessConfig> SelectedReceiveDamagePostProcesses;                // 0x00D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           DefaultReceiveDamageCameraShakeClass;              // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UBeingDamage>, TSubclassOf<class UCameraShakeBase>> SelectedReceiveDamageCameraShakeClasses;           // 0x0128(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FSHReceiveDamagePostProcessConfig      DefaultReceiveHealPostProcess;                     // 0x0178(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DeathSequenceSoftClass;                            // 0x01C8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ESHSimpleDirectionType, struct FSHGenericDeathSequencesContainer> DirectionalGenericDeathSequenceContainers;         // 0x01F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<ESHHealthStateEnum, struct FSHControllerLightsSettings> HealthControllerLightsSettings;                    // 0x0248(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackOnDamageNormal;                       // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackOnDamageStun;                         // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackOnDamageContinous;                    // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackOnDamageSoft;                         // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEffectHandle                          SpecialEffectDamageNormal;                         // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEffectHandle                          SpecialEffectDamageStun;                           // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEffectHandle                          SpecialEffectDamageContinous;                      // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEffectHandle                          SpecialEffectDamageSoft;                           // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEffectHandle                          SpecialEffectHeal;                                 // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          SpecialEffectBlinkKeys;                            // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x3];                                      // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 SpecialEffectBlinkColor0;                          // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 SpecialEffectBlinkColor1;                          // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecialEffectBlinkPeriod;                          // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayHealthSettings">();
	}
	static class USHCharacterPlayHealthSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayHealthSettings>();
	}
};
static_assert(alignof(USHCharacterPlayHealthSettings) == 0x000008, "Wrong alignment on USHCharacterPlayHealthSettings");
static_assert(sizeof(USHCharacterPlayHealthSettings) == 0x0002F0, "Wrong size on USHCharacterPlayHealthSettings");
static_assert(offsetof(USHCharacterPlayHealthSettings, LowInjuryThreshold) == 0x000030, "Member 'USHCharacterPlayHealthSettings::LowInjuryThreshold' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, HeavyInjuryThreshold) == 0x000034, "Member 'USHCharacterPlayHealthSettings::HeavyInjuryThreshold' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, CriticalnjuryThreshold) == 0x000038, "Member 'USHCharacterPlayHealthSettings::CriticalnjuryThreshold' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, TapHealingItem) == 0x000040, "Member 'USHCharacterPlayHealthSettings::TapHealingItem' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, ActionHealingRequiredHoldTime) == 0x000050, "Member 'USHCharacterPlayHealthSettings::ActionHealingRequiredHoldTime' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, HoldHealingItem) == 0x000058, "Member 'USHCharacterPlayHealthSettings::HoldHealingItem' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, HealthMaterial) == 0x000068, "Member 'USHCharacterPlayHealthSettings::HealthMaterial' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, HealthMaterialPropertyControlsConfigs) == 0x000070, "Member 'USHCharacterPlayHealthSettings::HealthMaterialPropertyControlsConfigs' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, DefaultReceiveDamagePostProcess) == 0x000080, "Member 'USHCharacterPlayHealthSettings::DefaultReceiveDamagePostProcess' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, SelectedReceiveDamagePostProcesses) == 0x0000D0, "Member 'USHCharacterPlayHealthSettings::SelectedReceiveDamagePostProcesses' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, DefaultReceiveDamageCameraShakeClass) == 0x000120, "Member 'USHCharacterPlayHealthSettings::DefaultReceiveDamageCameraShakeClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, SelectedReceiveDamageCameraShakeClasses) == 0x000128, "Member 'USHCharacterPlayHealthSettings::SelectedReceiveDamageCameraShakeClasses' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, DefaultReceiveHealPostProcess) == 0x000178, "Member 'USHCharacterPlayHealthSettings::DefaultReceiveHealPostProcess' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, DeathSequenceSoftClass) == 0x0001C8, "Member 'USHCharacterPlayHealthSettings::DeathSequenceSoftClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, DirectionalGenericDeathSequenceContainers) == 0x0001F8, "Member 'USHCharacterPlayHealthSettings::DirectionalGenericDeathSequenceContainers' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, HealthControllerLightsSettings) == 0x000248, "Member 'USHCharacterPlayHealthSettings::HealthControllerLightsSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, ForceFeedbackOnDamageNormal) == 0x000298, "Member 'USHCharacterPlayHealthSettings::ForceFeedbackOnDamageNormal' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, ForceFeedbackOnDamageStun) == 0x0002A0, "Member 'USHCharacterPlayHealthSettings::ForceFeedbackOnDamageStun' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, ForceFeedbackOnDamageContinous) == 0x0002A8, "Member 'USHCharacterPlayHealthSettings::ForceFeedbackOnDamageContinous' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, ForceFeedbackOnDamageSoft) == 0x0002B0, "Member 'USHCharacterPlayHealthSettings::ForceFeedbackOnDamageSoft' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, SpecialEffectDamageNormal) == 0x0002B8, "Member 'USHCharacterPlayHealthSettings::SpecialEffectDamageNormal' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, SpecialEffectDamageStun) == 0x0002C0, "Member 'USHCharacterPlayHealthSettings::SpecialEffectDamageStun' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, SpecialEffectDamageContinous) == 0x0002C8, "Member 'USHCharacterPlayHealthSettings::SpecialEffectDamageContinous' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, SpecialEffectDamageSoft) == 0x0002D0, "Member 'USHCharacterPlayHealthSettings::SpecialEffectDamageSoft' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, SpecialEffectHeal) == 0x0002D8, "Member 'USHCharacterPlayHealthSettings::SpecialEffectHeal' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, SpecialEffectBlinkKeys) == 0x0002E0, "Member 'USHCharacterPlayHealthSettings::SpecialEffectBlinkKeys' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, SpecialEffectBlinkColor0) == 0x0002E4, "Member 'USHCharacterPlayHealthSettings::SpecialEffectBlinkColor0' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, SpecialEffectBlinkColor1) == 0x0002E8, "Member 'USHCharacterPlayHealthSettings::SpecialEffectBlinkColor1' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthSettings, SpecialEffectBlinkPeriod) == 0x0002EC, "Member 'USHCharacterPlayHealthSettings::SpecialEffectBlinkPeriod' has a wrong offset!");

// Class SHProto.SHAnimLookAtSubcomp
// 0x0028 (0x0060 - 0x0038)
class USHAnimLookAtSubcomp : public USHAnimSubcomponentBase
{
public:
	struct FRotator                               HeadRotation;                                      // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LookAlpha;                                         // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0xC];                                       // 0x0054(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimLookAtSubcomp">();
	}
	static class USHAnimLookAtSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimLookAtSubcomp>();
	}
};
static_assert(alignof(USHAnimLookAtSubcomp) == 0x000008, "Wrong alignment on USHAnimLookAtSubcomp");
static_assert(sizeof(USHAnimLookAtSubcomp) == 0x000060, "Wrong size on USHAnimLookAtSubcomp");
static_assert(offsetof(USHAnimLookAtSubcomp, HeadRotation) == 0x000038, "Member 'USHAnimLookAtSubcomp::HeadRotation' has a wrong offset!");
static_assert(offsetof(USHAnimLookAtSubcomp, LookAlpha) == 0x000050, "Member 'USHAnimLookAtSubcomp::LookAlpha' has a wrong offset!");

// Class SHProto.SHAnimNPCMovementSubcomp
// 0x0110 (0x0148 - 0x0038)
class USHAnimNPCMovementSubcomp : public USHAnimSubcomponentBase
{
public:
	struct FVector                                DesiredMovement;                                   // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0050(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeAngle;                                       // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredStrafeAngle;                                // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalRotation;                                // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingHipsForward;                              // 0x0078(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Acceleration;                                      // 0x0080(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccelerationRelative;                              // 0x0098(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CircularMovementRadius;                            // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CircularMovementDirection;                         // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleToDesiredRotation;                            // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceAngle;                                  // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x80];                                      // 0x00C0(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class AAIController*                          OwnerController;                                   // 0x0140(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool IsPhysicRotationDuringAnimRootMotionAllowed();
	void OnMoveStartExit();
	void OnTurnOnSpotAnimationEnter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNPCMovementSubcomp">();
	}
	static class USHAnimNPCMovementSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNPCMovementSubcomp>();
	}
};
static_assert(alignof(USHAnimNPCMovementSubcomp) == 0x000008, "Wrong alignment on USHAnimNPCMovementSubcomp");
static_assert(sizeof(USHAnimNPCMovementSubcomp) == 0x000148, "Wrong size on USHAnimNPCMovementSubcomp");
static_assert(offsetof(USHAnimNPCMovementSubcomp, DesiredMovement) == 0x000038, "Member 'USHAnimNPCMovementSubcomp::DesiredMovement' has a wrong offset!");
static_assert(offsetof(USHAnimNPCMovementSubcomp, Velocity) == 0x000050, "Member 'USHAnimNPCMovementSubcomp::Velocity' has a wrong offset!");
static_assert(offsetof(USHAnimNPCMovementSubcomp, Speed) == 0x000068, "Member 'USHAnimNPCMovementSubcomp::Speed' has a wrong offset!");
static_assert(offsetof(USHAnimNPCMovementSubcomp, StrafeAngle) == 0x00006C, "Member 'USHAnimNPCMovementSubcomp::StrafeAngle' has a wrong offset!");
static_assert(offsetof(USHAnimNPCMovementSubcomp, DesiredStrafeAngle) == 0x000070, "Member 'USHAnimNPCMovementSubcomp::DesiredStrafeAngle' has a wrong offset!");
static_assert(offsetof(USHAnimNPCMovementSubcomp, AdditionalRotation) == 0x000074, "Member 'USHAnimNPCMovementSubcomp::AdditionalRotation' has a wrong offset!");
static_assert(offsetof(USHAnimNPCMovementSubcomp, bIsMovingHipsForward) == 0x000078, "Member 'USHAnimNPCMovementSubcomp::bIsMovingHipsForward' has a wrong offset!");
static_assert(offsetof(USHAnimNPCMovementSubcomp, Acceleration) == 0x000080, "Member 'USHAnimNPCMovementSubcomp::Acceleration' has a wrong offset!");
static_assert(offsetof(USHAnimNPCMovementSubcomp, AccelerationRelative) == 0x000098, "Member 'USHAnimNPCMovementSubcomp::AccelerationRelative' has a wrong offset!");
static_assert(offsetof(USHAnimNPCMovementSubcomp, CircularMovementRadius) == 0x0000B0, "Member 'USHAnimNPCMovementSubcomp::CircularMovementRadius' has a wrong offset!");
static_assert(offsetof(USHAnimNPCMovementSubcomp, CircularMovementDirection) == 0x0000B4, "Member 'USHAnimNPCMovementSubcomp::CircularMovementDirection' has a wrong offset!");
static_assert(offsetof(USHAnimNPCMovementSubcomp, AngleToDesiredRotation) == 0x0000B8, "Member 'USHAnimNPCMovementSubcomp::AngleToDesiredRotation' has a wrong offset!");
static_assert(offsetof(USHAnimNPCMovementSubcomp, TurnInPlaceAngle) == 0x0000BC, "Member 'USHAnimNPCMovementSubcomp::TurnInPlaceAngle' has a wrong offset!");
static_assert(offsetof(USHAnimNPCMovementSubcomp, OwnerController) == 0x000140, "Member 'USHAnimNPCMovementSubcomp::OwnerController' has a wrong offset!");

// Class SHProto.SHBrokenGlassShardsContainerComponent
// 0x0000 (0x02A0 - 0x02A0)
class USHBrokenGlassShardsContainerComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBrokenGlassShardsContainerComponent">();
	}
	static class USHBrokenGlassShardsContainerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBrokenGlassShardsContainerComponent>();
	}
};
static_assert(alignof(USHBrokenGlassShardsContainerComponent) == 0x000010, "Wrong alignment on USHBrokenGlassShardsContainerComponent");
static_assert(sizeof(USHBrokenGlassShardsContainerComponent) == 0x0002A0, "Wrong size on USHBrokenGlassShardsContainerComponent");

// Class SHProto.SHAnimLyingFigureMovementSubcomp
// 0x0018 (0x0160 - 0x0148)
class USHAnimLyingFigureMovementSubcomp final : public USHAnimNPCMovementSubcomp
{
public:
	uint8                                         Pad_148[0x18];                                     // 0x0148(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterPrerequisites(class USHEnemyLyingComponent* InLyingComponent, class USceneComponent* InCrawlRearComponent, class USceneComponent* InCrawlFrontComponent);
	void SetAllowInaccurateLocomotionAnimations(bool InAllow);
	void SetCrawlBendAngles(float InYawAngle, float InPitchAngle);
	void SetRequiredLocomotionDistanceAccuracy(float InDistanceAccuracy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimLyingFigureMovementSubcomp">();
	}
	static class USHAnimLyingFigureMovementSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimLyingFigureMovementSubcomp>();
	}
};
static_assert(alignof(USHAnimLyingFigureMovementSubcomp) == 0x000008, "Wrong alignment on USHAnimLyingFigureMovementSubcomp");
static_assert(sizeof(USHAnimLyingFigureMovementSubcomp) == 0x000160, "Wrong size on USHAnimLyingFigureMovementSubcomp");

// Class SHProto.SHMQSpiderAnimInstance
// 0x0000 (0x03E0 - 0x03E0)
class USHMQSpiderAnimInstance final : public USHMonsterAnimInstance
{
public:
	void OnChangeSurfaceAnimationBegin();
	void OnChangeSurfaceAnimationEnd();

	class USHMQSpiderAnimInstanceStateData* GetMQSpiderAnimInstanceStateData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMQSpiderAnimInstance">();
	}
	static class USHMQSpiderAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMQSpiderAnimInstance>();
	}
};
static_assert(alignof(USHMQSpiderAnimInstance) == 0x000010, "Wrong alignment on USHMQSpiderAnimInstance");
static_assert(sizeof(USHMQSpiderAnimInstance) == 0x0003E0, "Wrong size on USHMQSpiderAnimInstance");

// Class SHProto.SHAnimMandarinMovementSubcomp
// 0x0008 (0x0150 - 0x0148)
class USHAnimMandarinMovementSubcomp final : public USHAnimNPCMovementSubcomp
{
public:
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimMandarinMovementSubcomp">();
	}
	static class USHAnimMandarinMovementSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimMandarinMovementSubcomp>();
	}
};
static_assert(alignof(USHAnimMandarinMovementSubcomp) == 0x000008, "Wrong alignment on USHAnimMandarinMovementSubcomp");
static_assert(sizeof(USHAnimMandarinMovementSubcomp) == 0x000150, "Wrong size on USHAnimMandarinMovementSubcomp");

// Class SHProto.SHBonePhysicsControllerSubcomponent
// 0x00D8 (0x0110 - 0x0038)
class USHBonePhysicsControllerSubcomponent final : public USHAnimSubcomponentBase
{
public:
	bool                                          bPreventPhysicsOfRootBody;                         // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeverManagePhysicsProfiles;                       // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHBonePhysicsControllerSettingsProfile DefaultPhysicsProfile;                             // 0x0040(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bPrintPhysicsStatesDebug;                          // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawAppliedForcesDebug;                           // 0x00A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawAppliedForcesDebugScale;                       // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawBodyActiveForcesDebug;                        // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawBodyActiveForcesDebugScale;                    // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawDebugPose;                                    // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawStreamedPoseDebugDuration;                     // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x50];                                      // 0x00C0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ActivatePhysicsForBone(class FName InBoneName, int32 InActivatePhysicsForParentBodyLevelsAbove, const struct FSHBonePhysicsPhysicsBlendInput& InPhysicsBlendInput, bool InAllowRootPhysics, class FName InPhysicsIdentifier);
	bool ApplyPhysicsForceToBone(class FName InBoneName, const struct FVector& InForceLocation, const struct FVector& InForce, int32 InActivatePhysicsForParentBodyLevelsAbove, const struct FSHBonePhysicsPhysicsBlendInput& InPhysicsBlendInput, bool InAllowRootPhysics, class FName InPhysicsIdentifier);
	bool ApplyPhysicsForceToBoneAndItsChildren(class FName InBoneName, const struct FVector& InForceLocation, const struct FVector& InForce, float InChildrenBoneForceMultiplier, bool InOnlyApplyForceToDirectChildren, bool InApplyForceAtChildLocation, int32 InActivatePhysicsForParentBodyLevelsAbove, const struct FSHBonePhysicsPhysicsBlendInput& InPhysicsBlendInput, bool InAllowRootPhysics, class FName InPhysicsIdentifier);
	bool ApplyPhysicsForceToChildBodiesOfBone(class FName InBoneName, const struct FVector& InForceLocation, const struct FVector& InForce, bool InOnlyDirectChildren, bool InApplyForceAtChildLocation, const struct FSHBonePhysicsPhysicsBlendInput& InPhysicsBlendInput, bool InAllowRootPhysics, class FName InPhysicsIdentifier);
	void AssignBonePhysicsSettingsProfile(const struct FSHBonePhysicsControllerSettingsProfile& InSettingsProfile);
	void FadeOutAllPhysics(float InBlendOutTime, float InBlendOutCurveBend);
	void FadeOutBonePhysicsByIdentifier(float InBlendOutTime, float InBlendOutCurveBend, class FName InPhysicsIdentifier, class FName InBoneName);
	void FadeOutPhysicsByIdentifier(float InBlendOutTime, float InBlendOutCurveBend, class FName InPhysicsIdentifier);
	void FreezeBodiesPose(bool InOnlyIfNotFrozen);
	void SetDebugPoseDrawing(bool InDrawPose);
	void SetDebugSettings(bool InPrintPhysicsStates, bool InDrawAppliedForcesDebug, float InDrawAppliedForcesScale, bool InDrawBodyActiveForcesDebug, float InBodyActiveForcesScale, bool InDrawPoseDebug, float InDrawStreamedPoseDuration);
	void SetDrawAppliedForcesDebugArrows(bool InDrawAppliedForcesDebug, float InDrawAppliedForcesScale);
	void SetDrawBodyActiveForcesDebugArrows(bool InDrawBodyActiveForcesDebug, float InBodyActiveForcesScale);
	void SetPhysicsStatesDebugPrinting(bool InEnableDebugPrint);
	void SetStreamedPoseDrawingDuration(float InDuration);
	void UnfreezeBodiesPose(float InUnfreezeDelay);

	bool FindIfBoneHasActivePhysics(class FName InBoneName) const;
	bool FindIfRootPhysicsSimulationIsActive() const;
	bool IsBodiesPoseFrozen(bool InIncludeUnfreezing) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBonePhysicsControllerSubcomponent">();
	}
	static class USHBonePhysicsControllerSubcomponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBonePhysicsControllerSubcomponent>();
	}
};
static_assert(alignof(USHBonePhysicsControllerSubcomponent) == 0x000008, "Wrong alignment on USHBonePhysicsControllerSubcomponent");
static_assert(sizeof(USHBonePhysicsControllerSubcomponent) == 0x000110, "Wrong size on USHBonePhysicsControllerSubcomponent");
static_assert(offsetof(USHBonePhysicsControllerSubcomponent, bPreventPhysicsOfRootBody) == 0x000038, "Member 'USHBonePhysicsControllerSubcomponent::bPreventPhysicsOfRootBody' has a wrong offset!");
static_assert(offsetof(USHBonePhysicsControllerSubcomponent, bNeverManagePhysicsProfiles) == 0x000039, "Member 'USHBonePhysicsControllerSubcomponent::bNeverManagePhysicsProfiles' has a wrong offset!");
static_assert(offsetof(USHBonePhysicsControllerSubcomponent, DefaultPhysicsProfile) == 0x000040, "Member 'USHBonePhysicsControllerSubcomponent::DefaultPhysicsProfile' has a wrong offset!");
static_assert(offsetof(USHBonePhysicsControllerSubcomponent, bPrintPhysicsStatesDebug) == 0x0000A8, "Member 'USHBonePhysicsControllerSubcomponent::bPrintPhysicsStatesDebug' has a wrong offset!");
static_assert(offsetof(USHBonePhysicsControllerSubcomponent, bDrawAppliedForcesDebug) == 0x0000A9, "Member 'USHBonePhysicsControllerSubcomponent::bDrawAppliedForcesDebug' has a wrong offset!");
static_assert(offsetof(USHBonePhysicsControllerSubcomponent, DrawAppliedForcesDebugScale) == 0x0000AC, "Member 'USHBonePhysicsControllerSubcomponent::DrawAppliedForcesDebugScale' has a wrong offset!");
static_assert(offsetof(USHBonePhysicsControllerSubcomponent, bDrawBodyActiveForcesDebug) == 0x0000B0, "Member 'USHBonePhysicsControllerSubcomponent::bDrawBodyActiveForcesDebug' has a wrong offset!");
static_assert(offsetof(USHBonePhysicsControllerSubcomponent, DrawBodyActiveForcesDebugScale) == 0x0000B4, "Member 'USHBonePhysicsControllerSubcomponent::DrawBodyActiveForcesDebugScale' has a wrong offset!");
static_assert(offsetof(USHBonePhysicsControllerSubcomponent, bDrawDebugPose) == 0x0000B8, "Member 'USHBonePhysicsControllerSubcomponent::bDrawDebugPose' has a wrong offset!");
static_assert(offsetof(USHBonePhysicsControllerSubcomponent, DrawStreamedPoseDebugDuration) == 0x0000BC, "Member 'USHBonePhysicsControllerSubcomponent::DrawStreamedPoseDebugDuration' has a wrong offset!");

// Class SHProto.SHAnimMariaMovementSubcomp
// 0x0000 (0x0148 - 0x0148)
class USHAnimMariaMovementSubcomp final : public USHAnimNPCMovementSubcomp
{
public:
	void PrepareChaseMovement(const class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimMariaMovementSubcomp">();
	}
	static class USHAnimMariaMovementSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimMariaMovementSubcomp>();
	}
};
static_assert(alignof(USHAnimMariaMovementSubcomp) == 0x000008, "Wrong alignment on USHAnimMariaMovementSubcomp");
static_assert(sizeof(USHAnimMariaMovementSubcomp) == 0x000148, "Wrong size on USHAnimMariaMovementSubcomp");

// Class SHProto.SHAnimMontagePlayer
// 0x0100 (0x0128 - 0x0028)
class USHAnimMontagePlayer final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             MontageStartEvent;                                 // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             MontageEndEvent;                                   // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             MontageBlendingOutEvent;                           // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class USHAnimComponent*                       OwnerComponent;                                    // 0x0058(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      InputData;                                         // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           CurrentMontage;                                    // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPlayAnimationData                     PlayAnimationData;                                 // 0x0070(0x00B0)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ChangeSectionRequest(const class FName NewSectionName, const float NewSectionBlendInTime, const float OldSectionBlendOutTime);
	void OnAnyMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void OnAnyMontageEnd(class UAnimMontage* Montage, bool bInterrupted);
	bool OverwriteRequest(const float StopBlendoutTime, const struct FPlayAnimationData& AnimData, const struct FVector& BlendSpaceInput);
	bool PauseRequest();
	bool PlayOrOverwriteRequest(const float StopBlendoutTime, const struct FPlayAnimationData& AnimData, const struct FVector& BlendSpaceInput);
	bool PlayRequest(const struct FPlayAnimationData& AnimData, const struct FVector& BlendSpaceInput);
	bool ResumeRequest();
	bool StopRequest(const float StopBlendoutTime);

	class UAnimMontage* GetCurrentMontage() const;
	class UAnimSequenceBase* GetInputData() const;
	const struct FPlayAnimationData GetPlayAnimationData() const;
	float GetPosition() const;
	bool IsPlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimMontagePlayer">();
	}
	static class USHAnimMontagePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimMontagePlayer>();
	}
};
static_assert(alignof(USHAnimMontagePlayer) == 0x000008, "Wrong alignment on USHAnimMontagePlayer");
static_assert(sizeof(USHAnimMontagePlayer) == 0x000128, "Wrong size on USHAnimMontagePlayer");
static_assert(offsetof(USHAnimMontagePlayer, MontageStartEvent) == 0x000028, "Member 'USHAnimMontagePlayer::MontageStartEvent' has a wrong offset!");
static_assert(offsetof(USHAnimMontagePlayer, MontageEndEvent) == 0x000038, "Member 'USHAnimMontagePlayer::MontageEndEvent' has a wrong offset!");
static_assert(offsetof(USHAnimMontagePlayer, MontageBlendingOutEvent) == 0x000048, "Member 'USHAnimMontagePlayer::MontageBlendingOutEvent' has a wrong offset!");
static_assert(offsetof(USHAnimMontagePlayer, OwnerComponent) == 0x000058, "Member 'USHAnimMontagePlayer::OwnerComponent' has a wrong offset!");
static_assert(offsetof(USHAnimMontagePlayer, InputData) == 0x000060, "Member 'USHAnimMontagePlayer::InputData' has a wrong offset!");
static_assert(offsetof(USHAnimMontagePlayer, CurrentMontage) == 0x000068, "Member 'USHAnimMontagePlayer::CurrentMontage' has a wrong offset!");
static_assert(offsetof(USHAnimMontagePlayer, PlayAnimationData) == 0x000070, "Member 'USHAnimMontagePlayer::PlayAnimationData' has a wrong offset!");

// Class SHProto.SHCharacterPlayInteractionSlotComponent
// 0x0010 (0x00B0 - 0x00A0)
class USHCharacterPlayInteractionSlotComponent : public UActorComponent
{
public:
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayInteractionSlotComponent">();
	}
	static class USHCharacterPlayInteractionSlotComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayInteractionSlotComponent>();
	}
};
static_assert(alignof(USHCharacterPlayInteractionSlotComponent) == 0x000008, "Wrong alignment on USHCharacterPlayInteractionSlotComponent");
static_assert(sizeof(USHCharacterPlayInteractionSlotComponent) == 0x0000B0, "Wrong size on USHCharacterPlayInteractionSlotComponent");
static_assert(offsetof(USHCharacterPlayInteractionSlotComponent, OwnerCharacter) == 0x0000A0, "Member 'USHCharacterPlayInteractionSlotComponent::OwnerCharacter' has a wrong offset!");

// Class SHProto.SHCharacterPlayManagedInteractionSlotComponent
// 0x0098 (0x0148 - 0x00B0)
class USHCharacterPlayManagedInteractionSlotComponent : public USHCharacterPlayInteractionSlotComponent
{
public:
	float                                         MouseRotationMultiplier;                           // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PadRotationMultiplier;                             // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementMultiplier;                                // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSHManagedInteractionSlotCleanupConfig CleanupConfig;                                     // 0x00BC(0x0014)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x78];                                      // 0x00D0(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayManagedInteractionSlotComponent">();
	}
	static class USHCharacterPlayManagedInteractionSlotComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayManagedInteractionSlotComponent>();
	}
};
static_assert(alignof(USHCharacterPlayManagedInteractionSlotComponent) == 0x000008, "Wrong alignment on USHCharacterPlayManagedInteractionSlotComponent");
static_assert(sizeof(USHCharacterPlayManagedInteractionSlotComponent) == 0x000148, "Wrong size on USHCharacterPlayManagedInteractionSlotComponent");
static_assert(offsetof(USHCharacterPlayManagedInteractionSlotComponent, MouseRotationMultiplier) == 0x0000B0, "Member 'USHCharacterPlayManagedInteractionSlotComponent::MouseRotationMultiplier' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayManagedInteractionSlotComponent, PadRotationMultiplier) == 0x0000B4, "Member 'USHCharacterPlayManagedInteractionSlotComponent::PadRotationMultiplier' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayManagedInteractionSlotComponent, MovementMultiplier) == 0x0000B8, "Member 'USHCharacterPlayManagedInteractionSlotComponent::MovementMultiplier' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayManagedInteractionSlotComponent, CleanupConfig) == 0x0000BC, "Member 'USHCharacterPlayManagedInteractionSlotComponent::CleanupConfig' has a wrong offset!");

// Class SHProto.SHAnimMovementSubcomp
// 0x00D0 (0x0108 - 0x0038)
class USHAnimMovementSubcomp final : public USHAnimSubcomponentBase
{
public:
	class FName                                   CustomLocomotionGraphTag;                          // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomChangeLocomotionSnapshotName;                // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHLocomotionAnimInstance*              LocomotionAnimInstanceCurrent;                     // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharAnimationInstance*               MainCharAnimationInstance;                         // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x98];                                      // 0x0058(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHAnimMovementSubcompSettings         Settings;                                          // 0x00F0(0x0010)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanPlayInvestigationAnim() const;
	ELocomotionState GetLocomotionAnimationState() const;
	class USHLocomotionAnimInstance* GetLocomotionAnimInstance() const;
	bool HasMovementInput() const;
	bool IsMoving() const;
	bool ShouldLookOnAimWalk() const;
	bool ShouldMove() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimMovementSubcomp">();
	}
	static class USHAnimMovementSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimMovementSubcomp>();
	}
};
static_assert(alignof(USHAnimMovementSubcomp) == 0x000008, "Wrong alignment on USHAnimMovementSubcomp");
static_assert(sizeof(USHAnimMovementSubcomp) == 0x000108, "Wrong size on USHAnimMovementSubcomp");
static_assert(offsetof(USHAnimMovementSubcomp, CustomLocomotionGraphTag) == 0x000038, "Member 'USHAnimMovementSubcomp::CustomLocomotionGraphTag' has a wrong offset!");
static_assert(offsetof(USHAnimMovementSubcomp, CustomChangeLocomotionSnapshotName) == 0x000040, "Member 'USHAnimMovementSubcomp::CustomChangeLocomotionSnapshotName' has a wrong offset!");
static_assert(offsetof(USHAnimMovementSubcomp, LocomotionAnimInstanceCurrent) == 0x000048, "Member 'USHAnimMovementSubcomp::LocomotionAnimInstanceCurrent' has a wrong offset!");
static_assert(offsetof(USHAnimMovementSubcomp, MainCharAnimationInstance) == 0x000050, "Member 'USHAnimMovementSubcomp::MainCharAnimationInstance' has a wrong offset!");
static_assert(offsetof(USHAnimMovementSubcomp, Settings) == 0x0000F0, "Member 'USHAnimMovementSubcomp::Settings' has a wrong offset!");

// Class SHProto.SHStagedAnimActionExecutive
// 0x0018 (0x0080 - 0x0068)
class USHStagedAnimActionExecutive final : public USHAnimActionExecutiveBase
{
public:
	TSubclassOf<class USHBaseStagedAnimInstance>  GameplayStagedAnimInstClass;                       // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHBaseStagedAnimInstance*              LinkedStagedAnimInst;                              // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AdvanceStageRequest();
	class USHBaseStagedAnimInstance* GetLinkedStagedAnimInst();
	void OnAnimInstInteractionBlendingOut();
	void OnAnimInstInteractionFinished();
	void OnAnimInstInteractionFinishStart();
	void OnAnimInstInteractionStarted();
	void OnAnimInstStageAdvanced();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHStagedAnimActionExecutive">();
	}
	static class USHStagedAnimActionExecutive* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHStagedAnimActionExecutive>();
	}
};
static_assert(alignof(USHStagedAnimActionExecutive) == 0x000008, "Wrong alignment on USHStagedAnimActionExecutive");
static_assert(sizeof(USHStagedAnimActionExecutive) == 0x000080, "Wrong size on USHStagedAnimActionExecutive");
static_assert(offsetof(USHStagedAnimActionExecutive, GameplayStagedAnimInstClass) == 0x000068, "Member 'USHStagedAnimActionExecutive::GameplayStagedAnimInstClass' has a wrong offset!");
static_assert(offsetof(USHStagedAnimActionExecutive, LinkedStagedAnimInst) == 0x000070, "Member 'USHStagedAnimActionExecutive::LinkedStagedAnimInst' has a wrong offset!");

// Class SHProto.SHAnimNotifyState_DelayHitReactions
// 0x0018 (0x0048 - 0x0030)
class USHAnimNotifyState_DelayHitReactions final : public UAnimNotifyState
{
public:
	ESHHitReactionResponseType                    DelayHitReactionTypes;                             // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DontDelayVariants;                                 // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotifyState_DelayHitReactions">();
	}
	static class USHAnimNotifyState_DelayHitReactions* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotifyState_DelayHitReactions>();
	}
};
static_assert(alignof(USHAnimNotifyState_DelayHitReactions) == 0x000008, "Wrong alignment on USHAnimNotifyState_DelayHitReactions");
static_assert(sizeof(USHAnimNotifyState_DelayHitReactions) == 0x000048, "Wrong size on USHAnimNotifyState_DelayHitReactions");
static_assert(offsetof(USHAnimNotifyState_DelayHitReactions, DelayHitReactionTypes) == 0x000030, "Member 'USHAnimNotifyState_DelayHitReactions::DelayHitReactionTypes' has a wrong offset!");
static_assert(offsetof(USHAnimNotifyState_DelayHitReactions, DontDelayVariants) == 0x000038, "Member 'USHAnimNotifyState_DelayHitReactions::DontDelayVariants' has a wrong offset!");

// Class SHProto.SHCharacterPlayLightingControlDataBlender
// 0x0020 (0x0098 - 0x0078)
class USHCharacterPlayLightingControlDataBlender final : public USHBlenderBase
{
public:
	uint8                                         Pad_78[0x20];                                      // 0x0078(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayLightingControlDataBlender">();
	}
	static class USHCharacterPlayLightingControlDataBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayLightingControlDataBlender>();
	}
};
static_assert(alignof(USHCharacterPlayLightingControlDataBlender) == 0x000008, "Wrong alignment on USHCharacterPlayLightingControlDataBlender");
static_assert(sizeof(USHCharacterPlayLightingControlDataBlender) == 0x000098, "Wrong size on USHCharacterPlayLightingControlDataBlender");

// Class SHProto.SHAnimNState_FallingState
// 0x0038 (0x0068 - 0x0030)
class USHAnimNState_FallingState final : public UAnimNotifyState
{
public:
	float                                         CheckDistance;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VectorToRotate;                                    // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNState_FallingState">();
	}
	static class USHAnimNState_FallingState* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNState_FallingState>();
	}
};
static_assert(alignof(USHAnimNState_FallingState) == 0x000008, "Wrong alignment on USHAnimNState_FallingState");
static_assert(sizeof(USHAnimNState_FallingState) == 0x000068, "Wrong size on USHAnimNState_FallingState");
static_assert(offsetof(USHAnimNState_FallingState, CheckDistance) == 0x000030, "Member 'USHAnimNState_FallingState::CheckDistance' has a wrong offset!");
static_assert(offsetof(USHAnimNState_FallingState, Speed) == 0x000034, "Member 'USHAnimNState_FallingState::Speed' has a wrong offset!");
static_assert(offsetof(USHAnimNState_FallingState, MaxSpeed) == 0x000038, "Member 'USHAnimNState_FallingState::MaxSpeed' has a wrong offset!");
static_assert(offsetof(USHAnimNState_FallingState, Acceleration) == 0x00003C, "Member 'USHAnimNState_FallingState::Acceleration' has a wrong offset!");
static_assert(offsetof(USHAnimNState_FallingState, VectorToRotate) == 0x000040, "Member 'USHAnimNState_FallingState::VectorToRotate' has a wrong offset!");

// Class SHProto.SHAnimNState_RotateActor
// 0x0088 (0x00B8 - 0x0030)
class USHAnimNState_RotateActor final : public UAnimNotifyState
{
public:
	struct FVector                                VectorToRotate;                                    // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpeed;                                     // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MoveSpeed;                                         // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x50];                                      // 0x0068(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNState_RotateActor">();
	}
	static class USHAnimNState_RotateActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNState_RotateActor>();
	}
};
static_assert(alignof(USHAnimNState_RotateActor) == 0x000008, "Wrong alignment on USHAnimNState_RotateActor");
static_assert(sizeof(USHAnimNState_RotateActor) == 0x0000B8, "Wrong size on USHAnimNState_RotateActor");
static_assert(offsetof(USHAnimNState_RotateActor, VectorToRotate) == 0x000030, "Member 'USHAnimNState_RotateActor::VectorToRotate' has a wrong offset!");
static_assert(offsetof(USHAnimNState_RotateActor, RotationSpeed) == 0x000048, "Member 'USHAnimNState_RotateActor::RotationSpeed' has a wrong offset!");
static_assert(offsetof(USHAnimNState_RotateActor, MoveSpeed) == 0x000050, "Member 'USHAnimNState_RotateActor::MoveSpeed' has a wrong offset!");

// Class SHProto.SHCharacterPlayImpactDetectionComponent
// 0x0070 (0x0110 - 0x00A0)
class USHCharacterPlayImpactDetectionComponent final : public UActorComponent
{
public:
	float                                         OverlapTestMargin;                                 // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHitHeightFraction;                              // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class AActor*, struct FHitEvent>         ImpactCandidates;                                  // 0x00A8(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         ActiveContacts;                                    // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x0108(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CreateHitEvent(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void SHDebug_Character_ImpactDetection_DrawDebug();
	void SHDebug_Character_ImpactDetection_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayImpactDetectionComponent">();
	}
	static class USHCharacterPlayImpactDetectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayImpactDetectionComponent>();
	}
};
static_assert(alignof(USHCharacterPlayImpactDetectionComponent) == 0x000008, "Wrong alignment on USHCharacterPlayImpactDetectionComponent");
static_assert(sizeof(USHCharacterPlayImpactDetectionComponent) == 0x000110, "Wrong size on USHCharacterPlayImpactDetectionComponent");
static_assert(offsetof(USHCharacterPlayImpactDetectionComponent, OverlapTestMargin) == 0x0000A0, "Member 'USHCharacterPlayImpactDetectionComponent::OverlapTestMargin' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayImpactDetectionComponent, MinHitHeightFraction) == 0x0000A4, "Member 'USHCharacterPlayImpactDetectionComponent::MinHitHeightFraction' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayImpactDetectionComponent, ImpactCandidates) == 0x0000A8, "Member 'USHCharacterPlayImpactDetectionComponent::ImpactCandidates' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayImpactDetectionComponent, ActiveContacts) == 0x0000F8, "Member 'USHCharacterPlayImpactDetectionComponent::ActiveContacts' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayImpactDetectionComponent, OwnerCharacter) == 0x000108, "Member 'USHCharacterPlayImpactDetectionComponent::OwnerCharacter' has a wrong offset!");

// Class SHProto.SHAnimNotifyState_IdleLoop
// 0x0000 (0x0030 - 0x0030)
class USHAnimNotifyState_IdleLoop final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotifyState_IdleLoop">();
	}
	static class USHAnimNotifyState_IdleLoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotifyState_IdleLoop>();
	}
};
static_assert(alignof(USHAnimNotifyState_IdleLoop) == 0x000008, "Wrong alignment on USHAnimNotifyState_IdleLoop");
static_assert(sizeof(USHAnimNotifyState_IdleLoop) == 0x000030, "Wrong size on USHAnimNotifyState_IdleLoop");

// Class SHProto.SHNurseAnimComponent
// 0x0080 (0x0510 - 0x0490)
class USHNurseAnimComponent final : public USHEnemyAnimComponent
{
public:
	struct FSHAnimFootIKSubcompSettings           SHAnimFootIKSubcompSettings;                       // 0x0490(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 HeadShakeMaterialsIndexes;                         // 0x0500(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHNurseAnimComponent">();
	}
	static class USHNurseAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHNurseAnimComponent>();
	}
};
static_assert(alignof(USHNurseAnimComponent) == 0x000008, "Wrong alignment on USHNurseAnimComponent");
static_assert(sizeof(USHNurseAnimComponent) == 0x000510, "Wrong size on USHNurseAnimComponent");
static_assert(offsetof(USHNurseAnimComponent, SHAnimFootIKSubcompSettings) == 0x000490, "Member 'USHNurseAnimComponent::SHAnimFootIKSubcompSettings' has a wrong offset!");
static_assert(offsetof(USHNurseAnimComponent, HeadShakeMaterialsIndexes) == 0x000500, "Member 'USHNurseAnimComponent::HeadShakeMaterialsIndexes' has a wrong offset!");

// Class SHProto.AnimNotify_LockPhysicsRotation
// 0x0010 (0x0040 - 0x0030)
class UAnimNotify_LockPhysicsRotation final : public UAnimNotifyState
{
public:
	bool                                          bLockRotation;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LockType;                                          // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_LockPhysicsRotation">();
	}
	static class UAnimNotify_LockPhysicsRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_LockPhysicsRotation>();
	}
};
static_assert(alignof(UAnimNotify_LockPhysicsRotation) == 0x000008, "Wrong alignment on UAnimNotify_LockPhysicsRotation");
static_assert(sizeof(UAnimNotify_LockPhysicsRotation) == 0x000040, "Wrong size on UAnimNotify_LockPhysicsRotation");
static_assert(offsetof(UAnimNotify_LockPhysicsRotation, bLockRotation) == 0x000030, "Member 'UAnimNotify_LockPhysicsRotation::bLockRotation' has a wrong offset!");
static_assert(offsetof(UAnimNotify_LockPhysicsRotation, LockType) == 0x000034, "Member 'UAnimNotify_LockPhysicsRotation::LockType' has a wrong offset!");

// Class SHProto.SHCharacterPlayDeathPlayer
// 0x0020 (0x0320 - 0x0300)
class ASHCharacterPlayDeathPlayer : public ASHDeathPlayer
{
public:
	class UBoxComponent*                          FullAreaWork;                                      // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CharacterPlaySpot;                                 // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CharacterPlayPreviewStandMesh;                     // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CharacterPlayPreviewLayDownMesh;                   // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayDeathPlayer">();
	}
	static class ASHCharacterPlayDeathPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHCharacterPlayDeathPlayer>();
	}
};
static_assert(alignof(ASHCharacterPlayDeathPlayer) == 0x000008, "Wrong alignment on ASHCharacterPlayDeathPlayer");
static_assert(sizeof(ASHCharacterPlayDeathPlayer) == 0x000320, "Wrong size on ASHCharacterPlayDeathPlayer");
static_assert(offsetof(ASHCharacterPlayDeathPlayer, FullAreaWork) == 0x000300, "Member 'ASHCharacterPlayDeathPlayer::FullAreaWork' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayDeathPlayer, CharacterPlaySpot) == 0x000308, "Member 'ASHCharacterPlayDeathPlayer::CharacterPlaySpot' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayDeathPlayer, CharacterPlayPreviewStandMesh) == 0x000310, "Member 'ASHCharacterPlayDeathPlayer::CharacterPlayPreviewStandMesh' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayDeathPlayer, CharacterPlayPreviewLayDownMesh) == 0x000318, "Member 'ASHCharacterPlayDeathPlayer::CharacterPlayPreviewLayDownMesh' has a wrong offset!");

// Class SHProto.SHCharacterPlayGenericDeathPlayer
// 0x0130 (0x0450 - 0x0320)
class ASHCharacterPlayGenericDeathPlayer final : public ASHCharacterPlayDeathPlayer
{
public:
	struct FPlayAnimationData                     CharacterAnimation;                                // 0x0320(0x00B0)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSHCameraAnimationData                 CameraAnimation;                                   // 0x03D0(0x0080)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayGenericDeathPlayer">();
	}
	static class ASHCharacterPlayGenericDeathPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHCharacterPlayGenericDeathPlayer>();
	}
};
static_assert(alignof(ASHCharacterPlayGenericDeathPlayer) == 0x000008, "Wrong alignment on ASHCharacterPlayGenericDeathPlayer");
static_assert(sizeof(ASHCharacterPlayGenericDeathPlayer) == 0x000450, "Wrong size on ASHCharacterPlayGenericDeathPlayer");
static_assert(offsetof(ASHCharacterPlayGenericDeathPlayer, CharacterAnimation) == 0x000320, "Member 'ASHCharacterPlayGenericDeathPlayer::CharacterAnimation' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayGenericDeathPlayer, CameraAnimation) == 0x0003D0, "Member 'ASHCharacterPlayGenericDeathPlayer::CameraAnimation' has a wrong offset!");

// Class SHProto.SHAnimNotifyState_LookAtEnemy
// 0x0010 (0x0040 - 0x0030)
class USHAnimNotifyState_LookAtEnemy final : public UAnimNotifyState
{
public:
	bool                                          _CheckConeRange;                                   // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _ConeRange;                                        // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         _Priority;                                         // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotifyState_LookAtEnemy">();
	}
	static class USHAnimNotifyState_LookAtEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotifyState_LookAtEnemy>();
	}
};
static_assert(alignof(USHAnimNotifyState_LookAtEnemy) == 0x000008, "Wrong alignment on USHAnimNotifyState_LookAtEnemy");
static_assert(sizeof(USHAnimNotifyState_LookAtEnemy) == 0x000040, "Wrong size on USHAnimNotifyState_LookAtEnemy");
static_assert(offsetof(USHAnimNotifyState_LookAtEnemy, _CheckConeRange) == 0x000030, "Member 'USHAnimNotifyState_LookAtEnemy::_CheckConeRange' has a wrong offset!");
static_assert(offsetof(USHAnimNotifyState_LookAtEnemy, _ConeRange) == 0x000034, "Member 'USHAnimNotifyState_LookAtEnemy::_ConeRange' has a wrong offset!");
static_assert(offsetof(USHAnimNotifyState_LookAtEnemy, _Priority) == 0x000038, "Member 'USHAnimNotifyState_LookAtEnemy::_Priority' has a wrong offset!");

// Class SHProto.SHAnimNState_MQSpiderChangeSurface
// 0x0000 (0x0030 - 0x0030)
class USHAnimNState_MQSpiderChangeSurface final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNState_MQSpiderChangeSurface">();
	}
	static class USHAnimNState_MQSpiderChangeSurface* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNState_MQSpiderChangeSurface>();
	}
};
static_assert(alignof(USHAnimNState_MQSpiderChangeSurface) == 0x000008, "Wrong alignment on USHAnimNState_MQSpiderChangeSurface");
static_assert(sizeof(USHAnimNState_MQSpiderChangeSurface) == 0x000030, "Wrong size on USHAnimNState_MQSpiderChangeSurface");

// Class SHProto.SHCharacterPlayLightingBase
// 0x0050 (0x0300 - 0x02B0)
class ASHCharacterPlayLightingBase : public AActor
{
public:
	struct FLinearColor                           DefaultGlobalColor;                                // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x40];                                     // 0x02C0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayLightingBase">();
	}
	static class ASHCharacterPlayLightingBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHCharacterPlayLightingBase>();
	}
};
static_assert(alignof(ASHCharacterPlayLightingBase) == 0x000008, "Wrong alignment on ASHCharacterPlayLightingBase");
static_assert(sizeof(ASHCharacterPlayLightingBase) == 0x000300, "Wrong size on ASHCharacterPlayLightingBase");
static_assert(offsetof(ASHCharacterPlayLightingBase, DefaultGlobalColor) == 0x0002B0, "Member 'ASHCharacterPlayLightingBase::DefaultGlobalColor' has a wrong offset!");

// Class SHProto.SHCharacterPlayLighting
// 0x00F0 (0x03F0 - 0x0300)
class ASHCharacterPlayLighting final : public ASHCharacterPlayLightingBase
{
public:
	class USpotLightComponent*                    LightCharacterBack;                                // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpotLightComponent*                    LightCharacterFace;                                // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpotLightComponent*                    LightCharacterSide;                                // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPointLightComponent*                   FlashlightOffSupportLight;                         // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LightCharacterBackMinIntensity;                    // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LightCharacterBackFlashlightMod;                   // 0x0324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLightCharacterBackCastShadowsWhenMin;             // 0x0328(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLightCharacterBackCastShadowsWhenFlashlightMod;   // 0x0329(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32A[0x2];                                      // 0x032A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LightCharacterFaceMinIntensity;                    // 0x032C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LightCharacterFaceFlashlightMod;                   // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLightCharacterFaceCastShadowsWhenMin;             // 0x0334(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLightCharacterFaceCastShadowsWhenFlashlightMod;   // 0x0335(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_336[0x2];                                      // 0x0336(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LightCharacterSideMinIntensity;                    // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LightCharacterSideFlashlightMod;                   // 0x033C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLightCharacterSideCastShadowsWhenMin;             // 0x0340(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLightCharacterSideCastShadowsWhenFlashlightMod;   // 0x0341(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_342[0x2];                                      // 0x0342(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlashlightOffSupportLightDefaultIntensity;         // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            FlashlightOffSupportLightIntensityCurve;           // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimeline                              FlashlightOffSupportLightIntensityTimeline;        // 0x0350(0x0098)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFlashlightOffSupportLightProgress(float ProgressValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayLighting">();
	}
	static class ASHCharacterPlayLighting* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHCharacterPlayLighting>();
	}
};
static_assert(alignof(ASHCharacterPlayLighting) == 0x000008, "Wrong alignment on ASHCharacterPlayLighting");
static_assert(sizeof(ASHCharacterPlayLighting) == 0x0003F0, "Wrong size on ASHCharacterPlayLighting");
static_assert(offsetof(ASHCharacterPlayLighting, LightCharacterBack) == 0x000300, "Member 'ASHCharacterPlayLighting::LightCharacterBack' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayLighting, LightCharacterFace) == 0x000308, "Member 'ASHCharacterPlayLighting::LightCharacterFace' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayLighting, LightCharacterSide) == 0x000310, "Member 'ASHCharacterPlayLighting::LightCharacterSide' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayLighting, FlashlightOffSupportLight) == 0x000318, "Member 'ASHCharacterPlayLighting::FlashlightOffSupportLight' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayLighting, LightCharacterBackMinIntensity) == 0x000320, "Member 'ASHCharacterPlayLighting::LightCharacterBackMinIntensity' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayLighting, LightCharacterBackFlashlightMod) == 0x000324, "Member 'ASHCharacterPlayLighting::LightCharacterBackFlashlightMod' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayLighting, bLightCharacterBackCastShadowsWhenMin) == 0x000328, "Member 'ASHCharacterPlayLighting::bLightCharacterBackCastShadowsWhenMin' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayLighting, bLightCharacterBackCastShadowsWhenFlashlightMod) == 0x000329, "Member 'ASHCharacterPlayLighting::bLightCharacterBackCastShadowsWhenFlashlightMod' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayLighting, LightCharacterFaceMinIntensity) == 0x00032C, "Member 'ASHCharacterPlayLighting::LightCharacterFaceMinIntensity' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayLighting, LightCharacterFaceFlashlightMod) == 0x000330, "Member 'ASHCharacterPlayLighting::LightCharacterFaceFlashlightMod' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayLighting, bLightCharacterFaceCastShadowsWhenMin) == 0x000334, "Member 'ASHCharacterPlayLighting::bLightCharacterFaceCastShadowsWhenMin' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayLighting, bLightCharacterFaceCastShadowsWhenFlashlightMod) == 0x000335, "Member 'ASHCharacterPlayLighting::bLightCharacterFaceCastShadowsWhenFlashlightMod' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayLighting, LightCharacterSideMinIntensity) == 0x000338, "Member 'ASHCharacterPlayLighting::LightCharacterSideMinIntensity' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayLighting, LightCharacterSideFlashlightMod) == 0x00033C, "Member 'ASHCharacterPlayLighting::LightCharacterSideFlashlightMod' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayLighting, bLightCharacterSideCastShadowsWhenMin) == 0x000340, "Member 'ASHCharacterPlayLighting::bLightCharacterSideCastShadowsWhenMin' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayLighting, bLightCharacterSideCastShadowsWhenFlashlightMod) == 0x000341, "Member 'ASHCharacterPlayLighting::bLightCharacterSideCastShadowsWhenFlashlightMod' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayLighting, FlashlightOffSupportLightDefaultIntensity) == 0x000344, "Member 'ASHCharacterPlayLighting::FlashlightOffSupportLightDefaultIntensity' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayLighting, FlashlightOffSupportLightIntensityCurve) == 0x000348, "Member 'ASHCharacterPlayLighting::FlashlightOffSupportLightIntensityCurve' has a wrong offset!");
static_assert(offsetof(ASHCharacterPlayLighting, FlashlightOffSupportLightIntensityTimeline) == 0x000350, "Member 'ASHCharacterPlayLighting::FlashlightOffSupportLightIntensityTimeline' has a wrong offset!");

// Class SHProto.SHAnimNState_PHMovePlayRate
// 0x0020 (0x0050 - 0x0030)
class USHAnimNState_PHMovePlayRate final : public UAnimNotifyState
{
public:
	float                                         PlayRate;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PlayRateCurve;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNState_PHMovePlayRate">();
	}
	static class USHAnimNState_PHMovePlayRate* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNState_PHMovePlayRate>();
	}
};
static_assert(alignof(USHAnimNState_PHMovePlayRate) == 0x000008, "Wrong alignment on USHAnimNState_PHMovePlayRate");
static_assert(sizeof(USHAnimNState_PHMovePlayRate) == 0x000050, "Wrong size on USHAnimNState_PHMovePlayRate");
static_assert(offsetof(USHAnimNState_PHMovePlayRate, PlayRate) == 0x000030, "Member 'USHAnimNState_PHMovePlayRate::PlayRate' has a wrong offset!");
static_assert(offsetof(USHAnimNState_PHMovePlayRate, PlayRateCurve) == 0x000038, "Member 'USHAnimNState_PHMovePlayRate::PlayRateCurve' has a wrong offset!");

// Class SHProto.SHSystemFXBase
// 0x0158 (0x0408 - 0x02B0)
class ASHSystemFXBase : public AActor
{
public:
	class USceneComponent*                        ParticlesPivotPoint;                               // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        DecalPivotPoint;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDecalComponent*                        DecalComponent;                                    // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USHSystemFXData*                        AssignedSystemFXData;                              // 0x02D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AkAudioEventOverride;                              // 0x02D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x128];                                    // 0x02E0(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnImpactDecalApplied();
	void OnInit(const class USHSystemFXData* InSystemFXData, const struct FHitResult& InHit);
	void PostAkEvent(class UAkAudioEvent* InAudioAsset, bool InShouldStopPooledAkComponentOnEndPlay);
	void ProcessImpactFXFinished(class UNiagaraComponent* InComponent);
	void SetSelfDestroyTimeValue(float InValue);

	class UMaterialInstanceDynamic* GetDecalMaterialDynamic() const;
	class UNiagaraComponent* GetSpawnedNiagaraComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSystemFXBase">();
	}
	static class ASHSystemFXBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHSystemFXBase>();
	}
};
static_assert(alignof(ASHSystemFXBase) == 0x000008, "Wrong alignment on ASHSystemFXBase");
static_assert(sizeof(ASHSystemFXBase) == 0x000408, "Wrong size on ASHSystemFXBase");
static_assert(offsetof(ASHSystemFXBase, ParticlesPivotPoint) == 0x0002B0, "Member 'ASHSystemFXBase::ParticlesPivotPoint' has a wrong offset!");
static_assert(offsetof(ASHSystemFXBase, DecalPivotPoint) == 0x0002B8, "Member 'ASHSystemFXBase::DecalPivotPoint' has a wrong offset!");
static_assert(offsetof(ASHSystemFXBase, DecalComponent) == 0x0002C0, "Member 'ASHSystemFXBase::DecalComponent' has a wrong offset!");
static_assert(offsetof(ASHSystemFXBase, AssignedSystemFXData) == 0x0002D0, "Member 'ASHSystemFXBase::AssignedSystemFXData' has a wrong offset!");
static_assert(offsetof(ASHSystemFXBase, AkAudioEventOverride) == 0x0002D8, "Member 'ASHSystemFXBase::AkAudioEventOverride' has a wrong offset!");

// Class SHProto.SHPukePuddleBase
// 0x0020 (0x0428 - 0x0408)
class ASHPukePuddleBase : public ASHSystemFXBase
{
public:
	float                                         _CloseDistDecalFactor;                             // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _ActivePhaseDuration;                              // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _DeactivatePhaseDuration;                          // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_414[0x4];                                      // 0x0414(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     _StaticDecalMaterial;                              // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_420[0x8];                                      // 0x0420(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPuddleActivated();
	void OnPuddleDeactivated();

	float GetPuddleRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPukePuddleBase">();
	}
	static class ASHPukePuddleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHPukePuddleBase>();
	}
};
static_assert(alignof(ASHPukePuddleBase) == 0x000008, "Wrong alignment on ASHPukePuddleBase");
static_assert(sizeof(ASHPukePuddleBase) == 0x000428, "Wrong size on ASHPukePuddleBase");
static_assert(offsetof(ASHPukePuddleBase, _CloseDistDecalFactor) == 0x000408, "Member 'ASHPukePuddleBase::_CloseDistDecalFactor' has a wrong offset!");
static_assert(offsetof(ASHPukePuddleBase, _ActivePhaseDuration) == 0x00040C, "Member 'ASHPukePuddleBase::_ActivePhaseDuration' has a wrong offset!");
static_assert(offsetof(ASHPukePuddleBase, _DeactivatePhaseDuration) == 0x000410, "Member 'ASHPukePuddleBase::_DeactivatePhaseDuration' has a wrong offset!");
static_assert(offsetof(ASHPukePuddleBase, _StaticDecalMaterial) == 0x000418, "Member 'ASHPukePuddleBase::_StaticDecalMaterial' has a wrong offset!");

// Class SHProto.SHAnimNState_PHStopMotionAnim
// 0x0020 (0x0050 - 0x0030)
class USHAnimNState_PHStopMotionAnim final : public UAnimNotifyState
{
public:
	float                                         StopMotionAlpha;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StopMotionAlphaCurve;                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNState_PHStopMotionAnim">();
	}
	static class USHAnimNState_PHStopMotionAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNState_PHStopMotionAnim>();
	}
};
static_assert(alignof(USHAnimNState_PHStopMotionAnim) == 0x000008, "Wrong alignment on USHAnimNState_PHStopMotionAnim");
static_assert(sizeof(USHAnimNState_PHStopMotionAnim) == 0x000050, "Wrong size on USHAnimNState_PHStopMotionAnim");
static_assert(offsetof(USHAnimNState_PHStopMotionAnim, StopMotionAlpha) == 0x000030, "Member 'USHAnimNState_PHStopMotionAnim::StopMotionAlpha' has a wrong offset!");
static_assert(offsetof(USHAnimNState_PHStopMotionAnim, StopMotionAlphaCurve) == 0x000038, "Member 'USHAnimNState_PHStopMotionAnim::StopMotionAlphaCurve' has a wrong offset!");

// Class SHProto.SHCharacterPlayMovementComponent
// 0x0440 (0x1340 - 0x0F00)
class USHCharacterPlayMovementComponent final : public UCharacterMovementComponent
{
public:
	class USHMovementObstacleDetection*           MovementObstacleDetection;                         // 0x0EF8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IncreaseMaxSpeedInterpSpeed;                       // 0x0F00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecreaseMaxSpeedInterpSpeed;                       // 0x0F04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinVelocityToPlaySprintShake;                      // 0x0F08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinWaterDepthToBeInWaterState;                     // 0x0F0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCharacterPlayMovementSettings*       Settings;                                          // 0x0F10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             PushableRegisteredBPEvent;                         // 0x0F18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             PushableUnregisteredBPEvent;                       // 0x0F28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x0F38(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraShakeBase*                       PlayingSprintCameraShake;                          // 0x0F40(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           AssignedSprintCameraShakeClass;                    // 0x0F48(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHPushableComponent*                   PushableComponent;                                 // 0x0F50(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHVehicleMovementProcessor*            VehicleMovementProcessor;                          // 0x0F58(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ASHInteriorExteriorVolume*>      TeriorVolumes;                                     // 0x0F60(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSHCustomMovementStruct>        CustomMovements;                                   // 0x0F70(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F80[0x3C0];                                    // 0x0F80(0x03C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearMovementScale(const class UObject* Object);
	void HandleReceiveDamageEvent(class USHCharacterPlayCombatComponent* CombatComp);
	class USHOperationEvents* MovementSnapAbsolute(const struct FVector& Location, const float Timeout, const struct FSHMovementSnapConfig& Config, const class UObject* Object);
	class USHOperationEvents* RotationSnapAbsolute(const struct FVector& Location, const float Duration, const class UObject* Object, class UCurveFloat* Curve);
	class USHOperationEvents* RotationSnapAbsoluteStatic(const struct FRotator& WorldRotation, const float Duration, const class UObject* Object, class UCurveFloat* Curve);
	void SetControllerYawRotationMatchingBlocked(const bool Blocked, const class UObject* Object);
	void SetDisableToggleSprintAutoEnd(const bool InValue, const class UObject* Object);
	void SetIsOnStairs(bool OnStairs);
	void SetMovementBlocked(const bool Blocked, const class UObject* Object);
	void SetMovementScale(const float Scale, const class UObject* Object);
	void SetPhysWalkingBlocked(const bool Blocked, const class UObject* Object);
	void SetRotateInPlaceBlocked(const bool Blocked, const class UObject* Object);
	void SetRotateInPlaceCustomAllowed(const bool bInAllowed, const class UObject* Object);
	void SetSprintBlocked(const bool Blocked, const class UObject* Object);
	void SHCharacterPlayMovementEvent__DelegateSignature(class USHCharacterPlayMovementComponent* ComponentRef);
	void SHDebug_Character_Movement_DrawDebug();
	void SHDebug_Character_Movement_ForceSprint();
	void SHDebug_Character_Movement_MovementSnapDrawDebug();
	void SHDebug_Character_Movement_PushableDrawDebug();
	void SHDebug_Character_Movement_RotationSnapDrawDebug();
	void SHDebug_Character_Movement_SlideSnapDrawDebug();
	void SHDebug_Character_Movement_SpamMovementImpacts();
	void SHDebug_Character_Movement_SpamMovementInputDebug();
	void SHDebug_Character_Movement_ValuesDebug();
	class USHOperationEvents* SlideSnapAbsolute(const struct FVector& Location, const float Duration, const class UObject* Object, const TArray<class AActor*>& InCollisionIgnoredActors, class UCurveFloat* Curve);
	void StopRotateInPlaceImmediately();
	void TeleportAbsolute(const struct FTransform& InTransform);
	void TeleportAbsoluteWithView(const struct FTransform& InTransform, const struct FRotator& InViewRotation);
	void TeleportRelatively(const struct FTransform& FirstAnchor, const struct FTransform& SecondAnchor);
	void TeleportRelativelyToActors(class AActor* FirstAnchor, class AActor* SecondAnchor);
	void TeleportRelativelyToComponents(class USceneComponent* FirstAnchor, class USceneComponent* SecondAnchor);
	void TelportAbsoluteWithDefaultView(const struct FTransform& InTransform);

	struct FVector GetFakedVelocity() const;
	ESHInteriorExteriorStateEnum GetInteriorExteriorState() const;
	struct FVector GetLastInputValue() const;
	float GetLastSlopeAngleDeg() const;
	bool IsControllerYawRotationMatchingBlocked() const;
	bool IsInWater() const;
	bool IsMovementBlocked() const;
	bool IsMovementBlockedBy(const class UObject* Object) const;
	bool IsMovingOnSlope() const;
	bool IsOnStairs() const;
	bool IsPhysWalkingBlocked() const;
	bool IsRotateInPlaceBlocked() const;
	bool IsSprintBlocked() const;
	bool IsSprintBlockedBy(const class UObject* Object) const;
	bool IsSprinting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayMovementComponent">();
	}
	static class USHCharacterPlayMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayMovementComponent>();
	}
};
static_assert(alignof(USHCharacterPlayMovementComponent) == 0x000010, "Wrong alignment on USHCharacterPlayMovementComponent");
static_assert(sizeof(USHCharacterPlayMovementComponent) == 0x001340, "Wrong size on USHCharacterPlayMovementComponent");
static_assert(offsetof(USHCharacterPlayMovementComponent, MovementObstacleDetection) == 0x000EF8, "Member 'USHCharacterPlayMovementComponent::MovementObstacleDetection' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMovementComponent, IncreaseMaxSpeedInterpSpeed) == 0x000F00, "Member 'USHCharacterPlayMovementComponent::IncreaseMaxSpeedInterpSpeed' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMovementComponent, DecreaseMaxSpeedInterpSpeed) == 0x000F04, "Member 'USHCharacterPlayMovementComponent::DecreaseMaxSpeedInterpSpeed' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMovementComponent, MinVelocityToPlaySprintShake) == 0x000F08, "Member 'USHCharacterPlayMovementComponent::MinVelocityToPlaySprintShake' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMovementComponent, MinWaterDepthToBeInWaterState) == 0x000F0C, "Member 'USHCharacterPlayMovementComponent::MinWaterDepthToBeInWaterState' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMovementComponent, Settings) == 0x000F10, "Member 'USHCharacterPlayMovementComponent::Settings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMovementComponent, PushableRegisteredBPEvent) == 0x000F18, "Member 'USHCharacterPlayMovementComponent::PushableRegisteredBPEvent' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMovementComponent, PushableUnregisteredBPEvent) == 0x000F28, "Member 'USHCharacterPlayMovementComponent::PushableUnregisteredBPEvent' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMovementComponent, OwnerCharacter) == 0x000F38, "Member 'USHCharacterPlayMovementComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMovementComponent, PlayingSprintCameraShake) == 0x000F40, "Member 'USHCharacterPlayMovementComponent::PlayingSprintCameraShake' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMovementComponent, AssignedSprintCameraShakeClass) == 0x000F48, "Member 'USHCharacterPlayMovementComponent::AssignedSprintCameraShakeClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMovementComponent, PushableComponent) == 0x000F50, "Member 'USHCharacterPlayMovementComponent::PushableComponent' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMovementComponent, VehicleMovementProcessor) == 0x000F58, "Member 'USHCharacterPlayMovementComponent::VehicleMovementProcessor' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMovementComponent, TeriorVolumes) == 0x000F60, "Member 'USHCharacterPlayMovementComponent::TeriorVolumes' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMovementComponent, CustomMovements) == 0x000F70, "Member 'USHCharacterPlayMovementComponent::CustomMovements' has a wrong offset!");

// Class SHProto.AnimNotify_DisableLookAt
// 0x0008 (0x0038 - 0x0030)
class UAnimNotify_DisableLookAt final : public UAnimNotifyState
{
public:
	float                                         LookAtAlphaBlendInSpeed;                           // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtAlphaBlendOutSpeed;                          // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DisableLookAt">();
	}
	static class UAnimNotify_DisableLookAt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DisableLookAt>();
	}
};
static_assert(alignof(UAnimNotify_DisableLookAt) == 0x000008, "Wrong alignment on UAnimNotify_DisableLookAt");
static_assert(sizeof(UAnimNotify_DisableLookAt) == 0x000038, "Wrong size on UAnimNotify_DisableLookAt");
static_assert(offsetof(UAnimNotify_DisableLookAt, LookAtAlphaBlendInSpeed) == 0x000030, "Member 'UAnimNotify_DisableLookAt::LookAtAlphaBlendInSpeed' has a wrong offset!");
static_assert(offsetof(UAnimNotify_DisableLookAt, LookAtAlphaBlendOutSpeed) == 0x000034, "Member 'UAnimNotify_DisableLookAt::LookAtAlphaBlendOutSpeed' has a wrong offset!");

// Class SHProto.AnimNotify_HideWeaponMesh
// 0x0018 (0x0048 - 0x0030)
class UAnimNotify_HideWeaponMesh final : public UAnimNotifyState
{
public:
	bool                                          EnsureIsHiddenPerTick;                             // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASHItemWeapon*>                  ProcessedWeapons;                                  // 0x0038(0x0010)(BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_HideWeaponMesh">();
	}
	static class UAnimNotify_HideWeaponMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_HideWeaponMesh>();
	}
};
static_assert(alignof(UAnimNotify_HideWeaponMesh) == 0x000008, "Wrong alignment on UAnimNotify_HideWeaponMesh");
static_assert(sizeof(UAnimNotify_HideWeaponMesh) == 0x000048, "Wrong size on UAnimNotify_HideWeaponMesh");
static_assert(offsetof(UAnimNotify_HideWeaponMesh, EnsureIsHiddenPerTick) == 0x000030, "Member 'UAnimNotify_HideWeaponMesh::EnsureIsHiddenPerTick' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HideWeaponMesh, ProcessedWeapons) == 0x000038, "Member 'UAnimNotify_HideWeaponMesh::ProcessedWeapons' has a wrong offset!");

// Class SHProto.SHCharacterPlayLookAtLogicComponent
// 0x0010 (0x0190 - 0x0180)
class USHCharacterPlayLookAtLogicComponent final : public USHCharacterLookAtLogicComponent
{
public:
	class ASHCharacterPlay*                       CharacterPlay;                                     // 0x0180(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Character_LookAt_DrawDebug();
	void SHDebug_Character_LookAt_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayLookAtLogicComponent">();
	}
	static class USHCharacterPlayLookAtLogicComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayLookAtLogicComponent>();
	}
};
static_assert(alignof(USHCharacterPlayLookAtLogicComponent) == 0x000008, "Wrong alignment on USHCharacterPlayLookAtLogicComponent");
static_assert(sizeof(USHCharacterPlayLookAtLogicComponent) == 0x000190, "Wrong size on USHCharacterPlayLookAtLogicComponent");
static_assert(offsetof(USHCharacterPlayLookAtLogicComponent, CharacterPlay) == 0x000180, "Member 'USHCharacterPlayLookAtLogicComponent::CharacterPlay' has a wrong offset!");

// Class SHProto.SHAnimNState_HyperArmor
// 0x0068 (0x0098 - 0x0030)
class USHAnimNState_HyperArmor final : public UAnimNotifyState
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHEnemyHitReactionSelectionAllowedStates AllowedHitReactions;                               // 0x0038(0x0060)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNState_HyperArmor">();
	}
	static class USHAnimNState_HyperArmor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNState_HyperArmor>();
	}
};
static_assert(alignof(USHAnimNState_HyperArmor) == 0x000008, "Wrong alignment on USHAnimNState_HyperArmor");
static_assert(sizeof(USHAnimNState_HyperArmor) == 0x000098, "Wrong size on USHAnimNState_HyperArmor");
static_assert(offsetof(USHAnimNState_HyperArmor, AllowedHitReactions) == 0x000038, "Member 'USHAnimNState_HyperArmor::AllowedHitReactions' has a wrong offset!");

// Class SHProto.NurseInjectDamage
// 0x0000 (0x0068 - 0x0068)
class UNurseInjectDamage final : public UMeleeDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NurseInjectDamage">();
	}
	static class UNurseInjectDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNurseInjectDamage>();
	}
};
static_assert(alignof(UNurseInjectDamage) == 0x000008, "Wrong alignment on UNurseInjectDamage");
static_assert(sizeof(UNurseInjectDamage) == 0x000068, "Wrong size on UNurseInjectDamage");

// Class SHProto.SHAnimNotify_MariaDialogue
// 0x00F0 (0x0128 - 0x0038)
class USHAnimNotify_MariaDialogue final : public UAnimNotify
{
public:
	struct FDialogDialog                          DialogToPlay;                                      // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDialogInfo                            DialogInfo;                                        // 0x0060(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_MariaDialogue">();
	}
	static class USHAnimNotify_MariaDialogue* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_MariaDialogue>();
	}
};
static_assert(alignof(USHAnimNotify_MariaDialogue) == 0x000008, "Wrong alignment on USHAnimNotify_MariaDialogue");
static_assert(sizeof(USHAnimNotify_MariaDialogue) == 0x000128, "Wrong size on USHAnimNotify_MariaDialogue");
static_assert(offsetof(USHAnimNotify_MariaDialogue, DialogToPlay) == 0x000038, "Member 'USHAnimNotify_MariaDialogue::DialogToPlay' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_MariaDialogue, DialogInfo) == 0x000060, "Member 'USHAnimNotify_MariaDialogue::DialogInfo' has a wrong offset!");

// Class SHProto.SHCharacterPlayItemsComponent
// 0x01E0 (0x0280 - 0x00A0)
class USHCharacterPlayItemsComponent final : public UActorComponent
{
public:
	TSubclassOf<class ASHItem>                    DefaultItemClass;                                  // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USHItemUseExecutive>        NotesExecutiveClass;                               // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ASHItemInvestigationExecutive> ItemInvestigationExeClass;                         // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ASHItemInvestigationExecutive> ReadableItemInvestigationExeClass;                 // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ASHItemInvestigationExecutive> MapItemInvestigationExeClass;                      // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnCollectedItemInvestigatedBlueprintEvent;         // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnEquipmentItemSpawnedBlueprintEvent;              // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x00E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHItemUseExecutive*                    ItemUseExe;                                        // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHItemExecutiveBase*                   ItemExecutive;                                     // 0x00F8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ASHItemEquipment*>               EquipmentActors;                                   // 0x0100(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSHCollectedItemData>           CollectedItems;                                    // 0x0110(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           SkipInvestigationItems;                            // 0x0120(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, bool>                       EquipmentStateValues;                              // 0x0130(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           NewCollectedItems;                                 // 0x0180(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_190[0xF0];                                     // 0x0190(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CollectItem(const class FName ItemDataRowName, int32 ItemQuantity, const bool AddNewItemFlag);
	class ASHItemExecutiveBase* GetItemExecutive();
	bool InvestigateCollectedItemRequest(const class FName& InItemDataRowName);
	void OverrideFlashlightPocketState(bool InShouldBeOpened, const class UObject* Object);
	void ProcessOwnerCombatInputModeChanged(class USHCharacterPlayCombatComponent* CombatComp);
	void ProcessOwnerReceivedDamage(class USHCharacterPlayCombatComponent* CombatComp);
	void RemoveItem(const class FName ItemDataRowName, const int32 ItemQuantity, const bool RemoveNewItemFlag);
	void SetInvestigateItemBlocked(const bool Blocked, const class UObject* Object);
	void SetUseItemBlocked(const bool Blocked, const class UObject* Object);
	void SHDebug_Character_Items_Give(const class FString& ItemRowName);
	void SHDebug_Character_Items_GiveAllCombineables();
	void SHDebug_Character_Items_GiveAllConsumables();
	void SHDebug_Character_Items_GiveAllEquipment();
	void SHDebug_Character_Items_GiveAllItems();
	void SHDebug_Character_Items_GiveAllMaps();
	void SHDebug_Character_Items_GiveAllReflections();
	void SHDebug_Character_Items_GiveAllWeapons();
	void SHDebug_Character_Items_PerformNotesScribble();
	void SHDebug_Character_Items_RemoveAllItems();
	void SHDebug_Character_Items_UnlimitedAmmo();
	void SHDebug_Character_Items_ValuesDebug();
	void SHItemsComponentEvent__DelegateSignature(class USHCharacterPlayItemsComponent* ComponentPtr);
	void SHItemsComponentWithContextEvent__DelegateSignature(class USHCharacterPlayItemsComponent* ComponentPtr, class FName ItemContext);

	int32 GetItemCount(const class FName ItemDataRowName) const;
	bool HasItem(const class FName ItemDataRowName) const;
	bool IsInvestigateItemBlocked() const;
	bool IsUseItemBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayItemsComponent">();
	}
	static class USHCharacterPlayItemsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayItemsComponent>();
	}
};
static_assert(alignof(USHCharacterPlayItemsComponent) == 0x000008, "Wrong alignment on USHCharacterPlayItemsComponent");
static_assert(sizeof(USHCharacterPlayItemsComponent) == 0x000280, "Wrong size on USHCharacterPlayItemsComponent");
static_assert(offsetof(USHCharacterPlayItemsComponent, DefaultItemClass) == 0x0000A0, "Member 'USHCharacterPlayItemsComponent::DefaultItemClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayItemsComponent, NotesExecutiveClass) == 0x0000A8, "Member 'USHCharacterPlayItemsComponent::NotesExecutiveClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayItemsComponent, ItemInvestigationExeClass) == 0x0000B0, "Member 'USHCharacterPlayItemsComponent::ItemInvestigationExeClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayItemsComponent, ReadableItemInvestigationExeClass) == 0x0000B8, "Member 'USHCharacterPlayItemsComponent::ReadableItemInvestigationExeClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayItemsComponent, MapItemInvestigationExeClass) == 0x0000C0, "Member 'USHCharacterPlayItemsComponent::MapItemInvestigationExeClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayItemsComponent, OnCollectedItemInvestigatedBlueprintEvent) == 0x0000C8, "Member 'USHCharacterPlayItemsComponent::OnCollectedItemInvestigatedBlueprintEvent' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayItemsComponent, OnEquipmentItemSpawnedBlueprintEvent) == 0x0000D8, "Member 'USHCharacterPlayItemsComponent::OnEquipmentItemSpawnedBlueprintEvent' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayItemsComponent, OwnerCharacter) == 0x0000E8, "Member 'USHCharacterPlayItemsComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayItemsComponent, ItemUseExe) == 0x0000F0, "Member 'USHCharacterPlayItemsComponent::ItemUseExe' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayItemsComponent, ItemExecutive) == 0x0000F8, "Member 'USHCharacterPlayItemsComponent::ItemExecutive' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayItemsComponent, EquipmentActors) == 0x000100, "Member 'USHCharacterPlayItemsComponent::EquipmentActors' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayItemsComponent, CollectedItems) == 0x000110, "Member 'USHCharacterPlayItemsComponent::CollectedItems' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayItemsComponent, SkipInvestigationItems) == 0x000120, "Member 'USHCharacterPlayItemsComponent::SkipInvestigationItems' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayItemsComponent, EquipmentStateValues) == 0x000130, "Member 'USHCharacterPlayItemsComponent::EquipmentStateValues' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayItemsComponent, NewCollectedItems) == 0x000180, "Member 'USHCharacterPlayItemsComponent::NewCollectedItems' has a wrong offset!");

// Class SHProto.SHAnimNotify_MonsterReviveSeizureRestart
// 0x0010 (0x0048 - 0x0038)
class USHAnimNotify_MonsterReviveSeizureRestart final : public UAnimNotify
{
public:
	class FName                                   SeizuresFinishSection;                             // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReduceSeizuresCountBy;                             // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_MonsterReviveSeizureRestart">();
	}
	static class USHAnimNotify_MonsterReviveSeizureRestart* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_MonsterReviveSeizureRestart>();
	}
};
static_assert(alignof(USHAnimNotify_MonsterReviveSeizureRestart) == 0x000008, "Wrong alignment on USHAnimNotify_MonsterReviveSeizureRestart");
static_assert(sizeof(USHAnimNotify_MonsterReviveSeizureRestart) == 0x000048, "Wrong size on USHAnimNotify_MonsterReviveSeizureRestart");
static_assert(offsetof(USHAnimNotify_MonsterReviveSeizureRestart, SeizuresFinishSection) == 0x000038, "Member 'USHAnimNotify_MonsterReviveSeizureRestart::SeizuresFinishSection' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_MonsterReviveSeizureRestart, ReduceSeizuresCountBy) == 0x000040, "Member 'USHAnimNotify_MonsterReviveSeizureRestart::ReduceSeizuresCountBy' has a wrong offset!");

// Class SHProto.SHAnimNotify_MovementVariationRandomChange
// 0x0000 (0x0038 - 0x0038)
class USHAnimNotify_MovementVariationRandomChange final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_MovementVariationRandomChange">();
	}
	static class USHAnimNotify_MovementVariationRandomChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_MovementVariationRandomChange>();
	}
};
static_assert(alignof(USHAnimNotify_MovementVariationRandomChange) == 0x000008, "Wrong alignment on USHAnimNotify_MovementVariationRandomChange");
static_assert(sizeof(USHAnimNotify_MovementVariationRandomChange) == 0x000038, "Wrong size on USHAnimNotify_MovementVariationRandomChange");

// Class SHProto.SHLookAtInteractionTargetProvider
// 0x0048 (0x00B0 - 0x0068)
class USHLookAtInteractionTargetProvider : public USHLookAtTargetProvider
{
public:
	float                                         MaxDistance;                                       // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle;                                          // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AngleScoreCurve;                                   // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteractionTraceRetries;                           // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        ActiveInteractionComponent;                        // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        LastSelectedComponent;                             // 0x0088(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x20];                                      // 0x0090(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLookAtInteractionTargetProvider">();
	}
	static class USHLookAtInteractionTargetProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLookAtInteractionTargetProvider>();
	}
};
static_assert(alignof(USHLookAtInteractionTargetProvider) == 0x000008, "Wrong alignment on USHLookAtInteractionTargetProvider");
static_assert(sizeof(USHLookAtInteractionTargetProvider) == 0x0000B0, "Wrong size on USHLookAtInteractionTargetProvider");
static_assert(offsetof(USHLookAtInteractionTargetProvider, MaxDistance) == 0x000068, "Member 'USHLookAtInteractionTargetProvider::MaxDistance' has a wrong offset!");
static_assert(offsetof(USHLookAtInteractionTargetProvider, MaxAngle) == 0x00006C, "Member 'USHLookAtInteractionTargetProvider::MaxAngle' has a wrong offset!");
static_assert(offsetof(USHLookAtInteractionTargetProvider, AngleScoreCurve) == 0x000070, "Member 'USHLookAtInteractionTargetProvider::AngleScoreCurve' has a wrong offset!");
static_assert(offsetof(USHLookAtInteractionTargetProvider, InteractionTraceRetries) == 0x000078, "Member 'USHLookAtInteractionTargetProvider::InteractionTraceRetries' has a wrong offset!");
static_assert(offsetof(USHLookAtInteractionTargetProvider, ActiveInteractionComponent) == 0x000080, "Member 'USHLookAtInteractionTargetProvider::ActiveInteractionComponent' has a wrong offset!");
static_assert(offsetof(USHLookAtInteractionTargetProvider, LastSelectedComponent) == 0x000088, "Member 'USHLookAtInteractionTargetProvider::LastSelectedComponent' has a wrong offset!");

// Class SHProto.SHCharacterPlayLookAtInteractionTargetProvider
// 0x0000 (0x00B0 - 0x00B0)
class USHCharacterPlayLookAtInteractionTargetProvider final : public USHLookAtInteractionTargetProvider
{
public:
	void SHDebug_Character_LookAtInteraction_DrawDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayLookAtInteractionTargetProvider">();
	}
	static class USHCharacterPlayLookAtInteractionTargetProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayLookAtInteractionTargetProvider>();
	}
};
static_assert(alignof(USHCharacterPlayLookAtInteractionTargetProvider) == 0x000008, "Wrong alignment on USHCharacterPlayLookAtInteractionTargetProvider");
static_assert(sizeof(USHCharacterPlayLookAtInteractionTargetProvider) == 0x0000B0, "Wrong size on USHCharacterPlayLookAtInteractionTargetProvider");

// Class SHProto.SHAnimNotify_TransformationState
// 0x0018 (0x0050 - 0x0038)
class USHAnimNotify_TransformationState final : public UAnimNotify
{
public:
	class USHEnemyTransformationState*            TransformationState;                               // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverrideDuration;                                  // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverrideHitReactionsChangeDelay;                   // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverrideLyingTransformationDelay;                  // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverrideLyingTransformationDuration;               // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_TransformationState">();
	}
	static class USHAnimNotify_TransformationState* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_TransformationState>();
	}
};
static_assert(alignof(USHAnimNotify_TransformationState) == 0x000008, "Wrong alignment on USHAnimNotify_TransformationState");
static_assert(sizeof(USHAnimNotify_TransformationState) == 0x000050, "Wrong size on USHAnimNotify_TransformationState");
static_assert(offsetof(USHAnimNotify_TransformationState, TransformationState) == 0x000038, "Member 'USHAnimNotify_TransformationState::TransformationState' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_TransformationState, OverrideDuration) == 0x000040, "Member 'USHAnimNotify_TransformationState::OverrideDuration' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_TransformationState, OverrideHitReactionsChangeDelay) == 0x000044, "Member 'USHAnimNotify_TransformationState::OverrideHitReactionsChangeDelay' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_TransformationState, OverrideLyingTransformationDelay) == 0x000048, "Member 'USHAnimNotify_TransformationState::OverrideLyingTransformationDelay' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_TransformationState, OverrideLyingTransformationDuration) == 0x00004C, "Member 'USHAnimNotify_TransformationState::OverrideLyingTransformationDuration' has a wrong offset!");

// Class SHProto.SHPushNClimbDesiredSpot
// 0x0030 (0x02E0 - 0x02B0)
class ASHPushNClimbDesiredSpot final : public AActor
{
public:
	class USHSafeBeginPlayComponent*              SafeBeginPlayComponent;                            // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 ManagedActor;                                      // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              LocalLocationTolerance;                            // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             ManagedActorReachedDesiredSpotEvent;               // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void RelayAppliedManagedActorState(bool bIsInDesiredSpotState, bool bInstantApply);
	void SHPushNClimbDesiredSpotEvent__DelegateSignature(class ASHPushNClimbDesiredSpot* DesiredSpot);

	bool IsManagedActorInDesiredSpot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPushNClimbDesiredSpot">();
	}
	static class ASHPushNClimbDesiredSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHPushNClimbDesiredSpot>();
	}
};
static_assert(alignof(ASHPushNClimbDesiredSpot) == 0x000008, "Wrong alignment on ASHPushNClimbDesiredSpot");
static_assert(sizeof(ASHPushNClimbDesiredSpot) == 0x0002E0, "Wrong size on ASHPushNClimbDesiredSpot");
static_assert(offsetof(ASHPushNClimbDesiredSpot, SafeBeginPlayComponent) == 0x0002B0, "Member 'ASHPushNClimbDesiredSpot::SafeBeginPlayComponent' has a wrong offset!");
static_assert(offsetof(ASHPushNClimbDesiredSpot, ManagedActor) == 0x0002B8, "Member 'ASHPushNClimbDesiredSpot::ManagedActor' has a wrong offset!");
static_assert(offsetof(ASHPushNClimbDesiredSpot, LocalLocationTolerance) == 0x0002C0, "Member 'ASHPushNClimbDesiredSpot::LocalLocationTolerance' has a wrong offset!");
static_assert(offsetof(ASHPushNClimbDesiredSpot, ManagedActorReachedDesiredSpotEvent) == 0x0002D0, "Member 'ASHPushNClimbDesiredSpot::ManagedActorReachedDesiredSpotEvent' has a wrong offset!");

// Class SHProto.SHAnimNPCIdleSubcomp
// 0x0020 (0x0058 - 0x0038)
class USHAnimNPCIdleSubcomp final : public USHAnimSubcomponentBase
{
public:
	float                                         IdlePlayRate;                                      // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x1C];                                      // 0x003C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCustomIdleEnter();
	void OnIdleLoopEnter();

	bool GetShouldPlayCustomIdle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNPCIdleSubcomp">();
	}
	static class USHAnimNPCIdleSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNPCIdleSubcomp>();
	}
};
static_assert(alignof(USHAnimNPCIdleSubcomp) == 0x000008, "Wrong alignment on USHAnimNPCIdleSubcomp");
static_assert(sizeof(USHAnimNPCIdleSubcomp) == 0x000058, "Wrong size on USHAnimNPCIdleSubcomp");
static_assert(offsetof(USHAnimNPCIdleSubcomp, IdlePlayRate) == 0x000038, "Member 'USHAnimNPCIdleSubcomp::IdlePlayRate' has a wrong offset!");

// Class SHProto.SHCharacterPlayStatisticsComponent
// 0x0058 (0x00F8 - 0x00A0)
class USHCharacterPlayStatisticsComponent final : public UActorComponent
{
public:
	class USHCharacterPlayStatisticsComponentSettings* Settings;                                          // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USHStatisticsValueProcessor*>    OwnedValueProcessors;                              // 0x00B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	ESHEndingType                                 RegisteredEnding;                                  // 0x00C0(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x37];                                      // 0x00C1(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Character_Statistics_SetPlaytime(float InHours);
	void SHDebug_Character_Statistics_ValuesDebug();
	void StartWatchingEverEnabledRadio();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayStatisticsComponent">();
	}
	static class USHCharacterPlayStatisticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayStatisticsComponent>();
	}
};
static_assert(alignof(USHCharacterPlayStatisticsComponent) == 0x000008, "Wrong alignment on USHCharacterPlayStatisticsComponent");
static_assert(sizeof(USHCharacterPlayStatisticsComponent) == 0x0000F8, "Wrong size on USHCharacterPlayStatisticsComponent");
static_assert(offsetof(USHCharacterPlayStatisticsComponent, Settings) == 0x0000A0, "Member 'USHCharacterPlayStatisticsComponent::Settings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponent, OwnerCharacter) == 0x0000A8, "Member 'USHCharacterPlayStatisticsComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponent, OwnedValueProcessors) == 0x0000B0, "Member 'USHCharacterPlayStatisticsComponent::OwnedValueProcessors' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponent, RegisteredEnding) == 0x0000C0, "Member 'USHCharacterPlayStatisticsComponent::RegisteredEnding' has a wrong offset!");

// Class SHProto.SHAnimNPCObstaclesDetectSubcomp
// 0x0030 (0x0068 - 0x0038)
class USHAnimNPCObstaclesDetectSubcomp : public USHAnimSubcomponentBase
{
public:
	TArray<struct FSHObstacleDetectSocketData>    SocketsToDetect;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSHObstacleDetectMovementData          MovementDetectionData;                             // 0x0048(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetSocketAlpha(int32 Index_0) const;
	struct FVector GetSocketCheckVector(int32 Index_0) const;
	float GetSocketCheckVectorLength(int32 Index_0) const;
	struct FVector GetSocketLocation(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNPCObstaclesDetectSubcomp">();
	}
	static class USHAnimNPCObstaclesDetectSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNPCObstaclesDetectSubcomp>();
	}
};
static_assert(alignof(USHAnimNPCObstaclesDetectSubcomp) == 0x000008, "Wrong alignment on USHAnimNPCObstaclesDetectSubcomp");
static_assert(sizeof(USHAnimNPCObstaclesDetectSubcomp) == 0x000068, "Wrong size on USHAnimNPCObstaclesDetectSubcomp");
static_assert(offsetof(USHAnimNPCObstaclesDetectSubcomp, SocketsToDetect) == 0x000038, "Member 'USHAnimNPCObstaclesDetectSubcomp::SocketsToDetect' has a wrong offset!");
static_assert(offsetof(USHAnimNPCObstaclesDetectSubcomp, MovementDetectionData) == 0x000048, "Member 'USHAnimNPCObstaclesDetectSubcomp::MovementDetectionData' has a wrong offset!");

// Class SHProto.SHAnimNurseHeadShakeSubcomp
// 0x0018 (0x0050 - 0x0038)
class USHAnimNurseHeadShakeSubcomp final : public USHAnimSubcomponentBase
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHeadShakeFinish();
	void OnHeadShakeStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNurseHeadShakeSubcomp">();
	}
	static class USHAnimNurseHeadShakeSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNurseHeadShakeSubcomp>();
	}
};
static_assert(alignof(USHAnimNurseHeadShakeSubcomp) == 0x000008, "Wrong alignment on USHAnimNurseHeadShakeSubcomp");
static_assert(sizeof(USHAnimNurseHeadShakeSubcomp) == 0x000050, "Wrong size on USHAnimNurseHeadShakeSubcomp");

// Class SHProto.SHCharacterPlayRaycastDetectorComponent
// 0x03E8 (0x0488 - 0x00A0)
class USHCharacterPlayRaycastDetectorComponent final : public UActorComponent
{
public:
	struct FSHRaycastDetectorTraceData            Hover;                                             // 0x00A0(0x0128)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSHRaycastDetectorTraceData            Interact;                                          // 0x01C8(0x0128)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x02F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x190];                                    // 0x02F8(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHoverBlocked(const bool Blocked, const class UObject* Object);
	void SetInteractBlocked(const bool Blocked, const class UObject* Object);

	bool IsHoverBlocked() const;
	bool IsInteractBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayRaycastDetectorComponent">();
	}
	static class USHCharacterPlayRaycastDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayRaycastDetectorComponent>();
	}
};
static_assert(alignof(USHCharacterPlayRaycastDetectorComponent) == 0x000008, "Wrong alignment on USHCharacterPlayRaycastDetectorComponent");
static_assert(sizeof(USHCharacterPlayRaycastDetectorComponent) == 0x000488, "Wrong size on USHCharacterPlayRaycastDetectorComponent");
static_assert(offsetof(USHCharacterPlayRaycastDetectorComponent, Hover) == 0x0000A0, "Member 'USHCharacterPlayRaycastDetectorComponent::Hover' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayRaycastDetectorComponent, Interact) == 0x0001C8, "Member 'USHCharacterPlayRaycastDetectorComponent::Interact' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayRaycastDetectorComponent, OwnerCharacter) == 0x0002F0, "Member 'USHCharacterPlayRaycastDetectorComponent::OwnerCharacter' has a wrong offset!");

// Class SHProto.SHAnimNurseMovementSubcomp
// 0x0028 (0x0170 - 0x0148)
class USHAnimNurseMovementSubcomp final : public USHAnimNPCMovementSubcomp
{
public:
	uint8                                         Pad_148[0x28];                                     // 0x0148(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNurseMovementSubcomp">();
	}
	static class USHAnimNurseMovementSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNurseMovementSubcomp>();
	}
};
static_assert(alignof(USHAnimNurseMovementSubcomp) == 0x000008, "Wrong alignment on USHAnimNurseMovementSubcomp");
static_assert(sizeof(USHAnimNurseMovementSubcomp) == 0x000170, "Wrong size on USHAnimNurseMovementSubcomp");

// Class SHProto.SHScriptedBreakGlassTutorialHandler
// 0x0010 (0x0048 - 0x0038)
class USHScriptedBreakGlassTutorialHandler final : public USHTutorialHandlerBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHScriptedBreakGlassTutorialHandler">();
	}
	static class USHScriptedBreakGlassTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHScriptedBreakGlassTutorialHandler>();
	}
};
static_assert(alignof(USHScriptedBreakGlassTutorialHandler) == 0x000008, "Wrong alignment on USHScriptedBreakGlassTutorialHandler");
static_assert(sizeof(USHScriptedBreakGlassTutorialHandler) == 0x000048, "Wrong size on USHScriptedBreakGlassTutorialHandler");

// Class SHProto.SHAnimNurseObstaclesDetectSubcmp
// 0x0000 (0x0068 - 0x0068)
class USHAnimNurseObstaclesDetectSubcmp final : public USHAnimNPCObstaclesDetectSubcomp
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNurseObstaclesDetectSubcmp">();
	}
	static class USHAnimNurseObstaclesDetectSubcmp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNurseObstaclesDetectSubcmp>();
	}
};
static_assert(alignof(USHAnimNurseObstaclesDetectSubcmp) == 0x000008, "Wrong alignment on USHAnimNurseObstaclesDetectSubcmp");
static_assert(sizeof(USHAnimNurseObstaclesDetectSubcmp) == 0x000068, "Wrong size on USHAnimNurseObstaclesDetectSubcmp");

// Class SHProto.SHLookAtEnemyTargetProvider
// 0x0030 (0x0098 - 0x0068)
class USHLookAtEnemyTargetProvider : public USHLookAtTargetProvider
{
public:
	float                                         MaxDistance;                                       // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle;                                          // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AngleScoreCurve;                                   // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACharacter>                 EnemyClass;                                        // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             LastSelectedEnemy;                                 // 0x0090(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLookAtEnemyTargetProvider">();
	}
	static class USHLookAtEnemyTargetProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLookAtEnemyTargetProvider>();
	}
};
static_assert(alignof(USHLookAtEnemyTargetProvider) == 0x000008, "Wrong alignment on USHLookAtEnemyTargetProvider");
static_assert(sizeof(USHLookAtEnemyTargetProvider) == 0x000098, "Wrong size on USHLookAtEnemyTargetProvider");
static_assert(offsetof(USHLookAtEnemyTargetProvider, MaxDistance) == 0x000068, "Member 'USHLookAtEnemyTargetProvider::MaxDistance' has a wrong offset!");
static_assert(offsetof(USHLookAtEnemyTargetProvider, MaxAngle) == 0x00006C, "Member 'USHLookAtEnemyTargetProvider::MaxAngle' has a wrong offset!");
static_assert(offsetof(USHLookAtEnemyTargetProvider, AngleScoreCurve) == 0x000070, "Member 'USHLookAtEnemyTargetProvider::AngleScoreCurve' has a wrong offset!");
static_assert(offsetof(USHLookAtEnemyTargetProvider, EnemyClass) == 0x000078, "Member 'USHLookAtEnemyTargetProvider::EnemyClass' has a wrong offset!");
static_assert(offsetof(USHLookAtEnemyTargetProvider, LastSelectedEnemy) == 0x000090, "Member 'USHLookAtEnemyTargetProvider::LastSelectedEnemy' has a wrong offset!");

// Class SHProto.SHCharacterPlayLookAtEnemyTargetProvider
// 0x0000 (0x0098 - 0x0098)
class USHCharacterPlayLookAtEnemyTargetProvider final : public USHLookAtEnemyTargetProvider
{
public:
	void SHDebug_Character_LookAtEnemy_DrawDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayLookAtEnemyTargetProvider">();
	}
	static class USHCharacterPlayLookAtEnemyTargetProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayLookAtEnemyTargetProvider>();
	}
};
static_assert(alignof(USHCharacterPlayLookAtEnemyTargetProvider) == 0x000008, "Wrong alignment on USHCharacterPlayLookAtEnemyTargetProvider");
static_assert(sizeof(USHCharacterPlayLookAtEnemyTargetProvider) == 0x000098, "Wrong size on USHCharacterPlayLookAtEnemyTargetProvider");

// Class SHProto.SHAnimObstacleDetectionSubcomp
// 0x0188 (0x01C0 - 0x0038)
class USHAnimObstacleDetectionSubcomp final : public USHAnimSubcomponentBase
{
public:
	float                                         WallHandTimeSinceLast;                             // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WallHandRightHandLast;                             // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WallHandLastActorLocation;                         // 0x0040(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WallHandLastWallNormal;                            // 0x0058(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WallHandLastWallDirection;                         // 0x0070(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWallFaceSide;                                     // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallHandDistanceLast;                              // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WallHandRightLocation;                             // 0x0090(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               WallHandRightRotation;                             // 0x00A8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         WallHandRightAlpha;                                // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WallHandRightLocationTarget;                       // 0x00C8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WallHandLeftLocation;                              // 0x00E0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               WallHandLeftRotation;                              // 0x00F8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         WallHandLeftAlpha;                                 // 0x0110(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WallHandLeftLocationTarget;                        // 0x0118(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               WallSpineRotation;                                 // 0x0130(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         WallSpineRotationAlpha;                            // 0x0148(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               WallSpineImpulseRotation;                          // 0x0150(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         WallSpineImpulseAlpha;                             // 0x0168(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallSpineImpulseTimeMax;                           // 0x016C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallSpineImpulseTime;                              // 0x0170(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               WallSpineRotationFromCorner;                       // 0x0178(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         WallSpineRotationFromCornerAlpha;                  // 0x0190(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallRotationFromCornerEndTimer;                    // 0x0194(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallAvoidHandLeft;                                 // 0x0198(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallAvoidHandRight;                                // 0x019C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A0[0x20];                                     // 0x01A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimObstacleDetectionSubcomp">();
	}
	static class USHAnimObstacleDetectionSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimObstacleDetectionSubcomp>();
	}
};
static_assert(alignof(USHAnimObstacleDetectionSubcomp) == 0x000008, "Wrong alignment on USHAnimObstacleDetectionSubcomp");
static_assert(sizeof(USHAnimObstacleDetectionSubcomp) == 0x0001C0, "Wrong size on USHAnimObstacleDetectionSubcomp");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallHandTimeSinceLast) == 0x000038, "Member 'USHAnimObstacleDetectionSubcomp::WallHandTimeSinceLast' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallHandRightHandLast) == 0x00003C, "Member 'USHAnimObstacleDetectionSubcomp::WallHandRightHandLast' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallHandLastActorLocation) == 0x000040, "Member 'USHAnimObstacleDetectionSubcomp::WallHandLastActorLocation' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallHandLastWallNormal) == 0x000058, "Member 'USHAnimObstacleDetectionSubcomp::WallHandLastWallNormal' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallHandLastWallDirection) == 0x000070, "Member 'USHAnimObstacleDetectionSubcomp::WallHandLastWallDirection' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, bWallFaceSide) == 0x000088, "Member 'USHAnimObstacleDetectionSubcomp::bWallFaceSide' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallHandDistanceLast) == 0x00008C, "Member 'USHAnimObstacleDetectionSubcomp::WallHandDistanceLast' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallHandRightLocation) == 0x000090, "Member 'USHAnimObstacleDetectionSubcomp::WallHandRightLocation' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallHandRightRotation) == 0x0000A8, "Member 'USHAnimObstacleDetectionSubcomp::WallHandRightRotation' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallHandRightAlpha) == 0x0000C0, "Member 'USHAnimObstacleDetectionSubcomp::WallHandRightAlpha' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallHandRightLocationTarget) == 0x0000C8, "Member 'USHAnimObstacleDetectionSubcomp::WallHandRightLocationTarget' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallHandLeftLocation) == 0x0000E0, "Member 'USHAnimObstacleDetectionSubcomp::WallHandLeftLocation' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallHandLeftRotation) == 0x0000F8, "Member 'USHAnimObstacleDetectionSubcomp::WallHandLeftRotation' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallHandLeftAlpha) == 0x000110, "Member 'USHAnimObstacleDetectionSubcomp::WallHandLeftAlpha' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallHandLeftLocationTarget) == 0x000118, "Member 'USHAnimObstacleDetectionSubcomp::WallHandLeftLocationTarget' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallSpineRotation) == 0x000130, "Member 'USHAnimObstacleDetectionSubcomp::WallSpineRotation' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallSpineRotationAlpha) == 0x000148, "Member 'USHAnimObstacleDetectionSubcomp::WallSpineRotationAlpha' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallSpineImpulseRotation) == 0x000150, "Member 'USHAnimObstacleDetectionSubcomp::WallSpineImpulseRotation' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallSpineImpulseAlpha) == 0x000168, "Member 'USHAnimObstacleDetectionSubcomp::WallSpineImpulseAlpha' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallSpineImpulseTimeMax) == 0x00016C, "Member 'USHAnimObstacleDetectionSubcomp::WallSpineImpulseTimeMax' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallSpineImpulseTime) == 0x000170, "Member 'USHAnimObstacleDetectionSubcomp::WallSpineImpulseTime' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallSpineRotationFromCorner) == 0x000178, "Member 'USHAnimObstacleDetectionSubcomp::WallSpineRotationFromCorner' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallSpineRotationFromCornerAlpha) == 0x000190, "Member 'USHAnimObstacleDetectionSubcomp::WallSpineRotationFromCornerAlpha' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallRotationFromCornerEndTimer) == 0x000194, "Member 'USHAnimObstacleDetectionSubcomp::WallRotationFromCornerEndTimer' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallAvoidHandLeft) == 0x000198, "Member 'USHAnimObstacleDetectionSubcomp::WallAvoidHandLeft' has a wrong offset!");
static_assert(offsetof(USHAnimObstacleDetectionSubcomp, WallAvoidHandRight) == 0x00019C, "Member 'USHAnimObstacleDetectionSubcomp::WallAvoidHandRight' has a wrong offset!");

// Class SHProto.SHAnimReviveSubcomp
// 0x0008 (0x0040 - 0x0038)
class USHAnimReviveSubcomp final : public USHAnimSubcomponentBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetActorOnBodyPosition(const struct FReviveAnimationData& ReviveData);

	class UAnimSequenceBase* GetReviveAnimation() const;
	class UAnimSequenceBase* GetReviveAnimationFromBodyPose() const;
	struct FReviveAnimationData GetReviveData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimReviveSubcomp">();
	}
	static class USHAnimReviveSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimReviveSubcomp>();
	}
};
static_assert(alignof(USHAnimReviveSubcomp) == 0x000008, "Wrong alignment on USHAnimReviveSubcomp");
static_assert(sizeof(USHAnimReviveSubcomp) == 0x000040, "Wrong size on USHAnimReviveSubcomp");

// Class SHProto.SHEndingValueProcessor
// 0x0008 (0x0030 - 0x0028)
class USHEndingValueProcessor : public UObject
{
public:
	class USHCharacterPlayEndingsComponent*       OwnerComponent;                                    // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEndingValueProcessor">();
	}
	static class USHEndingValueProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEndingValueProcessor>();
	}
};
static_assert(alignof(USHEndingValueProcessor) == 0x000008, "Wrong alignment on USHEndingValueProcessor");
static_assert(sizeof(USHEndingValueProcessor) == 0x000030, "Wrong size on USHEndingValueProcessor");
static_assert(offsetof(USHEndingValueProcessor, OwnerComponent) == 0x000028, "Member 'USHEndingValueProcessor::OwnerComponent' has a wrong offset!");

// Class SHProto.SHItemInvestigatedEndingValueProcessor
// 0x0020 (0x0050 - 0x0030)
class USHItemInvestigatedEndingValueProcessor final : public USHEndingValueProcessor
{
public:
	TArray<struct FDataTableRowHandle>            MaryItems;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    AngelasKnifeItem;                                  // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void ProcessCollectedItemInvestigatedEvent(class USHCharacterPlayItemsComponent* ComponentPtr, class FName ItemContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemInvestigatedEndingValueProcessor">();
	}
	static class USHItemInvestigatedEndingValueProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHItemInvestigatedEndingValueProcessor>();
	}
};
static_assert(alignof(USHItemInvestigatedEndingValueProcessor) == 0x000008, "Wrong alignment on USHItemInvestigatedEndingValueProcessor");
static_assert(sizeof(USHItemInvestigatedEndingValueProcessor) == 0x000050, "Wrong size on USHItemInvestigatedEndingValueProcessor");
static_assert(offsetof(USHItemInvestigatedEndingValueProcessor, MaryItems) == 0x000030, "Member 'USHItemInvestigatedEndingValueProcessor::MaryItems' has a wrong offset!");
static_assert(offsetof(USHItemInvestigatedEndingValueProcessor, AngelasKnifeItem) == 0x000040, "Member 'USHItemInvestigatedEndingValueProcessor::AngelasKnifeItem' has a wrong offset!");

// Class SHProto.SHAnimsPlayedStatisticsValueProcessor
// 0x0008 (0x0038 - 0x0030)
class USHAnimsPlayedStatisticsValueProcessor final : public USHStatisticsValueProcessor
{
public:
	int32                                         AutoLockedDoorCheckAnimActionPlayedCount;          // 0x0030(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimsPlayedStatisticsValueProcessor">();
	}
	static class USHAnimsPlayedStatisticsValueProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimsPlayedStatisticsValueProcessor>();
	}
};
static_assert(alignof(USHAnimsPlayedStatisticsValueProcessor) == 0x000008, "Wrong alignment on USHAnimsPlayedStatisticsValueProcessor");
static_assert(sizeof(USHAnimsPlayedStatisticsValueProcessor) == 0x000038, "Wrong size on USHAnimsPlayedStatisticsValueProcessor");
static_assert(offsetof(USHAnimsPlayedStatisticsValueProcessor, AutoLockedDoorCheckAnimActionPlayedCount) == 0x000030, "Member 'USHAnimsPlayedStatisticsValueProcessor::AutoLockedDoorCheckAnimActionPlayedCount' has a wrong offset!");

// Class SHProto.SHAskReloadWidget
// 0x0020 (0x03D0 - 0x03B0)
class USHAskReloadWidget final : public UAskReloadWidget
{
public:
	class FText                                   TimeInfoFormatText;                                // 0x03B0(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Info_txt;                                          // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAskReloadWidget">();
	}
	static class USHAskReloadWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAskReloadWidget>();
	}
};
static_assert(alignof(USHAskReloadWidget) == 0x000008, "Wrong alignment on USHAskReloadWidget");
static_assert(sizeof(USHAskReloadWidget) == 0x0003D0, "Wrong size on USHAskReloadWidget");
static_assert(offsetof(USHAskReloadWidget, TimeInfoFormatText) == 0x0003B0, "Member 'USHAskReloadWidget::TimeInfoFormatText' has a wrong offset!");
static_assert(offsetof(USHAskReloadWidget, Info_txt) == 0x0003C8, "Member 'USHAskReloadWidget::Info_txt' has a wrong offset!");

// Class SHProto.SHInteractionIconWidget
// 0x0088 (0x0300 - 0x0278)
class USHInteractionIconWidget final : public UUserWidget
{
public:
	class UWidget*                                Root_wdg;                                          // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MainImage;                                         // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTipTextBlock*                          ActionTip_wdg;                                     // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DefaultMaterial;                                   // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     TraversalMaterial;                                 // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DefaultMaterialWithActionKey;                      // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     TraversalMaterialWithActionKey;                    // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PhaseName;                                         // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusedMaterialControlPhaseChangeSpeed;            // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusedMaterialControlTargetPhase;                 // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x40];                                     // 0x02C0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInteractionIconWidget">();
	}
	static class USHInteractionIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHInteractionIconWidget>();
	}
};
static_assert(alignof(USHInteractionIconWidget) == 0x000008, "Wrong alignment on USHInteractionIconWidget");
static_assert(sizeof(USHInteractionIconWidget) == 0x000300, "Wrong size on USHInteractionIconWidget");
static_assert(offsetof(USHInteractionIconWidget, Root_wdg) == 0x000278, "Member 'USHInteractionIconWidget::Root_wdg' has a wrong offset!");
static_assert(offsetof(USHInteractionIconWidget, MainImage) == 0x000280, "Member 'USHInteractionIconWidget::MainImage' has a wrong offset!");
static_assert(offsetof(USHInteractionIconWidget, ActionTip_wdg) == 0x000288, "Member 'USHInteractionIconWidget::ActionTip_wdg' has a wrong offset!");
static_assert(offsetof(USHInteractionIconWidget, DefaultMaterial) == 0x000290, "Member 'USHInteractionIconWidget::DefaultMaterial' has a wrong offset!");
static_assert(offsetof(USHInteractionIconWidget, TraversalMaterial) == 0x000298, "Member 'USHInteractionIconWidget::TraversalMaterial' has a wrong offset!");
static_assert(offsetof(USHInteractionIconWidget, DefaultMaterialWithActionKey) == 0x0002A0, "Member 'USHInteractionIconWidget::DefaultMaterialWithActionKey' has a wrong offset!");
static_assert(offsetof(USHInteractionIconWidget, TraversalMaterialWithActionKey) == 0x0002A8, "Member 'USHInteractionIconWidget::TraversalMaterialWithActionKey' has a wrong offset!");
static_assert(offsetof(USHInteractionIconWidget, PhaseName) == 0x0002B0, "Member 'USHInteractionIconWidget::PhaseName' has a wrong offset!");
static_assert(offsetof(USHInteractionIconWidget, FocusedMaterialControlPhaseChangeSpeed) == 0x0002B8, "Member 'USHInteractionIconWidget::FocusedMaterialControlPhaseChangeSpeed' has a wrong offset!");
static_assert(offsetof(USHInteractionIconWidget, FocusedMaterialControlTargetPhase) == 0x0002BC, "Member 'USHInteractionIconWidget::FocusedMaterialControlTargetPhase' has a wrong offset!");

// Class SHProto.SHAsyncLoadRequestingComponent
// 0x0028 (0x00C8 - 0x00A0)
class USHAsyncLoadRequestingComponent final : public UActorComponent
{
public:
	bool                                          bSkipReleaseAllAssetsOnEndPlay;                    // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnObjectLoaded;                                    // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSoftObjectPath>                KeepedObjects;                                     // 0x00B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	class UObject* GetObject(TSoftObjectPtr<class UObject> SoftObject, bool bShouldFallbackToSyncLoad);
	void PreloadAnimActionExecutive(const TSubclassOf<class USHAnimActionExecutiveBase>& InAnimActionExeClass);
	void PreloadAnimationData(const struct FPlayAnimationData& InAnimationData);
	void PreloadCameraData(const struct FSHCameraAnimationData& InCameraData);
	void PreloadDialog(const struct FDialogTalkID& InDialogTalkID);
	void PreloadItemCollect(const class FName InItemName);
	void ReleaseAllAssets();
	void ReleaseAsset(TSoftObjectPtr<class UObject> SoftObject);
	void RequestAsyncLoad(TSoftObjectPtr<class UObject> SoftObject, bool bKeepLoaded);
	void RequestAsyncLoadAnimActionExe(const TSubclassOf<class USHAnimActionExecutiveBase>& InAnimActionExeClass, bool bKeepLoaded);
	void RequestAsyncLoadSet(const TSet<TSoftObjectPtr<class UObject>>& SoftObjects, bool bKeepLoaded);
	void SHAsyncLoadReqEventWithObjectContext__DelegateSignature(class USHAsyncLoadRequestingComponent* Component, TSoftObjectPtr<class UObject> SoftObjectContext);

	bool IsLoaded(const TSubclassOf<class USHAnimActionExecutiveBase>& InAnimActionExeClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAsyncLoadRequestingComponent">();
	}
	static class USHAsyncLoadRequestingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAsyncLoadRequestingComponent>();
	}
};
static_assert(alignof(USHAsyncLoadRequestingComponent) == 0x000008, "Wrong alignment on USHAsyncLoadRequestingComponent");
static_assert(sizeof(USHAsyncLoadRequestingComponent) == 0x0000C8, "Wrong size on USHAsyncLoadRequestingComponent");
static_assert(offsetof(USHAsyncLoadRequestingComponent, bSkipReleaseAllAssetsOnEndPlay) == 0x0000A0, "Member 'USHAsyncLoadRequestingComponent::bSkipReleaseAllAssetsOnEndPlay' has a wrong offset!");
static_assert(offsetof(USHAsyncLoadRequestingComponent, OnObjectLoaded) == 0x0000A8, "Member 'USHAsyncLoadRequestingComponent::OnObjectLoaded' has a wrong offset!");
static_assert(offsetof(USHAsyncLoadRequestingComponent, KeepedObjects) == 0x0000B8, "Member 'USHAsyncLoadRequestingComponent::KeepedObjects' has a wrong offset!");

// Class SHProto.SHBaseMainMenuWidget
// 0x0010 (0x0370 - 0x0360)
class USHBaseMainMenuWidget : public UUCSWMainMenuWidget
{
public:
	class USHSettingsWidget*                      Settings_wdg;                                      // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             SavePointInfos;                                    // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDlcDataUpdated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBaseMainMenuWidget">();
	}
	static class USHBaseMainMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBaseMainMenuWidget>();
	}
};
static_assert(alignof(USHBaseMainMenuWidget) == 0x000008, "Wrong alignment on USHBaseMainMenuWidget");
static_assert(sizeof(USHBaseMainMenuWidget) == 0x000370, "Wrong size on USHBaseMainMenuWidget");
static_assert(offsetof(USHBaseMainMenuWidget, Settings_wdg) == 0x000360, "Member 'USHBaseMainMenuWidget::Settings_wdg' has a wrong offset!");
static_assert(offsetof(USHBaseMainMenuWidget, SavePointInfos) == 0x000368, "Member 'USHBaseMainMenuWidget::SavePointInfos' has a wrong offset!");

// Class SHProto.SHItemsStatics
// 0x0000 (0x0028 - 0x0028)
class USHItemsStatics final : public UBlueprintFunctionLibrary
{
public:
	static void DebugGiveItems(const class UObject* WorldContextObject, const TArray<struct FDataTableRowHandle>& InItemsHandles);
	static class ASHFlashlight* GetFlashlight(const class UObject* WorldContextObject);
	static class ASHRadio* GetRadio(const class UObject* WorldContextObject);
	static bool IsFlashlightInUse(const class UObject* WorldContextObject);
	static bool IsPlayerInventoryEmpty(class UObject* WorldContextObject, const TArray<class FName>& ItemsToIgnore);
	static bool PerformNotesScribble(const class UObject* WorldContextObject);
	static bool PerformNotesScribbleMapContexted(const class UObject* WorldContextObject, ESHMapsEnum InMapContext);
	static void PreloadAssetsForItemWeapon(class UObject* Requester, class FName InItemWeaponName);
	static void ReleaseAssetsForItemWeapon(class UObject* Requester, class FName InItemWeaponName);
	static void ReleasePreloadedItemInvestigationAssets(class UObject* Requester, class FName ItemName);
	static bool RequestCollectAndInvestigateItem(class UObject* WorldContextObject, class FName ItemDataRowName);
	static bool RequestCollectItemWithNotify(class UObject* WorldContextObject, class FName ItemDataRowName);
	static bool RequestItemsSwap(class UObject* WorldContextObject, class FName ItemNameToRemove, class FName ItemNameToAdd, bool bAddOnlyIfRemovedWithSuccess);
	static void RequestPreloadItemInvestigationAssets(class UObject* Requester, class FName ItemName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemsStatics">();
	}
	static class USHItemsStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHItemsStatics>();
	}
};
static_assert(alignof(USHItemsStatics) == 0x000008, "Wrong alignment on USHItemsStatics");
static_assert(sizeof(USHItemsStatics) == 0x000028, "Wrong size on USHItemsStatics");

// Class SHProto.SHMannequinAnimInstanceStateData
// 0x0000 (0x0078 - 0x0078)
class USHMannequinAnimInstanceStateData final : public USHMonsterAnimInstanceStateData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMannequinAnimInstanceStateData">();
	}
	static class USHMannequinAnimInstanceStateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMannequinAnimInstanceStateData>();
	}
};
static_assert(alignof(USHMannequinAnimInstanceStateData) == 0x000008, "Wrong alignment on USHMannequinAnimInstanceStateData");
static_assert(sizeof(USHMannequinAnimInstanceStateData) == 0x000078, "Wrong size on USHMannequinAnimInstanceStateData");

// Class SHProto.SHBloodPuddle
// 0x0058 (0x0308 - 0x02B0)
class ASHBloodPuddle final : public AActor
{
public:
	class UDecalComponent*                        DecalPuddle;                                       // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ErosionCurve;                                      // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToFillPuddle;                                  // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VisibleFactorParameterName;                        // 0x02C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeAwayTime;                                      // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EnableAutoFadeAway;                                // 0x02D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayToFadeAway;                                   // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DestroyAfterFadeAway;                              // 0x02D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               DecalMaterialDynamic;                              // 0x02E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  OwnerCharacterGuid;                                // 0x02E8(0x0010)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x10];                                     // 0x02F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableFadeAway();
	void OnFadeInCompleted();
	void OnFadeOutCompleted();
	void OnInitialized();

	bool IsFullyDeveloped() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBloodPuddle">();
	}
	static class ASHBloodPuddle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHBloodPuddle>();
	}
};
static_assert(alignof(ASHBloodPuddle) == 0x000008, "Wrong alignment on ASHBloodPuddle");
static_assert(sizeof(ASHBloodPuddle) == 0x000308, "Wrong size on ASHBloodPuddle");
static_assert(offsetof(ASHBloodPuddle, DecalPuddle) == 0x0002B0, "Member 'ASHBloodPuddle::DecalPuddle' has a wrong offset!");
static_assert(offsetof(ASHBloodPuddle, ErosionCurve) == 0x0002B8, "Member 'ASHBloodPuddle::ErosionCurve' has a wrong offset!");
static_assert(offsetof(ASHBloodPuddle, TimeToFillPuddle) == 0x0002C0, "Member 'ASHBloodPuddle::TimeToFillPuddle' has a wrong offset!");
static_assert(offsetof(ASHBloodPuddle, VisibleFactorParameterName) == 0x0002C4, "Member 'ASHBloodPuddle::VisibleFactorParameterName' has a wrong offset!");
static_assert(offsetof(ASHBloodPuddle, FadeAwayTime) == 0x0002CC, "Member 'ASHBloodPuddle::FadeAwayTime' has a wrong offset!");
static_assert(offsetof(ASHBloodPuddle, EnableAutoFadeAway) == 0x0002D0, "Member 'ASHBloodPuddle::EnableAutoFadeAway' has a wrong offset!");
static_assert(offsetof(ASHBloodPuddle, DelayToFadeAway) == 0x0002D4, "Member 'ASHBloodPuddle::DelayToFadeAway' has a wrong offset!");
static_assert(offsetof(ASHBloodPuddle, DestroyAfterFadeAway) == 0x0002D8, "Member 'ASHBloodPuddle::DestroyAfterFadeAway' has a wrong offset!");
static_assert(offsetof(ASHBloodPuddle, DecalMaterialDynamic) == 0x0002E0, "Member 'ASHBloodPuddle::DecalMaterialDynamic' has a wrong offset!");
static_assert(offsetof(ASHBloodPuddle, OwnerCharacterGuid) == 0x0002E8, "Member 'ASHBloodPuddle::OwnerCharacterGuid' has a wrong offset!");

// Class SHProto.SHBlueprintEventsDebugCommandComponent
// 0x0010 (0x00B8 - 0x00A8)
class USHBlueprintEventsDebugCommandComponent final : public USHBlueprintEventsBaseComponent
{
public:
	FMulticastInlineDelegateProperty_             OnDebugCommand;                                    // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBlueprintEventsDebugCommandComponent">();
	}
	static class USHBlueprintEventsDebugCommandComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBlueprintEventsDebugCommandComponent>();
	}
};
static_assert(alignof(USHBlueprintEventsDebugCommandComponent) == 0x000008, "Wrong alignment on USHBlueprintEventsDebugCommandComponent");
static_assert(sizeof(USHBlueprintEventsDebugCommandComponent) == 0x0000B8, "Wrong size on USHBlueprintEventsDebugCommandComponent");
static_assert(offsetof(USHBlueprintEventsDebugCommandComponent, OnDebugCommand) == 0x0000A8, "Member 'USHBlueprintEventsDebugCommandComponent::OnDebugCommand' has a wrong offset!");

// Class SHProto.SHHitReactionSubcomponent
// 0x0260 (0x0298 - 0x0038)
class USHHitReactionSubcomponent final : public USHAnimSubcomponentBase
{
public:
	FMulticastInlineDelegateProperty_             EventHitReactionStateStarted;                      // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionStateFinishing;                    // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionStateEnded;                        // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionDeathStarted;                      // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionDeathFinishing;                    // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionDeathEnded;                        // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionKnockdownStarted;                  // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionKnockdownFinishing;                // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionKnockdownEnded;                    // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionFalterStarted;                     // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionFalterFinishing;                   // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionFalterEnded;                       // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionStaggerStarted;                    // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionStaggerFinishing;                  // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionStaggerEnded;                      // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionNormalStarted;                     // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionNormalFinishing;                   // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionNormalEnded;                       // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionTwitchStarted;                     // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionTwitchFinishing;                   // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionTwitchEnded;                       // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionsRequestAIBlocking;                // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventHitReactionsRequestAllowingControllerRotation; // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USHHitReactionsSet>      HitReactionsSet;                                   // 0x01A8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          LoadHitReactionsOnStart;                           // 0x01D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugPrint;                                       // 0x01D9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DA[0x16];                                     // 0x01DA(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHHitReactionStateSerializedData> SerializedHitReactionStates;                       // 0x01F0(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	class USHHitReactionsSet*                     LoadedHitReactionsSet;                             // 0x0200(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USHHitReactionsSet>      DelayedHitReactionsSet;                            // 0x0210(0x0030)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSHHitReactionTypePermissionState> HitReactionTypePermissions;                        // 0x0240(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSHHitReactionTypeDelayedHitReactions> PermissionDelayedHitReactions;                     // 0x0250(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class USHHitReactionState*>            HitReactionStates;                                 // 0x0260(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class USHHitReactionStatesContext*            HitReactionStatesContext;                          // 0x0270(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USHHitReactionState*>            HitReactionStatesPool;                             // 0x0278(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x10];                                     // 0x0288(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ApplyArtificialHitReaction(struct FSHHitReactionResult* OutHitReactionResult, const struct FSHHitReactionArtificialHitConfiguration& InArtificialHitReactionConfiguration);
	bool ApplyHitReaction(struct FSHHitReactionResult* OutHitReactionResult, const class UDamageType* InDamageType, ESHHitReactionResponseType InResponseType, class FName InResponseVariant, float InDurationLimit, float InForce, ESHHitReactionHitType InHitType, const struct FVector& InSourceLocation, class AActor* InDamageCauser, const struct FHitResult& HitInfo, const struct FSHHitReactionConfiguration& InHitReactionConfiguration);
	bool AreHitReactionsOfTypeDelayed(ESHHitReactionResponseType InResponseType);
	void CancelAllHitReactions(bool InInstant);
	void CancelHitReactionsOfType(ESHHitReactionResponseType InResponseType, bool InInstant);
	void CancelHitReactionsOfTypeAndVariant(ESHHitReactionResponseType InResponseType, class FName InResponseVariant, bool InInstant);
	void CancelHitReactionsOfTypes(bool InDeath, bool InKnockdown, bool InFalter, bool InStagger, bool InNormal, bool InTwitch, bool InInstant);
	bool ChooseAndApplyHitReaction(struct FSHHitReactionResult* OutHitReactionResult, const class UDamageType* InDamageType, ESHHitReactionResponseType InResponseType, class FName InResponseVariant, float InDurationLimit, float InForce, ESHHitReactionHitType InHitType, const struct FVector& InSourceLocation, class AActor* InDamageCauser, const struct FHitResult& HitInfo);
	void DisableHitReactionTypeDelay(ESHHitReactionResponseType InResponseType, bool InApplyDelayedHitReactions, const TArray<class FName>& InDontApplyVariants);
	void EnableHitReactionTypeDelay(ESHHitReactionResponseType InResponseType, const TArray<class FName>& InDontDelayVariants);
	void FinishAllHitReactions();
	void FinishHitReactionsOfType(ESHHitReactionResponseType InResponseType);
	void FinishHitReactionsOfTypeAndVariant(ESHHitReactionResponseType InResponseType, class FName InResponseVariant);
	void FinishHitReactionsOfTypes(bool InDeath, bool InKnockdown, bool InFalter, bool InStagger, bool InNormal, bool InTwitch);
	void HitReactionStateEnded(class USHHitReactionState* InHitReactionState);
	void HitReactionStateFinishing(class USHHitReactionState* InHitReactionState);
	void SetChangeHitReactionsSetDelayed(bool bInChangeHitReactionsSetDelayed);
	void SetHitReactionsDrawDebugEnabled(bool InDrawDebug);
	void SetHitReactionsSet(TSoftObjectPtr<class USHHitReactionsSet> InHitReactionsSet);

	bool AreHitReactionsPreventingControllerRotation() const;
	bool AreHitReactionsWantingDisabledAI() const;
	bool ChooseHitReaction(struct FSHHitReactionConfiguration* OutHitReactionConfiguration, const class UDamageType* InDamageType, ESHHitReactionResponseType InResponseType, class FName InResponseVariant, float InForce, ESHHitReactionHitType InHitType, const struct FVector& InSourceLocation, class AActor* InDamageCauser, const struct FHitResult& HitInfo) const;
	void FindActiveHitReactionVariants(ESHHitReactionResponseType InResponseType, TArray<class FName>* OutHitReactionVariants, bool InIncludeFinishing, bool InIncludeDelayed) const;
	void FindAllHitReactionStateIdentifiers(TArray<struct FSHHitReactionIdentifier>* OutHitReactionIdentifiers, bool InIncludeFinishing, bool InIncludeDelayed) const;
	bool HasAnyOfHitReactionStatesOfTypeInProgress(bool InDeath, bool InKnockdown, bool InFalter, bool InStagger, bool InNormal, bool InTwitch, bool InIncludeFinishing, bool InIncludeDelayed) const;
	bool HasHitReactionStatesOfTypeAndVariantInProgress(ESHHitReactionResponseType InResponseType, class FName InResponseVariant, bool InIncludeFinishing, bool InIncludeDelayed) const;
	bool HasHitReactionStatesOfTypeInProgress(ESHHitReactionResponseType InResponseType, bool InIncludeFinishing, bool InIncludeDelayed) const;
	bool IsUsingHitReactionsSet(TSoftObjectPtr<class USHHitReactionsSet> InHitReactionsSet, bool InCheckDelayedSet) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHitReactionSubcomponent">();
	}
	static class USHHitReactionSubcomponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHHitReactionSubcomponent>();
	}
};
static_assert(alignof(USHHitReactionSubcomponent) == 0x000008, "Wrong alignment on USHHitReactionSubcomponent");
static_assert(sizeof(USHHitReactionSubcomponent) == 0x000298, "Wrong size on USHHitReactionSubcomponent");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionStateStarted) == 0x000038, "Member 'USHHitReactionSubcomponent::EventHitReactionStateStarted' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionStateFinishing) == 0x000048, "Member 'USHHitReactionSubcomponent::EventHitReactionStateFinishing' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionStateEnded) == 0x000058, "Member 'USHHitReactionSubcomponent::EventHitReactionStateEnded' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionDeathStarted) == 0x000068, "Member 'USHHitReactionSubcomponent::EventHitReactionDeathStarted' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionDeathFinishing) == 0x000078, "Member 'USHHitReactionSubcomponent::EventHitReactionDeathFinishing' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionDeathEnded) == 0x000088, "Member 'USHHitReactionSubcomponent::EventHitReactionDeathEnded' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionKnockdownStarted) == 0x000098, "Member 'USHHitReactionSubcomponent::EventHitReactionKnockdownStarted' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionKnockdownFinishing) == 0x0000A8, "Member 'USHHitReactionSubcomponent::EventHitReactionKnockdownFinishing' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionKnockdownEnded) == 0x0000B8, "Member 'USHHitReactionSubcomponent::EventHitReactionKnockdownEnded' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionFalterStarted) == 0x0000C8, "Member 'USHHitReactionSubcomponent::EventHitReactionFalterStarted' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionFalterFinishing) == 0x0000D8, "Member 'USHHitReactionSubcomponent::EventHitReactionFalterFinishing' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionFalterEnded) == 0x0000E8, "Member 'USHHitReactionSubcomponent::EventHitReactionFalterEnded' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionStaggerStarted) == 0x0000F8, "Member 'USHHitReactionSubcomponent::EventHitReactionStaggerStarted' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionStaggerFinishing) == 0x000108, "Member 'USHHitReactionSubcomponent::EventHitReactionStaggerFinishing' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionStaggerEnded) == 0x000118, "Member 'USHHitReactionSubcomponent::EventHitReactionStaggerEnded' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionNormalStarted) == 0x000128, "Member 'USHHitReactionSubcomponent::EventHitReactionNormalStarted' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionNormalFinishing) == 0x000138, "Member 'USHHitReactionSubcomponent::EventHitReactionNormalFinishing' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionNormalEnded) == 0x000148, "Member 'USHHitReactionSubcomponent::EventHitReactionNormalEnded' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionTwitchStarted) == 0x000158, "Member 'USHHitReactionSubcomponent::EventHitReactionTwitchStarted' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionTwitchFinishing) == 0x000168, "Member 'USHHitReactionSubcomponent::EventHitReactionTwitchFinishing' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionTwitchEnded) == 0x000178, "Member 'USHHitReactionSubcomponent::EventHitReactionTwitchEnded' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionsRequestAIBlocking) == 0x000188, "Member 'USHHitReactionSubcomponent::EventHitReactionsRequestAIBlocking' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, EventHitReactionsRequestAllowingControllerRotation) == 0x000198, "Member 'USHHitReactionSubcomponent::EventHitReactionsRequestAllowingControllerRotation' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, HitReactionsSet) == 0x0001A8, "Member 'USHHitReactionSubcomponent::HitReactionsSet' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, LoadHitReactionsOnStart) == 0x0001D8, "Member 'USHHitReactionSubcomponent::LoadHitReactionsOnStart' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, bDebugPrint) == 0x0001D9, "Member 'USHHitReactionSubcomponent::bDebugPrint' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, SerializedHitReactionStates) == 0x0001F0, "Member 'USHHitReactionSubcomponent::SerializedHitReactionStates' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, LoadedHitReactionsSet) == 0x000200, "Member 'USHHitReactionSubcomponent::LoadedHitReactionsSet' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, DelayedHitReactionsSet) == 0x000210, "Member 'USHHitReactionSubcomponent::DelayedHitReactionsSet' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, HitReactionTypePermissions) == 0x000240, "Member 'USHHitReactionSubcomponent::HitReactionTypePermissions' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, PermissionDelayedHitReactions) == 0x000250, "Member 'USHHitReactionSubcomponent::PermissionDelayedHitReactions' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, HitReactionStates) == 0x000260, "Member 'USHHitReactionSubcomponent::HitReactionStates' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, HitReactionStatesContext) == 0x000270, "Member 'USHHitReactionSubcomponent::HitReactionStatesContext' has a wrong offset!");
static_assert(offsetof(USHHitReactionSubcomponent, HitReactionStatesPool) == 0x000278, "Member 'USHHitReactionSubcomponent::HitReactionStatesPool' has a wrong offset!");

// Class SHProto.SHBoatInputReceiver
// 0x0030 (0x0060 - 0x0030)
class USHBoatInputReceiver final : public USHVehicleInputReceiver
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBoatInputReceiver">();
	}
	static class USHBoatInputReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBoatInputReceiver>();
	}
};
static_assert(alignof(USHBoatInputReceiver) == 0x000008, "Wrong alignment on USHBoatInputReceiver");
static_assert(sizeof(USHBoatInputReceiver) == 0x000060, "Wrong size on USHBoatInputReceiver");

// Class SHProto.SHBoatMovementProcessor
// 0x0090 (0x00C0 - 0x0030)
class USHBoatMovementProcessor final : public USHVehicleMovementProcessor
{
public:
	bool                                          bRootMotionMovementOnlyXY;                         // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRootMotionRotationOnlyYaw;                        // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RootMotionMovementScale;                           // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RootMotionRotationScale;                           // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementDragFactor;                                // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationDragValue;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPrintDebug;                                       // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45[0x7B];                                      // 0x0045(0x007B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBoatMovementProcessor">();
	}
	static class USHBoatMovementProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBoatMovementProcessor>();
	}
};
static_assert(alignof(USHBoatMovementProcessor) == 0x000008, "Wrong alignment on USHBoatMovementProcessor");
static_assert(sizeof(USHBoatMovementProcessor) == 0x0000C0, "Wrong size on USHBoatMovementProcessor");
static_assert(offsetof(USHBoatMovementProcessor, bRootMotionMovementOnlyXY) == 0x000030, "Member 'USHBoatMovementProcessor::bRootMotionMovementOnlyXY' has a wrong offset!");
static_assert(offsetof(USHBoatMovementProcessor, bRootMotionRotationOnlyYaw) == 0x000031, "Member 'USHBoatMovementProcessor::bRootMotionRotationOnlyYaw' has a wrong offset!");
static_assert(offsetof(USHBoatMovementProcessor, RootMotionMovementScale) == 0x000034, "Member 'USHBoatMovementProcessor::RootMotionMovementScale' has a wrong offset!");
static_assert(offsetof(USHBoatMovementProcessor, RootMotionRotationScale) == 0x000038, "Member 'USHBoatMovementProcessor::RootMotionRotationScale' has a wrong offset!");
static_assert(offsetof(USHBoatMovementProcessor, MovementDragFactor) == 0x00003C, "Member 'USHBoatMovementProcessor::MovementDragFactor' has a wrong offset!");
static_assert(offsetof(USHBoatMovementProcessor, RotationDragValue) == 0x000040, "Member 'USHBoatMovementProcessor::RotationDragValue' has a wrong offset!");
static_assert(offsetof(USHBoatMovementProcessor, bPrintDebug) == 0x000044, "Member 'USHBoatMovementProcessor::bPrintDebug' has a wrong offset!");

// Class SHProto.SHMariaCombatComponent
// 0x0060 (0x0100 - 0x00A0)
class USHMariaCombatComponent final : public UActorComponent
{
public:
	class FName                                   BlackboardDangerModeKeyname;                       // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnInDangerStateChangedEvent;                       // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnInjuredStateChangedEvent;                        // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x38];                                      // 0x00C8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GrabAborted();
	void GrabFinished();
	void GrabStarted();
	void InitBehaviors();
	void SHMariaCombatBlueprintEvent__DelegateSignature(class USHMariaCombatComponent* Component);

	bool IsInDanger() const;
	bool IsInjured() const;
	bool WasAttacked() const;
	bool WasSaved() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMariaCombatComponent">();
	}
	static class USHMariaCombatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMariaCombatComponent>();
	}
};
static_assert(alignof(USHMariaCombatComponent) == 0x000008, "Wrong alignment on USHMariaCombatComponent");
static_assert(sizeof(USHMariaCombatComponent) == 0x000100, "Wrong size on USHMariaCombatComponent");
static_assert(offsetof(USHMariaCombatComponent, BlackboardDangerModeKeyname) == 0x0000A0, "Member 'USHMariaCombatComponent::BlackboardDangerModeKeyname' has a wrong offset!");
static_assert(offsetof(USHMariaCombatComponent, OnInDangerStateChangedEvent) == 0x0000A8, "Member 'USHMariaCombatComponent::OnInDangerStateChangedEvent' has a wrong offset!");
static_assert(offsetof(USHMariaCombatComponent, OnInjuredStateChangedEvent) == 0x0000B8, "Member 'USHMariaCombatComponent::OnInjuredStateChangedEvent' has a wrong offset!");

// Class SHProto.SHBoatNavigationTutorialHandler
// 0x0008 (0x0040 - 0x0038)
class USHBoatNavigationTutorialHandler final : public USHTutorialHandlerBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBoatNavigationTutorialHandler">();
	}
	static class USHBoatNavigationTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBoatNavigationTutorialHandler>();
	}
};
static_assert(alignof(USHBoatNavigationTutorialHandler) == 0x000008, "Wrong alignment on USHBoatNavigationTutorialHandler");
static_assert(sizeof(USHBoatNavigationTutorialHandler) == 0x000040, "Wrong size on USHBoatNavigationTutorialHandler");

// Class SHProto.SHHotelFWKilledAllDefenselessEnemiesEndingFactor
// 0x0000 (0x0088 - 0x0088)
class USHHotelFWKilledAllDefenselessEnemiesEndingFactor final : public USHBoolEndingFactor
{
public:
	void SHDebug_Character_Endings_HotelFWKilledAllDefenselessEnemiesEndingFactor_SetDebugValue(bool InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHotelFWKilledAllDefenselessEnemiesEndingFactor">();
	}
	static class USHHotelFWKilledAllDefenselessEnemiesEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHHotelFWKilledAllDefenselessEnemiesEndingFactor>();
	}
};
static_assert(alignof(USHHotelFWKilledAllDefenselessEnemiesEndingFactor) == 0x000008, "Wrong alignment on USHHotelFWKilledAllDefenselessEnemiesEndingFactor");
static_assert(sizeof(USHHotelFWKilledAllDefenselessEnemiesEndingFactor) == 0x000088, "Wrong size on USHHotelFWKilledAllDefenselessEnemiesEndingFactor");

// Class SHProto.SHBossfightItemsManager
// 0x00F0 (0x03A0 - 0x02B0)
class ASHBossfightItemsManager final : public AActor
{
public:
	TSet<class ASHItem*>                          ManualSelectedItemsActorsToManage;                 // 0x02B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TMap<ECombatDifficulty, class USHBossfightItemsManagerConfigDataAsset*> ConfigurationDataAssets;                           // 0x0300(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSet<struct FGuid>                            EnabledItemActorsGuids;                            // 0x0350(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)

public:
	void PerformManagementForPhase(int32 InPhaseIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBossfightItemsManager">();
	}
	static class ASHBossfightItemsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHBossfightItemsManager>();
	}
};
static_assert(alignof(ASHBossfightItemsManager) == 0x000008, "Wrong alignment on ASHBossfightItemsManager");
static_assert(sizeof(ASHBossfightItemsManager) == 0x0003A0, "Wrong size on ASHBossfightItemsManager");
static_assert(offsetof(ASHBossfightItemsManager, ManualSelectedItemsActorsToManage) == 0x0002B0, "Member 'ASHBossfightItemsManager::ManualSelectedItemsActorsToManage' has a wrong offset!");
static_assert(offsetof(ASHBossfightItemsManager, ConfigurationDataAssets) == 0x000300, "Member 'ASHBossfightItemsManager::ConfigurationDataAssets' has a wrong offset!");
static_assert(offsetof(ASHBossfightItemsManager, EnabledItemActorsGuids) == 0x000350, "Member 'ASHBossfightItemsManager::EnabledItemActorsGuids' has a wrong offset!");

// Class SHProto.SHBreakableActorWithPortal
// 0x0000 (0x0370 - 0x0370)
class ASHBreakableActorWithPortal final : public ASHBreakableActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBreakableActorWithPortal">();
	}
	static class ASHBreakableActorWithPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHBreakableActorWithPortal>();
	}
};
static_assert(alignof(ASHBreakableActorWithPortal) == 0x000008, "Wrong alignment on ASHBreakableActorWithPortal");
static_assert(sizeof(ASHBreakableActorWithPortal) == 0x000370, "Wrong size on ASHBreakableActorWithPortal");

// Class SHProto.SHMariaLookAtCharPlayProvider
// 0x0008 (0x0070 - 0x0068)
class USHMariaLookAtCharPlayProvider final : public USHLookAtTargetProvider
{
public:
	float                                         MaxDistance;                                       // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle;                                          // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMariaLookAtCharPlayProvider">();
	}
	static class USHMariaLookAtCharPlayProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMariaLookAtCharPlayProvider>();
	}
};
static_assert(alignof(USHMariaLookAtCharPlayProvider) == 0x000008, "Wrong alignment on USHMariaLookAtCharPlayProvider");
static_assert(sizeof(USHMariaLookAtCharPlayProvider) == 0x000070, "Wrong size on USHMariaLookAtCharPlayProvider");
static_assert(offsetof(USHMariaLookAtCharPlayProvider, MaxDistance) == 0x000068, "Member 'USHMariaLookAtCharPlayProvider::MaxDistance' has a wrong offset!");
static_assert(offsetof(USHMariaLookAtCharPlayProvider, MaxAngle) == 0x00006C, "Member 'USHMariaLookAtCharPlayProvider::MaxAngle' has a wrong offset!");

// Class SHProto.SHBrokenGlassInteractablesManagerComponent
// 0x0000 (0x0580 - 0x0580)
class USHBrokenGlassInteractablesManagerComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBrokenGlassInteractablesManagerComponent">();
	}
	static class USHBrokenGlassInteractablesManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBrokenGlassInteractablesManagerComponent>();
	}
};
static_assert(alignof(USHBrokenGlassInteractablesManagerComponent) == 0x000010, "Wrong alignment on USHBrokenGlassInteractablesManagerComponent");
static_assert(sizeof(USHBrokenGlassInteractablesManagerComponent) == 0x000580, "Wrong size on USHBrokenGlassInteractablesManagerComponent");

// Class SHProto.SHBreakableGlassFXData
// 0x0030 (0x0060 - 0x0030)
class USHBreakableGlassFXData final : public UDataAsset
{
public:
	class UAkAudioEvent*                          DefaultAkEventToPlayAtHit;                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSHBreakableGlassSizeAudioData> GlassSizeAudioConfig;                              // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         NiagaraSystemToPlayAtHit;                          // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NiagaraHitSystemDirectionParamName;                // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NiagaraHitSystemLocationParamName;                 // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBreakableGlassFXData">();
	}
	static class USHBreakableGlassFXData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBreakableGlassFXData>();
	}
};
static_assert(alignof(USHBreakableGlassFXData) == 0x000008, "Wrong alignment on USHBreakableGlassFXData");
static_assert(sizeof(USHBreakableGlassFXData) == 0x000060, "Wrong size on USHBreakableGlassFXData");
static_assert(offsetof(USHBreakableGlassFXData, DefaultAkEventToPlayAtHit) == 0x000030, "Member 'USHBreakableGlassFXData::DefaultAkEventToPlayAtHit' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassFXData, GlassSizeAudioConfig) == 0x000038, "Member 'USHBreakableGlassFXData::GlassSizeAudioConfig' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassFXData, NiagaraSystemToPlayAtHit) == 0x000048, "Member 'USHBreakableGlassFXData::NiagaraSystemToPlayAtHit' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassFXData, NiagaraHitSystemDirectionParamName) == 0x000050, "Member 'USHBreakableGlassFXData::NiagaraHitSystemDirectionParamName' has a wrong offset!");
static_assert(offsetof(USHBreakableGlassFXData, NiagaraHitSystemLocationParamName) == 0x000058, "Member 'USHBreakableGlassFXData::NiagaraHitSystemLocationParamName' has a wrong offset!");

// Class SHProto.SHGameplayFocusWidget
// 0x0080 (0x02F8 - 0x0278)
class USHGameplayFocusWidget final : public UUserWidget
{
public:
	class USHMiniInventoryWidget*                 MiniInventoryWidget;                               // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHInputKeysData*                       InputKeysDataAsset;                                // 0x0280(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUE4InputActionHandle                  ToggleFlashlightActionHandle;                      // 0x0288(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUE4InputAxisHandle                    FocusableCameraRotationAxisHandleX;                // 0x0290(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUE4InputAxisHandle                    FocusableCameraRotationAxisHandleY;                // 0x0298(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x02A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x50];                                     // 0x02A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayFocusWidget">();
	}
	static class USHGameplayFocusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayFocusWidget>();
	}
};
static_assert(alignof(USHGameplayFocusWidget) == 0x000008, "Wrong alignment on USHGameplayFocusWidget");
static_assert(sizeof(USHGameplayFocusWidget) == 0x0002F8, "Wrong size on USHGameplayFocusWidget");
static_assert(offsetof(USHGameplayFocusWidget, MiniInventoryWidget) == 0x000278, "Member 'USHGameplayFocusWidget::MiniInventoryWidget' has a wrong offset!");
static_assert(offsetof(USHGameplayFocusWidget, InputKeysDataAsset) == 0x000280, "Member 'USHGameplayFocusWidget::InputKeysDataAsset' has a wrong offset!");
static_assert(offsetof(USHGameplayFocusWidget, ToggleFlashlightActionHandle) == 0x000288, "Member 'USHGameplayFocusWidget::ToggleFlashlightActionHandle' has a wrong offset!");
static_assert(offsetof(USHGameplayFocusWidget, FocusableCameraRotationAxisHandleX) == 0x000290, "Member 'USHGameplayFocusWidget::FocusableCameraRotationAxisHandleX' has a wrong offset!");
static_assert(offsetof(USHGameplayFocusWidget, FocusableCameraRotationAxisHandleY) == 0x000298, "Member 'USHGameplayFocusWidget::FocusableCameraRotationAxisHandleY' has a wrong offset!");
static_assert(offsetof(USHGameplayFocusWidget, OwnerCharacter) == 0x0002A0, "Member 'USHGameplayFocusWidget::OwnerCharacter' has a wrong offset!");

// Class SHProto.SHBreakableMeshComponent
// 0x00A0 (0x06A0 - 0x0600)
class USHBreakableMeshComponent final : public UStaticMeshComponent
{
public:
	int32                                         StartFromIndex;                                    // 0x05F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FC[0x4];                                      // 0x05FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHBreakableMeshBreakStepData>  BreakSteps;                                        // 0x0600(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bHideAfterLastBreakStep;                           // 0x0610(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPenetrable;                                     // 0x0611(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBreakByDamage;                                 // 0x0612(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseDamageTypesWhitelist;                          // 0x0613(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_614[0x4];                                      // 0x0614(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UDamageType>>        DamageTypesWhitelist;                              // 0x0618(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnReceivedDamageEvent;                             // 0x0628(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnBreakEvent;                                      // 0x0638(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_648[0x58];                                     // 0x0648(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ManualBreakRequest(const class UObject* Requester);
	void SHBreakableMeshEvent__DelegateSignature(class USHBreakableMeshComponent* Component);
	void SHBreakableMeshWithHitContextEvent__DelegateSignature(class USHBreakableMeshComponent* Component, TSubclassOf<class UDamageType> DamageTypeClass, const struct FHitResult& HitResult);

	int32 GetCurrentBrokenIndex() const;
	bool IsAfterLastBrokenStep(int32 CheckedIndex) const;
	bool IsLastBrokenStep(int32 CheckedIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBreakableMeshComponent">();
	}
	static class USHBreakableMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBreakableMeshComponent>();
	}
};
static_assert(alignof(USHBreakableMeshComponent) == 0x000010, "Wrong alignment on USHBreakableMeshComponent");
static_assert(sizeof(USHBreakableMeshComponent) == 0x0006A0, "Wrong size on USHBreakableMeshComponent");
static_assert(offsetof(USHBreakableMeshComponent, StartFromIndex) == 0x0005F8, "Member 'USHBreakableMeshComponent::StartFromIndex' has a wrong offset!");
static_assert(offsetof(USHBreakableMeshComponent, BreakSteps) == 0x000600, "Member 'USHBreakableMeshComponent::BreakSteps' has a wrong offset!");
static_assert(offsetof(USHBreakableMeshComponent, bHideAfterLastBreakStep) == 0x000610, "Member 'USHBreakableMeshComponent::bHideAfterLastBreakStep' has a wrong offset!");
static_assert(offsetof(USHBreakableMeshComponent, bIsPenetrable) == 0x000611, "Member 'USHBreakableMeshComponent::bIsPenetrable' has a wrong offset!");
static_assert(offsetof(USHBreakableMeshComponent, bCanBreakByDamage) == 0x000612, "Member 'USHBreakableMeshComponent::bCanBreakByDamage' has a wrong offset!");
static_assert(offsetof(USHBreakableMeshComponent, bUseDamageTypesWhitelist) == 0x000613, "Member 'USHBreakableMeshComponent::bUseDamageTypesWhitelist' has a wrong offset!");
static_assert(offsetof(USHBreakableMeshComponent, DamageTypesWhitelist) == 0x000618, "Member 'USHBreakableMeshComponent::DamageTypesWhitelist' has a wrong offset!");
static_assert(offsetof(USHBreakableMeshComponent, OnReceivedDamageEvent) == 0x000628, "Member 'USHBreakableMeshComponent::OnReceivedDamageEvent' has a wrong offset!");
static_assert(offsetof(USHBreakableMeshComponent, OnBreakEvent) == 0x000638, "Member 'USHBreakableMeshComponent::OnBreakEvent' has a wrong offset!");

// Class SHProto.USHMariaPushComponent
// 0x0008 (0x00A8 - 0x00A0)
class UUSHMariaPushComponent final : public UActorComponent
{
public:
	float                                         DistanceToMove;                                    // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector CalculatePushedLoc(const struct FVector& PushingLoc, const struct FVector& PushingNormal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"USHMariaPushComponent">();
	}
	static class UUSHMariaPushComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUSHMariaPushComponent>();
	}
};
static_assert(alignof(UUSHMariaPushComponent) == 0x000008, "Wrong alignment on UUSHMariaPushComponent");
static_assert(sizeof(UUSHMariaPushComponent) == 0x0000A8, "Wrong size on UUSHMariaPushComponent");
static_assert(offsetof(UUSHMariaPushComponent, DistanceToMove) == 0x0000A0, "Member 'UUSHMariaPushComponent::DistanceToMove' has a wrong offset!");

// Class SHProto.SHItemWeaponExtensionComponent
// 0x0000 (0x00A0 - 0x00A0)
class USHItemWeaponExtensionComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemWeaponExtensionComponent">();
	}
	static class USHItemWeaponExtensionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHItemWeaponExtensionComponent>();
	}
};
static_assert(alignof(USHItemWeaponExtensionComponent) == 0x000008, "Wrong alignment on USHItemWeaponExtensionComponent");
static_assert(sizeof(USHItemWeaponExtensionComponent) == 0x0000A0, "Wrong size on USHItemWeaponExtensionComponent");

// Class SHProto.SHBreakWallTutorialHandler
// 0x0000 (0x0048 - 0x0048)
class USHBreakWallTutorialHandler final : public USHSecondaryTargetTutorialHandler
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHBreakWallTutorialHandler">();
	}
	static class USHBreakWallTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHBreakWallTutorialHandler>();
	}
};
static_assert(alignof(USHBreakWallTutorialHandler) == 0x000008, "Wrong alignment on USHBreakWallTutorialHandler");
static_assert(sizeof(USHBreakWallTutorialHandler) == 0x000048, "Wrong size on USHBreakWallTutorialHandler");

// Class SHProto.SHGameplayItemNotificationWidget
// 0x00D8 (0x0350 - 0x0278)
class USHGameplayItemNotificationWidget final : public UUserWidget
{
public:
	class UTextBlock*                             NotificationText;                                  // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ShowAnim;                                          // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       HideAnim;                                          // 0x0288(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NotificationTime;                                  // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ConsumedText;                                      // 0x0298(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   CollectedText;                                     // 0x02B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          NotificationAudioEvent;                            // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class FText>                CustomTexts;                                       // 0x02D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   GameNotFullyInstalledRowName;                      // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEffectHandle                          LightEffect;                                       // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x20];                                     // 0x0330(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayGameNotFullyInstalledNotificationRequest();

	bool CanShowNotification() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayItemNotificationWidget">();
	}
	static class USHGameplayItemNotificationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayItemNotificationWidget>();
	}
};
static_assert(alignof(USHGameplayItemNotificationWidget) == 0x000008, "Wrong alignment on USHGameplayItemNotificationWidget");
static_assert(sizeof(USHGameplayItemNotificationWidget) == 0x000350, "Wrong size on USHGameplayItemNotificationWidget");
static_assert(offsetof(USHGameplayItemNotificationWidget, NotificationText) == 0x000278, "Member 'USHGameplayItemNotificationWidget::NotificationText' has a wrong offset!");
static_assert(offsetof(USHGameplayItemNotificationWidget, ShowAnim) == 0x000280, "Member 'USHGameplayItemNotificationWidget::ShowAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayItemNotificationWidget, HideAnim) == 0x000288, "Member 'USHGameplayItemNotificationWidget::HideAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayItemNotificationWidget, NotificationTime) == 0x000290, "Member 'USHGameplayItemNotificationWidget::NotificationTime' has a wrong offset!");
static_assert(offsetof(USHGameplayItemNotificationWidget, ConsumedText) == 0x000298, "Member 'USHGameplayItemNotificationWidget::ConsumedText' has a wrong offset!");
static_assert(offsetof(USHGameplayItemNotificationWidget, CollectedText) == 0x0002B0, "Member 'USHGameplayItemNotificationWidget::CollectedText' has a wrong offset!");
static_assert(offsetof(USHGameplayItemNotificationWidget, NotificationAudioEvent) == 0x0002C8, "Member 'USHGameplayItemNotificationWidget::NotificationAudioEvent' has a wrong offset!");
static_assert(offsetof(USHGameplayItemNotificationWidget, CustomTexts) == 0x0002D0, "Member 'USHGameplayItemNotificationWidget::CustomTexts' has a wrong offset!");
static_assert(offsetof(USHGameplayItemNotificationWidget, GameNotFullyInstalledRowName) == 0x000320, "Member 'USHGameplayItemNotificationWidget::GameNotFullyInstalledRowName' has a wrong offset!");
static_assert(offsetof(USHGameplayItemNotificationWidget, LightEffect) == 0x000328, "Member 'USHGameplayItemNotificationWidget::LightEffect' has a wrong offset!");

// Class SHProto.SHCameraAnimationExecutive
// 0x0100 (0x03B0 - 0x02B0)
class alignas(0x10) ASHCameraAnimationExecutive final : public AActor
{
public:
	class USHCineCameraComponent*                 Camera;                                            // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnPlayed;                                          // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlendOut;                                        // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStop;                                            // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0xC8];                                     // 0x02E8(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSequenceStopped();
	void SetActorToAttachTo(class AActor* InActorToAttachTo);
	void SetLockCharacterAttachment(bool InLockCharacterAttachment);
	void SetLockCharacterAttachmentTransform(const struct FTransform& InTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCameraAnimationExecutive">();
	}
	static class ASHCameraAnimationExecutive* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHCameraAnimationExecutive>();
	}
};
static_assert(alignof(ASHCameraAnimationExecutive) == 0x000010, "Wrong alignment on ASHCameraAnimationExecutive");
static_assert(sizeof(ASHCameraAnimationExecutive) == 0x0003B0, "Wrong size on ASHCameraAnimationExecutive");
static_assert(offsetof(ASHCameraAnimationExecutive, Camera) == 0x0002B0, "Member 'ASHCameraAnimationExecutive::Camera' has a wrong offset!");
static_assert(offsetof(ASHCameraAnimationExecutive, OnPlayed) == 0x0002B8, "Member 'ASHCameraAnimationExecutive::OnPlayed' has a wrong offset!");
static_assert(offsetof(ASHCameraAnimationExecutive, OnBlendOut) == 0x0002C8, "Member 'ASHCameraAnimationExecutive::OnBlendOut' has a wrong offset!");
static_assert(offsetof(ASHCameraAnimationExecutive, OnStop) == 0x0002D8, "Member 'ASHCameraAnimationExecutive::OnStop' has a wrong offset!");

// Class SHProto.SHHitReactionConfig
// 0x0010 (0x0040 - 0x0030)
class USHHitReactionConfig final : public UDataAsset
{
public:
	TArray<struct FSHHitReactionConfiguration>    HitReactionOptions;                                // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHitReactionConfig">();
	}
	static class USHHitReactionConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHHitReactionConfig>();
	}
};
static_assert(alignof(USHHitReactionConfig) == 0x000008, "Wrong alignment on USHHitReactionConfig");
static_assert(sizeof(USHHitReactionConfig) == 0x000040, "Wrong size on USHHitReactionConfig");
static_assert(offsetof(USHHitReactionConfig, HitReactionOptions) == 0x000030, "Member 'USHHitReactionConfig::HitReactionOptions' has a wrong offset!");

// Class SHProto.SHCameraDataBlender
// 0x00C0 (0x0138 - 0x0078)
class USHCameraDataBlender final : public USHBlenderBase
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHCameraDataStruct                    CameraData;                                        // 0x0080(0x0058)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHCameraDataStruct                    CollisionData;                                     // 0x00E0(0x0058)(NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCameraDataBlender">();
	}
	static class USHCameraDataBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCameraDataBlender>();
	}
};
static_assert(alignof(USHCameraDataBlender) == 0x000008, "Wrong alignment on USHCameraDataBlender");
static_assert(sizeof(USHCameraDataBlender) == 0x000138, "Wrong size on USHCameraDataBlender");
static_assert(offsetof(USHCameraDataBlender, CameraData) == 0x000080, "Member 'USHCameraDataBlender::CameraData' has a wrong offset!");
static_assert(offsetof(USHCameraDataBlender, CollisionData) == 0x0000E0, "Member 'USHCameraDataBlender::CollisionData' has a wrong offset!");

// Class SHProto.SHCameraMAACRBlender
// 0x0008 (0x0080 - 0x0078)
class USHCameraMAACRBlender final : public USHBlenderBase
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCameraMAACRBlender">();
	}
	static class USHCameraMAACRBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCameraMAACRBlender>();
	}
};
static_assert(alignof(USHCameraMAACRBlender) == 0x000008, "Wrong alignment on USHCameraMAACRBlender");
static_assert(sizeof(USHCameraMAACRBlender) == 0x000080, "Wrong size on USHCameraMAACRBlender");

// Class SHProto.SHInteriorExteriorVolume
// 0x0008 (0x02F0 - 0x02E8)
class ASHInteriorExteriorVolume final : public AVolume
{
public:
	ESHInteriorExteriorStateEnum                  Value;                                             // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsPointWithin(const struct FVector& Point) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInteriorExteriorVolume">();
	}
	static class ASHInteriorExteriorVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHInteriorExteriorVolume>();
	}
};
static_assert(alignof(ASHInteriorExteriorVolume) == 0x000008, "Wrong alignment on ASHInteriorExteriorVolume");
static_assert(sizeof(ASHInteriorExteriorVolume) == 0x0002F0, "Wrong size on ASHInteriorExteriorVolume");
static_assert(offsetof(ASHInteriorExteriorVolume, Value) == 0x0002E8, "Member 'ASHInteriorExteriorVolume::Value' has a wrong offset!");

// Class SHProto.SHCameraPostProcessConfig
// 0x0720 (0x0750 - 0x0030)
class USHCameraPostProcessConfig final : public UDataAsset
{
public:
	struct FSHBlendData                           BlendConfigData;                                   // 0x0030(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0050(0x0700)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCameraPostProcessConfig">();
	}
	static class USHCameraPostProcessConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCameraPostProcessConfig>();
	}
};
static_assert(alignof(USHCameraPostProcessConfig) == 0x000010, "Wrong alignment on USHCameraPostProcessConfig");
static_assert(sizeof(USHCameraPostProcessConfig) == 0x000750, "Wrong size on USHCameraPostProcessConfig");
static_assert(offsetof(USHCameraPostProcessConfig, BlendConfigData) == 0x000030, "Member 'USHCameraPostProcessConfig::BlendConfigData' has a wrong offset!");
static_assert(offsetof(USHCameraPostProcessConfig, PostProcessSettings) == 0x000050, "Member 'USHCameraPostProcessConfig::PostProcessSettings' has a wrong offset!");

// Class SHProto.SHCameraWorkStatics
// 0x0000 (0x0028 - 0x0028)
class USHCameraWorkStatics final : public UBlueprintFunctionLibrary
{
public:
	static class ASHCameraAnimationExecutive* CreateAndPlayCameraAnimation(class UObject* WorldContextObject, class ACharacter* Character, const struct FSHCameraAnimationData& CameraAnimData);
	static class ASHCameraAnimationExecutive* CreateCameraAnimation(class UObject* WorldContextObject, const struct FSHCameraAnimationData& CameraAnimData);
	static TArray<class UMovieSceneTrack*> GetCameraAnimTracks(class UMovieSceneSequence* Sequence);
	static TArray<struct FVector> GetCameraPath(class UMovieSceneSequence* Sequence);
	static bool PlayCameraAnimation(class ASHCameraAnimationExecutive* CameraAnimExe, class ACharacter* Character, const struct FSHCameraAnimationData& CameraAnimData);
	static bool ValidateCameraAnimData(const struct FSHCameraAnimationData& CameraAnimData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCameraWorkStatics">();
	}
	static class USHCameraWorkStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCameraWorkStatics>();
	}
};
static_assert(alignof(USHCameraWorkStatics) == 0x000008, "Wrong alignment on USHCameraWorkStatics");
static_assert(sizeof(USHCameraWorkStatics) == 0x000028, "Wrong size on USHCameraWorkStatics");

// Class SHProto.SHHud
// 0x0000 (0x0610 - 0x0610)
class ASHHud : public ABHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHud">();
	}
	static class ASHHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHHud>();
	}
};
static_assert(alignof(ASHHud) == 0x000008, "Wrong alignment on ASHHud");
static_assert(sizeof(ASHHud) == 0x000610, "Wrong size on ASHHud");

// Class SHProto.SHCarMovementProcessor
// 0x0080 (0x00B0 - 0x0030)
class USHCarMovementProcessor final : public USHVehicleMovementProcessor
{
public:
	float                                         WheelsRadius;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AxlesDistance;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WheelsMaxTurnAngle;                                // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EngineBaseRevolutionsPerMinute;                    // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EngineMaxRevolutionsPerMinute;                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EngineRevolutionsGainFactor;                       // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EngineRevolutionsDragFactor;                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementDragFactor;                                // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccumulatedInputRotationGainInterpSpeed;           // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccumulatedInputRotationLoseInterpSpeed;           // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPrintDebug;                                       // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x57];                                      // 0x0059(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTransmissionRatio(float InRatio);

	int32 GetEngineRevolutionsPerMinute() const;
	float GetRotationInput() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCarMovementProcessor">();
	}
	static class USHCarMovementProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCarMovementProcessor>();
	}
};
static_assert(alignof(USHCarMovementProcessor) == 0x000008, "Wrong alignment on USHCarMovementProcessor");
static_assert(sizeof(USHCarMovementProcessor) == 0x0000B0, "Wrong size on USHCarMovementProcessor");
static_assert(offsetof(USHCarMovementProcessor, WheelsRadius) == 0x000030, "Member 'USHCarMovementProcessor::WheelsRadius' has a wrong offset!");
static_assert(offsetof(USHCarMovementProcessor, AxlesDistance) == 0x000034, "Member 'USHCarMovementProcessor::AxlesDistance' has a wrong offset!");
static_assert(offsetof(USHCarMovementProcessor, WheelsMaxTurnAngle) == 0x000038, "Member 'USHCarMovementProcessor::WheelsMaxTurnAngle' has a wrong offset!");
static_assert(offsetof(USHCarMovementProcessor, EngineBaseRevolutionsPerMinute) == 0x00003C, "Member 'USHCarMovementProcessor::EngineBaseRevolutionsPerMinute' has a wrong offset!");
static_assert(offsetof(USHCarMovementProcessor, EngineMaxRevolutionsPerMinute) == 0x000040, "Member 'USHCarMovementProcessor::EngineMaxRevolutionsPerMinute' has a wrong offset!");
static_assert(offsetof(USHCarMovementProcessor, EngineRevolutionsGainFactor) == 0x000044, "Member 'USHCarMovementProcessor::EngineRevolutionsGainFactor' has a wrong offset!");
static_assert(offsetof(USHCarMovementProcessor, EngineRevolutionsDragFactor) == 0x000048, "Member 'USHCarMovementProcessor::EngineRevolutionsDragFactor' has a wrong offset!");
static_assert(offsetof(USHCarMovementProcessor, MovementDragFactor) == 0x00004C, "Member 'USHCarMovementProcessor::MovementDragFactor' has a wrong offset!");
static_assert(offsetof(USHCarMovementProcessor, AccumulatedInputRotationGainInterpSpeed) == 0x000050, "Member 'USHCarMovementProcessor::AccumulatedInputRotationGainInterpSpeed' has a wrong offset!");
static_assert(offsetof(USHCarMovementProcessor, AccumulatedInputRotationLoseInterpSpeed) == 0x000054, "Member 'USHCarMovementProcessor::AccumulatedInputRotationLoseInterpSpeed' has a wrong offset!");
static_assert(offsetof(USHCarMovementProcessor, bPrintDebug) == 0x000058, "Member 'USHCarMovementProcessor::bPrintDebug' has a wrong offset!");

// Class SHProto.SHTranscriptData
// 0x0018 (0x0048 - 0x0030)
class USHTranscriptData final : public UDataAsset
{
public:
	class FText                                   Transcript;                                        // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTranscriptData">();
	}
	static class USHTranscriptData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTranscriptData>();
	}
};
static_assert(alignof(USHTranscriptData) == 0x000008, "Wrong alignment on USHTranscriptData");
static_assert(sizeof(USHTranscriptData) == 0x000048, "Wrong size on USHTranscriptData");
static_assert(offsetof(USHTranscriptData, Transcript) == 0x000030, "Member 'USHTranscriptData::Transcript' has a wrong offset!");

// Class SHProto.SHCharacterAudioSubcomponentBase
// 0x0010 (0x0038 - 0x0028)
class USHCharacterAudioSubcomponentBase : public UObject
{
public:
	class ACharacter*                             OwnerCharacter;                                    // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkComponent*                         OwnerComponent;                                    // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterAudioSubcomponentBase">();
	}
	static class USHCharacterAudioSubcomponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterAudioSubcomponentBase>();
	}
};
static_assert(alignof(USHCharacterAudioSubcomponentBase) == 0x000008, "Wrong alignment on USHCharacterAudioSubcomponentBase");
static_assert(sizeof(USHCharacterAudioSubcomponentBase) == 0x000038, "Wrong size on USHCharacterAudioSubcomponentBase");
static_assert(offsetof(USHCharacterAudioSubcomponentBase, OwnerCharacter) == 0x000028, "Member 'USHCharacterAudioSubcomponentBase::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHCharacterAudioSubcomponentBase, OwnerComponent) == 0x000030, "Member 'USHCharacterAudioSubcomponentBase::OwnerComponent' has a wrong offset!");

// Class SHProto.SHInteraction
// 0x0000 (0x0028 - 0x0028)
class ISHInteraction : public IInterface
{
public:
	void ProcessInput(const struct FVector2D& Input, const EGameBaseInputDevice& InputDevice);
	bool TryStartInteraction(const TScriptInterface<class ISHInteractionSlot>& InteractionSlot);

	struct FSHManagedInteractionSlotCleanupConfig GetCleanupConfig() const;
	bool IsInteractionActive() const;
	bool IsOverridingCleanupConfig() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInteraction">();
	}
	static class ISHInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHInteraction>();
	}
};
static_assert(alignof(ISHInteraction) == 0x000008, "Wrong alignment on ISHInteraction");
static_assert(sizeof(ISHInteraction) == 0x000028, "Wrong size on ISHInteraction");

// Class SHProto.Critical_LookAtType
// 0x0000 (0x0028 - 0x0028)
class UCritical_LookAtType final : public USHLookAtTypeID
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Critical_LookAtType">();
	}
	static class UCritical_LookAtType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCritical_LookAtType>();
	}
};
static_assert(alignof(UCritical_LookAtType) == 0x000008, "Wrong alignment on UCritical_LookAtType");
static_assert(sizeof(UCritical_LookAtType) == 0x000028, "Wrong size on UCritical_LookAtType");

// Class SHProto.Enemy_LookAtType
// 0x0000 (0x0028 - 0x0028)
class UEnemy_LookAtType final : public USHLookAtTypeID
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Enemy_LookAtType">();
	}
	static class UEnemy_LookAtType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemy_LookAtType>();
	}
};
static_assert(alignof(UEnemy_LookAtType) == 0x000008, "Wrong alignment on UEnemy_LookAtType");
static_assert(sizeof(UEnemy_LookAtType) == 0x000028, "Wrong size on UEnemy_LookAtType");

// Class SHProto.SHMariaLightingActor
// 0x0040 (0x02F0 - 0x02B0)
class ASHMariaLightingActor final : public AActor
{
public:
	class USpotLightComponent*                    SpotLightComponent;                                // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultIntensity;                                  // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           DefaultGlobalColor;                                // 0x02BC(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SourceOffset;                                      // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x20];                                     // 0x02D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMariaLightingActor">();
	}
	static class ASHMariaLightingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHMariaLightingActor>();
	}
};
static_assert(alignof(ASHMariaLightingActor) == 0x000008, "Wrong alignment on ASHMariaLightingActor");
static_assert(sizeof(ASHMariaLightingActor) == 0x0002F0, "Wrong size on ASHMariaLightingActor");
static_assert(offsetof(ASHMariaLightingActor, SpotLightComponent) == 0x0002B0, "Member 'ASHMariaLightingActor::SpotLightComponent' has a wrong offset!");
static_assert(offsetof(ASHMariaLightingActor, DefaultIntensity) == 0x0002B8, "Member 'ASHMariaLightingActor::DefaultIntensity' has a wrong offset!");
static_assert(offsetof(ASHMariaLightingActor, DefaultGlobalColor) == 0x0002BC, "Member 'ASHMariaLightingActor::DefaultGlobalColor' has a wrong offset!");
static_assert(offsetof(ASHMariaLightingActor, SourceOffset) == 0x0002CC, "Member 'ASHMariaLightingActor::SourceOffset' has a wrong offset!");

// Class SHProto.SHAdaptiveTriggersManagerSettings
// 0x0038 (0x0068 - 0x0030)
class USHAdaptiveTriggersManagerSettings final : public UDataAsset
{
public:
	TArray<struct FDataTableRowHandle>            WeaponUsingWeaponSettings_HeavyRanged;             // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FDataTableRowHandle>            WeaponUsingWeaponSettings_LightRanged;             // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSHAdaptiveTriggerWeaponData           RightTriggerSettings_LightRangedWeapon;            // 0x0050(0x0003)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSHAdaptiveTriggerWeaponData           RightTriggerSettings_HeavyRangedWeapon;            // 0x0053(0x0003)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSHAdaptiveTriggerFeedbackData         RightTriggerSettings_MeleeWeapon;                  // 0x0056(0x0002)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSHAdaptiveTriggerWeaponData           RightTriggerSettings_NoWeapon;                     // 0x0058(0x0003)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSHAdaptiveTriggerFeedbackData         RightTriggerSettings_Custom_Boat;                  // 0x005B(0x0002)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSHAdaptiveTriggerFeedbackData         LeftTiggerSettings_LightRanged;                    // 0x005D(0x0002)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSHAdaptiveTriggerFeedbackData         LeftTiggerSettings_HeavyRanged;                    // 0x005F(0x0002)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSHAdaptiveTriggerFeedbackData         LeftTiggerSettings_NoWeapon;                       // 0x0061(0x0002)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSHAdaptiveTriggerFeedbackData         LeftTriggerSettings_Custom_Boat;                   // 0x0063(0x0002)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAdaptiveTriggersManagerSettings">();
	}
	static class USHAdaptiveTriggersManagerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAdaptiveTriggersManagerSettings>();
	}
};
static_assert(alignof(USHAdaptiveTriggersManagerSettings) == 0x000008, "Wrong alignment on USHAdaptiveTriggersManagerSettings");
static_assert(sizeof(USHAdaptiveTriggersManagerSettings) == 0x000068, "Wrong size on USHAdaptiveTriggersManagerSettings");
static_assert(offsetof(USHAdaptiveTriggersManagerSettings, WeaponUsingWeaponSettings_HeavyRanged) == 0x000030, "Member 'USHAdaptiveTriggersManagerSettings::WeaponUsingWeaponSettings_HeavyRanged' has a wrong offset!");
static_assert(offsetof(USHAdaptiveTriggersManagerSettings, WeaponUsingWeaponSettings_LightRanged) == 0x000040, "Member 'USHAdaptiveTriggersManagerSettings::WeaponUsingWeaponSettings_LightRanged' has a wrong offset!");
static_assert(offsetof(USHAdaptiveTriggersManagerSettings, RightTriggerSettings_LightRangedWeapon) == 0x000050, "Member 'USHAdaptiveTriggersManagerSettings::RightTriggerSettings_LightRangedWeapon' has a wrong offset!");
static_assert(offsetof(USHAdaptiveTriggersManagerSettings, RightTriggerSettings_HeavyRangedWeapon) == 0x000053, "Member 'USHAdaptiveTriggersManagerSettings::RightTriggerSettings_HeavyRangedWeapon' has a wrong offset!");
static_assert(offsetof(USHAdaptiveTriggersManagerSettings, RightTriggerSettings_MeleeWeapon) == 0x000056, "Member 'USHAdaptiveTriggersManagerSettings::RightTriggerSettings_MeleeWeapon' has a wrong offset!");
static_assert(offsetof(USHAdaptiveTriggersManagerSettings, RightTriggerSettings_NoWeapon) == 0x000058, "Member 'USHAdaptiveTriggersManagerSettings::RightTriggerSettings_NoWeapon' has a wrong offset!");
static_assert(offsetof(USHAdaptiveTriggersManagerSettings, RightTriggerSettings_Custom_Boat) == 0x00005B, "Member 'USHAdaptiveTriggersManagerSettings::RightTriggerSettings_Custom_Boat' has a wrong offset!");
static_assert(offsetof(USHAdaptiveTriggersManagerSettings, LeftTiggerSettings_LightRanged) == 0x00005D, "Member 'USHAdaptiveTriggersManagerSettings::LeftTiggerSettings_LightRanged' has a wrong offset!");
static_assert(offsetof(USHAdaptiveTriggersManagerSettings, LeftTiggerSettings_HeavyRanged) == 0x00005F, "Member 'USHAdaptiveTriggersManagerSettings::LeftTiggerSettings_HeavyRanged' has a wrong offset!");
static_assert(offsetof(USHAdaptiveTriggersManagerSettings, LeftTiggerSettings_NoWeapon) == 0x000061, "Member 'USHAdaptiveTriggersManagerSettings::LeftTiggerSettings_NoWeapon' has a wrong offset!");
static_assert(offsetof(USHAdaptiveTriggersManagerSettings, LeftTriggerSettings_Custom_Boat) == 0x000063, "Member 'USHAdaptiveTriggersManagerSettings::LeftTriggerSettings_Custom_Boat' has a wrong offset!");

// Class SHProto.SHMandarinAnimFootIKSubcomp
// 0x0048 (0x0150 - 0x0108)
class USHMandarinAnimFootIKSubcomp final : public USHAnimFootIKSubcomp
{
public:
	uint8                                         Pad_108[0x48];                                     // 0x0108(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMandarinAnimFootIKSubcomp">();
	}
	static class USHMandarinAnimFootIKSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMandarinAnimFootIKSubcomp>();
	}
};
static_assert(alignof(USHMandarinAnimFootIKSubcomp) == 0x000008, "Wrong alignment on USHMandarinAnimFootIKSubcomp");
static_assert(sizeof(USHMandarinAnimFootIKSubcomp) == 0x000150, "Wrong size on USHMandarinAnimFootIKSubcomp");

// Class SHProto.SHCharacterPlayAimOffsetMatchingToolWidget
// 0x0000 (0x0278 - 0x0278)
class USHCharacterPlayAimOffsetMatchingToolWidget final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayAimOffsetMatchingToolWidget">();
	}
	static class USHCharacterPlayAimOffsetMatchingToolWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayAimOffsetMatchingToolWidget>();
	}
};
static_assert(alignof(USHCharacterPlayAimOffsetMatchingToolWidget) == 0x000008, "Wrong alignment on USHCharacterPlayAimOffsetMatchingToolWidget");
static_assert(sizeof(USHCharacterPlayAimOffsetMatchingToolWidget) == 0x000278, "Wrong size on USHCharacterPlayAimOffsetMatchingToolWidget");

// Class SHProto.SHCharacterPlayAnimComponent
// 0x0238 (0x04C8 - 0x0290)
class USHCharacterPlayAnimComponent final : public USHAnimComponent
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalAnimationProfileDA*            PhysicalAnimationProfilesDA;                       // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSHAnimHeadRotationSubcompSettings     SHAnimHeadRotationSubcompSettings;                 // 0x02A0(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSHAnimFootIKSubcompSettings           SHAnimFootIKSubcompSettings;                       // 0x0310(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSHAnimEnviroHitReactionsSubcompSettings SHAnimEnviroHitReactionsSubcompSettings;           // 0x0380(0x00E0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSHAnimMovementSubcompSettings         SHAnimMovementSubcompSettings;                     // 0x0460(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x0470(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_478[0x50];                                     // 0x0478(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Character_AimOffset_Enabled(bool Enabled);
	void SHDebug_Character_Animation_DrawDebug();

	bool ForceTposeDebug() const;
	struct FRotator GetAimRotation() const;
	struct FVector2D GetCurrentRotationSpeed() const;
	struct FVector GetHealthStateAsMontageBlendspaceInput() const;
	bool IsAlive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayAnimComponent">();
	}
	static class USHCharacterPlayAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayAnimComponent>();
	}
};
static_assert(alignof(USHCharacterPlayAnimComponent) == 0x000008, "Wrong alignment on USHCharacterPlayAnimComponent");
static_assert(sizeof(USHCharacterPlayAnimComponent) == 0x0004C8, "Wrong size on USHCharacterPlayAnimComponent");
static_assert(offsetof(USHCharacterPlayAnimComponent, PhysicalAnimationProfilesDA) == 0x000298, "Member 'USHCharacterPlayAnimComponent::PhysicalAnimationProfilesDA' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayAnimComponent, SHAnimHeadRotationSubcompSettings) == 0x0002A0, "Member 'USHCharacterPlayAnimComponent::SHAnimHeadRotationSubcompSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayAnimComponent, SHAnimFootIKSubcompSettings) == 0x000310, "Member 'USHCharacterPlayAnimComponent::SHAnimFootIKSubcompSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayAnimComponent, SHAnimEnviroHitReactionsSubcompSettings) == 0x000380, "Member 'USHCharacterPlayAnimComponent::SHAnimEnviroHitReactionsSubcompSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayAnimComponent, SHAnimMovementSubcompSettings) == 0x000460, "Member 'USHCharacterPlayAnimComponent::SHAnimMovementSubcompSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayAnimComponent, OwnerCharacter) == 0x000470, "Member 'USHCharacterPlayAnimComponent::OwnerCharacter' has a wrong offset!");

// Class SHProto.SHMaryAnimComponent
// 0x0000 (0x0490 - 0x0490)
class USHMaryAnimComponent final : public USHEnemyAnimComponent
{
public:
	void SetMaryMovementState(ESHMaryAnimInstanceMovementState InMovementState, bool InMovementChangeInProgress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMaryAnimComponent">();
	}
	static class USHMaryAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMaryAnimComponent>();
	}
};
static_assert(alignof(USHMaryAnimComponent) == 0x000008, "Wrong alignment on USHMaryAnimComponent");
static_assert(sizeof(USHMaryAnimComponent) == 0x000490, "Wrong size on USHMaryAnimComponent");

// Class SHProto.SHDebugOnlyDamage
// 0x0000 (0x0040 - 0x0040)
class USHDebugOnlyDamage final : public UDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDebugOnlyDamage">();
	}
	static class USHDebugOnlyDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDebugOnlyDamage>();
	}
};
static_assert(alignof(USHDebugOnlyDamage) == 0x000008, "Wrong alignment on USHDebugOnlyDamage");
static_assert(sizeof(USHDebugOnlyDamage) == 0x000040, "Wrong size on USHDebugOnlyDamage");

// Class SHProto.SHFirearmBaseDamage
// 0x0000 (0x0068 - 0x0068)
class USHFirearmBaseDamage final : public UFirearmDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFirearmBaseDamage">();
	}
	static class USHFirearmBaseDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFirearmBaseDamage>();
	}
};
static_assert(alignof(USHFirearmBaseDamage) == 0x000008, "Wrong alignment on USHFirearmBaseDamage");
static_assert(sizeof(USHFirearmBaseDamage) == 0x000068, "Wrong size on USHFirearmBaseDamage");

// Class SHProto.SHCharacterPlayBreathNoiseComponent
// 0x0010 (0x0310 - 0x0300)
class USHCharacterPlayBreathNoiseComponent final : public UMaiNoiseEmitter
{
public:
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x0300(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsHoldingBreath() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayBreathNoiseComponent">();
	}
	static class USHCharacterPlayBreathNoiseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayBreathNoiseComponent>();
	}
};
static_assert(alignof(USHCharacterPlayBreathNoiseComponent) == 0x000010, "Wrong alignment on USHCharacterPlayBreathNoiseComponent");
static_assert(sizeof(USHCharacterPlayBreathNoiseComponent) == 0x000310, "Wrong size on USHCharacterPlayBreathNoiseComponent");
static_assert(offsetof(USHCharacterPlayBreathNoiseComponent, OwnerCharacter) == 0x000300, "Member 'USHCharacterPlayBreathNoiseComponent::OwnerCharacter' has a wrong offset!");

// Class SHProto.SHItemWeapon
// 0x0330 (0x0690 - 0x0360)
class ASHItemWeapon : public ASHItemEquipable
{
public:
	class USHAkItemWeaponBaseAudioComponent*      WeaponItemAudioComponent;                          // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              DamageRange;                                       // 0x0368(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoUnequipTime;                                   // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoUnequipTimeInWater;                            // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   MeshAnimClass;                                     // 0x0380(0x0030)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetingMinViewDotProduct;                        // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            TargetingAngleScoreCurve;                          // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            TargetingDistanceScoreCurve;                       // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseWeaponMovementSet;                             // 0x03C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C9[0x7];                                      // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHWeaponMovementSet                   WeaponMovementSet;                                 // 0x03D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   AlternativeEquipAttachSocket;                      // 0x0420(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                AlternativeEquipRelativeLocation;                  // 0x0428(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                AlternativeEquipRelativeRotation;                  // 0x0440(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USHSystemFXDataMappings> TraceHitFXMappings;                                // 0x0458(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TraceHitFXSpawnerClass;                            // 0x0488(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkAudioEvent>           HitFXSpawnerAkAudioEvent;                          // 0x04B8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSHMakeNoiseConfig                     HitNoiseConfig;                                    // 0x04E8(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_504[0x18C];                                    // 0x0504(0x018C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMeshHidden(const bool InWantHidden, const class UObject* Object);

	bool HasEnabledAnyDebug() const;
	bool IsMeshHidden() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemWeapon">();
	}
	static class ASHItemWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHItemWeapon>();
	}
};
static_assert(alignof(ASHItemWeapon) == 0x000008, "Wrong alignment on ASHItemWeapon");
static_assert(sizeof(ASHItemWeapon) == 0x000690, "Wrong size on ASHItemWeapon");
static_assert(offsetof(ASHItemWeapon, WeaponItemAudioComponent) == 0x000360, "Member 'ASHItemWeapon::WeaponItemAudioComponent' has a wrong offset!");
static_assert(offsetof(ASHItemWeapon, DamageRange) == 0x000368, "Member 'ASHItemWeapon::DamageRange' has a wrong offset!");
static_assert(offsetof(ASHItemWeapon, AutoUnequipTime) == 0x000378, "Member 'ASHItemWeapon::AutoUnequipTime' has a wrong offset!");
static_assert(offsetof(ASHItemWeapon, AutoUnequipTimeInWater) == 0x00037C, "Member 'ASHItemWeapon::AutoUnequipTimeInWater' has a wrong offset!");
static_assert(offsetof(ASHItemWeapon, MeshAnimClass) == 0x000380, "Member 'ASHItemWeapon::MeshAnimClass' has a wrong offset!");
static_assert(offsetof(ASHItemWeapon, TargetingMinViewDotProduct) == 0x0003B0, "Member 'ASHItemWeapon::TargetingMinViewDotProduct' has a wrong offset!");
static_assert(offsetof(ASHItemWeapon, TargetingAngleScoreCurve) == 0x0003B8, "Member 'ASHItemWeapon::TargetingAngleScoreCurve' has a wrong offset!");
static_assert(offsetof(ASHItemWeapon, TargetingDistanceScoreCurve) == 0x0003C0, "Member 'ASHItemWeapon::TargetingDistanceScoreCurve' has a wrong offset!");
static_assert(offsetof(ASHItemWeapon, bUseWeaponMovementSet) == 0x0003C8, "Member 'ASHItemWeapon::bUseWeaponMovementSet' has a wrong offset!");
static_assert(offsetof(ASHItemWeapon, WeaponMovementSet) == 0x0003D0, "Member 'ASHItemWeapon::WeaponMovementSet' has a wrong offset!");
static_assert(offsetof(ASHItemWeapon, AlternativeEquipAttachSocket) == 0x000420, "Member 'ASHItemWeapon::AlternativeEquipAttachSocket' has a wrong offset!");
static_assert(offsetof(ASHItemWeapon, AlternativeEquipRelativeLocation) == 0x000428, "Member 'ASHItemWeapon::AlternativeEquipRelativeLocation' has a wrong offset!");
static_assert(offsetof(ASHItemWeapon, AlternativeEquipRelativeRotation) == 0x000440, "Member 'ASHItemWeapon::AlternativeEquipRelativeRotation' has a wrong offset!");
static_assert(offsetof(ASHItemWeapon, TraceHitFXMappings) == 0x000458, "Member 'ASHItemWeapon::TraceHitFXMappings' has a wrong offset!");
static_assert(offsetof(ASHItemWeapon, TraceHitFXSpawnerClass) == 0x000488, "Member 'ASHItemWeapon::TraceHitFXSpawnerClass' has a wrong offset!");
static_assert(offsetof(ASHItemWeapon, HitFXSpawnerAkAudioEvent) == 0x0004B8, "Member 'ASHItemWeapon::HitFXSpawnerAkAudioEvent' has a wrong offset!");
static_assert(offsetof(ASHItemWeapon, HitNoiseConfig) == 0x0004E8, "Member 'ASHItemWeapon::HitNoiseConfig' has a wrong offset!");

// Class SHProto.SHItemWeaponRanged
// 0x05A8 (0x0C38 - 0x0690)
class ASHItemWeaponRanged : public ASHItemWeapon
{
public:
	float                                         RequiredCameraBlendAlpha;                          // 0x0690(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_694[0x4];                                      // 0x0694(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    WeaponAmmoItem;                                    // 0x0698(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         WeaponClipSize;                                    // 0x06A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ReloadAmmoAddedPerNotify;                          // 0x06AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCustomInitalAmmoInWeapon;                      // 0x06B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B1[0x3];                                      // 0x06B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CustomInitalAmmoInWeapon;                          // 0x06B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USHFirearmBaseDamage>       DamageClass;                                       // 0x06B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DamageFalloffCurve;                                // 0x06C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusGainSpeed;                                    // 0x06C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeaponFocusAfterShoot;                             // 0x06CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResetFocusOnViewRotation;                         // 0x06D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D1[0x3];                                      // 0x06D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ViewRotationToResetFocus;                          // 0x06D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlockGainFocusOnViewRotation;                     // 0x06D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D9[0x3];                                      // 0x06D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ViewRotationToBlockGainFocus;                      // 0x06DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResetFocusOnMovement;                             // 0x06E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E1[0x3];                                      // 0x06E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementValueToResetFocus;                         // 0x06E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlockGainFocusOnMovement;                         // 0x06E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E9[0x3];                                      // 0x06E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementValueToBlockGainFocus;                     // 0x06EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoseFocusOnMovement;                              // 0x06F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6F1[0x3];                                      // 0x06F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementValueToLoseFocus;                          // 0x06F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementLoseFocusSpeed;                            // 0x06F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6FC[0x4];                                      // 0x06FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCurveVector*>                   RecoilCurves;                                      // 0x0700(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              SpreadUnfocusedMax;                                // 0x0710(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              SpreadUnfocusedMin;                                // 0x0720(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              SpreadFocusedMax;                                  // 0x0730(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              SpreadFocusedMin;                                  // 0x0740(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumberOfTracesPerShoot;                            // 0x0750(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCircleUniformSpread;                           // 0x0754(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_755[0x3];                                      // 0x0755(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceRadius;                                       // 0x0758(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxShootDistance;                                  // 0x075C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimationAsset>         FireWeaponAnim;                                    // 0x0760(0x0030)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimationAsset>         FireNoAmmoWeaponAnim;                              // 0x0790(0x0030)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimationAsset>         ReloadWeaponAnim;                                  // 0x07C0(0x0030)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoAimMaxRange;                                   // 0x07F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7F4[0x4];                                      // 0x07F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AutoAimRangeToStrengthMappingCurve;                // 0x07F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharacterRotationInputScale;                       // 0x0800(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharacterControlRotationInterpSpeed;               // 0x0804(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSHMovementDataStruct                  AimMovementData;                                   // 0x0808(0x0028)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseReloadMovementData;                            // 0x0830(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_831[0x7];                                      // 0x0831(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHMovementDataStruct                  ReloadMovementData;                                // 0x0838(0x0028)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPlayAnimationData                     FireAnimData;                                      // 0x0860(0x00B0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FPlayAnimationData                     FireNoAmmoAnimData;                                // 0x0910(0x00B0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<ESHCombatPoseType, struct FPlayAnimationData> ReloadAnimsData;                                   // 0x09C0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FSHCameraDataFull                      DefaultAimCameraData;                              // 0x0A10(0x00B0)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<ESHCombatPoseType, struct FSHCameraDataFull> PosesAimCameraData;                                // 0x0AC0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FSHCameraFOVBlendData                  AimCameraFOVData;                                  // 0x0B10(0x0028)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USHCameraPostProcessConfig> AimCameraPostProcessConfig;                        // 0x0B38(0x0030)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           AimCameraShake;                                    // 0x0B68(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           FireCameraShake;                                   // 0x0B70(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForceFeedbackEffect*                   ForceFeedbackOnFire;                               // 0x0B78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForceFeedbackEffect*                   ForceFeedbackOnOutOfAmmo;                          // 0x0B80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEffectHandle                          LightEffect;                                       // 0x0B88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UCameraShakeBase*                       PlayingAimCameraShake;                             // 0x0B90(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraShakeBase*                       PlayingFireCameraShake;                            // 0x0B98(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           RecoilCurveToUse;                                  // 0x0BA0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RegisteredFirePoint;                               // 0x0BA8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BB0[0x88];                                     // 0x0BB0(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DrawAimDetailedDebug(float DeltaTime);
	void OnFirePerformed(const struct FVector& ShootEndWorldLoc);
	void OnFireSpreadPerformed(const TArray<struct FVector>& ShootsHitLoc);
	void OnOutOfAmmoPerformed();
	void OnShellEjected();
	void RegisterFirePoint(class USceneComponent* InPoint);
	struct FSHWeaponRangedPointingData TracePerfectForPointingData(bool bForceRefresh);

	bool CanBeReloaded() const;
	struct FSHWeaponRangedPointingData GetCachedPerfectTraceCachedData() const;
	struct FVector GetEndTraceLoc(const float ShootAngle, const struct FVector2D& SpreadAngles) const;
	float GetFocusValue() const;
	struct FVector GetPerfectShootVector() const;
	struct FVector GetRandomEndTraceLoc() const;
	struct FVector GetSpreadShootVector(const struct FVector2D& SpreadAngles) const;
	struct FVector GetStartTraceLoc() const;
	bool HasAnyAmmoInClip() const;
	bool HasWeaponAmmoInInventory() const;
	bool IsFireReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemWeaponRanged">();
	}
	static class ASHItemWeaponRanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHItemWeaponRanged>();
	}
};
static_assert(alignof(ASHItemWeaponRanged) == 0x000008, "Wrong alignment on ASHItemWeaponRanged");
static_assert(sizeof(ASHItemWeaponRanged) == 0x000C38, "Wrong size on ASHItemWeaponRanged");
static_assert(offsetof(ASHItemWeaponRanged, RequiredCameraBlendAlpha) == 0x000690, "Member 'ASHItemWeaponRanged::RequiredCameraBlendAlpha' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, WeaponAmmoItem) == 0x000698, "Member 'ASHItemWeaponRanged::WeaponAmmoItem' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, WeaponClipSize) == 0x0006A8, "Member 'ASHItemWeaponRanged::WeaponClipSize' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, ReloadAmmoAddedPerNotify) == 0x0006AC, "Member 'ASHItemWeaponRanged::ReloadAmmoAddedPerNotify' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, bUseCustomInitalAmmoInWeapon) == 0x0006B0, "Member 'ASHItemWeaponRanged::bUseCustomInitalAmmoInWeapon' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, CustomInitalAmmoInWeapon) == 0x0006B4, "Member 'ASHItemWeaponRanged::CustomInitalAmmoInWeapon' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, DamageClass) == 0x0006B8, "Member 'ASHItemWeaponRanged::DamageClass' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, DamageFalloffCurve) == 0x0006C0, "Member 'ASHItemWeaponRanged::DamageFalloffCurve' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, FocusGainSpeed) == 0x0006C8, "Member 'ASHItemWeaponRanged::FocusGainSpeed' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, WeaponFocusAfterShoot) == 0x0006CC, "Member 'ASHItemWeaponRanged::WeaponFocusAfterShoot' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, bResetFocusOnViewRotation) == 0x0006D0, "Member 'ASHItemWeaponRanged::bResetFocusOnViewRotation' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, ViewRotationToResetFocus) == 0x0006D4, "Member 'ASHItemWeaponRanged::ViewRotationToResetFocus' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, bBlockGainFocusOnViewRotation) == 0x0006D8, "Member 'ASHItemWeaponRanged::bBlockGainFocusOnViewRotation' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, ViewRotationToBlockGainFocus) == 0x0006DC, "Member 'ASHItemWeaponRanged::ViewRotationToBlockGainFocus' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, bResetFocusOnMovement) == 0x0006E0, "Member 'ASHItemWeaponRanged::bResetFocusOnMovement' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, MovementValueToResetFocus) == 0x0006E4, "Member 'ASHItemWeaponRanged::MovementValueToResetFocus' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, bBlockGainFocusOnMovement) == 0x0006E8, "Member 'ASHItemWeaponRanged::bBlockGainFocusOnMovement' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, MovementValueToBlockGainFocus) == 0x0006EC, "Member 'ASHItemWeaponRanged::MovementValueToBlockGainFocus' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, bLoseFocusOnMovement) == 0x0006F0, "Member 'ASHItemWeaponRanged::bLoseFocusOnMovement' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, MovementValueToLoseFocus) == 0x0006F4, "Member 'ASHItemWeaponRanged::MovementValueToLoseFocus' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, MovementLoseFocusSpeed) == 0x0006F8, "Member 'ASHItemWeaponRanged::MovementLoseFocusSpeed' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, RecoilCurves) == 0x000700, "Member 'ASHItemWeaponRanged::RecoilCurves' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, SpreadUnfocusedMax) == 0x000710, "Member 'ASHItemWeaponRanged::SpreadUnfocusedMax' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, SpreadUnfocusedMin) == 0x000720, "Member 'ASHItemWeaponRanged::SpreadUnfocusedMin' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, SpreadFocusedMax) == 0x000730, "Member 'ASHItemWeaponRanged::SpreadFocusedMax' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, SpreadFocusedMin) == 0x000740, "Member 'ASHItemWeaponRanged::SpreadFocusedMin' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, NumberOfTracesPerShoot) == 0x000750, "Member 'ASHItemWeaponRanged::NumberOfTracesPerShoot' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, bUseCircleUniformSpread) == 0x000754, "Member 'ASHItemWeaponRanged::bUseCircleUniformSpread' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, TraceRadius) == 0x000758, "Member 'ASHItemWeaponRanged::TraceRadius' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, MaxShootDistance) == 0x00075C, "Member 'ASHItemWeaponRanged::MaxShootDistance' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, FireWeaponAnim) == 0x000760, "Member 'ASHItemWeaponRanged::FireWeaponAnim' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, FireNoAmmoWeaponAnim) == 0x000790, "Member 'ASHItemWeaponRanged::FireNoAmmoWeaponAnim' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, ReloadWeaponAnim) == 0x0007C0, "Member 'ASHItemWeaponRanged::ReloadWeaponAnim' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, AutoAimMaxRange) == 0x0007F0, "Member 'ASHItemWeaponRanged::AutoAimMaxRange' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, AutoAimRangeToStrengthMappingCurve) == 0x0007F8, "Member 'ASHItemWeaponRanged::AutoAimRangeToStrengthMappingCurve' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, CharacterRotationInputScale) == 0x000800, "Member 'ASHItemWeaponRanged::CharacterRotationInputScale' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, CharacterControlRotationInterpSpeed) == 0x000804, "Member 'ASHItemWeaponRanged::CharacterControlRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, AimMovementData) == 0x000808, "Member 'ASHItemWeaponRanged::AimMovementData' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, bUseReloadMovementData) == 0x000830, "Member 'ASHItemWeaponRanged::bUseReloadMovementData' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, ReloadMovementData) == 0x000838, "Member 'ASHItemWeaponRanged::ReloadMovementData' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, FireAnimData) == 0x000860, "Member 'ASHItemWeaponRanged::FireAnimData' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, FireNoAmmoAnimData) == 0x000910, "Member 'ASHItemWeaponRanged::FireNoAmmoAnimData' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, ReloadAnimsData) == 0x0009C0, "Member 'ASHItemWeaponRanged::ReloadAnimsData' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, DefaultAimCameraData) == 0x000A10, "Member 'ASHItemWeaponRanged::DefaultAimCameraData' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, PosesAimCameraData) == 0x000AC0, "Member 'ASHItemWeaponRanged::PosesAimCameraData' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, AimCameraFOVData) == 0x000B10, "Member 'ASHItemWeaponRanged::AimCameraFOVData' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, AimCameraPostProcessConfig) == 0x000B38, "Member 'ASHItemWeaponRanged::AimCameraPostProcessConfig' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, AimCameraShake) == 0x000B68, "Member 'ASHItemWeaponRanged::AimCameraShake' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, FireCameraShake) == 0x000B70, "Member 'ASHItemWeaponRanged::FireCameraShake' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, ForceFeedbackOnFire) == 0x000B78, "Member 'ASHItemWeaponRanged::ForceFeedbackOnFire' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, ForceFeedbackOnOutOfAmmo) == 0x000B80, "Member 'ASHItemWeaponRanged::ForceFeedbackOnOutOfAmmo' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, LightEffect) == 0x000B88, "Member 'ASHItemWeaponRanged::LightEffect' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, PlayingAimCameraShake) == 0x000B90, "Member 'ASHItemWeaponRanged::PlayingAimCameraShake' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, PlayingFireCameraShake) == 0x000B98, "Member 'ASHItemWeaponRanged::PlayingFireCameraShake' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, RecoilCurveToUse) == 0x000BA0, "Member 'ASHItemWeaponRanged::RecoilCurveToUse' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRanged, RegisteredFirePoint) == 0x000BA8, "Member 'ASHItemWeaponRanged::RegisteredFirePoint' has a wrong offset!");

// Class SHProto.SHCharacterPlayCombatComponent
// 0x0158 (0x01F8 - 0x00A0)
class USHCharacterPlayCombatComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             ReceiveDamageEvent;                                // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             CombatInputModeChangedEvent;                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	ECollisionChannel                             ProjectileCollisionChannel;                        // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USHWeaponManageCmbSubcompSettings*      WeaponManageSettings;                              // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHEnemiesManageCmbSubcompSettings*     EnemiesManageSettings;                             // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHDefenceCmbSubcompSettings*           DefenceSettings;                                   // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHStruggleCmbSubcompSettings*          StruggleSettings;                                  // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHRangedAutoAimCmbSubcompSettings*     RangedAutoAimSettings;                             // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHStressCmbSubcompSettings*            StressSettings;                                    // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x00F8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class USHCombatSubcomponentBase*>        OwnedSubcomponents;                                // 0x0100(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0xA8];                                     // 0x0150(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InteruptCombat();
	float ReceiveDamage(float DamageValue, const class UObject* Object, const struct FVector& HitDirection, const TSubclassOf<class UDamageType> DamageType);
	void SetAllCombatBlocked(const bool Blocked, const class UObject* Object);
	void SHCombatComponentEvent__DelegateSignature(class USHCharacterPlayCombatComponent* ComponentPtr);
	void SHCombatEvent__DelegateSignature();
	void SHDebug_Character_Combat_ActionsDebug();
	void SHDebug_Character_Combat_DrawDebug();
	void SHDebug_Character_Combat_DrawSecondaryTargetsDebug();
	void SHDebug_Character_Combat_ValuesDebug();
	bool SynchroReceiveDamage(const class UObject* Object, const struct FPlayAnimationData& AnimData);

	class USHCombatSubcomponentBase* FindSubcomponentByClass(const TSubclassOf<class USHCombatSubcomponentBase> SubcomponentClass) const;
	ESHCombatInputModeEnum GetCombatInputMode() const;
	ESHCombatPoseType GetCombatPose() const;
	bool GetDrawDebug() const;
	bool IsAllCombatBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayCombatComponent">();
	}
	static class USHCharacterPlayCombatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayCombatComponent>();
	}
};
static_assert(alignof(USHCharacterPlayCombatComponent) == 0x000008, "Wrong alignment on USHCharacterPlayCombatComponent");
static_assert(sizeof(USHCharacterPlayCombatComponent) == 0x0001F8, "Wrong size on USHCharacterPlayCombatComponent");
static_assert(offsetof(USHCharacterPlayCombatComponent, ReceiveDamageEvent) == 0x0000A0, "Member 'USHCharacterPlayCombatComponent::ReceiveDamageEvent' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayCombatComponent, CombatInputModeChangedEvent) == 0x0000B0, "Member 'USHCharacterPlayCombatComponent::CombatInputModeChangedEvent' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayCombatComponent, ProjectileCollisionChannel) == 0x0000C0, "Member 'USHCharacterPlayCombatComponent::ProjectileCollisionChannel' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayCombatComponent, WeaponManageSettings) == 0x0000C8, "Member 'USHCharacterPlayCombatComponent::WeaponManageSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayCombatComponent, EnemiesManageSettings) == 0x0000D0, "Member 'USHCharacterPlayCombatComponent::EnemiesManageSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayCombatComponent, DefenceSettings) == 0x0000D8, "Member 'USHCharacterPlayCombatComponent::DefenceSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayCombatComponent, StruggleSettings) == 0x0000E0, "Member 'USHCharacterPlayCombatComponent::StruggleSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayCombatComponent, RangedAutoAimSettings) == 0x0000E8, "Member 'USHCharacterPlayCombatComponent::RangedAutoAimSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayCombatComponent, StressSettings) == 0x0000F0, "Member 'USHCharacterPlayCombatComponent::StressSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayCombatComponent, OwnerCharacter) == 0x0000F8, "Member 'USHCharacterPlayCombatComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayCombatComponent, OwnedSubcomponents) == 0x000100, "Member 'USHCharacterPlayCombatComponent::OwnedSubcomponents' has a wrong offset!");

// Class SHProto.SHCharacterPlayDLCSkinStaticMeshComponent
// 0x0020 (0x0620 - 0x0600)
class USHCharacterPlayDLCSkinStaticMeshComponent final : public UStaticMeshComponent
{
public:
	class USHDLCSkinSettingsDataAsset*            Settings;                                          // 0x05F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_600[0x20];                                     // 0x0600(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetShouldBeHidden(const bool bInHidden, const class UObject* Object);

	bool ShouldBeHidden() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayDLCSkinStaticMeshComponent">();
	}
	static class USHCharacterPlayDLCSkinStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayDLCSkinStaticMeshComponent>();
	}
};
static_assert(alignof(USHCharacterPlayDLCSkinStaticMeshComponent) == 0x000010, "Wrong alignment on USHCharacterPlayDLCSkinStaticMeshComponent");
static_assert(sizeof(USHCharacterPlayDLCSkinStaticMeshComponent) == 0x000620, "Wrong size on USHCharacterPlayDLCSkinStaticMeshComponent");
static_assert(offsetof(USHCharacterPlayDLCSkinStaticMeshComponent, Settings) == 0x0005F8, "Member 'USHCharacterPlayDLCSkinStaticMeshComponent::Settings' has a wrong offset!");

// Class SHProto.SHFleshLipAnimInstance
// 0x0010 (0x03F0 - 0x03E0)
class USHFleshLipAnimInstance final : public USHMonsterAnimInstance
{
public:
	ESHFleshLipAnimInstanceTransformationState    TransformationState;                               // 0x03E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0xF];                                      // 0x03E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnFleshLipTransformationStateChanged(ESHFleshLipAnimInstanceTransformationState InTransformedInto);
	void StartChargeMovement();
	void StopChargeMovement();

	class USHFleshLipLocomotionAnimInstance* GetActiveFleshLipLocomotionAnimInstance() const;
	class USHFleshLipAnimInstanceStateData* GetFleshLipAnimInstanceStateData() const;
	class USHFleshLipFallenLocomotionAnimInstance* GetFleshLipFallenLocomotionAnimInstance() const;
	class USHFleshLipFlyingLocomotionAnimInstance* GetFleshLipFlyingLocomotionAnimInstance() const;
	class USHFleshLipHangingLocomotionAnimInstance* GetFleshLipHangingLocomotionAnimInstance() const;
	bool GetFleshLipLeftArmIsReleased() const;
	bool GetFleshLipLegsAreReleased() const;
	bool GetFleshLipRightArmIsReleased() const;
	class USHFleshLipStandingLocomotionAnimInstance* GetFleshLipStandingLocomotionAnimInstance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFleshLipAnimInstance">();
	}
	static class USHFleshLipAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFleshLipAnimInstance>();
	}
};
static_assert(alignof(USHFleshLipAnimInstance) == 0x000010, "Wrong alignment on USHFleshLipAnimInstance");
static_assert(sizeof(USHFleshLipAnimInstance) == 0x0003F0, "Wrong size on USHFleshLipAnimInstance");
static_assert(offsetof(USHFleshLipAnimInstance, TransformationState) == 0x0003E0, "Member 'USHFleshLipAnimInstance::TransformationState' has a wrong offset!");

// Class SHProto.SHCharacterPlayEndingsComponentSettings
// 0x0070 (0x00A0 - 0x0030)
class USHCharacterPlayEndingsComponentSettings final : public UDataAsset
{
public:
	TMap<ESHEndingType, int32>                    InitialEndingsScoresMap;                           // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<class USHEndingFactor*>                Factors;                                           // 0x0080(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class USHEndingValueProcessor>> CustomizedValueProcessors;                         // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayEndingsComponentSettings">();
	}
	static class USHCharacterPlayEndingsComponentSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayEndingsComponentSettings>();
	}
};
static_assert(alignof(USHCharacterPlayEndingsComponentSettings) == 0x000008, "Wrong alignment on USHCharacterPlayEndingsComponentSettings");
static_assert(sizeof(USHCharacterPlayEndingsComponentSettings) == 0x0000A0, "Wrong size on USHCharacterPlayEndingsComponentSettings");
static_assert(offsetof(USHCharacterPlayEndingsComponentSettings, InitialEndingsScoresMap) == 0x000030, "Member 'USHCharacterPlayEndingsComponentSettings::InitialEndingsScoresMap' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayEndingsComponentSettings, Factors) == 0x000080, "Member 'USHCharacterPlayEndingsComponentSettings::Factors' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayEndingsComponentSettings, CustomizedValueProcessors) == 0x000090, "Member 'USHCharacterPlayEndingsComponentSettings::CustomizedValueProcessors' has a wrong offset!");

// Class SHProto.SHCharacterPlayEndingsComponent
// 0x0038 (0x00D8 - 0x00A0)
class USHCharacterPlayEndingsComponent final : public UActorComponent
{
public:
	class USHCharacterPlayEndingsComponentSettings* Settings;                                          // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USHEndingFactor*>                OwnedFactors;                                      // 0x00B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class USHEndingValueProcessor*>        OwnedValueProcessors;                              // 0x00C0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Character_Endings_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayEndingsComponent">();
	}
	static class USHCharacterPlayEndingsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayEndingsComponent>();
	}
};
static_assert(alignof(USHCharacterPlayEndingsComponent) == 0x000008, "Wrong alignment on USHCharacterPlayEndingsComponent");
static_assert(sizeof(USHCharacterPlayEndingsComponent) == 0x0000D8, "Wrong size on USHCharacterPlayEndingsComponent");
static_assert(offsetof(USHCharacterPlayEndingsComponent, Settings) == 0x0000A0, "Member 'USHCharacterPlayEndingsComponent::Settings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayEndingsComponent, OwnerCharacter) == 0x0000A8, "Member 'USHCharacterPlayEndingsComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayEndingsComponent, OwnedFactors) == 0x0000B0, "Member 'USHCharacterPlayEndingsComponent::OwnedFactors' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayEndingsComponent, OwnedValueProcessors) == 0x0000C0, "Member 'USHCharacterPlayEndingsComponent::OwnedValueProcessors' has a wrong offset!");

// Class SHProto.SHFXManagerComponent
// 0x0060 (0x0100 - 0x00A0)
class USHFXManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x60];                                      // 0x00A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_FX_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXManagerComponent">();
	}
	static class USHFXManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXManagerComponent>();
	}
};
static_assert(alignof(USHFXManagerComponent) == 0x000008, "Wrong alignment on USHFXManagerComponent");
static_assert(sizeof(USHFXManagerComponent) == 0x000100, "Wrong size on USHFXManagerComponent");

// Class SHProto.SHLauraLookAtLogicComponent
// 0x0010 (0x0190 - 0x0180)
class USHLauraLookAtLogicComponent final : public USHCharacterLookAtLogicComponent
{
public:
	uint8                                         Pad_180[0x10];                                     // 0x0180(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLauraLookAtLogicComponent">();
	}
	static class USHLauraLookAtLogicComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLauraLookAtLogicComponent>();
	}
};
static_assert(alignof(USHLauraLookAtLogicComponent) == 0x000008, "Wrong alignment on USHLauraLookAtLogicComponent");
static_assert(sizeof(USHLauraLookAtLogicComponent) == 0x000190, "Wrong size on USHLauraLookAtLogicComponent");

// Class SHProto.SHCharacterPlayEnviroFrontHitEvent
// 0x0010 (0x0068 - 0x0058)
class USHCharacterPlayEnviroFrontHitEvent final : public UEnviroHitReactionEvent
{
public:
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayEnviroFrontHitEvent">();
	}
	static class USHCharacterPlayEnviroFrontHitEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayEnviroFrontHitEvent>();
	}
};
static_assert(alignof(USHCharacterPlayEnviroFrontHitEvent) == 0x000008, "Wrong alignment on USHCharacterPlayEnviroFrontHitEvent");
static_assert(sizeof(USHCharacterPlayEnviroFrontHitEvent) == 0x000068, "Wrong size on USHCharacterPlayEnviroFrontHitEvent");

// Class SHProto.SHCharacterPlayFXComponent
// 0x0088 (0x0178 - 0x00F0)
class USHCharacterPlayFXComponent final : public USHFXComponent
{
public:
	class USHFXPukePuddleDamageSubcompSettings*   PukePuddleDamageSettings;                          // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXFrozenBreathSubcompSettings*       FrozenBreathSettings;                              // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXWaterInteractionSubcompSettings*   WaterInteractionSettings;                          // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXVisualHPSubcompSettings*           VisualHPSettings;                                  // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXRaingWettingSubcompSettings*       RainWettingSettings;                               // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXDirtLayerSubcompSettings*          DirtLayerSettings;                                 // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXAcidLayerSubcompSettings*          AcidLayerSettings;                                 // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXSwarmSubcompSettings*              SwarmSettings;                                     // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x48];                                     // 0x0130(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Character_FX_Rain_DrawDebug();
	void SHDebug_Character_FX_Rain_EncompassesPointDebug();
	void SHDebug_Character_FX_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayFXComponent">();
	}
	static class USHCharacterPlayFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayFXComponent>();
	}
};
static_assert(alignof(USHCharacterPlayFXComponent) == 0x000008, "Wrong alignment on USHCharacterPlayFXComponent");
static_assert(sizeof(USHCharacterPlayFXComponent) == 0x000178, "Wrong size on USHCharacterPlayFXComponent");
static_assert(offsetof(USHCharacterPlayFXComponent, PukePuddleDamageSettings) == 0x0000F0, "Member 'USHCharacterPlayFXComponent::PukePuddleDamageSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayFXComponent, FrozenBreathSettings) == 0x0000F8, "Member 'USHCharacterPlayFXComponent::FrozenBreathSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayFXComponent, WaterInteractionSettings) == 0x000100, "Member 'USHCharacterPlayFXComponent::WaterInteractionSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayFXComponent, VisualHPSettings) == 0x000108, "Member 'USHCharacterPlayFXComponent::VisualHPSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayFXComponent, RainWettingSettings) == 0x000110, "Member 'USHCharacterPlayFXComponent::RainWettingSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayFXComponent, DirtLayerSettings) == 0x000118, "Member 'USHCharacterPlayFXComponent::DirtLayerSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayFXComponent, AcidLayerSettings) == 0x000120, "Member 'USHCharacterPlayFXComponent::AcidLayerSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayFXComponent, SwarmSettings) == 0x000128, "Member 'USHCharacterPlayFXComponent::SwarmSettings' has a wrong offset!");

// Class SHProto.SHMariaFXComponent
// 0x0018 (0x0108 - 0x00F0)
class USHMariaFXComponent final : public USHFXComponent
{
public:
	class USHFXVisualHPSubcompSettings*           VisualHPSettings;                                  // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXRaingWettingSubcompSettings*       RainWettingSettings;                               // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXAcidLayerSubcompSettings*          AcidLayerSettings;                                 // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMariaFXComponent">();
	}
	static class USHMariaFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMariaFXComponent>();
	}
};
static_assert(alignof(USHMariaFXComponent) == 0x000008, "Wrong alignment on USHMariaFXComponent");
static_assert(sizeof(USHMariaFXComponent) == 0x000108, "Wrong size on USHMariaFXComponent");
static_assert(offsetof(USHMariaFXComponent, VisualHPSettings) == 0x0000F0, "Member 'USHMariaFXComponent::VisualHPSettings' has a wrong offset!");
static_assert(offsetof(USHMariaFXComponent, RainWettingSettings) == 0x0000F8, "Member 'USHMariaFXComponent::RainWettingSettings' has a wrong offset!");
static_assert(offsetof(USHMariaFXComponent, AcidLayerSettings) == 0x000100, "Member 'USHMariaFXComponent::AcidLayerSettings' has a wrong offset!");

// Class SHProto.SHAskQuitDialogWidget
// 0x0040 (0x03D8 - 0x0398)
class USHAskQuitDialogWidget final : public UAskDialogWidget
{
public:
	class FText                                   QuitInfoText;                                      // 0x0398(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   ExitInfoText;                                      // 0x03B0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Info_txt;                                          // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsExitGame;                                       // 0x03D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D1[0x7];                                      // 0x03D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAskQuitDialogWidget">();
	}
	static class USHAskQuitDialogWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAskQuitDialogWidget>();
	}
};
static_assert(alignof(USHAskQuitDialogWidget) == 0x000008, "Wrong alignment on USHAskQuitDialogWidget");
static_assert(sizeof(USHAskQuitDialogWidget) == 0x0003D8, "Wrong size on USHAskQuitDialogWidget");
static_assert(offsetof(USHAskQuitDialogWidget, QuitInfoText) == 0x000398, "Member 'USHAskQuitDialogWidget::QuitInfoText' has a wrong offset!");
static_assert(offsetof(USHAskQuitDialogWidget, ExitInfoText) == 0x0003B0, "Member 'USHAskQuitDialogWidget::ExitInfoText' has a wrong offset!");
static_assert(offsetof(USHAskQuitDialogWidget, Info_txt) == 0x0003C8, "Member 'USHAskQuitDialogWidget::Info_txt' has a wrong offset!");
static_assert(offsetof(USHAskQuitDialogWidget, bIsExitGame) == 0x0003D0, "Member 'USHAskQuitDialogWidget::bIsExitGame' has a wrong offset!");

// Class SHProto.SHCharacterPlayGenericInteractionSlotComponent
// 0x0088 (0x01D0 - 0x0148)
class USHCharacterPlayGenericInteractionSlotComponent final : public USHCharacterPlayManagedInteractionSlotComponent
{
public:
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class ISHInteractionGeneric> ActiveInteraction;                                 // 0x0150(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x50];                                     // 0x0160(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class USHInteractionGenericComponent*         GenericObject;                                     // 0x01B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B8[0x18];                                     // 0x01B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayGenericInteractionSlotComponent">();
	}
	static class USHCharacterPlayGenericInteractionSlotComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayGenericInteractionSlotComponent>();
	}
};
static_assert(alignof(USHCharacterPlayGenericInteractionSlotComponent) == 0x000008, "Wrong alignment on USHCharacterPlayGenericInteractionSlotComponent");
static_assert(sizeof(USHCharacterPlayGenericInteractionSlotComponent) == 0x0001D0, "Wrong size on USHCharacterPlayGenericInteractionSlotComponent");
static_assert(offsetof(USHCharacterPlayGenericInteractionSlotComponent, ActiveInteraction) == 0x000150, "Member 'USHCharacterPlayGenericInteractionSlotComponent::ActiveInteraction' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayGenericInteractionSlotComponent, GenericObject) == 0x0001B0, "Member 'USHCharacterPlayGenericInteractionSlotComponent::GenericObject' has a wrong offset!");

// Class SHProto.SHCharacterPlayHealthComponent
// 0x00F0 (0x0190 - 0x00A0)
class USHCharacterPlayHealthComponent final : public UActorComponent
{
public:
	class USHCharacterPlayHealthSettings*         Settings;                                          // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnHealthStateChangedBlueprintEvent;                // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ASHPlayerDeathVolume*>           PlayerDeathVolumes;                                // 0x00C0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSHMaterialPropertyControlHandler> HealthMaterialPropertyControlsHandlers;            // 0x00D0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSHDynamicPostProcessHandler>   DynamicPostProcessHandlers;                        // 0x00E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UCameraShakeBase*                       PlayingSprintCameraShake;                          // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthValue;                                       // 0x00F8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x94];                                      // 0x00FC(0x0094)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool PlayDeathSequenceRequest(class UObject* InSlayer, const struct FVector& InHitWorldDirection);
	float ReceiveDamage(float DamageValue, const class UObject* Object, bool bRequireCriticalnjuryState);
	float ReceiveHeal(float InHealValue, const class UObject* Object);
	void SetDeathSequenceBlocked(const bool Blocked, const class UObject* Object);
	void SHDebug_Character_Health_CantTouchThis();
	void SHDebug_Character_Health_DeathSequence_Debug();
	void SHDebug_Character_Health_DisableReceiveDamageEffects();
	void SHDebug_Character_Health_DrawHitpointsDebug();
	void SHDebug_Character_Health_FakeDamage(int32 Value);
	void SHDebug_Character_Health_FakeHeal(int32 Value);
	void SHDebug_Character_Health_GodMode();
	void SHDebug_Character_Health_NotEverybodyHurts();
	void SHDebug_Character_Health_ValuesDebug();
	void SHHealthComponentEvent__DelegateSignature(class USHCharacterPlayHealthComponent* Component);
	void SHHealthValueChangedDetailedEvent__DelegateSignature(class USHCharacterPlayHealthComponent* Component, float ChangeDelta, float OldValue, float NewValue);
	void UpdateControllerLights();

	ESHHealthStateEnum GetHealthState() const;
	float GetHealthValue() const;
	bool IsDeathSequenceBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayHealthComponent">();
	}
	static class USHCharacterPlayHealthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayHealthComponent>();
	}
};
static_assert(alignof(USHCharacterPlayHealthComponent) == 0x000008, "Wrong alignment on USHCharacterPlayHealthComponent");
static_assert(sizeof(USHCharacterPlayHealthComponent) == 0x000190, "Wrong size on USHCharacterPlayHealthComponent");
static_assert(offsetof(USHCharacterPlayHealthComponent, Settings) == 0x0000A0, "Member 'USHCharacterPlayHealthComponent::Settings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthComponent, OnHealthStateChangedBlueprintEvent) == 0x0000A8, "Member 'USHCharacterPlayHealthComponent::OnHealthStateChangedBlueprintEvent' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthComponent, OwnerCharacter) == 0x0000B8, "Member 'USHCharacterPlayHealthComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthComponent, PlayerDeathVolumes) == 0x0000C0, "Member 'USHCharacterPlayHealthComponent::PlayerDeathVolumes' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthComponent, HealthMaterialPropertyControlsHandlers) == 0x0000D0, "Member 'USHCharacterPlayHealthComponent::HealthMaterialPropertyControlsHandlers' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthComponent, DynamicPostProcessHandlers) == 0x0000E0, "Member 'USHCharacterPlayHealthComponent::DynamicPostProcessHandlers' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthComponent, PlayingSprintCameraShake) == 0x0000F0, "Member 'USHCharacterPlayHealthComponent::PlayingSprintCameraShake' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayHealthComponent, HealthValue) == 0x0000F8, "Member 'USHCharacterPlayHealthComponent::HealthValue' has a wrong offset!");

// Class SHProto.SHMaryLocomotionAnimInstance
// 0x0010 (0x03C0 - 0x03B0)
class USHMaryLocomotionAnimInstance : public USHMonsterLocomotionAnimInstance
{
public:
	ESHMaryAnimInstanceLocomotionState            LocomotionStateRequest;                            // 0x03A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DesiredRotationYaw;                                // 0x03AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DesiredStrafeAngle;                                // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B4[0xC];                                      // 0x03B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMaryLocomotionAnimInstance">();
	}
	static class USHMaryLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMaryLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHMaryLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHMaryLocomotionAnimInstance");
static_assert(sizeof(USHMaryLocomotionAnimInstance) == 0x0003C0, "Wrong size on USHMaryLocomotionAnimInstance");
static_assert(offsetof(USHMaryLocomotionAnimInstance, LocomotionStateRequest) == 0x0003A8, "Member 'USHMaryLocomotionAnimInstance::LocomotionStateRequest' has a wrong offset!");
static_assert(offsetof(USHMaryLocomotionAnimInstance, DesiredRotationYaw) == 0x0003AC, "Member 'USHMaryLocomotionAnimInstance::DesiredRotationYaw' has a wrong offset!");
static_assert(offsetof(USHMaryLocomotionAnimInstance, DesiredStrafeAngle) == 0x0003B0, "Member 'USHMaryLocomotionAnimInstance::DesiredStrafeAngle' has a wrong offset!");

// Class SHProto.SHMaryHangingLocomotionAnimInstance
// 0x0000 (0x03C0 - 0x03C0)
class USHMaryHangingLocomotionAnimInstance final : public USHMaryLocomotionAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMaryHangingLocomotionAnimInstance">();
	}
	static class USHMaryHangingLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMaryHangingLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHMaryHangingLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHMaryHangingLocomotionAnimInstance");
static_assert(sizeof(USHMaryHangingLocomotionAnimInstance) == 0x0003C0, "Wrong size on USHMaryHangingLocomotionAnimInstance");

// Class SHProto.SHCharacterPlayInputComponent
// 0x0118 (0x0240 - 0x0128)
class USHCharacterPlayInputComponent final : public UInputComponent
{
public:
	class UBInputAction*                          MainMenu;                                          // 0x0128(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          Cancel;                                            // 0x0130(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputMovement*                        Movement;                                          // 0x0138(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputRotation*                        Rotation;                                          // 0x0140(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          Crouch;                                            // 0x0148(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          Sprint;                                            // 0x0150(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          Interact;                                          // 0x0158(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          FlashlightToggle;                                  // 0x0160(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputMovement*                        InvestigationMovement;                             // 0x0168(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputRotation*                        InvestigationRotation;                             // 0x0170(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          InvestigationFlip;                                 // 0x0178(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          InvestigationZoom;                                 // 0x0180(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          InvestigationTranscript;                           // 0x0188(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          InvestigationPreviousItem;                         // 0x0190(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          InvestigationNextItem;                             // 0x0198(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          InventoryToggle;                                   // 0x01A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          MapToggle;                                         // 0x01A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          InventoryMapHold;                                  // 0x01B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          MeleeAttack;                                       // 0x01B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          RangedAim;                                         // 0x01C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAxis*                            SwitchFocus;                                       // 0x01C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          Fire;                                              // 0x01D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          Reload;                                            // 0x01D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          Dodge;                                             // 0x01E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          Struggling;                                        // 0x01E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          QuickTurn;                                         // 0x01F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          ActionHealing;                                     // 0x01F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          WeaponChangeRangedPrevious;                        // 0x0200(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          WeaponChangeRangedNext;                            // 0x0208(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          WeaponChangePistol;                                // 0x0210(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          WeaponChangeShotgun;                               // 0x0218(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          WeaponChangeRifle;                                 // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          BoatForward;                                       // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          BoatLeft;                                          // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBInputAction*                          BoatRight;                                         // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayInputComponent">();
	}
	static class USHCharacterPlayInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayInputComponent>();
	}
};
static_assert(alignof(USHCharacterPlayInputComponent) == 0x000008, "Wrong alignment on USHCharacterPlayInputComponent");
static_assert(sizeof(USHCharacterPlayInputComponent) == 0x000240, "Wrong size on USHCharacterPlayInputComponent");
static_assert(offsetof(USHCharacterPlayInputComponent, MainMenu) == 0x000128, "Member 'USHCharacterPlayInputComponent::MainMenu' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, Cancel) == 0x000130, "Member 'USHCharacterPlayInputComponent::Cancel' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, Movement) == 0x000138, "Member 'USHCharacterPlayInputComponent::Movement' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, Rotation) == 0x000140, "Member 'USHCharacterPlayInputComponent::Rotation' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, Crouch) == 0x000148, "Member 'USHCharacterPlayInputComponent::Crouch' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, Sprint) == 0x000150, "Member 'USHCharacterPlayInputComponent::Sprint' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, Interact) == 0x000158, "Member 'USHCharacterPlayInputComponent::Interact' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, FlashlightToggle) == 0x000160, "Member 'USHCharacterPlayInputComponent::FlashlightToggle' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, InvestigationMovement) == 0x000168, "Member 'USHCharacterPlayInputComponent::InvestigationMovement' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, InvestigationRotation) == 0x000170, "Member 'USHCharacterPlayInputComponent::InvestigationRotation' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, InvestigationFlip) == 0x000178, "Member 'USHCharacterPlayInputComponent::InvestigationFlip' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, InvestigationZoom) == 0x000180, "Member 'USHCharacterPlayInputComponent::InvestigationZoom' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, InvestigationTranscript) == 0x000188, "Member 'USHCharacterPlayInputComponent::InvestigationTranscript' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, InvestigationPreviousItem) == 0x000190, "Member 'USHCharacterPlayInputComponent::InvestigationPreviousItem' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, InvestigationNextItem) == 0x000198, "Member 'USHCharacterPlayInputComponent::InvestigationNextItem' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, InventoryToggle) == 0x0001A0, "Member 'USHCharacterPlayInputComponent::InventoryToggle' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, MapToggle) == 0x0001A8, "Member 'USHCharacterPlayInputComponent::MapToggle' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, InventoryMapHold) == 0x0001B0, "Member 'USHCharacterPlayInputComponent::InventoryMapHold' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, MeleeAttack) == 0x0001B8, "Member 'USHCharacterPlayInputComponent::MeleeAttack' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, RangedAim) == 0x0001C0, "Member 'USHCharacterPlayInputComponent::RangedAim' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, SwitchFocus) == 0x0001C8, "Member 'USHCharacterPlayInputComponent::SwitchFocus' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, Fire) == 0x0001D0, "Member 'USHCharacterPlayInputComponent::Fire' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, Reload) == 0x0001D8, "Member 'USHCharacterPlayInputComponent::Reload' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, Dodge) == 0x0001E0, "Member 'USHCharacterPlayInputComponent::Dodge' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, Struggling) == 0x0001E8, "Member 'USHCharacterPlayInputComponent::Struggling' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, QuickTurn) == 0x0001F0, "Member 'USHCharacterPlayInputComponent::QuickTurn' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, ActionHealing) == 0x0001F8, "Member 'USHCharacterPlayInputComponent::ActionHealing' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, WeaponChangeRangedPrevious) == 0x000200, "Member 'USHCharacterPlayInputComponent::WeaponChangeRangedPrevious' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, WeaponChangeRangedNext) == 0x000208, "Member 'USHCharacterPlayInputComponent::WeaponChangeRangedNext' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, WeaponChangePistol) == 0x000210, "Member 'USHCharacterPlayInputComponent::WeaponChangePistol' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, WeaponChangeShotgun) == 0x000218, "Member 'USHCharacterPlayInputComponent::WeaponChangeShotgun' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, WeaponChangeRifle) == 0x000220, "Member 'USHCharacterPlayInputComponent::WeaponChangeRifle' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, BoatForward) == 0x000228, "Member 'USHCharacterPlayInputComponent::BoatForward' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, BoatLeft) == 0x000230, "Member 'USHCharacterPlayInputComponent::BoatLeft' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayInputComponent, BoatRight) == 0x000238, "Member 'USHCharacterPlayInputComponent::BoatRight' has a wrong offset!");

// Class SHProto.SHInteractionSlot
// 0x0000 (0x0028 - 0x0028)
class ISHInteractionSlot : public IInterface
{
public:
	bool ProcessInteractionRequest(const TScriptInterface<class ISHInteraction>& Interaction);

	bool HasInteraction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInteractionSlot">();
	}
	static class ISHInteractionSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHInteractionSlot>();
	}
};
static_assert(alignof(ISHInteractionSlot) == 0x000008, "Wrong alignment on ISHInteractionSlot");
static_assert(sizeof(ISHInteractionSlot) == 0x000028, "Wrong size on ISHInteractionSlot");

// Class SHProto.SHInteractionGenericSlot
// 0x0000 (0x0028 - 0x0028)
class ISHInteractionGenericSlot final : public ISHInteractionSlot
{
public:
	void ProcessGenericInteractionStop(const struct FSHInteractionGenericStopData& StopData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInteractionGenericSlot">();
	}
	static class ISHInteractionGenericSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHInteractionGenericSlot>();
	}
};
static_assert(alignof(ISHInteractionGenericSlot) == 0x000008, "Wrong alignment on ISHInteractionGenericSlot");
static_assert(sizeof(ISHInteractionGenericSlot) == 0x000028, "Wrong size on ISHInteractionGenericSlot");

// Class SHProto.SHCharacterPlayLightingAlternative
// 0x0000 (0x0300 - 0x0300)
class ASHCharacterPlayLightingAlternative final : public ASHCharacterPlayLightingBase
{
public:
	void HandleDisableCharacterLightsUpdated(bool CurrentDisableCharacterLightsFlag);
	void HandleFlashlightColorChanged(const struct FColor& CurrentFlashlightColor);
	void HandleFlashlightIntensityChanged(float CurrentFlashlightIntensity);
	void HandleGlobalColorUpdated(const struct FLinearColor& InColorOverride);
	void HandleGlobalIntensityMulUpdated(float CurrentGlobalIntensityMul);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayLightingAlternative">();
	}
	static class ASHCharacterPlayLightingAlternative* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHCharacterPlayLightingAlternative>();
	}
};
static_assert(alignof(ASHCharacterPlayLightingAlternative) == 0x000008, "Wrong alignment on ASHCharacterPlayLightingAlternative");
static_assert(sizeof(ASHCharacterPlayLightingAlternative) == 0x000300, "Wrong size on ASHCharacterPlayLightingAlternative");

// Class SHProto.SHCharacterPlayLightsComponent
// 0x0048 (0x00E8 - 0x00A0)
class USHCharacterPlayLightsComponent final : public UActorComponent
{
public:
	TSubclassOf<class ASHCharacterPlayLightingBase> LightingActorClass;                                // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ASHFlashlightControlVolume*>     FlashlightControlVolumes;                          // 0x00B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class ASHCharacterPlayLightingBase*           LightingActor;                                     // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USHCharacterPlayLightingControlDataBlender*> LightingControlDataBlenders;                       // 0x00C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Character_Lights_DrawDebug();
	void SHDebug_Character_Lights_Flashlight_DrawDebug();
	void SHDebug_Character_Lights_Flashlight_ValuesDebug();
	void SHDebug_Character_Lights_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayLightsComponent">();
	}
	static class USHCharacterPlayLightsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayLightsComponent>();
	}
};
static_assert(alignof(USHCharacterPlayLightsComponent) == 0x000008, "Wrong alignment on USHCharacterPlayLightsComponent");
static_assert(sizeof(USHCharacterPlayLightsComponent) == 0x0000E8, "Wrong size on USHCharacterPlayLightsComponent");
static_assert(offsetof(USHCharacterPlayLightsComponent, LightingActorClass) == 0x0000A0, "Member 'USHCharacterPlayLightsComponent::LightingActorClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayLightsComponent, OwnerCharacter) == 0x0000A8, "Member 'USHCharacterPlayLightsComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayLightsComponent, FlashlightControlVolumes) == 0x0000B0, "Member 'USHCharacterPlayLightsComponent::FlashlightControlVolumes' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayLightsComponent, LightingActor) == 0x0000C0, "Member 'USHCharacterPlayLightsComponent::LightingActor' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayLightsComponent, LightingControlDataBlenders) == 0x0000C8, "Member 'USHCharacterPlayLightsComponent::LightingControlDataBlenders' has a wrong offset!");

// Class SHProto.SHKilledEnemyEndingValueProcessor
// 0x0000 (0x0030 - 0x0030)
class USHKilledEnemyEndingValueProcessor final : public USHEndingValueProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHKilledEnemyEndingValueProcessor">();
	}
	static class USHKilledEnemyEndingValueProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHKilledEnemyEndingValueProcessor>();
	}
};
static_assert(alignof(USHKilledEnemyEndingValueProcessor) == 0x000008, "Wrong alignment on USHKilledEnemyEndingValueProcessor");
static_assert(sizeof(USHKilledEnemyEndingValueProcessor) == 0x000030, "Wrong size on USHKilledEnemyEndingValueProcessor");

// Class SHProto.SHMandarinLocomotionAnimInstance
// 0x0060 (0x0410 - 0x03B0)
class USHMandarinLocomotionAnimInstance final : public USHMonsterLocomotionAnimInstance
{
public:
	ESHMandarinAnimInstanceLocomotionState        LocomotionStateRequest;                            // 0x03A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveChangeLegOnGround;                             // 0x03AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveChangeStrafeAngle;                             // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeAngle;                                       // 0x03B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredStrafeAngle;                                // 0x03B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceAngle;                                  // 0x03BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C0[0x8];                                      // 0x03C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetDesiredRotationYaw;                          // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CC[0x4];                                      // 0x03CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetDesiredVelocity;                             // 0x03D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x28];                                     // 0x03E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CacheTurnInPlaceAngle();
	void GetDesiredVelocitySizeAndYaw(float* OutVectorSize, float* OutVectorYaw, float Smoothing);
	bool IsMandarinOver();

	class USHMandarinAnimInstanceStateData* GetMandarinAnimInstanceStateData() const;
	void GetSmoothedLookAt(struct FRotator* OutRotation, float* OutAlpha) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMandarinLocomotionAnimInstance">();
	}
	static class USHMandarinLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMandarinLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHMandarinLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHMandarinLocomotionAnimInstance");
static_assert(sizeof(USHMandarinLocomotionAnimInstance) == 0x000410, "Wrong size on USHMandarinLocomotionAnimInstance");
static_assert(offsetof(USHMandarinLocomotionAnimInstance, LocomotionStateRequest) == 0x0003A8, "Member 'USHMandarinLocomotionAnimInstance::LocomotionStateRequest' has a wrong offset!");
static_assert(offsetof(USHMandarinLocomotionAnimInstance, MoveChangeLegOnGround) == 0x0003AC, "Member 'USHMandarinLocomotionAnimInstance::MoveChangeLegOnGround' has a wrong offset!");
static_assert(offsetof(USHMandarinLocomotionAnimInstance, MoveChangeStrafeAngle) == 0x0003B0, "Member 'USHMandarinLocomotionAnimInstance::MoveChangeStrafeAngle' has a wrong offset!");
static_assert(offsetof(USHMandarinLocomotionAnimInstance, StrafeAngle) == 0x0003B4, "Member 'USHMandarinLocomotionAnimInstance::StrafeAngle' has a wrong offset!");
static_assert(offsetof(USHMandarinLocomotionAnimInstance, DesiredStrafeAngle) == 0x0003B8, "Member 'USHMandarinLocomotionAnimInstance::DesiredStrafeAngle' has a wrong offset!");
static_assert(offsetof(USHMandarinLocomotionAnimInstance, TurnInPlaceAngle) == 0x0003BC, "Member 'USHMandarinLocomotionAnimInstance::TurnInPlaceAngle' has a wrong offset!");
static_assert(offsetof(USHMandarinLocomotionAnimInstance, TargetDesiredRotationYaw) == 0x0003C8, "Member 'USHMandarinLocomotionAnimInstance::TargetDesiredRotationYaw' has a wrong offset!");
static_assert(offsetof(USHMandarinLocomotionAnimInstance, TargetDesiredVelocity) == 0x0003D0, "Member 'USHMandarinLocomotionAnimInstance::TargetDesiredVelocity' has a wrong offset!");

// Class SHProto.SHCharacterPlayMapComponent
// 0x01A0 (0x0240 - 0x00A0)
class USHCharacterPlayMapComponent final : public UActorComponent
{
public:
	TMap<ESHMapsEnum, int32>                      MapsPriorities;                                    // 0x00A0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ASHGameplayMapVolume*>           MapsVolumes;                                       // 0x00F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSHMapFogRevealObjectData>      FogMapRevealObjectsToApply;                        // 0x0108(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<ESHMapsEnum, struct FSHMapObjectsStruct> MapsObjectsData;                                   // 0x0118(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)
	TMap<ESHMapsEnum, struct FSHMapDynamicObjectsContainer> MapsDynamicObjectsContainers;                      // 0x0168(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)
	TMap<ESHMapsEnum, struct FSHMapFogRevealObjectsContainer> FogMapsMapRevealedObjectsContainers;               // 0x01B8(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_208[0x38];                                     // 0x0208(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddFogRevealObjectToApply(const struct FSHMapFogRevealObjectData& MapFogRevealObjectData);
	void AddOrUpdateDynamicObjectData(const struct FSHMapDynamicObjectDataStruct& MapDynamicObjectData);
	void AddOrUpdateObjectData(const struct FSHMapObjectDataStruct& MapObjectData);
	void AddOrUpdateObjectDataArray(const TArray<struct FSHMapObjectDataStruct>& MapObjectDataArray);
	void TryOverrideObjectType(const struct FSHMapDataConfigStruct& ExistingMapObjectConfig, ESHMapObjectTypeEnum InNewType);

	int32 FindObjectDataValue(const class FName& ObjectID, ESHMapsEnum Map) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayMapComponent">();
	}
	static class USHCharacterPlayMapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayMapComponent>();
	}
};
static_assert(alignof(USHCharacterPlayMapComponent) == 0x000008, "Wrong alignment on USHCharacterPlayMapComponent");
static_assert(sizeof(USHCharacterPlayMapComponent) == 0x000240, "Wrong size on USHCharacterPlayMapComponent");
static_assert(offsetof(USHCharacterPlayMapComponent, MapsPriorities) == 0x0000A0, "Member 'USHCharacterPlayMapComponent::MapsPriorities' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMapComponent, OwnerCharacter) == 0x0000F0, "Member 'USHCharacterPlayMapComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMapComponent, MapsVolumes) == 0x0000F8, "Member 'USHCharacterPlayMapComponent::MapsVolumes' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMapComponent, FogMapRevealObjectsToApply) == 0x000108, "Member 'USHCharacterPlayMapComponent::FogMapRevealObjectsToApply' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMapComponent, MapsObjectsData) == 0x000118, "Member 'USHCharacterPlayMapComponent::MapsObjectsData' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMapComponent, MapsDynamicObjectsContainers) == 0x000168, "Member 'USHCharacterPlayMapComponent::MapsDynamicObjectsContainers' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMapComponent, FogMapsMapRevealedObjectsContainers) == 0x0001B8, "Member 'USHCharacterPlayMapComponent::FogMapsMapRevealedObjectsContainers' has a wrong offset!");

// Class SHProto.SHCharacterPlayMPCGameplayComponent
// 0x0030 (0x00D0 - 0x00A0)
class USHCharacterPlayMPCGameplayComponent final : public UActorComponent
{
public:
	class UMaterialParameterCollection*           AssetMPC;                                          // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FlashlightAlphaMPCParamName;                       // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LerpItemEmissiveMPCParamName;                      // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayMPCGameplayComponent">();
	}
	static class USHCharacterPlayMPCGameplayComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayMPCGameplayComponent>();
	}
};
static_assert(alignof(USHCharacterPlayMPCGameplayComponent) == 0x000008, "Wrong alignment on USHCharacterPlayMPCGameplayComponent");
static_assert(sizeof(USHCharacterPlayMPCGameplayComponent) == 0x0000D0, "Wrong size on USHCharacterPlayMPCGameplayComponent");
static_assert(offsetof(USHCharacterPlayMPCGameplayComponent, AssetMPC) == 0x0000A0, "Member 'USHCharacterPlayMPCGameplayComponent::AssetMPC' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMPCGameplayComponent, FlashlightAlphaMPCParamName) == 0x0000A8, "Member 'USHCharacterPlayMPCGameplayComponent::FlashlightAlphaMPCParamName' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMPCGameplayComponent, LerpItemEmissiveMPCParamName) == 0x0000B0, "Member 'USHCharacterPlayMPCGameplayComponent::LerpItemEmissiveMPCParamName' has a wrong offset!");

// Class SHProto.SHMannequinLocomotionAnimInstance
// 0x0000 (0x03B0 - 0x03B0)
#pragma pack(push, 0x1)
class alignas(0x10) USHMannequinLocomotionAnimInstance : public USHMonsterLocomotionAnimInstance
{
public:
	class USHMannequinAnimInstanceStateData* GetMannequinAnimInstanceStateData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMannequinLocomotionAnimInstance">();
	}
	static class USHMannequinLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMannequinLocomotionAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(USHMannequinLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHMannequinLocomotionAnimInstance");
static_assert(sizeof(USHMannequinLocomotionAnimInstance) == 0x0003B0, "Wrong size on USHMannequinLocomotionAnimInstance");

// Class SHProto.SHMannequinStandingLocomotionAnimInstance
// 0x00B0 (0x0460 - 0x03B0)
class USHMannequinStandingLocomotionAnimInstance final : public USHMannequinLocomotionAnimInstance
{
public:
	ESHMannequinAnimInstanceStandingLocomotionState LocomotionState;                                   // 0x03A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumWalkVelocity;                               // 0x03AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationToStrafingRatio;                           // 0x03B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementStopDelay;                                 // 0x03B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DesiredVelocityIncrementHalfTime;                  // 0x03B8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DesiredVelocityDecrementHalfTime;                  // 0x03D0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetDesiredVelocity;                             // 0x03E8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DesiredYawAdjustmentHalfTime;                      // 0x0400(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetDesiredRotationYaw;                          // 0x0404(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtAlphaIncrementHalfTime;                      // 0x0408(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtAlphaDecrementHalfTime;                      // 0x040C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_410[0x50];                                     // 0x0410(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetSmoothedDesiredRotationYaw(float* OutYaw) const;
	void GetSmoothedDesiredVelocity(struct FVector* OutVelocity) const;
	void GetSmoothedDesiredVelocitySizeAndYaw(float* OutVelocitySize, float* OutVelocityYaw) const;
	void GetSmoothedDesiredVelocitySizeAndYawLimitedToDirection(float* OutVelocitySize, float* OutVelocityYaw, float InDirectionYaw, float InToleranceAngle) const;
	void GetSmoothedLookAt(struct FRotator* OutRotation, float* OutAlpha) const;
	void GetTargetDesiredRotationYaw(float* OutYaw) const;
	void GetTargetDesiredVelocity(struct FVector* OutVelocity) const;
	void GetTargetDesiredVelocitySizeAndYaw(float* OutVelocitySize, float* OutVelocityYaw) const;
	void GetTargetDesiredVelocitySizeAndYawLimitedToDirection(float* OutVelocitySize, float* OutVelocityYaw, float InDirectionYaw, float InToleranceAngle) const;
	void GetTargetLookAtAlpha(float* OutAlpha) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMannequinStandingLocomotionAnimInstance">();
	}
	static class USHMannequinStandingLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMannequinStandingLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHMannequinStandingLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHMannequinStandingLocomotionAnimInstance");
static_assert(sizeof(USHMannequinStandingLocomotionAnimInstance) == 0x000460, "Wrong size on USHMannequinStandingLocomotionAnimInstance");
static_assert(offsetof(USHMannequinStandingLocomotionAnimInstance, LocomotionState) == 0x0003A8, "Member 'USHMannequinStandingLocomotionAnimInstance::LocomotionState' has a wrong offset!");
static_assert(offsetof(USHMannequinStandingLocomotionAnimInstance, MinimumWalkVelocity) == 0x0003AC, "Member 'USHMannequinStandingLocomotionAnimInstance::MinimumWalkVelocity' has a wrong offset!");
static_assert(offsetof(USHMannequinStandingLocomotionAnimInstance, RotationToStrafingRatio) == 0x0003B0, "Member 'USHMannequinStandingLocomotionAnimInstance::RotationToStrafingRatio' has a wrong offset!");
static_assert(offsetof(USHMannequinStandingLocomotionAnimInstance, MovementStopDelay) == 0x0003B4, "Member 'USHMannequinStandingLocomotionAnimInstance::MovementStopDelay' has a wrong offset!");
static_assert(offsetof(USHMannequinStandingLocomotionAnimInstance, DesiredVelocityIncrementHalfTime) == 0x0003B8, "Member 'USHMannequinStandingLocomotionAnimInstance::DesiredVelocityIncrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHMannequinStandingLocomotionAnimInstance, DesiredVelocityDecrementHalfTime) == 0x0003D0, "Member 'USHMannequinStandingLocomotionAnimInstance::DesiredVelocityDecrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHMannequinStandingLocomotionAnimInstance, TargetDesiredVelocity) == 0x0003E8, "Member 'USHMannequinStandingLocomotionAnimInstance::TargetDesiredVelocity' has a wrong offset!");
static_assert(offsetof(USHMannequinStandingLocomotionAnimInstance, DesiredYawAdjustmentHalfTime) == 0x000400, "Member 'USHMannequinStandingLocomotionAnimInstance::DesiredYawAdjustmentHalfTime' has a wrong offset!");
static_assert(offsetof(USHMannequinStandingLocomotionAnimInstance, TargetDesiredRotationYaw) == 0x000404, "Member 'USHMannequinStandingLocomotionAnimInstance::TargetDesiredRotationYaw' has a wrong offset!");
static_assert(offsetof(USHMannequinStandingLocomotionAnimInstance, LookAtAlphaIncrementHalfTime) == 0x000408, "Member 'USHMannequinStandingLocomotionAnimInstance::LookAtAlphaIncrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHMannequinStandingLocomotionAnimInstance, LookAtAlphaDecrementHalfTime) == 0x00040C, "Member 'USHMannequinStandingLocomotionAnimInstance::LookAtAlphaDecrementHalfTime' has a wrong offset!");

// Class SHProto.SHCharacterPlayStatisticsComponentSettings
// 0x00F0 (0x0120 - 0x0030)
class USHCharacterPlayStatisticsComponentSettings final : public UDataAsset
{
public:
	struct FAchievementHandle                     NewGamePlusCompletedAchievement;                   // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ESHEndingType, struct FAchievementHandle> EndingToAchievementMap;                            // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCollectionHandle                      SeenEndingsAchievementCollection;                  // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHoursToGivePlaytimeAchievement;                 // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAchievementHandle                     PlaytimeAchievement;                               // 0x0094(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAchievementHandle                     FinishGameNoRangeWeaponAchievement;                // 0x009C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCounterHandle                         UsedWeaponsAchievement;                            // 0x00A4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDataTableRowHandle>            UsedWeaponsItemsRowHandlesWhitelist;               // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCounterHandle                         MeleeWeaponKillsAchievement;                       // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCounterHandle                         RangedWeaponKillsAchievement;                      // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCounterHandle                         ClosedDoorsTriedAchievement;                       // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCounterHandle                         GlassDestroyedAchievement;                         // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KillingStompAttackRowName;                         // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCounterHandle                         KillingStompAttackAchievement;                     // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAchievementHandle                     RadioSilenceAchievement;                           // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    ChainsawItemDataRowHandle;                         // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAchievementHandle                     ChainsawCollectedAchievement;                      // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCounterHandle                         ReflectionItemsPickedUpAchievement;                // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCounterHandle                         MemosItemsPickedUpAchievement;                     // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayStatisticsComponentSettings">();
	}
	static class USHCharacterPlayStatisticsComponentSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayStatisticsComponentSettings>();
	}
};
static_assert(alignof(USHCharacterPlayStatisticsComponentSettings) == 0x000008, "Wrong alignment on USHCharacterPlayStatisticsComponentSettings");
static_assert(sizeof(USHCharacterPlayStatisticsComponentSettings) == 0x000120, "Wrong size on USHCharacterPlayStatisticsComponentSettings");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, NewGamePlusCompletedAchievement) == 0x000030, "Member 'USHCharacterPlayStatisticsComponentSettings::NewGamePlusCompletedAchievement' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, EndingToAchievementMap) == 0x000038, "Member 'USHCharacterPlayStatisticsComponentSettings::EndingToAchievementMap' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, SeenEndingsAchievementCollection) == 0x000088, "Member 'USHCharacterPlayStatisticsComponentSettings::SeenEndingsAchievementCollection' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, MaxHoursToGivePlaytimeAchievement) == 0x000090, "Member 'USHCharacterPlayStatisticsComponentSettings::MaxHoursToGivePlaytimeAchievement' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, PlaytimeAchievement) == 0x000094, "Member 'USHCharacterPlayStatisticsComponentSettings::PlaytimeAchievement' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, FinishGameNoRangeWeaponAchievement) == 0x00009C, "Member 'USHCharacterPlayStatisticsComponentSettings::FinishGameNoRangeWeaponAchievement' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, UsedWeaponsAchievement) == 0x0000A4, "Member 'USHCharacterPlayStatisticsComponentSettings::UsedWeaponsAchievement' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, UsedWeaponsItemsRowHandlesWhitelist) == 0x0000B0, "Member 'USHCharacterPlayStatisticsComponentSettings::UsedWeaponsItemsRowHandlesWhitelist' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, MeleeWeaponKillsAchievement) == 0x0000C0, "Member 'USHCharacterPlayStatisticsComponentSettings::MeleeWeaponKillsAchievement' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, RangedWeaponKillsAchievement) == 0x0000C8, "Member 'USHCharacterPlayStatisticsComponentSettings::RangedWeaponKillsAchievement' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, ClosedDoorsTriedAchievement) == 0x0000D0, "Member 'USHCharacterPlayStatisticsComponentSettings::ClosedDoorsTriedAchievement' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, GlassDestroyedAchievement) == 0x0000D8, "Member 'USHCharacterPlayStatisticsComponentSettings::GlassDestroyedAchievement' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, KillingStompAttackRowName) == 0x0000E0, "Member 'USHCharacterPlayStatisticsComponentSettings::KillingStompAttackRowName' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, KillingStompAttackAchievement) == 0x0000E8, "Member 'USHCharacterPlayStatisticsComponentSettings::KillingStompAttackAchievement' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, RadioSilenceAchievement) == 0x0000F0, "Member 'USHCharacterPlayStatisticsComponentSettings::RadioSilenceAchievement' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, ChainsawItemDataRowHandle) == 0x0000F8, "Member 'USHCharacterPlayStatisticsComponentSettings::ChainsawItemDataRowHandle' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, ChainsawCollectedAchievement) == 0x000108, "Member 'USHCharacterPlayStatisticsComponentSettings::ChainsawCollectedAchievement' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, ReflectionItemsPickedUpAchievement) == 0x000110, "Member 'USHCharacterPlayStatisticsComponentSettings::ReflectionItemsPickedUpAchievement' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayStatisticsComponentSettings, MemosItemsPickedUpAchievement) == 0x000118, "Member 'USHCharacterPlayStatisticsComponentSettings::MemosItemsPickedUpAchievement' has a wrong offset!");

// Class SHProto.SHCharacterPlayTraversalComponent
// 0x0070 (0x0110 - 0x00A0)
class USHCharacterPlayTraversalComponent final : public UActorComponent
{
public:
	class USHTraversalBaseComponent*              CurrentlyPlayingTraversal;                         // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USHTraversalBaseComponent*>      ManagedTraversalComponents;                        // 0x00A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x58];                                      // 0x00B8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessTraversalEndedEvent(class USHTraversalBaseComponent* InTraversalComp);
	void ProcessTraversalStartedEvent(class USHTraversalBaseComponent* InTraversalComp);
	void SHDebug_Character_Traversal_ClimbDrawDebug();
	void SHDebug_Character_Traversal_ClimbPrintDebug();
	void SHDebug_Character_Traversal_ObstacleDrawDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayTraversalComponent">();
	}
	static class USHCharacterPlayTraversalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayTraversalComponent>();
	}
};
static_assert(alignof(USHCharacterPlayTraversalComponent) == 0x000008, "Wrong alignment on USHCharacterPlayTraversalComponent");
static_assert(sizeof(USHCharacterPlayTraversalComponent) == 0x000110, "Wrong size on USHCharacterPlayTraversalComponent");
static_assert(offsetof(USHCharacterPlayTraversalComponent, CurrentlyPlayingTraversal) == 0x0000A0, "Member 'USHCharacterPlayTraversalComponent::CurrentlyPlayingTraversal' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayTraversalComponent, ManagedTraversalComponents) == 0x0000A8, "Member 'USHCharacterPlayTraversalComponent::ManagedTraversalComponents' has a wrong offset!");

// Class SHProto.SHCharacterPlayUIComponent
// 0x00B0 (0x0150 - 0x00A0)
class USHCharacterPlayUIComponent final : public UActorComponent
{
public:
	TSubclassOf<class USHGameplayGameOverWidget>  GameplayGameOverWidgetClass;                       // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USHGameplayEndGameWidget>   GameplayEndGameWidgetClass;                        // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USHGameplayHudWidget>       GameplayHudWidgetClass;                            // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USHGameplayMenuWidget>      GameplayMenuWidgetClass;                           // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USHGameplayFocusWidget>     GameplayFocusWidgetClass;                          // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USHGameplayReadingWidget>   GameplayReadingWidgetClass;                        // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USHGameplaySaveMenuWidget>  GameplaySaveMenuWidgetClass;                       // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USHGameplayItemInvestigationWidget> GameplayItemInvestigationWidgetClass;              // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USHControlTipsPanel>        ControlTipsPanelClass;                             // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCutsceneSkipWidget>        SkipWidgetClass;                                   // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                DeveloperToolWidgetClass;                          // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayHudWidget*                   GameplayHudWidget;                                 // 0x00F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayMenuWidget*                  GameplayMenuWidget;                                // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayFocusWidget*                 GameplayFocusWidget;                               // 0x0108(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayReadingWidget*               GameplayReadingWidget;                             // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayGameOverWidget*              GameplayGameOverWidget;                            // 0x0118(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayEndGameWidget*               GameplayEndGameWidget;                             // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplaySaveMenuWidget*              GameplaySaveMenuWidget;                            // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayItemInvestigationWidget*     GameplayItemInvestigationWidget;                   // 0x0130(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHControlTipsPanel*                    ControlTipsPanel;                                  // 0x0138(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCutsceneSkipWidget*                    SkipWidget;                                        // 0x0140(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            DeveloperToolWidget;                               // 0x0148(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SHDebug_Tool_Hide();
	void SHDebug_Tool_Show();

	class USHGameplayHudWidget* GetGameplayHudWidgetPointer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayUIComponent">();
	}
	static class USHCharacterPlayUIComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayUIComponent>();
	}
};
static_assert(alignof(USHCharacterPlayUIComponent) == 0x000008, "Wrong alignment on USHCharacterPlayUIComponent");
static_assert(sizeof(USHCharacterPlayUIComponent) == 0x000150, "Wrong size on USHCharacterPlayUIComponent");
static_assert(offsetof(USHCharacterPlayUIComponent, GameplayGameOverWidgetClass) == 0x0000A0, "Member 'USHCharacterPlayUIComponent::GameplayGameOverWidgetClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, GameplayEndGameWidgetClass) == 0x0000A8, "Member 'USHCharacterPlayUIComponent::GameplayEndGameWidgetClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, GameplayHudWidgetClass) == 0x0000B0, "Member 'USHCharacterPlayUIComponent::GameplayHudWidgetClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, GameplayMenuWidgetClass) == 0x0000B8, "Member 'USHCharacterPlayUIComponent::GameplayMenuWidgetClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, GameplayFocusWidgetClass) == 0x0000C0, "Member 'USHCharacterPlayUIComponent::GameplayFocusWidgetClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, GameplayReadingWidgetClass) == 0x0000C8, "Member 'USHCharacterPlayUIComponent::GameplayReadingWidgetClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, GameplaySaveMenuWidgetClass) == 0x0000D0, "Member 'USHCharacterPlayUIComponent::GameplaySaveMenuWidgetClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, GameplayItemInvestigationWidgetClass) == 0x0000D8, "Member 'USHCharacterPlayUIComponent::GameplayItemInvestigationWidgetClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, ControlTipsPanelClass) == 0x0000E0, "Member 'USHCharacterPlayUIComponent::ControlTipsPanelClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, SkipWidgetClass) == 0x0000E8, "Member 'USHCharacterPlayUIComponent::SkipWidgetClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, DeveloperToolWidgetClass) == 0x0000F0, "Member 'USHCharacterPlayUIComponent::DeveloperToolWidgetClass' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, GameplayHudWidget) == 0x0000F8, "Member 'USHCharacterPlayUIComponent::GameplayHudWidget' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, GameplayMenuWidget) == 0x000100, "Member 'USHCharacterPlayUIComponent::GameplayMenuWidget' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, GameplayFocusWidget) == 0x000108, "Member 'USHCharacterPlayUIComponent::GameplayFocusWidget' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, GameplayReadingWidget) == 0x000110, "Member 'USHCharacterPlayUIComponent::GameplayReadingWidget' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, GameplayGameOverWidget) == 0x000118, "Member 'USHCharacterPlayUIComponent::GameplayGameOverWidget' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, GameplayEndGameWidget) == 0x000120, "Member 'USHCharacterPlayUIComponent::GameplayEndGameWidget' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, GameplaySaveMenuWidget) == 0x000128, "Member 'USHCharacterPlayUIComponent::GameplaySaveMenuWidget' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, GameplayItemInvestigationWidget) == 0x000130, "Member 'USHCharacterPlayUIComponent::GameplayItemInvestigationWidget' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, ControlTipsPanel) == 0x000138, "Member 'USHCharacterPlayUIComponent::ControlTipsPanel' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, SkipWidget) == 0x000140, "Member 'USHCharacterPlayUIComponent::SkipWidget' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayUIComponent, DeveloperToolWidget) == 0x000148, "Member 'USHCharacterPlayUIComponent::DeveloperToolWidget' has a wrong offset!");

// Class SHProto.SHCharacterPlayViewComponent
// 0x02F0 (0x0590 - 0x02A0)
class USHCharacterPlayViewComponent final : public USceneComponent
{
public:
	struct FVector2D                              PitchLimit;                                        // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPitchLimitHalvedOnCollision;                      // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScaleRotationScale;                                // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeltaRotationScale;                                // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EnsureRelativeLoc;                                 // 0x02C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       CharacterPlay;                                     // 0x02D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USHCameraMAARLBlender*>          MAARLBlenders;                                     // 0x02E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class USHCameraMAACRBlender*>          MAACRBlenders;                                     // 0x02F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FSHViewLookOperation                   LookOperation;                                     // 0x0300(0x00F0)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F0[0x1A0];                                    // 0x03F0(0x01A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToControlRotation(const struct FRotator& RotationToAdd, const class UObject* Object);
	void ClearRotationScale(const class UObject* Object);
	class USHOperationEvents* LookAtLocationAbsolute(const struct FVector& Location, float RotateDuration, const class UObject* Object, float OffsetAngle, class UCurveFloat* InCurve);
	class USHOperationEvents* LookAtRotationAbsolute(const struct FRotator& Rotation, float RotateDuration, const class UObject* Object, float OffsetAngle, class UCurveFloat* InCurve);
	class USHOperationEvents* LookOperationComp(class USceneComponent* InComponent, float RotateDuration, const class UObject* Object, const struct FSHViewLookOperationSettings& InSettings);
	class USHOperationEvents* LookOperationLoc(const struct FVector& Location, float RotateDuration, const class UObject* Object, const struct FSHViewLookOperationSettings& InSettings);
	class USHOperationEvents* LookOperationRot(const struct FRotator& Rotation, float RotateDuration, const class UObject* Object, const struct FSHViewLookOperationSettings& InSettings);
	void OverrideControlRotation(const struct FRotator& NewControlRotation, const class UObject* Object);
	bool ResetLookOperation(const class UObject* Object);
	void SetRotationBlocked(const bool Blocked, const class UObject* Object);
	void SetRotationScale(const float Scale, const class UObject* Object);
	void SHDebug_Character_View_LookOperationDrawDebug();
	void SHDebug_Character_View_ValuesDebug();

	struct FVector GetViewDirection() const;
	const struct FVector GetViewLocation() const;
	const struct FRotator GetViewRotation() const;
	bool IsRotationBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayViewComponent">();
	}
	static class USHCharacterPlayViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayViewComponent>();
	}
};
static_assert(alignof(USHCharacterPlayViewComponent) == 0x000010, "Wrong alignment on USHCharacterPlayViewComponent");
static_assert(sizeof(USHCharacterPlayViewComponent) == 0x000590, "Wrong size on USHCharacterPlayViewComponent");
static_assert(offsetof(USHCharacterPlayViewComponent, PitchLimit) == 0x0002A0, "Member 'USHCharacterPlayViewComponent::PitchLimit' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayViewComponent, bPitchLimitHalvedOnCollision) == 0x0002B0, "Member 'USHCharacterPlayViewComponent::bPitchLimitHalvedOnCollision' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayViewComponent, ScaleRotationScale) == 0x0002B4, "Member 'USHCharacterPlayViewComponent::ScaleRotationScale' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayViewComponent, DeltaRotationScale) == 0x0002B8, "Member 'USHCharacterPlayViewComponent::DeltaRotationScale' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayViewComponent, EnsureRelativeLoc) == 0x0002C0, "Member 'USHCharacterPlayViewComponent::EnsureRelativeLoc' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayViewComponent, CharacterPlay) == 0x0002D8, "Member 'USHCharacterPlayViewComponent::CharacterPlay' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayViewComponent, MAARLBlenders) == 0x0002E0, "Member 'USHCharacterPlayViewComponent::MAARLBlenders' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayViewComponent, MAACRBlenders) == 0x0002F0, "Member 'USHCharacterPlayViewComponent::MAACRBlenders' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayViewComponent, LookOperation) == 0x000300, "Member 'USHCharacterPlayViewComponent::LookOperation' has a wrong offset!");

// Class SHProto.SHCharacterSpawnableObject
// 0x0000 (0x02B0 - 0x02B0)
class ASHCharacterSpawnableObject final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterSpawnableObject">();
	}
	static class ASHCharacterSpawnableObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHCharacterSpawnableObject>();
	}
};
static_assert(alignof(ASHCharacterSpawnableObject) == 0x000008, "Wrong alignment on ASHCharacterSpawnableObject");
static_assert(sizeof(ASHCharacterSpawnableObject) == 0x0002B0, "Wrong size on ASHCharacterSpawnableObject");

// Class SHProto.SHFogCutoutActor
// 0x0028 (0x02D8 - 0x02B0)
class ASHFogCutoutActor final : public AActor
{
public:
	int32                                         CutoutStencilNumber;                               // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Opacity;                                           // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EdgeFade;                                          // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x1C];                                     // 0x02BC(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnabled(const class UObject* Enabler, bool InEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFogCutoutActor">();
	}
	static class ASHFogCutoutActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHFogCutoutActor>();
	}
};
static_assert(alignof(ASHFogCutoutActor) == 0x000008, "Wrong alignment on ASHFogCutoutActor");
static_assert(sizeof(ASHFogCutoutActor) == 0x0002D8, "Wrong size on ASHFogCutoutActor");
static_assert(offsetof(ASHFogCutoutActor, CutoutStencilNumber) == 0x0002B0, "Member 'ASHFogCutoutActor::CutoutStencilNumber' has a wrong offset!");
static_assert(offsetof(ASHFogCutoutActor, Opacity) == 0x0002B4, "Member 'ASHFogCutoutActor::Opacity' has a wrong offset!");
static_assert(offsetof(ASHFogCutoutActor, EdgeFade) == 0x0002B8, "Member 'ASHFogCutoutActor::EdgeFade' has a wrong offset!");

// Class SHProto.SHCharAnimationInstance
// 0x0060 (0x03B0 - 0x0350)
class USHCharAnimationInstance final : public UAnimInstance
{
public:
	class FName                                   LocomotionGraphTag;                                // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LookAtOffsetGraphTag;                              // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChangeLocomotionSnapshotName;                      // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeLocomotionAlphaInterpSpeed;                  // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWholeBodyAnimation;                               // 0x0364(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_365[0x3];                                      // 0x0365(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SpineExtraAngle;                                   // 0x0368(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeLocomotionAlpha;                             // 0x0378(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELocomotionState                              LocomotionState;                                   // 0x037C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37D[0x3];                                      // 0x037D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USHMovementAnimationsSetData*           RequestedNewAnimationsSetData;                     // 0x0380(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x18];                                     // 0x0388(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USHWeaponManageCmbSubcomp*              WeaponManageCmbSubcomp;                            // 0x03A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FName> GetAllPlayingSlotAnimationSlotNames() const;
	class ASHItemWeapon* GetEquippedWeapon() const;
	TArray<class FName> GetPlayingSlotAnimationSlotNames() const;
	void GetSpeedWarpingForcedMultiplier(bool* Enabled, float* ForcedValue) const;
	bool IsAimingWeapon() const;
	bool IsChangingWeaponActionPlaying() const;
	bool IsCharacterCorrectivePostprocessEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharAnimationInstance">();
	}
	static class USHCharAnimationInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharAnimationInstance>();
	}
};
static_assert(alignof(USHCharAnimationInstance) == 0x000010, "Wrong alignment on USHCharAnimationInstance");
static_assert(sizeof(USHCharAnimationInstance) == 0x0003B0, "Wrong size on USHCharAnimationInstance");
static_assert(offsetof(USHCharAnimationInstance, LocomotionGraphTag) == 0x000348, "Member 'USHCharAnimationInstance::LocomotionGraphTag' has a wrong offset!");
static_assert(offsetof(USHCharAnimationInstance, LookAtOffsetGraphTag) == 0x000350, "Member 'USHCharAnimationInstance::LookAtOffsetGraphTag' has a wrong offset!");
static_assert(offsetof(USHCharAnimationInstance, ChangeLocomotionSnapshotName) == 0x000358, "Member 'USHCharAnimationInstance::ChangeLocomotionSnapshotName' has a wrong offset!");
static_assert(offsetof(USHCharAnimationInstance, ChangeLocomotionAlphaInterpSpeed) == 0x000360, "Member 'USHCharAnimationInstance::ChangeLocomotionAlphaInterpSpeed' has a wrong offset!");
static_assert(offsetof(USHCharAnimationInstance, bWholeBodyAnimation) == 0x000364, "Member 'USHCharAnimationInstance::bWholeBodyAnimation' has a wrong offset!");
static_assert(offsetof(USHCharAnimationInstance, SpineExtraAngle) == 0x000368, "Member 'USHCharAnimationInstance::SpineExtraAngle' has a wrong offset!");
static_assert(offsetof(USHCharAnimationInstance, ChangeLocomotionAlpha) == 0x000378, "Member 'USHCharAnimationInstance::ChangeLocomotionAlpha' has a wrong offset!");
static_assert(offsetof(USHCharAnimationInstance, LocomotionState) == 0x00037C, "Member 'USHCharAnimationInstance::LocomotionState' has a wrong offset!");
static_assert(offsetof(USHCharAnimationInstance, RequestedNewAnimationsSetData) == 0x000380, "Member 'USHCharAnimationInstance::RequestedNewAnimationsSetData' has a wrong offset!");
static_assert(offsetof(USHCharAnimationInstance, WeaponManageCmbSubcomp) == 0x0003A0, "Member 'USHCharAnimationInstance::WeaponManageCmbSubcomp' has a wrong offset!");

// Class SHProto.SHAudioBreathingSettings
// 0x0010 (0x0040 - 0x0030)
class USHAudioBreathingSettings final : public UDataAsset
{
public:
	class UAkAudioEvent*                          PlayBreathingEvent;                                // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StopBreathingEvent;                                // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAudioBreathingSettings">();
	}
	static class USHAudioBreathingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAudioBreathingSettings>();
	}
};
static_assert(alignof(USHAudioBreathingSettings) == 0x000008, "Wrong alignment on USHAudioBreathingSettings");
static_assert(sizeof(USHAudioBreathingSettings) == 0x000040, "Wrong size on USHAudioBreathingSettings");
static_assert(offsetof(USHAudioBreathingSettings, PlayBreathingEvent) == 0x000030, "Member 'USHAudioBreathingSettings::PlayBreathingEvent' has a wrong offset!");
static_assert(offsetof(USHAudioBreathingSettings, StopBreathingEvent) == 0x000038, "Member 'USHAudioBreathingSettings::StopBreathingEvent' has a wrong offset!");

// Class SHProto.SHFXNurseHeadShakeSubcomp
// 0x0060 (0x0098 - 0x0038)
class USHFXNurseHeadShakeSubcomp final : public USHFXSubcomponent
{
public:
	class USHFXNurseHeadShakeSubcompSettings*     Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 OwnerSkeletalMesh;                                 // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               HeadDynamicMaterial;                               // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        DestinationOffset;                                 // 0x0050(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        CurrentAccelerations;                              // 0x0060(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        CurrentPositions;                                  // 0x0070(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMaterialParameterInfo>         MaterialParameterInfos;                            // 0x0080(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXNurseHeadShakeSubcomp">();
	}
	static class USHFXNurseHeadShakeSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXNurseHeadShakeSubcomp>();
	}
};
static_assert(alignof(USHFXNurseHeadShakeSubcomp) == 0x000008, "Wrong alignment on USHFXNurseHeadShakeSubcomp");
static_assert(sizeof(USHFXNurseHeadShakeSubcomp) == 0x000098, "Wrong size on USHFXNurseHeadShakeSubcomp");
static_assert(offsetof(USHFXNurseHeadShakeSubcomp, Settings) == 0x000038, "Member 'USHFXNurseHeadShakeSubcomp::Settings' has a wrong offset!");
static_assert(offsetof(USHFXNurseHeadShakeSubcomp, OwnerSkeletalMesh) == 0x000040, "Member 'USHFXNurseHeadShakeSubcomp::OwnerSkeletalMesh' has a wrong offset!");
static_assert(offsetof(USHFXNurseHeadShakeSubcomp, HeadDynamicMaterial) == 0x000048, "Member 'USHFXNurseHeadShakeSubcomp::HeadDynamicMaterial' has a wrong offset!");
static_assert(offsetof(USHFXNurseHeadShakeSubcomp, DestinationOffset) == 0x000050, "Member 'USHFXNurseHeadShakeSubcomp::DestinationOffset' has a wrong offset!");
static_assert(offsetof(USHFXNurseHeadShakeSubcomp, CurrentAccelerations) == 0x000060, "Member 'USHFXNurseHeadShakeSubcomp::CurrentAccelerations' has a wrong offset!");
static_assert(offsetof(USHFXNurseHeadShakeSubcomp, CurrentPositions) == 0x000070, "Member 'USHFXNurseHeadShakeSubcomp::CurrentPositions' has a wrong offset!");
static_assert(offsetof(USHFXNurseHeadShakeSubcomp, MaterialParameterInfos) == 0x000080, "Member 'USHFXNurseHeadShakeSubcomp::MaterialParameterInfos' has a wrong offset!");

// Class SHProto.SHChAudioBreathingSubcomponent
// 0x0038 (0x0070 - 0x0038)
class USHChAudioBreathingSubcomponent final : public USHCharacterAudioSubcomponentBase
{
public:
	class USHAudioBreathingSettings*              Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x30];                                      // 0x0040(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHChAudioBreathingSubcomponent">();
	}
	static class USHChAudioBreathingSubcomponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHChAudioBreathingSubcomponent>();
	}
};
static_assert(alignof(USHChAudioBreathingSubcomponent) == 0x000008, "Wrong alignment on USHChAudioBreathingSubcomponent");
static_assert(sizeof(USHChAudioBreathingSubcomponent) == 0x000070, "Wrong size on USHChAudioBreathingSubcomponent");
static_assert(offsetof(USHChAudioBreathingSubcomponent, Settings) == 0x000038, "Member 'USHChAudioBreathingSubcomponent::Settings' has a wrong offset!");

// Class SHProto.SHEnvironmentComponentSettings
// 0x0028 (0x0058 - 0x0030)
class USHEnvironmentComponentSettings final : public UDataAsset
{
public:
	TArray<struct FSHSwitchesPrioritiesEnviromentData> SwitchesPrioritiesData;                            // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAkSwitchValue*                         EnviromentSwitchNone;                              // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_PlayEnvironment;                        // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_StopEnvironment;                        // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEnvironmentComponentSettings">();
	}
	static class USHEnvironmentComponentSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEnvironmentComponentSettings>();
	}
};
static_assert(alignof(USHEnvironmentComponentSettings) == 0x000008, "Wrong alignment on USHEnvironmentComponentSettings");
static_assert(sizeof(USHEnvironmentComponentSettings) == 0x000058, "Wrong size on USHEnvironmentComponentSettings");
static_assert(offsetof(USHEnvironmentComponentSettings, SwitchesPrioritiesData) == 0x000030, "Member 'USHEnvironmentComponentSettings::SwitchesPrioritiesData' has a wrong offset!");
static_assert(offsetof(USHEnvironmentComponentSettings, EnviromentSwitchNone) == 0x000040, "Member 'USHEnvironmentComponentSettings::EnviromentSwitchNone' has a wrong offset!");
static_assert(offsetof(USHEnvironmentComponentSettings, AudioEvent_PlayEnvironment) == 0x000048, "Member 'USHEnvironmentComponentSettings::AudioEvent_PlayEnvironment' has a wrong offset!");
static_assert(offsetof(USHEnvironmentComponentSettings, AudioEvent_StopEnvironment) == 0x000050, "Member 'USHEnvironmentComponentSettings::AudioEvent_StopEnvironment' has a wrong offset!");

// Class SHProto.SHChAudioEnviroSubcomponent
// 0x0050 (0x0088 - 0x0038)
class USHChAudioEnviroSubcomponent final : public USHCharacterAudioSubcomponentBase
{
public:
	class USHEnvironmentComponentSettings*        Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ASHEnvironmentSwitchVolume*>     EnvironmentVolumes;                                // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkSwitchValue>          CurrentPlayingEnvironmentSwitch;                   // 0x0050(0x0030)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHChAudioEnviroSubcomponent">();
	}
	static class USHChAudioEnviroSubcomponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHChAudioEnviroSubcomponent>();
	}
};
static_assert(alignof(USHChAudioEnviroSubcomponent) == 0x000008, "Wrong alignment on USHChAudioEnviroSubcomponent");
static_assert(sizeof(USHChAudioEnviroSubcomponent) == 0x000088, "Wrong size on USHChAudioEnviroSubcomponent");
static_assert(offsetof(USHChAudioEnviroSubcomponent, Settings) == 0x000038, "Member 'USHChAudioEnviroSubcomponent::Settings' has a wrong offset!");
static_assert(offsetof(USHChAudioEnviroSubcomponent, EnvironmentVolumes) == 0x000040, "Member 'USHChAudioEnviroSubcomponent::EnvironmentVolumes' has a wrong offset!");
static_assert(offsetof(USHChAudioEnviroSubcomponent, CurrentPlayingEnvironmentSwitch) == 0x000050, "Member 'USHChAudioEnviroSubcomponent::CurrentPlayingEnvironmentSwitch' has a wrong offset!");

// Class SHProto.SHFriendAnimInstance
// 0x0000 (0x03E0 - 0x03E0)
class USHFriendAnimInstance final : public USHNPCAnimInstance
{
public:
	class USHFriendAnimInstanceStateData* GetFriendAnimInstanceStateData() const;
	class USHFriendLocomotionAnimInstance* GetFriendLocomotionAnimInstance(int32 SlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFriendAnimInstance">();
	}
	static class USHFriendAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFriendAnimInstance>();
	}
};
static_assert(alignof(USHFriendAnimInstance) == 0x000010, "Wrong alignment on USHFriendAnimInstance");
static_assert(sizeof(USHFriendAnimInstance) == 0x0003E0, "Wrong size on USHFriendAnimInstance");

// Class SHProto.SHChAudioHealthSubcomponent
// 0x0030 (0x0068 - 0x0038)
class USHChAudioHealthSubcomponent final : public USHCharacterAudioSubcomponentBase
{
public:
	class USHAudioHealthSettings*                 Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReleaseDeathHealthState();
	void RequestDeathHealthState(class UObject* Requester);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHChAudioHealthSubcomponent">();
	}
	static class USHChAudioHealthSubcomponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHChAudioHealthSubcomponent>();
	}
};
static_assert(alignof(USHChAudioHealthSubcomponent) == 0x000008, "Wrong alignment on USHChAudioHealthSubcomponent");
static_assert(sizeof(USHChAudioHealthSubcomponent) == 0x000068, "Wrong size on USHChAudioHealthSubcomponent");
static_assert(offsetof(USHChAudioHealthSubcomponent, Settings) == 0x000038, "Member 'USHChAudioHealthSubcomponent::Settings' has a wrong offset!");

// Class SHProto.SHFlashlightMainLightOffsetBlender
// 0x0018 (0x0090 - 0x0078)
class USHFlashlightMainLightOffsetBlender final : public USHBlenderBase
{
public:
	uint8                                         Pad_78[0x18];                                      // 0x0078(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetAssignedValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFlashlightMainLightOffsetBlender">();
	}
	static class USHFlashlightMainLightOffsetBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFlashlightMainLightOffsetBlender>();
	}
};
static_assert(alignof(USHFlashlightMainLightOffsetBlender) == 0x000008, "Wrong alignment on USHFlashlightMainLightOffsetBlender");
static_assert(sizeof(USHFlashlightMainLightOffsetBlender) == 0x000090, "Wrong size on USHFlashlightMainLightOffsetBlender");

// Class SHProto.SHChAudioInteractionSubcomponent
// 0x0008 (0x0040 - 0x0038)
class USHChAudioInteractionSubcomponent final : public USHCharacterAudioSubcomponentBase
{
public:
	class USHAudioInteractionSettings*            Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHChAudioInteractionSubcomponent">();
	}
	static class USHChAudioInteractionSubcomponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHChAudioInteractionSubcomponent>();
	}
};
static_assert(alignof(USHChAudioInteractionSubcomponent) == 0x000008, "Wrong alignment on USHChAudioInteractionSubcomponent");
static_assert(sizeof(USHChAudioInteractionSubcomponent) == 0x000040, "Wrong size on USHChAudioInteractionSubcomponent");
static_assert(offsetof(USHChAudioInteractionSubcomponent, Settings) == 0x000038, "Member 'USHChAudioInteractionSubcomponent::Settings' has a wrong offset!");

// Class SHProto.SHFXPukePuddleDamageSubcomp
// 0x0040 (0x0078 - 0x0038)
class USHFXPukePuddleDamageSubcomp final : public USHFXSubcomponent
{
public:
	class USHFXPukePuddleDamageSubcompSettings*   Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ASHPukePuddleBase*>              _PukePuddles;                                      // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessFootstep(EFoot Foot, class ABeingFootstep* Footstep);
	void SetPuddleDamageBlocked(const bool IsBlock, const class UObject* Object);

	int32 GetPukeActivePuddlesCount() const;
	int32 GetPukePuddlesCount() const;
	bool IsPuddleDamageBlocked() const;
	bool IsPuddleDamageBlockedBy(const class UObject* Object) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXPukePuddleDamageSubcomp">();
	}
	static class USHFXPukePuddleDamageSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXPukePuddleDamageSubcomp>();
	}
};
static_assert(alignof(USHFXPukePuddleDamageSubcomp) == 0x000008, "Wrong alignment on USHFXPukePuddleDamageSubcomp");
static_assert(sizeof(USHFXPukePuddleDamageSubcomp) == 0x000078, "Wrong size on USHFXPukePuddleDamageSubcomp");
static_assert(offsetof(USHFXPukePuddleDamageSubcomp, Settings) == 0x000038, "Member 'USHFXPukePuddleDamageSubcomp::Settings' has a wrong offset!");
static_assert(offsetof(USHFXPukePuddleDamageSubcomp, _PukePuddles) == 0x000040, "Member 'USHFXPukePuddleDamageSubcomp::_PukePuddles' has a wrong offset!");

// Class SHProto.SHChAudioSpaceSubcomponent
// 0x0010 (0x0048 - 0x0038)
class USHChAudioSpaceSubcomponent final : public USHCharacterAudioSubcomponentBase
{
public:
	class USHAudioSpaceSettings*                  Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESHAudioCubatureEnum                          CurrentAudioCubature;                              // 0x0040(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESHAudioWorldEnum                             CurrentAudioWorld;                                 // 0x0041(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHChAudioSpaceSubcomponent">();
	}
	static class USHChAudioSpaceSubcomponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHChAudioSpaceSubcomponent>();
	}
};
static_assert(alignof(USHChAudioSpaceSubcomponent) == 0x000008, "Wrong alignment on USHChAudioSpaceSubcomponent");
static_assert(sizeof(USHChAudioSpaceSubcomponent) == 0x000048, "Wrong size on USHChAudioSpaceSubcomponent");
static_assert(offsetof(USHChAudioSpaceSubcomponent, Settings) == 0x000038, "Member 'USHChAudioSpaceSubcomponent::Settings' has a wrong offset!");
static_assert(offsetof(USHChAudioSpaceSubcomponent, CurrentAudioCubature) == 0x000040, "Member 'USHChAudioSpaceSubcomponent::CurrentAudioCubature' has a wrong offset!");
static_assert(offsetof(USHChAudioSpaceSubcomponent, CurrentAudioWorld) == 0x000041, "Member 'USHChAudioSpaceSubcomponent::CurrentAudioWorld' has a wrong offset!");

// Class SHProto.SHAudioStatesComponentSettings
// 0x0050 (0x0080 - 0x0030)
class USHAudioStatesComponentSettings final : public UDataAsset
{
public:
	float                                         CombatStateCooldownTime;                           // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DangerStateCooldownTime;                           // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          AudioState_Calm;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          AudioState_Danger;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          AudioState_Combat;                                 // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          AudioState_In_Bossfight;                           // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          AudioState_Out_Bossfight;                          // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_StopFleshLipEnviroEffect;               // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_StopFleshLipMusicEffect;                // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          AudioState_In_Cutscene;                            // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          AudioState_Out_Cutscene;                           // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAudioStatesComponentSettings">();
	}
	static class USHAudioStatesComponentSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAudioStatesComponentSettings>();
	}
};
static_assert(alignof(USHAudioStatesComponentSettings) == 0x000008, "Wrong alignment on USHAudioStatesComponentSettings");
static_assert(sizeof(USHAudioStatesComponentSettings) == 0x000080, "Wrong size on USHAudioStatesComponentSettings");
static_assert(offsetof(USHAudioStatesComponentSettings, CombatStateCooldownTime) == 0x000030, "Member 'USHAudioStatesComponentSettings::CombatStateCooldownTime' has a wrong offset!");
static_assert(offsetof(USHAudioStatesComponentSettings, DangerStateCooldownTime) == 0x000034, "Member 'USHAudioStatesComponentSettings::DangerStateCooldownTime' has a wrong offset!");
static_assert(offsetof(USHAudioStatesComponentSettings, AudioState_Calm) == 0x000038, "Member 'USHAudioStatesComponentSettings::AudioState_Calm' has a wrong offset!");
static_assert(offsetof(USHAudioStatesComponentSettings, AudioState_Danger) == 0x000040, "Member 'USHAudioStatesComponentSettings::AudioState_Danger' has a wrong offset!");
static_assert(offsetof(USHAudioStatesComponentSettings, AudioState_Combat) == 0x000048, "Member 'USHAudioStatesComponentSettings::AudioState_Combat' has a wrong offset!");
static_assert(offsetof(USHAudioStatesComponentSettings, AudioState_In_Bossfight) == 0x000050, "Member 'USHAudioStatesComponentSettings::AudioState_In_Bossfight' has a wrong offset!");
static_assert(offsetof(USHAudioStatesComponentSettings, AudioState_Out_Bossfight) == 0x000058, "Member 'USHAudioStatesComponentSettings::AudioState_Out_Bossfight' has a wrong offset!");
static_assert(offsetof(USHAudioStatesComponentSettings, AudioEvent_StopFleshLipEnviroEffect) == 0x000060, "Member 'USHAudioStatesComponentSettings::AudioEvent_StopFleshLipEnviroEffect' has a wrong offset!");
static_assert(offsetof(USHAudioStatesComponentSettings, AudioEvent_StopFleshLipMusicEffect) == 0x000068, "Member 'USHAudioStatesComponentSettings::AudioEvent_StopFleshLipMusicEffect' has a wrong offset!");
static_assert(offsetof(USHAudioStatesComponentSettings, AudioState_In_Cutscene) == 0x000070, "Member 'USHAudioStatesComponentSettings::AudioState_In_Cutscene' has a wrong offset!");
static_assert(offsetof(USHAudioStatesComponentSettings, AudioState_Out_Cutscene) == 0x000078, "Member 'USHAudioStatesComponentSettings::AudioState_Out_Cutscene' has a wrong offset!");

// Class SHProto.SHChAudioStatesSubcomponent
// 0x00A0 (0x00D8 - 0x0038)
class USHChAudioStatesSubcomponent final : public USHCharacterAudioSubcomponentBase
{
public:
	class USHAudioStatesComponentSettings*        Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x98];                                      // 0x0040(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestBossFightState(bool bInState, const class UObject* Requester);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHChAudioStatesSubcomponent">();
	}
	static class USHChAudioStatesSubcomponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHChAudioStatesSubcomponent>();
	}
};
static_assert(alignof(USHChAudioStatesSubcomponent) == 0x000008, "Wrong alignment on USHChAudioStatesSubcomponent");
static_assert(sizeof(USHChAudioStatesSubcomponent) == 0x0000D8, "Wrong size on USHChAudioStatesSubcomponent");
static_assert(offsetof(USHChAudioStatesSubcomponent, Settings) == 0x000038, "Member 'USHChAudioStatesSubcomponent::Settings' has a wrong offset!");

// Class SHProto.SHFleshLipLocomotionAnimInstance
// 0x00B0 (0x0460 - 0x03B0)
#pragma pack(push, 0x1)
class alignas(0x10) USHFleshLipLocomotionAnimInstance : public USHMonsterLocomotionAnimInstance
{
public:
	float                                         RotationToStrafingRatio;                           // 0x03A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementStopDelay;                                 // 0x03AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DesiredVelocityIncrementHalfTime;                  // 0x03B0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DesiredVelocityDecrementHalfTime;                  // 0x03C8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetDesiredVelocity;                             // 0x03E0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DesiredYawAdjustmentHalfTime;                      // 0x03F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetDesiredRotationYaw;                          // 0x03FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtAlphaIncrementHalfTime;                      // 0x0400(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtAlphaDecrementHalfTime;                      // 0x0404(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0x50];                                     // 0x0408(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USHFleshLipAnimInstanceStateData* GetFleshLipAnimInstanceStateData() const;
	bool GetFleshLipLeftArmIsReleased() const;
	bool GetFleshLipLegsAreReleased() const;
	bool GetFleshLipRightArmIsReleased() const;
	void GetSmoothedDesiredRotationYaw(float* OutYaw) const;
	void GetSmoothedDesiredVelocity(struct FVector* OutVelocity) const;
	void GetSmoothedDesiredVelocitySizeAndYaw(float* OutVelocitySize, float* OutVelocityYaw) const;
	void GetSmoothedLookAt(struct FRotator* OutRotation, float* OutAlpha) const;
	void GetTargetDesiredRotationYaw(float* OutYaw) const;
	void GetTargetDesiredVelocity(struct FVector* OutVelocity) const;
	void GetTargetDesiredVelocitySizeAndYaw(float* OutVelocitySize, float* OutVelocityYaw) const;
	void GetTargetLookAtAlpha(float* OutAlpha) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFleshLipLocomotionAnimInstance">();
	}
	static class USHFleshLipLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFleshLipLocomotionAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(USHFleshLipLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHFleshLipLocomotionAnimInstance");
static_assert(sizeof(USHFleshLipLocomotionAnimInstance) == 0x000460, "Wrong size on USHFleshLipLocomotionAnimInstance");
static_assert(offsetof(USHFleshLipLocomotionAnimInstance, RotationToStrafingRatio) == 0x0003A8, "Member 'USHFleshLipLocomotionAnimInstance::RotationToStrafingRatio' has a wrong offset!");
static_assert(offsetof(USHFleshLipLocomotionAnimInstance, MovementStopDelay) == 0x0003AC, "Member 'USHFleshLipLocomotionAnimInstance::MovementStopDelay' has a wrong offset!");
static_assert(offsetof(USHFleshLipLocomotionAnimInstance, DesiredVelocityIncrementHalfTime) == 0x0003B0, "Member 'USHFleshLipLocomotionAnimInstance::DesiredVelocityIncrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHFleshLipLocomotionAnimInstance, DesiredVelocityDecrementHalfTime) == 0x0003C8, "Member 'USHFleshLipLocomotionAnimInstance::DesiredVelocityDecrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHFleshLipLocomotionAnimInstance, TargetDesiredVelocity) == 0x0003E0, "Member 'USHFleshLipLocomotionAnimInstance::TargetDesiredVelocity' has a wrong offset!");
static_assert(offsetof(USHFleshLipLocomotionAnimInstance, DesiredYawAdjustmentHalfTime) == 0x0003F8, "Member 'USHFleshLipLocomotionAnimInstance::DesiredYawAdjustmentHalfTime' has a wrong offset!");
static_assert(offsetof(USHFleshLipLocomotionAnimInstance, TargetDesiredRotationYaw) == 0x0003FC, "Member 'USHFleshLipLocomotionAnimInstance::TargetDesiredRotationYaw' has a wrong offset!");
static_assert(offsetof(USHFleshLipLocomotionAnimInstance, LookAtAlphaIncrementHalfTime) == 0x000400, "Member 'USHFleshLipLocomotionAnimInstance::LookAtAlphaIncrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHFleshLipLocomotionAnimInstance, LookAtAlphaDecrementHalfTime) == 0x000404, "Member 'USHFleshLipLocomotionAnimInstance::LookAtAlphaDecrementHalfTime' has a wrong offset!");

// Class SHProto.SHCheatManagerPlay
// 0x0000 (0x0088 - 0x0088)
class USHCheatManagerPlay final : public USHCheatManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCheatManagerPlay">();
	}
	static class USHCheatManagerPlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCheatManagerPlay>();
	}
};
static_assert(alignof(USHCheatManagerPlay) == 0x000008, "Wrong alignment on USHCheatManagerPlay");
static_assert(sizeof(USHCheatManagerPlay) == 0x000088, "Wrong size on USHCheatManagerPlay");

// Class SHProto.SHCineCameraAnimationSequence
// 0x0000 (0x0120 - 0x0120)
class USHCineCameraAnimationSequence final : public UCameraAnimationSequence
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCineCameraAnimationSequence">();
	}
	static class USHCineCameraAnimationSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCineCameraAnimationSequence>();
	}
};
static_assert(alignof(USHCineCameraAnimationSequence) == 0x000008, "Wrong alignment on USHCineCameraAnimationSequence");
static_assert(sizeof(USHCineCameraAnimationSequence) == 0x000120, "Wrong size on USHCineCameraAnimationSequence");

// Class SHProto.SHGameplayRangedWeaponDetailsWidget
// 0x0098 (0x0310 - 0x0278)
class USHGameplayRangedWeaponDetailsWidget final : public UUserWidget
{
public:
	class UCanvasPanel*                           MainContainer;                                     // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         NotificationTextHorizontalBox;                     // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NotificationText_CurrentAmmo;                      // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NotificationText_InventoryAmmo;                    // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NotificationText_Separator;                        // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ShowAnim;                                          // 0x02A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       HideAnim;                                          // 0x02A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       NoCurrrentAmmoAnim;                                // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       NoAnyAmmoAnim;                                     // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NotificationTime;                                  // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           OriginalNotificationTextColorAndOpacity;           // 0x02C4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASHCharacterPlay*                       OwnerCharacterPlay;                                // 0x02D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x30];                                     // 0x02E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessEquippedWeaponModifiedEvent(class USHWeaponManageCmbSubcomp* WeaponManagement);
	void ProcessRangedAimStateChangedEvent(class USHRangedCmbSubcomp* RangedManagement);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayRangedWeaponDetailsWidget">();
	}
	static class USHGameplayRangedWeaponDetailsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayRangedWeaponDetailsWidget>();
	}
};
static_assert(alignof(USHGameplayRangedWeaponDetailsWidget) == 0x000008, "Wrong alignment on USHGameplayRangedWeaponDetailsWidget");
static_assert(sizeof(USHGameplayRangedWeaponDetailsWidget) == 0x000310, "Wrong size on USHGameplayRangedWeaponDetailsWidget");
static_assert(offsetof(USHGameplayRangedWeaponDetailsWidget, MainContainer) == 0x000278, "Member 'USHGameplayRangedWeaponDetailsWidget::MainContainer' has a wrong offset!");
static_assert(offsetof(USHGameplayRangedWeaponDetailsWidget, NotificationTextHorizontalBox) == 0x000280, "Member 'USHGameplayRangedWeaponDetailsWidget::NotificationTextHorizontalBox' has a wrong offset!");
static_assert(offsetof(USHGameplayRangedWeaponDetailsWidget, NotificationText_CurrentAmmo) == 0x000288, "Member 'USHGameplayRangedWeaponDetailsWidget::NotificationText_CurrentAmmo' has a wrong offset!");
static_assert(offsetof(USHGameplayRangedWeaponDetailsWidget, NotificationText_InventoryAmmo) == 0x000290, "Member 'USHGameplayRangedWeaponDetailsWidget::NotificationText_InventoryAmmo' has a wrong offset!");
static_assert(offsetof(USHGameplayRangedWeaponDetailsWidget, NotificationText_Separator) == 0x000298, "Member 'USHGameplayRangedWeaponDetailsWidget::NotificationText_Separator' has a wrong offset!");
static_assert(offsetof(USHGameplayRangedWeaponDetailsWidget, ShowAnim) == 0x0002A0, "Member 'USHGameplayRangedWeaponDetailsWidget::ShowAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayRangedWeaponDetailsWidget, HideAnim) == 0x0002A8, "Member 'USHGameplayRangedWeaponDetailsWidget::HideAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayRangedWeaponDetailsWidget, NoCurrrentAmmoAnim) == 0x0002B0, "Member 'USHGameplayRangedWeaponDetailsWidget::NoCurrrentAmmoAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayRangedWeaponDetailsWidget, NoAnyAmmoAnim) == 0x0002B8, "Member 'USHGameplayRangedWeaponDetailsWidget::NoAnyAmmoAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayRangedWeaponDetailsWidget, NotificationTime) == 0x0002C0, "Member 'USHGameplayRangedWeaponDetailsWidget::NotificationTime' has a wrong offset!");
static_assert(offsetof(USHGameplayRangedWeaponDetailsWidget, OriginalNotificationTextColorAndOpacity) == 0x0002C4, "Member 'USHGameplayRangedWeaponDetailsWidget::OriginalNotificationTextColorAndOpacity' has a wrong offset!");
static_assert(offsetof(USHGameplayRangedWeaponDetailsWidget, OwnerCharacterPlay) == 0x0002D8, "Member 'USHGameplayRangedWeaponDetailsWidget::OwnerCharacterPlay' has a wrong offset!");

// Class SHProto.SHCineCameraComponent
// 0x0030 (0x0BA0 - 0x0B70)
class USHCineCameraComponent final : public UCineCameraComponent
{
public:
	bool                                          RespectFilmbackAspectRatio;                        // 0x0B68(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WideScreenAdjustFOV;                               // 0x0B69(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B6A[0x2];                                      // 0x0B6A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DepthOfFieldAnamorphism;                           // 0x0B6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomShape;                                        // 0x0B70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomStretch;                                      // 0x0B74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LensDIntensity;                                    // 0x0B78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LensDIntensityX;                                   // 0x0B7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LensDIntensityY;                                   // 0x0B80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LensDCenterX;                                      // 0x0B84(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LensDCenterY;                                      // 0x0B88(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LensDScale;                                        // 0x0B8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B90[0x10];                                     // 0x0B90(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TrackCharacterBone(class ACharacter* InCharacter, class FName InCharacterBoneName);
	void TrackComponent(class USceneComponent* InComponent);
	void TrackSkeletalMeshBone(class USkeletalMeshComponent* InComponent, class FName InBoneName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCineCameraComponent">();
	}
	static class USHCineCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCineCameraComponent>();
	}
};
static_assert(alignof(USHCineCameraComponent) == 0x000010, "Wrong alignment on USHCineCameraComponent");
static_assert(sizeof(USHCineCameraComponent) == 0x000BA0, "Wrong size on USHCineCameraComponent");
static_assert(offsetof(USHCineCameraComponent, RespectFilmbackAspectRatio) == 0x000B68, "Member 'USHCineCameraComponent::RespectFilmbackAspectRatio' has a wrong offset!");
static_assert(offsetof(USHCineCameraComponent, WideScreenAdjustFOV) == 0x000B69, "Member 'USHCineCameraComponent::WideScreenAdjustFOV' has a wrong offset!");
static_assert(offsetof(USHCineCameraComponent, DepthOfFieldAnamorphism) == 0x000B6C, "Member 'USHCineCameraComponent::DepthOfFieldAnamorphism' has a wrong offset!");
static_assert(offsetof(USHCineCameraComponent, BloomShape) == 0x000B70, "Member 'USHCineCameraComponent::BloomShape' has a wrong offset!");
static_assert(offsetof(USHCineCameraComponent, BloomStretch) == 0x000B74, "Member 'USHCineCameraComponent::BloomStretch' has a wrong offset!");
static_assert(offsetof(USHCineCameraComponent, LensDIntensity) == 0x000B78, "Member 'USHCineCameraComponent::LensDIntensity' has a wrong offset!");
static_assert(offsetof(USHCineCameraComponent, LensDIntensityX) == 0x000B7C, "Member 'USHCineCameraComponent::LensDIntensityX' has a wrong offset!");
static_assert(offsetof(USHCineCameraComponent, LensDIntensityY) == 0x000B80, "Member 'USHCineCameraComponent::LensDIntensityY' has a wrong offset!");
static_assert(offsetof(USHCineCameraComponent, LensDCenterX) == 0x000B84, "Member 'USHCineCameraComponent::LensDCenterX' has a wrong offset!");
static_assert(offsetof(USHCineCameraComponent, LensDCenterY) == 0x000B88, "Member 'USHCineCameraComponent::LensDCenterY' has a wrong offset!");
static_assert(offsetof(USHCineCameraComponent, LensDScale) == 0x000B8C, "Member 'USHCineCameraComponent::LensDScale' has a wrong offset!");

// Class SHProto.SHCharacterPlayAttackCameraDataAsset
// 0x0200 (0x0230 - 0x0030)
class USHCharacterPlayAttackCameraDataAsset final : public UDataAsset
{
public:
	bool                                          bSecureCameraView;                                 // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecureViewDuration;                                // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSHViewLookOperationSettings           SecureViewSettings;                                // 0x0038(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverrrideCameraFOV;                               // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHCameraFOVBlendData                  CameraFOVOverrride;                                // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FSHCameraMAARLBlendData                CameraMAARL;                                       // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FSHCameraMAACRBlendData                CameraMAACR;                                       // 0x00C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverrrideCameraProfile;                           // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHCameraDataFull                      CameraProfileOverrride;                            // 0x00F8(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseCameraAnimation;                               // 0x01A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHCameraAnimationData                 CameraAnimationData;                               // 0x01B0(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayAttackCameraDataAsset">();
	}
	static class USHCharacterPlayAttackCameraDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayAttackCameraDataAsset>();
	}
};
static_assert(alignof(USHCharacterPlayAttackCameraDataAsset) == 0x000008, "Wrong alignment on USHCharacterPlayAttackCameraDataAsset");
static_assert(sizeof(USHCharacterPlayAttackCameraDataAsset) == 0x000230, "Wrong size on USHCharacterPlayAttackCameraDataAsset");
static_assert(offsetof(USHCharacterPlayAttackCameraDataAsset, bSecureCameraView) == 0x000030, "Member 'USHCharacterPlayAttackCameraDataAsset::bSecureCameraView' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayAttackCameraDataAsset, SecureViewDuration) == 0x000034, "Member 'USHCharacterPlayAttackCameraDataAsset::SecureViewDuration' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayAttackCameraDataAsset, SecureViewSettings) == 0x000038, "Member 'USHCharacterPlayAttackCameraDataAsset::SecureViewSettings' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayAttackCameraDataAsset, bOverrrideCameraFOV) == 0x000070, "Member 'USHCharacterPlayAttackCameraDataAsset::bOverrrideCameraFOV' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayAttackCameraDataAsset, CameraFOVOverrride) == 0x000078, "Member 'USHCharacterPlayAttackCameraDataAsset::CameraFOVOverrride' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayAttackCameraDataAsset, CameraMAARL) == 0x0000A0, "Member 'USHCharacterPlayAttackCameraDataAsset::CameraMAARL' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayAttackCameraDataAsset, CameraMAACR) == 0x0000C8, "Member 'USHCharacterPlayAttackCameraDataAsset::CameraMAACR' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayAttackCameraDataAsset, bOverrrideCameraProfile) == 0x0000F0, "Member 'USHCharacterPlayAttackCameraDataAsset::bOverrrideCameraProfile' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayAttackCameraDataAsset, CameraProfileOverrride) == 0x0000F8, "Member 'USHCharacterPlayAttackCameraDataAsset::CameraProfileOverrride' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayAttackCameraDataAsset, bUseCameraAnimation) == 0x0001A8, "Member 'USHCharacterPlayAttackCameraDataAsset::bUseCameraAnimation' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayAttackCameraDataAsset, CameraAnimationData) == 0x0001B0, "Member 'USHCharacterPlayAttackCameraDataAsset::CameraAnimationData' has a wrong offset!");

// Class SHProto.SHMeleeAttackSecondaryTargetInterface
// 0x0000 (0x0028 - 0x0028)
class ISHMeleeAttackSecondaryTargetInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMeleeAttackSecondaryTargetInterface">();
	}
	static class ISHMeleeAttackSecondaryTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHMeleeAttackSecondaryTargetInterface>();
	}
};
static_assert(alignof(ISHMeleeAttackSecondaryTargetInterface) == 0x000008, "Wrong alignment on ISHMeleeAttackSecondaryTargetInterface");
static_assert(sizeof(ISHMeleeAttackSecondaryTargetInterface) == 0x000028, "Wrong size on ISHMeleeAttackSecondaryTargetInterface");

// Class SHProto.SHFleshLipCeilingActor
// 0x0360 (0x0610 - 0x02B0)
class ASHFleshLipCeilingActor final : public AActor
{
public:
	class USceneComponent*                        TilesRoot;                                         // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        TileParticlesRoot;                                 // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInstancedStaticMeshComponent*          CeilingBarsHorizontalISMC;                         // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInstancedStaticMeshComponent*          CeilingBarsVerticalISMC;                           // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInstancedStaticMeshComponent*          CeilingTilesISMC;                                  // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CeilingTilesX;                                     // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CeilingTilesY;                                     // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CeilingTilesWidth;                                 // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CeilingTilesHeight;                                // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CeilingTilesTransform;                             // 0x02F0(0x0060)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             CeilingTilesHiddenTransform;                       // 0x0350(0x0060)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ASHFleshLipCeilingTileActor> CeilingTileActorClass;                             // 0x03B0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSHFleshLipCeilingCustomTileConfiguration> CustomTiles;                                       // 0x03B8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FSHFleshLipCeilingActorHangingTileDropChancesPerType DamagedTileDropChances;                            // 0x03C8(0x0030)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSHFleshLipCeilingActorHangingTileDropChancesPerType HangingTileDropChances;                            // 0x03F8(0x0030)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FMinMaxVector2D                        HangingTileDropDelay;                              // 0x0428(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         HangingTileDropVelocity;                           // 0x0430(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMinMaxVector2D                        HangingTileDropRotation;                           // 0x0434(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHFleshLipCeilingTileShakePhysicsConfiguration TileShakePhysicsConfiguration;                     // 0x0440(0x00A0)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         GridBarSeparationX;                                // 0x04E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GridBarSeparationY;                                // 0x04E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E8[0x8];                                      // 0x04E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CeilingHorizontalBarsTransform;                    // 0x04F0(0x0060)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             CeilingVerticalBarsTransform;                      // 0x0550(0x0060)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceActorTickingEnabled;                         // 0x05B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B1[0x7];                                      // 0x05B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHFleshLipCeilingTile>         CeilingTiles;                                      // 0x05B8(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class ASHFleshLipCeilingTileActor*>    CeilingTileActors;                                 // 0x05C8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         IgnoreCollisionWithActors;                         // 0x05D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E8[0x28];                                     // 0x05E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyTilesPressure(const struct FVector& InWorldLocation, float InPushDepth, float InRadius, bool InLimitedByBars, bool InIfTileExistsAtLocation, float InParticlesSpawnAlphaThreshold);
	void BreakCeilingTilesAtWorldLocation(const struct FVector& InWorldLocation, float InRadius, bool InLimitedByBars, float InVerticalVelocity, float InHorizontalVelocity, float InMaximumRotation, const struct FSimpleBentCurve& InForceDistribution);
	void DamageCeilingTile(int32 InTileX, int32 InTileY, const struct FVector& InHitLocation, const struct FVector& InHitVelocity, float InMaximumDropRotation);
	void DestroyCeilingTile(int32 InTileX, int32 InTileY, bool InDropHangingNeighbours);
	void DestroyCeilingTilesAtWorldLocation(const struct FVector& InWorldLocation, float InRadius, bool InLimitedByBars, bool InDropHangingNeighbours);
	void DropCeilingTile(int32 InTileX, int32 InTileY, float InDropDelay, bool InOverrideExistingDelay, const struct FVector& InDropVelocity, const struct FVector& InDropRotation);
	class ASHFleshLipCeilingTileActor* GetCeilingTileActorAtCoordinates(int32 InTileX, int32 InTileY, bool InConvertFromInstance);
	class ASHFleshLipCeilingTileActor* GetCeilingTileActorAtWorldLocation(const struct FVector& InWorldLocation, bool InConvertFromInstance);
	void GetCeilingTileActorsBetweenCoordinates(TArray<class ASHFleshLipCeilingTileActor*>* OutTileActors, int32 InFromTileX, int32 InFromTileY, int32 InToTileX, int32 InToTileY, bool InConvertFromInstances);
	void GetCeilingTileActorsBetweenWorldLocations(TArray<class ASHFleshLipCeilingTileActor*>* OutTileActors, const struct FVector& InFromWorldLocation, const struct FVector& InToWorldLocation, bool InConvertFromInstances);
	void InitializeCeiling();
	void OnTileParticlesSystemFinished(class UNiagaraComponent* InParticlesComponent);
	void SetIgnoreCollisionWithActor(class AActor* InActor, bool InIgnoreCollision);
	bool SetTileTransformRelativeToCell(const struct FVector2D& InTileCoordinates, const struct FTransform& InTransformInCell, bool InAllowForDisconnectedTile);
	bool SetTileWorldTransform(const struct FVector2D& InTileCoordinates, const struct FTransform& InWorldTransform, bool InAllowForDisconnectedTile);
	void SpawnParticlesAtTiles(class UNiagaraSystem* InParticles, const struct FTransform& InParticlesOffset, const struct FVector& InWorldLocation, float InRadius, bool InLimitedByBars, bool InIfTileExistsAtLocation, float InParticlesSpawnAlphaThreshold, class FName InParticleDistanceAlphaParameterName);

	bool AreTileCoordinatesValid(int32 InTileX, int32 InTileY) const;
	bool DoesCeilingTileAtCoordinatesExist(int32 InTileX, int32 InTileY, bool InAllowDisconnected) const;
	bool DoesCeilingTileAtWorldLocationExist(const struct FVector& InWorldLocation, bool InAllowDisconnected) const;
	void GetBarsFrameTileCoordinatesAroundTile(float* OutFrameMinX, float* OutFrameMinY, float* OutFrameMaxX, float* OutFrameMaxY, const struct FVector2D& InTileCoordinates, bool InInnerMax) const;
	void GetCeilingSize(struct FVector2D* OutSize) const;
	void GetNearestBarsGrabWorldTransform(struct FTransform* OutWorldTransform, const struct FVector& InNearLocation, float InJunctionDistance, bool InExcludeEdges) const;
	void GetNearestFreeWorldLocationBetweenBars(struct FVector* OutWorldLocation, const struct FVector& InNearLocation, float InBarsDistance) const;
	void GetTileCoordinatesFromGridLocation(struct FVector2D* OutTileCoordinates, const struct FVector& InGridLocation) const;
	void GetTileCoordinatesFromWorldLocation(struct FVector2D* OutTileCoordinates, const struct FVector& InWorldLocation) const;
	struct FVector GetTileGridCellLocation(const struct FVector2D& InTileCoordinates) const;
	struct FTransform GetTileGridCellTransform(const struct FVector2D& InTileCoordinates) const;
	struct FVector GetTileGridCellWorldLocation(const struct FVector2D& InTileCoordinates) const;
	struct FTransform GetTileGridCellWorldTransform(const struct FVector2D& InTileCoordinates) const;
	bool GetTileTransformRelativeToCell(const struct FVector2D& InTileCoordinates, struct FTransform* OutRelativeTransform) const;
	bool GetTileWorldTransform(const struct FVector2D& InTileCoordinates, struct FTransform* OutWorldTransform) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFleshLipCeilingActor">();
	}
	static class ASHFleshLipCeilingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHFleshLipCeilingActor>();
	}
};
static_assert(alignof(ASHFleshLipCeilingActor) == 0x000010, "Wrong alignment on ASHFleshLipCeilingActor");
static_assert(sizeof(ASHFleshLipCeilingActor) == 0x000610, "Wrong size on ASHFleshLipCeilingActor");
static_assert(offsetof(ASHFleshLipCeilingActor, TilesRoot) == 0x0002B0, "Member 'ASHFleshLipCeilingActor::TilesRoot' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, TileParticlesRoot) == 0x0002B8, "Member 'ASHFleshLipCeilingActor::TileParticlesRoot' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, CeilingBarsHorizontalISMC) == 0x0002C0, "Member 'ASHFleshLipCeilingActor::CeilingBarsHorizontalISMC' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, CeilingBarsVerticalISMC) == 0x0002C8, "Member 'ASHFleshLipCeilingActor::CeilingBarsVerticalISMC' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, CeilingTilesISMC) == 0x0002D0, "Member 'ASHFleshLipCeilingActor::CeilingTilesISMC' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, CeilingTilesX) == 0x0002D8, "Member 'ASHFleshLipCeilingActor::CeilingTilesX' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, CeilingTilesY) == 0x0002DC, "Member 'ASHFleshLipCeilingActor::CeilingTilesY' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, CeilingTilesWidth) == 0x0002E0, "Member 'ASHFleshLipCeilingActor::CeilingTilesWidth' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, CeilingTilesHeight) == 0x0002E4, "Member 'ASHFleshLipCeilingActor::CeilingTilesHeight' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, CeilingTilesTransform) == 0x0002F0, "Member 'ASHFleshLipCeilingActor::CeilingTilesTransform' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, CeilingTilesHiddenTransform) == 0x000350, "Member 'ASHFleshLipCeilingActor::CeilingTilesHiddenTransform' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, CeilingTileActorClass) == 0x0003B0, "Member 'ASHFleshLipCeilingActor::CeilingTileActorClass' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, CustomTiles) == 0x0003B8, "Member 'ASHFleshLipCeilingActor::CustomTiles' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, DamagedTileDropChances) == 0x0003C8, "Member 'ASHFleshLipCeilingActor::DamagedTileDropChances' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, HangingTileDropChances) == 0x0003F8, "Member 'ASHFleshLipCeilingActor::HangingTileDropChances' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, HangingTileDropDelay) == 0x000428, "Member 'ASHFleshLipCeilingActor::HangingTileDropDelay' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, HangingTileDropVelocity) == 0x000430, "Member 'ASHFleshLipCeilingActor::HangingTileDropVelocity' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, HangingTileDropRotation) == 0x000434, "Member 'ASHFleshLipCeilingActor::HangingTileDropRotation' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, TileShakePhysicsConfiguration) == 0x000440, "Member 'ASHFleshLipCeilingActor::TileShakePhysicsConfiguration' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, GridBarSeparationX) == 0x0004E0, "Member 'ASHFleshLipCeilingActor::GridBarSeparationX' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, GridBarSeparationY) == 0x0004E4, "Member 'ASHFleshLipCeilingActor::GridBarSeparationY' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, CeilingHorizontalBarsTransform) == 0x0004F0, "Member 'ASHFleshLipCeilingActor::CeilingHorizontalBarsTransform' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, CeilingVerticalBarsTransform) == 0x000550, "Member 'ASHFleshLipCeilingActor::CeilingVerticalBarsTransform' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, bForceActorTickingEnabled) == 0x0005B0, "Member 'ASHFleshLipCeilingActor::bForceActorTickingEnabled' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, CeilingTiles) == 0x0005B8, "Member 'ASHFleshLipCeilingActor::CeilingTiles' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, CeilingTileActors) == 0x0005C8, "Member 'ASHFleshLipCeilingActor::CeilingTileActors' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingActor, IgnoreCollisionWithActors) == 0x0005D8, "Member 'ASHFleshLipCeilingActor::IgnoreCollisionWithActors' has a wrong offset!");

// Class SHProto.SHFleshLipStandingLocomotionAnimInstance
// 0x0000 (0x0460 - 0x0460)
class USHFleshLipStandingLocomotionAnimInstance final : public USHFleshLipLocomotionAnimInstance
{
public:
	ESHFleshLipStandingAnimInstanceLocomotionState LocomotionState;                                   // 0x0458(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChargeMovementIsActive;                           // 0x0459(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45A[0x6];                                      // 0x045A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFleshLipStandingLocomotionAnimInstance">();
	}
	static class USHFleshLipStandingLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFleshLipStandingLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHFleshLipStandingLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHFleshLipStandingLocomotionAnimInstance");
static_assert(sizeof(USHFleshLipStandingLocomotionAnimInstance) == 0x000460, "Wrong size on USHFleshLipStandingLocomotionAnimInstance");
static_assert(offsetof(USHFleshLipStandingLocomotionAnimInstance, LocomotionState) == 0x000458, "Member 'USHFleshLipStandingLocomotionAnimInstance::LocomotionState' has a wrong offset!");
static_assert(offsetof(USHFleshLipStandingLocomotionAnimInstance, bChargeMovementIsActive) == 0x000459, "Member 'USHFleshLipStandingLocomotionAnimInstance::bChargeMovementIsActive' has a wrong offset!");

// Class SHProto.SHCombatPlayDeathInterface
// 0x0000 (0x0028 - 0x0028)
class ISHCombatPlayDeathInterface final : public IInterface
{
public:
	struct FSHDeathPlayerData GetDeathPlayerData(class ACharacter* Killed);
	struct FSHDeathPlayerData GetDeathPlayerDataForDebug(class ACharacter* Killed);
	bool PlayDeath(class ACharacter* Player, const struct FGameplayTag& PawnAnimTag, const struct FGameplayTag& PlayerAnimTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCombatPlayDeathInterface">();
	}
	static class ISHCombatPlayDeathInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHCombatPlayDeathInterface>();
	}
};
static_assert(alignof(ISHCombatPlayDeathInterface) == 0x000008, "Wrong alignment on ISHCombatPlayDeathInterface");
static_assert(sizeof(ISHCombatPlayDeathInterface) == 0x000028, "Wrong size on ISHCombatPlayDeathInterface");

// Class SHProto.SHCombatCustomGenericDeathSequenceProvider
// 0x0000 (0x0028 - 0x0028)
class ISHCombatCustomGenericDeathSequenceProvider final : public IInterface
{
public:
	TSoftClassPtr<class UClass> GetCustomGenericDeathSequenceSoftClass(ESHSimpleDirectionType InLastHitWorldDirType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCombatCustomGenericDeathSequenceProvider">();
	}
	static class ISHCombatCustomGenericDeathSequenceProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHCombatCustomGenericDeathSequenceProvider>();
	}
};
static_assert(alignof(ISHCombatCustomGenericDeathSequenceProvider) == 0x000008, "Wrong alignment on ISHCombatCustomGenericDeathSequenceProvider");
static_assert(sizeof(ISHCombatCustomGenericDeathSequenceProvider) == 0x000028, "Wrong size on ISHCombatCustomGenericDeathSequenceProvider");

// Class SHProto.SHCombatStatesInterface
// 0x0000 (0x0028 - 0x0028)
class ISHCombatStatesInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCombatStatesInterface">();
	}
	static class ISHCombatStatesInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHCombatStatesInterface>();
	}
};
static_assert(alignof(ISHCombatStatesInterface) == 0x000008, "Wrong alignment on ISHCombatStatesInterface");
static_assert(sizeof(ISHCombatStatesInterface) == 0x000028, "Wrong size on ISHCombatStatesInterface");

// Class SHProto.SHCombineItemsTutorialHandler
// 0x0008 (0x0040 - 0x0038)
class USHCombineItemsTutorialHandler final : public USHTutorialHandlerBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessItemCollected(class USHCharacterPlayItemsComponent* Component, class FName ItemContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCombineItemsTutorialHandler">();
	}
	static class USHCombineItemsTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCombineItemsTutorialHandler>();
	}
};
static_assert(alignof(USHCombineItemsTutorialHandler) == 0x000008, "Wrong alignment on USHCombineItemsTutorialHandler");
static_assert(sizeof(USHCombineItemsTutorialHandler) == 0x000040, "Wrong size on USHCombineItemsTutorialHandler");

// Class SHProto.SHCombineRecipeSlotWidget
// 0x0010 (0x0288 - 0x0278)
class USHCombineRecipeSlotWidget : public UUserWidget
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCombineRecipeSlotWidget">();
	}
	static class USHCombineRecipeSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCombineRecipeSlotWidget>();
	}
};
static_assert(alignof(USHCombineRecipeSlotWidget) == 0x000008, "Wrong alignment on USHCombineRecipeSlotWidget");
static_assert(sizeof(USHCombineRecipeSlotWidget) == 0x000288, "Wrong size on USHCombineRecipeSlotWidget");

// Class SHProto.SHCombineRecipeSlotItemImageWidget
// 0x0018 (0x02A0 - 0x0288)
class USHCombineRecipeSlotItemImageWidget final : public USHCombineRecipeSlotWidget
{
public:
	class UImage*                                 ItemImage;                                         // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       WrongItemAnim;                                     // 0x0290(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               DebugTexture;                                      // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCombineRecipeSlotItemImageWidget">();
	}
	static class USHCombineRecipeSlotItemImageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCombineRecipeSlotItemImageWidget>();
	}
};
static_assert(alignof(USHCombineRecipeSlotItemImageWidget) == 0x000008, "Wrong alignment on USHCombineRecipeSlotItemImageWidget");
static_assert(sizeof(USHCombineRecipeSlotItemImageWidget) == 0x0002A0, "Wrong size on USHCombineRecipeSlotItemImageWidget");
static_assert(offsetof(USHCombineRecipeSlotItemImageWidget, ItemImage) == 0x000288, "Member 'USHCombineRecipeSlotItemImageWidget::ItemImage' has a wrong offset!");
static_assert(offsetof(USHCombineRecipeSlotItemImageWidget, WrongItemAnim) == 0x000290, "Member 'USHCombineRecipeSlotItemImageWidget::WrongItemAnim' has a wrong offset!");
static_assert(offsetof(USHCombineRecipeSlotItemImageWidget, DebugTexture) == 0x000298, "Member 'USHCombineRecipeSlotItemImageWidget::DebugTexture' has a wrong offset!");

// Class SHProto.SHNiagaraVolume
// 0x0008 (0x02F0 - 0x02E8)
class ASHNiagaraVolume : public AVolume
{
public:
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsPointWithin(const struct FVector& Point) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHNiagaraVolume">();
	}
	static class ASHNiagaraVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHNiagaraVolume>();
	}
};
static_assert(alignof(ASHNiagaraVolume) == 0x000008, "Wrong alignment on ASHNiagaraVolume");
static_assert(sizeof(ASHNiagaraVolume) == 0x0002F0, "Wrong size on ASHNiagaraVolume");

// Class SHProto.SHControlsSettingsPanelWidget
// 0x0040 (0x03B0 - 0x0370)
class USHControlsSettingsPanelWidget final : public UControlsSettingsPanelWidget
{
public:
	struct FUE4InputHandle                        RangeAimAction;                                    // 0x0370(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUE4InputHandle                        FireAction;                                        // 0x037C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUE4InputHandle                        MeleeAttackAction;                                 // 0x0388(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUE4InputHandle                        BoatLeftAction;                                    // 0x0394(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUE4InputHandle                        BoatRightAction;                                   // 0x03A0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHControlsSettingsPanelWidget">();
	}
	static class USHControlsSettingsPanelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHControlsSettingsPanelWidget>();
	}
};
static_assert(alignof(USHControlsSettingsPanelWidget) == 0x000008, "Wrong alignment on USHControlsSettingsPanelWidget");
static_assert(sizeof(USHControlsSettingsPanelWidget) == 0x0003B0, "Wrong size on USHControlsSettingsPanelWidget");
static_assert(offsetof(USHControlsSettingsPanelWidget, RangeAimAction) == 0x000370, "Member 'USHControlsSettingsPanelWidget::RangeAimAction' has a wrong offset!");
static_assert(offsetof(USHControlsSettingsPanelWidget, FireAction) == 0x00037C, "Member 'USHControlsSettingsPanelWidget::FireAction' has a wrong offset!");
static_assert(offsetof(USHControlsSettingsPanelWidget, MeleeAttackAction) == 0x000388, "Member 'USHControlsSettingsPanelWidget::MeleeAttackAction' has a wrong offset!");
static_assert(offsetof(USHControlsSettingsPanelWidget, BoatLeftAction) == 0x000394, "Member 'USHControlsSettingsPanelWidget::BoatLeftAction' has a wrong offset!");
static_assert(offsetof(USHControlsSettingsPanelWidget, BoatRightAction) == 0x0003A0, "Member 'USHControlsSettingsPanelWidget::BoatRightAction' has a wrong offset!");

// Class SHProto.SHFXSkitteringBloodTraceSubcomp
// 0x0020 (0x0058 - 0x0038)
class USHFXSkitteringBloodTraceSubcomp final : public USHFXSubcomponent
{
public:
	class USHFXSkitteringBloodTraceSubcompSettings* Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      BloodTraceNS;                                      // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHEnemyLyingComponent*                 OwnerLyingComponent;                               // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaiHealth*                             OwnerHealthComponent;                              // 0x0050(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXSkitteringBloodTraceSubcomp">();
	}
	static class USHFXSkitteringBloodTraceSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXSkitteringBloodTraceSubcomp>();
	}
};
static_assert(alignof(USHFXSkitteringBloodTraceSubcomp) == 0x000008, "Wrong alignment on USHFXSkitteringBloodTraceSubcomp");
static_assert(sizeof(USHFXSkitteringBloodTraceSubcomp) == 0x000058, "Wrong size on USHFXSkitteringBloodTraceSubcomp");
static_assert(offsetof(USHFXSkitteringBloodTraceSubcomp, Settings) == 0x000038, "Member 'USHFXSkitteringBloodTraceSubcomp::Settings' has a wrong offset!");
static_assert(offsetof(USHFXSkitteringBloodTraceSubcomp, BloodTraceNS) == 0x000040, "Member 'USHFXSkitteringBloodTraceSubcomp::BloodTraceNS' has a wrong offset!");
static_assert(offsetof(USHFXSkitteringBloodTraceSubcomp, OwnerLyingComponent) == 0x000048, "Member 'USHFXSkitteringBloodTraceSubcomp::OwnerLyingComponent' has a wrong offset!");
static_assert(offsetof(USHFXSkitteringBloodTraceSubcomp, OwnerHealthComponent) == 0x000050, "Member 'USHFXSkitteringBloodTraceSubcomp::OwnerHealthComponent' has a wrong offset!");

// Class SHProto.SHCreeperAnimComponent
// 0x0000 (0x0490 - 0x0490)
class USHCreeperAnimComponent final : public USHEnemyAnimComponent
{
public:
	void SetAttackBlend(float Velocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCreeperAnimComponent">();
	}
	static class USHCreeperAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCreeperAnimComponent>();
	}
};
static_assert(alignof(USHCreeperAnimComponent) == 0x000008, "Wrong alignment on USHCreeperAnimComponent");
static_assert(sizeof(USHCreeperAnimComponent) == 0x000490, "Wrong size on USHCreeperAnimComponent");

// Class SHProto.SHCreeperAnimInstanceStateData
// 0x0000 (0x0078 - 0x0078)
class USHCreeperAnimInstanceStateData final : public USHMonsterAnimInstanceStateData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCreeperAnimInstanceStateData">();
	}
	static class USHCreeperAnimInstanceStateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCreeperAnimInstanceStateData>();
	}
};
static_assert(alignof(USHCreeperAnimInstanceStateData) == 0x000008, "Wrong alignment on USHCreeperAnimInstanceStateData");
static_assert(sizeof(USHCreeperAnimInstanceStateData) == 0x000078, "Wrong size on USHCreeperAnimInstanceStateData");

// Class SHProto.SHCrosshairContainerWidget
// 0x0058 (0x02D0 - 0x0278)
class USHCrosshairContainerWidget final : public UUserWidget
{
public:
	class UCanvasPanel*                           ContainerPanel;                                    // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USHCrosshairWidgetBase>     GameplayCenterDotClass;                            // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x0288(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCrosshairWidgetBase*                 CurrentCrosshairWidget;                            // 0x0290(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x38];                                     // 0x0298(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessEquippedWeaponModifiedEvent(class USHWeaponManageCmbSubcomp* WeaponManagement);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCrosshairContainerWidget">();
	}
	static class USHCrosshairContainerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCrosshairContainerWidget>();
	}
};
static_assert(alignof(USHCrosshairContainerWidget) == 0x000008, "Wrong alignment on USHCrosshairContainerWidget");
static_assert(sizeof(USHCrosshairContainerWidget) == 0x0002D0, "Wrong size on USHCrosshairContainerWidget");
static_assert(offsetof(USHCrosshairContainerWidget, ContainerPanel) == 0x000278, "Member 'USHCrosshairContainerWidget::ContainerPanel' has a wrong offset!");
static_assert(offsetof(USHCrosshairContainerWidget, GameplayCenterDotClass) == 0x000280, "Member 'USHCrosshairContainerWidget::GameplayCenterDotClass' has a wrong offset!");
static_assert(offsetof(USHCrosshairContainerWidget, OwnerCharacter) == 0x000288, "Member 'USHCrosshairContainerWidget::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHCrosshairContainerWidget, CurrentCrosshairWidget) == 0x000290, "Member 'USHCrosshairContainerWidget::CurrentCrosshairWidget' has a wrong offset!");

// Class SHProto.SHCustomBorder
// 0x0060 (0x0370 - 0x0310)
class USHCustomBorder : public UBorder
{
public:
	class USHMaterialPropertyControlSettings*     MaterialPropertyControlSettings;                   // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSHMaterialPropertyControlHandler> MaterialPropertyControlHandlers;                   // 0x0310(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x50];                                     // 0x0320(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ManualTick(float InDeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCustomBorder">();
	}
	static class USHCustomBorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCustomBorder>();
	}
};
static_assert(alignof(USHCustomBorder) == 0x000010, "Wrong alignment on USHCustomBorder");
static_assert(sizeof(USHCustomBorder) == 0x000370, "Wrong size on USHCustomBorder");
static_assert(offsetof(USHCustomBorder, MaterialPropertyControlSettings) == 0x000308, "Member 'USHCustomBorder::MaterialPropertyControlSettings' has a wrong offset!");
static_assert(offsetof(USHCustomBorder, MaterialPropertyControlHandlers) == 0x000310, "Member 'USHCustomBorder::MaterialPropertyControlHandlers' has a wrong offset!");

// Class SHProto.SHCustomPrimitiveDataHelper
// 0x0010 (0x00B0 - 0x00A0)
class USHCustomPrimitiveDataHelper : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InterpFloatValue(class UPrimitiveComponent* InComp, float StartValue, float EndValue, float InterpTime, int32 DataIndex);
	void SetFloatValue(class UPrimitiveComponent* InComp, float InValue, int32 DataIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCustomPrimitiveDataHelper">();
	}
	static class USHCustomPrimitiveDataHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCustomPrimitiveDataHelper>();
	}
};
static_assert(alignof(USHCustomPrimitiveDataHelper) == 0x000008, "Wrong alignment on USHCustomPrimitiveDataHelper");
static_assert(sizeof(USHCustomPrimitiveDataHelper) == 0x0000B0, "Wrong size on USHCustomPrimitiveDataHelper");

// Class SHProto.SHFlashlightTutorialHandler
// 0x0008 (0x0040 - 0x0038)
class USHFlashlightTutorialHandler final : public USHTutorialHandlerBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessEquipmentItemSpawned(class USHCharacterPlayItemsComponent* Component, class FName ItemContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFlashlightTutorialHandler">();
	}
	static class USHFlashlightTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFlashlightTutorialHandler>();
	}
};
static_assert(alignof(USHFlashlightTutorialHandler) == 0x000008, "Wrong alignment on USHFlashlightTutorialHandler");
static_assert(sizeof(USHFlashlightTutorialHandler) == 0x000040, "Wrong size on USHFlashlightTutorialHandler");

// Class SHProto.SHCustomRetainerBox
// 0x0068 (0x0200 - 0x0198)
class USHCustomRetainerBox : public URetainerBox
{
public:
	class USHMaterialPropertyControlSettings*     MaterialPropertyControlSettings;                   // 0x0198(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSHMaterialPropertyControlHandler> MaterialPropertyControlHandlers;                   // 0x01A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B0[0x50];                                     // 0x01B0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ManualTick(float InDeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCustomRetainerBox">();
	}
	static class USHCustomRetainerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCustomRetainerBox>();
	}
};
static_assert(alignof(USHCustomRetainerBox) == 0x000008, "Wrong alignment on USHCustomRetainerBox");
static_assert(sizeof(USHCustomRetainerBox) == 0x000200, "Wrong size on USHCustomRetainerBox");
static_assert(offsetof(USHCustomRetainerBox, MaterialPropertyControlSettings) == 0x000198, "Member 'USHCustomRetainerBox::MaterialPropertyControlSettings' has a wrong offset!");
static_assert(offsetof(USHCustomRetainerBox, MaterialPropertyControlHandlers) == 0x0001A0, "Member 'USHCustomRetainerBox::MaterialPropertyControlHandlers' has a wrong offset!");

// Class SHProto.SHCutscenePlayer
// 0x0030 (0x0568 - 0x0538)
class ASHCutscenePlayer final : public ACutscenePlayer
{
public:
	class UCapsuleComponent*                      TeleportTarget;                                    // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      MariaTeleportTarget;                               // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHideMariaDuringCutscene : 1;                      // 0x0548(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTeleportMariaAfterCutscene : 1;                   // 0x0548(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_549[0x3];                                      // 0x0549(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bResetAggressiveEnemiesOnActivate;                 // 0x054C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResetCameraToDefaultRotation;                     // 0x054D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54E[0x2];                                      // 0x054E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AfterCutsceneLightingBlendTime;                    // 0x0550(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DynamicResolutionMinScreenPercentage;              // 0x0554(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEffectHandle                          LightEffect;                                       // 0x0558(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_560[0x8];                                      // 0x0560(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCutscenePlayer">();
	}
	static class ASHCutscenePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHCutscenePlayer>();
	}
};
static_assert(alignof(ASHCutscenePlayer) == 0x000008, "Wrong alignment on ASHCutscenePlayer");
static_assert(sizeof(ASHCutscenePlayer) == 0x000568, "Wrong size on ASHCutscenePlayer");
static_assert(offsetof(ASHCutscenePlayer, TeleportTarget) == 0x000538, "Member 'ASHCutscenePlayer::TeleportTarget' has a wrong offset!");
static_assert(offsetof(ASHCutscenePlayer, MariaTeleportTarget) == 0x000540, "Member 'ASHCutscenePlayer::MariaTeleportTarget' has a wrong offset!");
static_assert(offsetof(ASHCutscenePlayer, bResetAggressiveEnemiesOnActivate) == 0x00054C, "Member 'ASHCutscenePlayer::bResetAggressiveEnemiesOnActivate' has a wrong offset!");
static_assert(offsetof(ASHCutscenePlayer, bResetCameraToDefaultRotation) == 0x00054D, "Member 'ASHCutscenePlayer::bResetCameraToDefaultRotation' has a wrong offset!");
static_assert(offsetof(ASHCutscenePlayer, AfterCutsceneLightingBlendTime) == 0x000550, "Member 'ASHCutscenePlayer::AfterCutsceneLightingBlendTime' has a wrong offset!");
static_assert(offsetof(ASHCutscenePlayer, DynamicResolutionMinScreenPercentage) == 0x000554, "Member 'ASHCutscenePlayer::DynamicResolutionMinScreenPercentage' has a wrong offset!");
static_assert(offsetof(ASHCutscenePlayer, LightEffect) == 0x000558, "Member 'ASHCutscenePlayer::LightEffect' has a wrong offset!");

// Class SHProto.SHDebugManagerWidget
// 0x0028 (0x02A0 - 0x0278)
class USHDebugManagerWidget : public UUserWidget
{
public:
	class UCanvasPanel*                           CharacterHP_Container;                             // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           CharacterHP_PB;                                    // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CharacterHP_TB;                                    // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CharacterGhost_TB;                                 // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CharacterSpeed_TB;                                 // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDebugManagerWidget">();
	}
	static class USHDebugManagerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDebugManagerWidget>();
	}
};
static_assert(alignof(USHDebugManagerWidget) == 0x000008, "Wrong alignment on USHDebugManagerWidget");
static_assert(sizeof(USHDebugManagerWidget) == 0x0002A0, "Wrong size on USHDebugManagerWidget");
static_assert(offsetof(USHDebugManagerWidget, CharacterHP_Container) == 0x000278, "Member 'USHDebugManagerWidget::CharacterHP_Container' has a wrong offset!");
static_assert(offsetof(USHDebugManagerWidget, CharacterHP_PB) == 0x000280, "Member 'USHDebugManagerWidget::CharacterHP_PB' has a wrong offset!");
static_assert(offsetof(USHDebugManagerWidget, CharacterHP_TB) == 0x000288, "Member 'USHDebugManagerWidget::CharacterHP_TB' has a wrong offset!");
static_assert(offsetof(USHDebugManagerWidget, CharacterGhost_TB) == 0x000290, "Member 'USHDebugManagerWidget::CharacterGhost_TB' has a wrong offset!");
static_assert(offsetof(USHDebugManagerWidget, CharacterSpeed_TB) == 0x000298, "Member 'USHDebugManagerWidget::CharacterSpeed_TB' has a wrong offset!");

// Class SHProto.SHFleshLipFlyingLocomotionAnimInstance
// 0x0000 (0x0460 - 0x0460)
class USHFleshLipFlyingLocomotionAnimInstance final : public USHFleshLipLocomotionAnimInstance
{
public:
	ESHFleshLipFlyingAnimInstanceLocomotionState  LocomotionState;                                   // 0x0458(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_459[0x7];                                      // 0x0459(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFleshLipFlyingLocomotionAnimInstance">();
	}
	static class USHFleshLipFlyingLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFleshLipFlyingLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHFleshLipFlyingLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHFleshLipFlyingLocomotionAnimInstance");
static_assert(sizeof(USHFleshLipFlyingLocomotionAnimInstance) == 0x000460, "Wrong size on USHFleshLipFlyingLocomotionAnimInstance");
static_assert(offsetof(USHFleshLipFlyingLocomotionAnimInstance, LocomotionState) == 0x000458, "Member 'USHFleshLipFlyingLocomotionAnimInstance::LocomotionState' has a wrong offset!");

// Class SHProto.SHDefenceCmbSubcompSettings
// 0x0040 (0x0070 - 0x0030)
class USHDefenceCmbSubcompSettings final : public UDataAsset
{
public:
	bool                                          bDodgeUseViewSnapOnEnemy;                          // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDodgeViewSnapOnEnemyDurationAsAnimLengthMul;      // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DodgeViewSnapOnEnemyDuration;                      // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSHViewLookOperationSettings           DodgeViewSnapOnEnemySettings;                      // 0x0038(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDefenceCmbSubcompSettings">();
	}
	static class USHDefenceCmbSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDefenceCmbSubcompSettings>();
	}
};
static_assert(alignof(USHDefenceCmbSubcompSettings) == 0x000008, "Wrong alignment on USHDefenceCmbSubcompSettings");
static_assert(sizeof(USHDefenceCmbSubcompSettings) == 0x000070, "Wrong size on USHDefenceCmbSubcompSettings");
static_assert(offsetof(USHDefenceCmbSubcompSettings, bDodgeUseViewSnapOnEnemy) == 0x000030, "Member 'USHDefenceCmbSubcompSettings::bDodgeUseViewSnapOnEnemy' has a wrong offset!");
static_assert(offsetof(USHDefenceCmbSubcompSettings, bDodgeViewSnapOnEnemyDurationAsAnimLengthMul) == 0x000031, "Member 'USHDefenceCmbSubcompSettings::bDodgeViewSnapOnEnemyDurationAsAnimLengthMul' has a wrong offset!");
static_assert(offsetof(USHDefenceCmbSubcompSettings, DodgeViewSnapOnEnemyDuration) == 0x000034, "Member 'USHDefenceCmbSubcompSettings::DodgeViewSnapOnEnemyDuration' has a wrong offset!");
static_assert(offsetof(USHDefenceCmbSubcompSettings, DodgeViewSnapOnEnemySettings) == 0x000038, "Member 'USHDefenceCmbSubcompSettings::DodgeViewSnapOnEnemySettings' has a wrong offset!");

// Class SHProto.SHFXMaterialModifierSubcompSettings
// 0x0020 (0x0050 - 0x0030)
class USHFXMaterialModifierSubcompSettings : public UDataAsset
{
public:
	bool                                          UseCustomMaterialIndexes;                          // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 CustomMaterialIndexes;                             // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class USHMaterialPropertyControlSettings*     MaterialPropertyControlSettings;                   // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXMaterialModifierSubcompSettings">();
	}
	static class USHFXMaterialModifierSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXMaterialModifierSubcompSettings>();
	}
};
static_assert(alignof(USHFXMaterialModifierSubcompSettings) == 0x000008, "Wrong alignment on USHFXMaterialModifierSubcompSettings");
static_assert(sizeof(USHFXMaterialModifierSubcompSettings) == 0x000050, "Wrong size on USHFXMaterialModifierSubcompSettings");
static_assert(offsetof(USHFXMaterialModifierSubcompSettings, UseCustomMaterialIndexes) == 0x000030, "Member 'USHFXMaterialModifierSubcompSettings::UseCustomMaterialIndexes' has a wrong offset!");
static_assert(offsetof(USHFXMaterialModifierSubcompSettings, CustomMaterialIndexes) == 0x000038, "Member 'USHFXMaterialModifierSubcompSettings::CustomMaterialIndexes' has a wrong offset!");
static_assert(offsetof(USHFXMaterialModifierSubcompSettings, MaterialPropertyControlSettings) == 0x000048, "Member 'USHFXMaterialModifierSubcompSettings::MaterialPropertyControlSettings' has a wrong offset!");

// Class SHProto.SHFXDirtLayerSubcompSettings
// 0x0020 (0x0070 - 0x0050)
class USHFXDirtLayerSubcompSettings final : public USHFXMaterialModifierSubcompSettings
{
public:
	bool                                          EnableDirtBlendLayer;                              // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DirtBlendCurve;                                    // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USHMaterialPropertyControlSettings*> MaterialIndexToPropertiesMapping;                  // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXDirtLayerSubcompSettings">();
	}
	static class USHFXDirtLayerSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXDirtLayerSubcompSettings>();
	}
};
static_assert(alignof(USHFXDirtLayerSubcompSettings) == 0x000008, "Wrong alignment on USHFXDirtLayerSubcompSettings");
static_assert(sizeof(USHFXDirtLayerSubcompSettings) == 0x000070, "Wrong size on USHFXDirtLayerSubcompSettings");
static_assert(offsetof(USHFXDirtLayerSubcompSettings, EnableDirtBlendLayer) == 0x000050, "Member 'USHFXDirtLayerSubcompSettings::EnableDirtBlendLayer' has a wrong offset!");
static_assert(offsetof(USHFXDirtLayerSubcompSettings, DirtBlendCurve) == 0x000058, "Member 'USHFXDirtLayerSubcompSettings::DirtBlendCurve' has a wrong offset!");
static_assert(offsetof(USHFXDirtLayerSubcompSettings, MaterialIndexToPropertiesMapping) == 0x000060, "Member 'USHFXDirtLayerSubcompSettings::MaterialIndexToPropertiesMapping' has a wrong offset!");

// Class SHProto.SHDistanceTravelledStatisticsValueProcessor
// 0x0008 (0x0038 - 0x0030)
class USHDistanceTravelledStatisticsValueProcessor final : public USHStatisticsValueProcessor
{
public:
	int32                                         DistanceTravelled;                                 // 0x0030(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDistanceTravelledStatisticsValueProcessor">();
	}
	static class USHDistanceTravelledStatisticsValueProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDistanceTravelledStatisticsValueProcessor>();
	}
};
static_assert(alignof(USHDistanceTravelledStatisticsValueProcessor) == 0x000008, "Wrong alignment on USHDistanceTravelledStatisticsValueProcessor");
static_assert(sizeof(USHDistanceTravelledStatisticsValueProcessor) == 0x000038, "Wrong size on USHDistanceTravelledStatisticsValueProcessor");
static_assert(offsetof(USHDistanceTravelledStatisticsValueProcessor, DistanceTravelled) == 0x000030, "Member 'USHDistanceTravelledStatisticsValueProcessor::DistanceTravelled' has a wrong offset!");

// Class SHProto.SHPersistentSaveData
// 0x0010 (0x0058 - 0x0048)
class USHPersistentSaveData final : public UPersistentSaveData
{
public:
	bool                                          bHasEverFinishedGame;                              // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUserSawNewGameInfo;                               // 0x0049(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSeenLeaveEnding;                               // 0x004A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSeenMariaEnding;                               // 0x004B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSeenInWaterEnding;                             // 0x004C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSeenRebirthEnding;                             // 0x004D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSeenTrueLeaveEnding;                           // 0x004E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSeenTrueInWaterEnding;                         // 0x004F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSeenDogEnding;                                 // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSeenUfoEnding;                                 // 0x0051(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPersistentSaveData">();
	}
	static class USHPersistentSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPersistentSaveData>();
	}
};
static_assert(alignof(USHPersistentSaveData) == 0x000008, "Wrong alignment on USHPersistentSaveData");
static_assert(sizeof(USHPersistentSaveData) == 0x000058, "Wrong size on USHPersistentSaveData");
static_assert(offsetof(USHPersistentSaveData, bHasEverFinishedGame) == 0x000048, "Member 'USHPersistentSaveData::bHasEverFinishedGame' has a wrong offset!");
static_assert(offsetof(USHPersistentSaveData, bUserSawNewGameInfo) == 0x000049, "Member 'USHPersistentSaveData::bUserSawNewGameInfo' has a wrong offset!");
static_assert(offsetof(USHPersistentSaveData, bHasSeenLeaveEnding) == 0x00004A, "Member 'USHPersistentSaveData::bHasSeenLeaveEnding' has a wrong offset!");
static_assert(offsetof(USHPersistentSaveData, bHasSeenMariaEnding) == 0x00004B, "Member 'USHPersistentSaveData::bHasSeenMariaEnding' has a wrong offset!");
static_assert(offsetof(USHPersistentSaveData, bHasSeenInWaterEnding) == 0x00004C, "Member 'USHPersistentSaveData::bHasSeenInWaterEnding' has a wrong offset!");
static_assert(offsetof(USHPersistentSaveData, bHasSeenRebirthEnding) == 0x00004D, "Member 'USHPersistentSaveData::bHasSeenRebirthEnding' has a wrong offset!");
static_assert(offsetof(USHPersistentSaveData, bHasSeenTrueLeaveEnding) == 0x00004E, "Member 'USHPersistentSaveData::bHasSeenTrueLeaveEnding' has a wrong offset!");
static_assert(offsetof(USHPersistentSaveData, bHasSeenTrueInWaterEnding) == 0x00004F, "Member 'USHPersistentSaveData::bHasSeenTrueInWaterEnding' has a wrong offset!");
static_assert(offsetof(USHPersistentSaveData, bHasSeenDogEnding) == 0x000050, "Member 'USHPersistentSaveData::bHasSeenDogEnding' has a wrong offset!");
static_assert(offsetof(USHPersistentSaveData, bHasSeenUfoEnding) == 0x000051, "Member 'USHPersistentSaveData::bHasSeenUfoEnding' has a wrong offset!");

// Class SHProto.SHGameplayGameOverWidget
// 0x0038 (0x02D8 - 0x02A0)
class USHGameplayGameOverWidget final : public UBUserWidget
{
public:
	class UWidgetAnimation*                       FadeIn;                                            // 0x02A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeOut;                                           // 0x02A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AutoReloadOnDeath;                                 // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShowDelayValue;                                    // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEffectHandle                          LightEffect;                                       // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x02C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x10];                                     // 0x02C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnShown(EGameOverCause _GameOverCause);
	void RequestReload();
	void ShowInternal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayGameOverWidget">();
	}
	static class USHGameplayGameOverWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayGameOverWidget>();
	}
};
static_assert(alignof(USHGameplayGameOverWidget) == 0x000008, "Wrong alignment on USHGameplayGameOverWidget");
static_assert(sizeof(USHGameplayGameOverWidget) == 0x0002D8, "Wrong size on USHGameplayGameOverWidget");
static_assert(offsetof(USHGameplayGameOverWidget, FadeIn) == 0x0002A0, "Member 'USHGameplayGameOverWidget::FadeIn' has a wrong offset!");
static_assert(offsetof(USHGameplayGameOverWidget, FadeOut) == 0x0002A8, "Member 'USHGameplayGameOverWidget::FadeOut' has a wrong offset!");
static_assert(offsetof(USHGameplayGameOverWidget, AutoReloadOnDeath) == 0x0002B0, "Member 'USHGameplayGameOverWidget::AutoReloadOnDeath' has a wrong offset!");
static_assert(offsetof(USHGameplayGameOverWidget, ShowDelayValue) == 0x0002B4, "Member 'USHGameplayGameOverWidget::ShowDelayValue' has a wrong offset!");
static_assert(offsetof(USHGameplayGameOverWidget, LightEffect) == 0x0002B8, "Member 'USHGameplayGameOverWidget::LightEffect' has a wrong offset!");
static_assert(offsetof(USHGameplayGameOverWidget, OwnerCharacter) == 0x0002C0, "Member 'USHGameplayGameOverWidget::OwnerCharacter' has a wrong offset!");

// Class SHProto.SHDoorAnimationsSetData
// 0x01A8 (0x01D8 - 0x0030)
class USHDoorAnimationsSetData final : public USHDoorAnimationsBaseSetData
{
public:
	TMap<class FName, struct FPlayAnimationData>  OpenWalkAnims;                                     // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FPlayAnimationData>  OpenSprintAnims;                                   // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FPlayAnimationData>  AutoLockedDoorCheckAnims;                          // 0x00D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AutoLockedCheckCurveDoorMovementAnim;              // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayAnimationData                     MariaOpenWalkAnim;                                 // 0x0128(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDoorAnimationsSetData">();
	}
	static class USHDoorAnimationsSetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDoorAnimationsSetData>();
	}
};
static_assert(alignof(USHDoorAnimationsSetData) == 0x000008, "Wrong alignment on USHDoorAnimationsSetData");
static_assert(sizeof(USHDoorAnimationsSetData) == 0x0001D8, "Wrong size on USHDoorAnimationsSetData");
static_assert(offsetof(USHDoorAnimationsSetData, OpenWalkAnims) == 0x000030, "Member 'USHDoorAnimationsSetData::OpenWalkAnims' has a wrong offset!");
static_assert(offsetof(USHDoorAnimationsSetData, OpenSprintAnims) == 0x000080, "Member 'USHDoorAnimationsSetData::OpenSprintAnims' has a wrong offset!");
static_assert(offsetof(USHDoorAnimationsSetData, AutoLockedDoorCheckAnims) == 0x0000D0, "Member 'USHDoorAnimationsSetData::AutoLockedDoorCheckAnims' has a wrong offset!");
static_assert(offsetof(USHDoorAnimationsSetData, AutoLockedCheckCurveDoorMovementAnim) == 0x000120, "Member 'USHDoorAnimationsSetData::AutoLockedCheckCurveDoorMovementAnim' has a wrong offset!");
static_assert(offsetof(USHDoorAnimationsSetData, MariaOpenWalkAnim) == 0x000128, "Member 'USHDoorAnimationsSetData::MariaOpenWalkAnim' has a wrong offset!");

// Class SHProto.SHDoorAnimationsComponent
// 0x0068 (0x0130 - 0x00C8)
class USHDoorAnimationsComponent final : public USHDoorAnimationsBaseComponent
{
public:
	class USHDoorAnimationsSetData*               AnimationsSetData;                                 // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnOpenAnimPlayed;                                  // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnLockAnimPlayed;                                  // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAutoLockedDoorCheckAnimPlayed;                   // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x30];                                     // 0x0100(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAutoLockedDoorCheckAnimEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void OnPhysicMovementAppliedForceFromActor(class USHDoorMovementComponent* DoorMovementComponent, class AActor* ActorContext);
	void SetPlayAutoLockedDoorCheckAnimBlocked(const bool bInBlocked, const class UObject* Object);
	void SHDoorAnimationEvent__DelegateSignature(class USHDoorAnimationsComponent* Component);
	void SHDoorAnimationEventBP__DelegateSignature(class USHDoorAnimationsComponent* Component);

	bool IsPlayAutoLockedDoorCheckAnimBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDoorAnimationsComponent">();
	}
	static class USHDoorAnimationsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDoorAnimationsComponent>();
	}
};
static_assert(alignof(USHDoorAnimationsComponent) == 0x000008, "Wrong alignment on USHDoorAnimationsComponent");
static_assert(sizeof(USHDoorAnimationsComponent) == 0x000130, "Wrong size on USHDoorAnimationsComponent");
static_assert(offsetof(USHDoorAnimationsComponent, AnimationsSetData) == 0x0000C8, "Member 'USHDoorAnimationsComponent::AnimationsSetData' has a wrong offset!");
static_assert(offsetof(USHDoorAnimationsComponent, OnOpenAnimPlayed) == 0x0000D0, "Member 'USHDoorAnimationsComponent::OnOpenAnimPlayed' has a wrong offset!");
static_assert(offsetof(USHDoorAnimationsComponent, OnLockAnimPlayed) == 0x0000E0, "Member 'USHDoorAnimationsComponent::OnLockAnimPlayed' has a wrong offset!");
static_assert(offsetof(USHDoorAnimationsComponent, OnAutoLockedDoorCheckAnimPlayed) == 0x0000F0, "Member 'USHDoorAnimationsComponent::OnAutoLockedDoorCheckAnimPlayed' has a wrong offset!");

// Class SHProto.SHDoorAttachment
// 0x0048 (0x0318 - 0x02D0)
class ASHDoorAttachment final : public ASHBaseDoorAttachment
{
public:
	class USHInteractionGenericComponent*         InteractionGeneric;                                // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            InteractionIcon;                                   // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHRaycastDetectableComponent*          InteractionDetectable;                             // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractionDetectableShape;                        // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      AnimSpot;                                          // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkDynamicTickComponent*              SHAkComponent;                                     // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionManagerComponent*         InteractionManager;                                // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       InteractingCharacter;                              // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBreak();
	void OnCharacterOnSpot();
	void OnInteracted();
	void OnInteractionAnimationEnd(ESHAnimEndType AnimEndType);
	bool PlayInteractionAnimation(const struct FPlayAnimationData& AnimToPlay);
	void ProcessActionAnimEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void ProcessInteracted(class USHInteractionGenericComponent* Generic, class ASHCharacterPlay* Character);
	void ProcessInteractionManagerInitialized(class USHInteractionManagerComponent* Manager);
	void ProcessMovementSnapFinished(bool WasCompleted);
	void ProcessPutCharacterOnSpotFinished(bool WasCompleted);
	void ProcessReceiveDamageEvent(class USHCharacterPlayCombatComponent* CombatComp);
	void PutCharacterOnSpotRequest(float InBlendInTime);
	void RegisterInteractionAnimation(const struct FPlayAnimationData& AnimToPlay);
	void UnregisterInteractionAnimation(const struct FPlayAnimationData& AnimToPlay);

	bool IsProximityCharacterOnCorrectSide() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDoorAttachment">();
	}
	static class ASHDoorAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHDoorAttachment>();
	}
};
static_assert(alignof(ASHDoorAttachment) == 0x000008, "Wrong alignment on ASHDoorAttachment");
static_assert(sizeof(ASHDoorAttachment) == 0x000318, "Wrong size on ASHDoorAttachment");
static_assert(offsetof(ASHDoorAttachment, InteractionGeneric) == 0x0002D0, "Member 'ASHDoorAttachment::InteractionGeneric' has a wrong offset!");
static_assert(offsetof(ASHDoorAttachment, InteractionIcon) == 0x0002D8, "Member 'ASHDoorAttachment::InteractionIcon' has a wrong offset!");
static_assert(offsetof(ASHDoorAttachment, InteractionDetectable) == 0x0002E0, "Member 'ASHDoorAttachment::InteractionDetectable' has a wrong offset!");
static_assert(offsetof(ASHDoorAttachment, InteractionDetectableShape) == 0x0002E8, "Member 'ASHDoorAttachment::InteractionDetectableShape' has a wrong offset!");
static_assert(offsetof(ASHDoorAttachment, AnimSpot) == 0x0002F0, "Member 'ASHDoorAttachment::AnimSpot' has a wrong offset!");
static_assert(offsetof(ASHDoorAttachment, SHAkComponent) == 0x0002F8, "Member 'ASHDoorAttachment::SHAkComponent' has a wrong offset!");
static_assert(offsetof(ASHDoorAttachment, InteractionManager) == 0x000300, "Member 'ASHDoorAttachment::InteractionManager' has a wrong offset!");
static_assert(offsetof(ASHDoorAttachment, InteractingCharacter) == 0x000308, "Member 'ASHDoorAttachment::InteractingCharacter' has a wrong offset!");

// Class SHProto.SHGameplaySectionBaseWidget
// 0x0018 (0x0290 - 0x0278)
class USHGameplaySectionBaseWidget : public UUserWidget
{
public:
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x0278(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayMenuWidget*                  OwnerWidget;                                       // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActivated();
	void OnInit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplaySectionBaseWidget">();
	}
	static class USHGameplaySectionBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplaySectionBaseWidget>();
	}
};
static_assert(alignof(USHGameplaySectionBaseWidget) == 0x000008, "Wrong alignment on USHGameplaySectionBaseWidget");
static_assert(sizeof(USHGameplaySectionBaseWidget) == 0x000290, "Wrong size on USHGameplaySectionBaseWidget");
static_assert(offsetof(USHGameplaySectionBaseWidget, OwnerCharacter) == 0x000278, "Member 'USHGameplaySectionBaseWidget::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHGameplaySectionBaseWidget, OwnerWidget) == 0x000280, "Member 'USHGameplaySectionBaseWidget::OwnerWidget' has a wrong offset!");

// Class SHProto.SHGameplaySectionCombineWidget
// 0x00C8 (0x0358 - 0x0290)
class USHGameplaySectionCombineWidget final : public USHGameplaySectionBaseWidget
{
public:
	class USHGameplayInventorySlider*             GameplayInventorySliderWidget;                     // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           CombineBox;                                        // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USHCombineRecipeSlotWidget> RequiredItemWidgetSubclass;                        // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                ConnectorWidgetSubclass;                           // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AudioEvent_CombineCorrectItem;                     // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AudioEvent_RemoveLast;                             // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AudioEvent_CombineFail;                            // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AudioEvent_CombineSuccess;                         // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x88];                                     // 0x02D0(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplaySectionCombineWidget">();
	}
	static class USHGameplaySectionCombineWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplaySectionCombineWidget>();
	}
};
static_assert(alignof(USHGameplaySectionCombineWidget) == 0x000008, "Wrong alignment on USHGameplaySectionCombineWidget");
static_assert(sizeof(USHGameplaySectionCombineWidget) == 0x000358, "Wrong size on USHGameplaySectionCombineWidget");
static_assert(offsetof(USHGameplaySectionCombineWidget, GameplayInventorySliderWidget) == 0x000290, "Member 'USHGameplaySectionCombineWidget::GameplayInventorySliderWidget' has a wrong offset!");
static_assert(offsetof(USHGameplaySectionCombineWidget, CombineBox) == 0x000298, "Member 'USHGameplaySectionCombineWidget::CombineBox' has a wrong offset!");
static_assert(offsetof(USHGameplaySectionCombineWidget, RequiredItemWidgetSubclass) == 0x0002A0, "Member 'USHGameplaySectionCombineWidget::RequiredItemWidgetSubclass' has a wrong offset!");
static_assert(offsetof(USHGameplaySectionCombineWidget, ConnectorWidgetSubclass) == 0x0002A8, "Member 'USHGameplaySectionCombineWidget::ConnectorWidgetSubclass' has a wrong offset!");
static_assert(offsetof(USHGameplaySectionCombineWidget, AudioEvent_CombineCorrectItem) == 0x0002B0, "Member 'USHGameplaySectionCombineWidget::AudioEvent_CombineCorrectItem' has a wrong offset!");
static_assert(offsetof(USHGameplaySectionCombineWidget, AudioEvent_RemoveLast) == 0x0002B8, "Member 'USHGameplaySectionCombineWidget::AudioEvent_RemoveLast' has a wrong offset!");
static_assert(offsetof(USHGameplaySectionCombineWidget, AudioEvent_CombineFail) == 0x0002C0, "Member 'USHGameplaySectionCombineWidget::AudioEvent_CombineFail' has a wrong offset!");
static_assert(offsetof(USHGameplaySectionCombineWidget, AudioEvent_CombineSuccess) == 0x0002C8, "Member 'USHGameplaySectionCombineWidget::AudioEvent_CombineSuccess' has a wrong offset!");

// Class SHProto.SHPlayerControllerPlay
// 0x0008 (0x0878 - 0x0870)
class ASHPlayerControllerPlay final : public ASHPlayerController
{
public:
	uint8                                         Pad_870[0x8];                                      // 0x0870(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPlayerControllerPlay">();
	}
	static class ASHPlayerControllerPlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHPlayerControllerPlay>();
	}
};
static_assert(alignof(ASHPlayerControllerPlay) == 0x000008, "Wrong alignment on ASHPlayerControllerPlay");
static_assert(sizeof(ASHPlayerControllerPlay) == 0x000878, "Wrong size on ASHPlayerControllerPlay");

// Class SHProto.SHDoorMovementBaseComponent
// 0x0088 (0x0128 - 0x00A0)
class USHDoorMovementBaseComponent : public UActorComponent
{
public:
	struct FVector                                DoorTraceAdjust;                                   // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DoorTraceLocalOffset;                              // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ManagedDoorMesh;                                   // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlaneSideDetectionComponent*           ManagedPlaneSideDetection;                         // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHDoorLockBaseComponent*               ManagedDoorLockComponent;                          // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       ManagedProximityDetectionSphere;                   // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        ManagedAboveHandleSpot;                            // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        ManagedBelowHandleSpot;                            // 0x00F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       ActiveProximitySHActor;                            // 0x0100(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x20];                                     // 0x0108(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessMeshHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void ProcessProximitySHActorBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void ProcessProximitySHActorEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex);
	void SetIsManagedByCutscene(bool InEnable, const class UObject* Object);
	void SHDoorBaseMovementEvent__DelegateSignature(class USHDoorMovementBaseComponent* Component);
	void SHDoorBaseMovementEventBP__DelegateSignature(class USHDoorMovementBaseComponent* Component);

	ESHDoorStateEnum GetCurrentDoorState() const;
	float GetCurrentDoorVelocity() const;
	struct FVector GetDoorTraceHalfSize() const;
	float GetLastDoorVelocity() const;
	bool IsManagedByCutscene() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDoorMovementBaseComponent">();
	}
	static class USHDoorMovementBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDoorMovementBaseComponent>();
	}
};
static_assert(alignof(USHDoorMovementBaseComponent) == 0x000008, "Wrong alignment on USHDoorMovementBaseComponent");
static_assert(sizeof(USHDoorMovementBaseComponent) == 0x000128, "Wrong size on USHDoorMovementBaseComponent");
static_assert(offsetof(USHDoorMovementBaseComponent, DoorTraceAdjust) == 0x0000A0, "Member 'USHDoorMovementBaseComponent::DoorTraceAdjust' has a wrong offset!");
static_assert(offsetof(USHDoorMovementBaseComponent, DoorTraceLocalOffset) == 0x0000B8, "Member 'USHDoorMovementBaseComponent::DoorTraceLocalOffset' has a wrong offset!");
static_assert(offsetof(USHDoorMovementBaseComponent, ManagedDoorMesh) == 0x0000D0, "Member 'USHDoorMovementBaseComponent::ManagedDoorMesh' has a wrong offset!");
static_assert(offsetof(USHDoorMovementBaseComponent, ManagedPlaneSideDetection) == 0x0000D8, "Member 'USHDoorMovementBaseComponent::ManagedPlaneSideDetection' has a wrong offset!");
static_assert(offsetof(USHDoorMovementBaseComponent, ManagedDoorLockComponent) == 0x0000E0, "Member 'USHDoorMovementBaseComponent::ManagedDoorLockComponent' has a wrong offset!");
static_assert(offsetof(USHDoorMovementBaseComponent, ManagedProximityDetectionSphere) == 0x0000E8, "Member 'USHDoorMovementBaseComponent::ManagedProximityDetectionSphere' has a wrong offset!");
static_assert(offsetof(USHDoorMovementBaseComponent, ManagedAboveHandleSpot) == 0x0000F0, "Member 'USHDoorMovementBaseComponent::ManagedAboveHandleSpot' has a wrong offset!");
static_assert(offsetof(USHDoorMovementBaseComponent, ManagedBelowHandleSpot) == 0x0000F8, "Member 'USHDoorMovementBaseComponent::ManagedBelowHandleSpot' has a wrong offset!");
static_assert(offsetof(USHDoorMovementBaseComponent, ActiveProximitySHActor) == 0x000100, "Member 'USHDoorMovementBaseComponent::ActiveProximitySHActor' has a wrong offset!");

// Class SHProto.SHDoorMovementComponent
// 0x02E0 (0x0408 - 0x0128)
class USHDoorMovementComponent final : public USHDoorMovementBaseComponent
{
public:
	float                                         BeginPlayAngle;                                    // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClosedAngle;                                       // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpenedAngle;                                       // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          OpenBothSides;                                     // 0x0134(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OtherSideOpenedAngle;                              // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFrozenOnBegin;                                    // 0x013C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13D[0x3];                                      // 0x013D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FakeMovementSpeed;                                 // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FakeMovementBlendExp;                              // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPushingAngle;                                   // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitForceMod;                                       // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VelocityDecreaserMod;                              // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxMoveVelocity;                                   // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowOnlyOneMovementSignOfPhysicalMove;           // 0x0158(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OneMovementSignOfPhysicalMove;                     // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseAutoclose;                                     // 0x0160(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_161[0x3];                                      // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutocloseCharacterDetectorRange;                   // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPushEnemyActive;                                  // 0x0168(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PushingSpeed;                                      // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSHMakeNoiseConfig                     AutoLockedDoorCheckNoiseConfig;                    // 0x0170(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSHMakeNoiseConfig                     PlayerStartedPhysicMovementNoiseConfig;            // 0x018C(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                DoorPreHitAdjust;                                  // 0x01A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHitTurnSpirntOff;                                 // 0x01C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnFakeMovementStart;                               // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnFakeMovementInterupted;                          // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnFakeMovementComplete;                            // 0x01E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnPhysicMovementStart;                             // 0x01F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnPhysicMovementInterupted;                        // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnPhysicMovementComplete;                          // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDoorAngleChanged;                                // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDoorStateChanged;                                // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnFrozenChanged;                                   // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UBoxComponent*                          ManagedPreHitDetector;                             // 0x0258(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         TraceIgnoreActors;                                 // 0x0260(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsDoorFrozen;                                     // 0x0270(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoorAngleSave;                                     // 0x0274(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x190];                                    // 0x0278(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddActorToTraceIgnoreActors(class AActor* InActor);
	void AddPhysicForce(const float MoveForce);
	void PlayCurveAnim(class UCurveFloat* InCurve, bool InSkipTracing);
	const bool RequestCustomFakeMovement(const float InAngleTarget, const float InSpeed, const float InBlendExp, const bool InForceMovement);
	const bool RequestFakeClose();
	const bool RequestFakeOpen(const bool ToOtherside);
	void SetAutocloseBlocked(const bool Blocked, const class UObject* Object);
	void SetDoorFrozen(bool NewValue);
	void SHDoorMovementEvent__DelegateSignature(class USHDoorMovementComponent* Component);
	void SHDoorMovementEventBP__DelegateSignature(class USHDoorMovementComponent* Component);
	void SHDoorMovementWithActorContextEvent__DelegateSignature(class USHDoorMovementComponent* Component, class AActor* ActorContext);
	void StopCurveAnim();

	float GetCurrentDoorAngle() const;
	struct FVector GetDoorTraceLoc(float DoorTraceAngle) const;
	float GetFakeMovementTargetAngle() const;
	const ESHDoorStateEnum GetFakeMovementTargetState() const;
	float GetMaxDoorVelocity() const;
	bool HasPhysicForce() const;
	bool IsAutocloseBlocked() const;
	bool IsDoorFrozen() const;
	bool IsPlayingCurveAnim() const;
	bool IsPreHitOverlapingAnyCharacter() const;
	bool IsPreHitOverlapingCharacterPlay() const;
	bool WasPhysicMovingLastTick() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDoorMovementComponent">();
	}
	static class USHDoorMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDoorMovementComponent>();
	}
};
static_assert(alignof(USHDoorMovementComponent) == 0x000008, "Wrong alignment on USHDoorMovementComponent");
static_assert(sizeof(USHDoorMovementComponent) == 0x000408, "Wrong size on USHDoorMovementComponent");
static_assert(offsetof(USHDoorMovementComponent, BeginPlayAngle) == 0x000128, "Member 'USHDoorMovementComponent::BeginPlayAngle' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, ClosedAngle) == 0x00012C, "Member 'USHDoorMovementComponent::ClosedAngle' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, OpenedAngle) == 0x000130, "Member 'USHDoorMovementComponent::OpenedAngle' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, OpenBothSides) == 0x000134, "Member 'USHDoorMovementComponent::OpenBothSides' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, OtherSideOpenedAngle) == 0x000138, "Member 'USHDoorMovementComponent::OtherSideOpenedAngle' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, bFrozenOnBegin) == 0x00013C, "Member 'USHDoorMovementComponent::bFrozenOnBegin' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, FakeMovementSpeed) == 0x000140, "Member 'USHDoorMovementComponent::FakeMovementSpeed' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, FakeMovementBlendExp) == 0x000144, "Member 'USHDoorMovementComponent::FakeMovementBlendExp' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, MaxPushingAngle) == 0x000148, "Member 'USHDoorMovementComponent::MaxPushingAngle' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, HitForceMod) == 0x00014C, "Member 'USHDoorMovementComponent::HitForceMod' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, VelocityDecreaserMod) == 0x000150, "Member 'USHDoorMovementComponent::VelocityDecreaserMod' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, MaxMoveVelocity) == 0x000154, "Member 'USHDoorMovementComponent::MaxMoveVelocity' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, bAllowOnlyOneMovementSignOfPhysicalMove) == 0x000158, "Member 'USHDoorMovementComponent::bAllowOnlyOneMovementSignOfPhysicalMove' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, OneMovementSignOfPhysicalMove) == 0x00015C, "Member 'USHDoorMovementComponent::OneMovementSignOfPhysicalMove' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, bUseAutoclose) == 0x000160, "Member 'USHDoorMovementComponent::bUseAutoclose' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, AutocloseCharacterDetectorRange) == 0x000164, "Member 'USHDoorMovementComponent::AutocloseCharacterDetectorRange' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, bPushEnemyActive) == 0x000168, "Member 'USHDoorMovementComponent::bPushEnemyActive' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, PushingSpeed) == 0x00016C, "Member 'USHDoorMovementComponent::PushingSpeed' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, AutoLockedDoorCheckNoiseConfig) == 0x000170, "Member 'USHDoorMovementComponent::AutoLockedDoorCheckNoiseConfig' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, PlayerStartedPhysicMovementNoiseConfig) == 0x00018C, "Member 'USHDoorMovementComponent::PlayerStartedPhysicMovementNoiseConfig' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, DoorPreHitAdjust) == 0x0001A8, "Member 'USHDoorMovementComponent::DoorPreHitAdjust' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, bHitTurnSpirntOff) == 0x0001C0, "Member 'USHDoorMovementComponent::bHitTurnSpirntOff' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, OnFakeMovementStart) == 0x0001C8, "Member 'USHDoorMovementComponent::OnFakeMovementStart' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, OnFakeMovementInterupted) == 0x0001D8, "Member 'USHDoorMovementComponent::OnFakeMovementInterupted' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, OnFakeMovementComplete) == 0x0001E8, "Member 'USHDoorMovementComponent::OnFakeMovementComplete' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, OnPhysicMovementStart) == 0x0001F8, "Member 'USHDoorMovementComponent::OnPhysicMovementStart' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, OnPhysicMovementInterupted) == 0x000208, "Member 'USHDoorMovementComponent::OnPhysicMovementInterupted' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, OnPhysicMovementComplete) == 0x000218, "Member 'USHDoorMovementComponent::OnPhysicMovementComplete' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, OnDoorAngleChanged) == 0x000228, "Member 'USHDoorMovementComponent::OnDoorAngleChanged' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, OnDoorStateChanged) == 0x000238, "Member 'USHDoorMovementComponent::OnDoorStateChanged' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, OnFrozenChanged) == 0x000248, "Member 'USHDoorMovementComponent::OnFrozenChanged' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, ManagedPreHitDetector) == 0x000258, "Member 'USHDoorMovementComponent::ManagedPreHitDetector' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, TraceIgnoreActors) == 0x000260, "Member 'USHDoorMovementComponent::TraceIgnoreActors' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, bIsDoorFrozen) == 0x000270, "Member 'USHDoorMovementComponent::bIsDoorFrozen' has a wrong offset!");
static_assert(offsetof(USHDoorMovementComponent, DoorAngleSave) == 0x000274, "Member 'USHDoorMovementComponent::DoorAngleSave' has a wrong offset!");

// Class SHProto.SHGameplayMapBaseWidget
// 0x00C8 (0x0340 - 0x0278)
class USHGameplayMapBaseWidget final : public UUserWidget
{
public:
	class UCanvasPanel*                           ObjectsContainer;                                  // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           FogRevealObjectsContainer;                         // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PlayerPointer;                                     // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Anchor1;                                           // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Anchor2;                                           // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  FontToLocalize;                                    // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapRotation;                                       // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Anchor1WorldPosition;                              // 0x02B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Anchor2WorldPosition;                              // 0x02C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x02E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UWidget*>                        MapFogRevealObjectToApplyWidgets;                  // 0x02E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x28];                                     // 0x02F8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTextLayoutWidget*>              TextWidgets;                                       // 0x0320(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ULocalizedFont*                         LocalizedFont;                                     // 0x0330(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyObjectData(class UWidget* WidgetObject, ESHMapObjectTypeEnum ObjectType, int32 ObjectValue);
	void OnInit();
	void OnShowed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayMapBaseWidget">();
	}
	static class USHGameplayMapBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayMapBaseWidget>();
	}
};
static_assert(alignof(USHGameplayMapBaseWidget) == 0x000008, "Wrong alignment on USHGameplayMapBaseWidget");
static_assert(sizeof(USHGameplayMapBaseWidget) == 0x000340, "Wrong size on USHGameplayMapBaseWidget");
static_assert(offsetof(USHGameplayMapBaseWidget, ObjectsContainer) == 0x000278, "Member 'USHGameplayMapBaseWidget::ObjectsContainer' has a wrong offset!");
static_assert(offsetof(USHGameplayMapBaseWidget, FogRevealObjectsContainer) == 0x000280, "Member 'USHGameplayMapBaseWidget::FogRevealObjectsContainer' has a wrong offset!");
static_assert(offsetof(USHGameplayMapBaseWidget, PlayerPointer) == 0x000288, "Member 'USHGameplayMapBaseWidget::PlayerPointer' has a wrong offset!");
static_assert(offsetof(USHGameplayMapBaseWidget, Anchor1) == 0x000290, "Member 'USHGameplayMapBaseWidget::Anchor1' has a wrong offset!");
static_assert(offsetof(USHGameplayMapBaseWidget, Anchor2) == 0x000298, "Member 'USHGameplayMapBaseWidget::Anchor2' has a wrong offset!");
static_assert(offsetof(USHGameplayMapBaseWidget, FontToLocalize) == 0x0002A0, "Member 'USHGameplayMapBaseWidget::FontToLocalize' has a wrong offset!");
static_assert(offsetof(USHGameplayMapBaseWidget, MapRotation) == 0x0002A8, "Member 'USHGameplayMapBaseWidget::MapRotation' has a wrong offset!");
static_assert(offsetof(USHGameplayMapBaseWidget, Anchor1WorldPosition) == 0x0002B0, "Member 'USHGameplayMapBaseWidget::Anchor1WorldPosition' has a wrong offset!");
static_assert(offsetof(USHGameplayMapBaseWidget, Anchor2WorldPosition) == 0x0002C8, "Member 'USHGameplayMapBaseWidget::Anchor2WorldPosition' has a wrong offset!");
static_assert(offsetof(USHGameplayMapBaseWidget, OwnerCharacter) == 0x0002E0, "Member 'USHGameplayMapBaseWidget::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHGameplayMapBaseWidget, MapFogRevealObjectToApplyWidgets) == 0x0002E8, "Member 'USHGameplayMapBaseWidget::MapFogRevealObjectToApplyWidgets' has a wrong offset!");
static_assert(offsetof(USHGameplayMapBaseWidget, TextWidgets) == 0x000320, "Member 'USHGameplayMapBaseWidget::TextWidgets' has a wrong offset!");
static_assert(offsetof(USHGameplayMapBaseWidget, LocalizedFont) == 0x000330, "Member 'USHGameplayMapBaseWidget::LocalizedFont' has a wrong offset!");

// Class SHProto.SHDoorsManagerComponent
// 0x0060 (0x0100 - 0x00A0)
class USHDoorsManagerComponent final : public UActorComponent
{
public:
	TArray<class USHDoorMovementComponent*>       RegisteredDoorMovementComponents;                  // 0x00A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class USHDoorAnimationsBaseSetData*, int32> RegisteredDoorAnimationsSets;                      // 0x00B0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDoorsManagerComponent">();
	}
	static class USHDoorsManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDoorsManagerComponent>();
	}
};
static_assert(alignof(USHDoorsManagerComponent) == 0x000008, "Wrong alignment on USHDoorsManagerComponent");
static_assert(sizeof(USHDoorsManagerComponent) == 0x000100, "Wrong size on USHDoorsManagerComponent");
static_assert(offsetof(USHDoorsManagerComponent, RegisteredDoorMovementComponents) == 0x0000A0, "Member 'USHDoorsManagerComponent::RegisteredDoorMovementComponents' has a wrong offset!");
static_assert(offsetof(USHDoorsManagerComponent, RegisteredDoorAnimationsSets) == 0x0000B0, "Member 'USHDoorsManagerComponent::RegisteredDoorAnimationsSets' has a wrong offset!");

// Class SHProto.SHDoubleDoorSD
// 0x0100 (0x03B0 - 0x02B0)
class ASHDoubleDoorSD final : public AActor
{
public:
	class UStaticMeshComponent*                   FrameMesh;                                         // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlaneSideDetectionComponent*           FramePlaneSideDetectionComponent;                  // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   LeftDoorMesh;                                      // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        LeftDoorMeshHandleSpotAbove;                       // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        LeftDoorMeshHandleSpotBelow;                       // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlaneSideDetectionComponent*           LeftDoorPlaneSideDetectionComponent;               // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          LeftDoorPreHitDetector;                            // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   RightDoorMesh;                                     // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RightDoorMeshHandleSpotAbove;                      // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RightDoorMeshHandleSpotBelow;                      // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlaneSideDetectionComponent*           RightDoorPlaneSideDetectionComponent;              // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          RightDoorPreHitDetector;                           // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionGenericComponent*         InteractionGeneric;                                // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractionProximitySphere;                        // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            InteractionIcon;                                   // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHRaycastDetectableComponent*          InteractionDetectable;                             // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractionDetectableShape;                        // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconSlotComponent*        InteractionIconSlotFront;                          // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconSlotComponent*        InteractionIconSlotBack;                           // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      LockAnimSpotAbove;                                 // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      LockAnimSpotBelow;                                 // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkDoorComponent*                     LeftSHAkDoorComponent;                             // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkDoorComponent*                     RightSHAkDoorComponent;                            // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          SHAkPortalBounds;                                  // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkPortalDoorComponent*               SHAkPortalDoorComponent;                           // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionManagerComponent*         InteractionManager;                                // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHDoorLockComponent*                   DoorLock;                                          // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHDoorAnimationsComponent*             DoorAnimations;                                    // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHDoorMovementComponent*               RightDoorMovement;                                 // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHDoorMovementComponent*               LeftDoorMovement;                                  // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayMapDoorComponent*            GameplayMapObject;                                 // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessDoorAlphaChanged(class USHDoorMovementBaseComponent* MovementComponent);
	void ProcessInteractionManagerInitialized(class USHInteractionManagerComponent* Manager);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDoubleDoorSD">();
	}
	static class ASHDoubleDoorSD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHDoubleDoorSD>();
	}
};
static_assert(alignof(ASHDoubleDoorSD) == 0x000008, "Wrong alignment on ASHDoubleDoorSD");
static_assert(sizeof(ASHDoubleDoorSD) == 0x0003B0, "Wrong size on ASHDoubleDoorSD");
static_assert(offsetof(ASHDoubleDoorSD, FrameMesh) == 0x0002B0, "Member 'ASHDoubleDoorSD::FrameMesh' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, FramePlaneSideDetectionComponent) == 0x0002B8, "Member 'ASHDoubleDoorSD::FramePlaneSideDetectionComponent' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, LeftDoorMesh) == 0x0002C0, "Member 'ASHDoubleDoorSD::LeftDoorMesh' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, LeftDoorMeshHandleSpotAbove) == 0x0002C8, "Member 'ASHDoubleDoorSD::LeftDoorMeshHandleSpotAbove' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, LeftDoorMeshHandleSpotBelow) == 0x0002D0, "Member 'ASHDoubleDoorSD::LeftDoorMeshHandleSpotBelow' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, LeftDoorPlaneSideDetectionComponent) == 0x0002D8, "Member 'ASHDoubleDoorSD::LeftDoorPlaneSideDetectionComponent' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, LeftDoorPreHitDetector) == 0x0002E0, "Member 'ASHDoubleDoorSD::LeftDoorPreHitDetector' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, RightDoorMesh) == 0x0002E8, "Member 'ASHDoubleDoorSD::RightDoorMesh' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, RightDoorMeshHandleSpotAbove) == 0x0002F0, "Member 'ASHDoubleDoorSD::RightDoorMeshHandleSpotAbove' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, RightDoorMeshHandleSpotBelow) == 0x0002F8, "Member 'ASHDoubleDoorSD::RightDoorMeshHandleSpotBelow' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, RightDoorPlaneSideDetectionComponent) == 0x000300, "Member 'ASHDoubleDoorSD::RightDoorPlaneSideDetectionComponent' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, RightDoorPreHitDetector) == 0x000308, "Member 'ASHDoubleDoorSD::RightDoorPreHitDetector' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, InteractionGeneric) == 0x000310, "Member 'ASHDoubleDoorSD::InteractionGeneric' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, InteractionProximitySphere) == 0x000318, "Member 'ASHDoubleDoorSD::InteractionProximitySphere' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, InteractionIcon) == 0x000320, "Member 'ASHDoubleDoorSD::InteractionIcon' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, InteractionDetectable) == 0x000328, "Member 'ASHDoubleDoorSD::InteractionDetectable' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, InteractionDetectableShape) == 0x000330, "Member 'ASHDoubleDoorSD::InteractionDetectableShape' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, InteractionIconSlotFront) == 0x000338, "Member 'ASHDoubleDoorSD::InteractionIconSlotFront' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, InteractionIconSlotBack) == 0x000340, "Member 'ASHDoubleDoorSD::InteractionIconSlotBack' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, LockAnimSpotAbove) == 0x000348, "Member 'ASHDoubleDoorSD::LockAnimSpotAbove' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, LockAnimSpotBelow) == 0x000350, "Member 'ASHDoubleDoorSD::LockAnimSpotBelow' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, LeftSHAkDoorComponent) == 0x000358, "Member 'ASHDoubleDoorSD::LeftSHAkDoorComponent' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, RightSHAkDoorComponent) == 0x000360, "Member 'ASHDoubleDoorSD::RightSHAkDoorComponent' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, SHAkPortalBounds) == 0x000368, "Member 'ASHDoubleDoorSD::SHAkPortalBounds' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, SHAkPortalDoorComponent) == 0x000370, "Member 'ASHDoubleDoorSD::SHAkPortalDoorComponent' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, InteractionManager) == 0x000378, "Member 'ASHDoubleDoorSD::InteractionManager' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, DoorLock) == 0x000380, "Member 'ASHDoubleDoorSD::DoorLock' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, DoorAnimations) == 0x000388, "Member 'ASHDoubleDoorSD::DoorAnimations' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, RightDoorMovement) == 0x000390, "Member 'ASHDoubleDoorSD::RightDoorMovement' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, LeftDoorMovement) == 0x000398, "Member 'ASHDoubleDoorSD::LeftDoorMovement' has a wrong offset!");
static_assert(offsetof(ASHDoubleDoorSD, GameplayMapObject) == 0x0003A0, "Member 'ASHDoubleDoorSD::GameplayMapObject' has a wrong offset!");

// Class SHProto.SHGameState
// 0x0000 (0x0300 - 0x0300)
class ASHGameState : public AGameStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameState">();
	}
	static class ASHGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHGameState>();
	}
};
static_assert(alignof(ASHGameState) == 0x000008, "Wrong alignment on ASHGameState");
static_assert(sizeof(ASHGameState) == 0x000300, "Wrong size on ASHGameState");

// Class SHProto.SHDynamicInteractionExecutive
// 0x0040 (0x02F0 - 0x02B0)
class ASHDynamicInteractionExecutive final : public AActor
{
public:
	class USHInteractionGenericComponent*         InteractionGeneric;                                // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractionProximitySphere;                        // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            InteractionIcon;                                   // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHRaycastDetectableComponent*          InteractionDetectable;                             // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractionDetectableShape;                        // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionManagerComponent*         InteractionManager;                                // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWantAutoAttachToOwnerContext;                     // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USHDynamicInteractionManagerComponent*  OwnerManager;                                      // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class AActor* GetOwnerContext();
	class USHDynamicInteractionManagerComponent* GetOwnerManager();
	void ProcessInteractionManagerInitialized(class USHInteractionManagerComponent* Manager);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDynamicInteractionExecutive">();
	}
	static class ASHDynamicInteractionExecutive* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHDynamicInteractionExecutive>();
	}
};
static_assert(alignof(ASHDynamicInteractionExecutive) == 0x000008, "Wrong alignment on ASHDynamicInteractionExecutive");
static_assert(sizeof(ASHDynamicInteractionExecutive) == 0x0002F0, "Wrong size on ASHDynamicInteractionExecutive");
static_assert(offsetof(ASHDynamicInteractionExecutive, InteractionGeneric) == 0x0002B0, "Member 'ASHDynamicInteractionExecutive::InteractionGeneric' has a wrong offset!");
static_assert(offsetof(ASHDynamicInteractionExecutive, InteractionProximitySphere) == 0x0002B8, "Member 'ASHDynamicInteractionExecutive::InteractionProximitySphere' has a wrong offset!");
static_assert(offsetof(ASHDynamicInteractionExecutive, InteractionIcon) == 0x0002C0, "Member 'ASHDynamicInteractionExecutive::InteractionIcon' has a wrong offset!");
static_assert(offsetof(ASHDynamicInteractionExecutive, InteractionDetectable) == 0x0002C8, "Member 'ASHDynamicInteractionExecutive::InteractionDetectable' has a wrong offset!");
static_assert(offsetof(ASHDynamicInteractionExecutive, InteractionDetectableShape) == 0x0002D0, "Member 'ASHDynamicInteractionExecutive::InteractionDetectableShape' has a wrong offset!");
static_assert(offsetof(ASHDynamicInteractionExecutive, InteractionManager) == 0x0002D8, "Member 'ASHDynamicInteractionExecutive::InteractionManager' has a wrong offset!");
static_assert(offsetof(ASHDynamicInteractionExecutive, bWantAutoAttachToOwnerContext) == 0x0002E0, "Member 'ASHDynamicInteractionExecutive::bWantAutoAttachToOwnerContext' has a wrong offset!");
static_assert(offsetof(ASHDynamicInteractionExecutive, OwnerManager) == 0x0002E8, "Member 'ASHDynamicInteractionExecutive::OwnerManager' has a wrong offset!");

// Class SHProto.SHPlaythroughMariaReceivedDamageEndingFactor
// 0x0000 (0x0088 - 0x0088)
class USHPlaythroughMariaReceivedDamageEndingFactor final : public USHIntEndingFactor
{
public:
	void SHDebug_Character_Endings_PlaythroughMariaReceivedDamageEndingFactor_SetDebugValue(int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPlaythroughMariaReceivedDamageEndingFactor">();
	}
	static class USHPlaythroughMariaReceivedDamageEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPlaythroughMariaReceivedDamageEndingFactor>();
	}
};
static_assert(alignof(USHPlaythroughMariaReceivedDamageEndingFactor) == 0x000008, "Wrong alignment on USHPlaythroughMariaReceivedDamageEndingFactor");
static_assert(sizeof(USHPlaythroughMariaReceivedDamageEndingFactor) == 0x000088, "Wrong size on USHPlaythroughMariaReceivedDamageEndingFactor");

// Class SHProto.InteriorExteriorManager
// 0x0010 (0x00B0 - 0x00A0)
class UInteriorExteriorManager final : public UActorComponent
{
public:
	TArray<class ASHInteriorExteriorVolume*>      InteriorExteriorVolumes;                           // 0x00A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UInteriorExteriorManager* GetInstance(class UObject* WorldContext);

	ESHInteriorExteriorStateEnum CalcInteriorExteriorState(class AActor* Actor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteriorExteriorManager">();
	}
	static class UInteriorExteriorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteriorExteriorManager>();
	}
};
static_assert(alignof(UInteriorExteriorManager) == 0x000008, "Wrong alignment on UInteriorExteriorManager");
static_assert(sizeof(UInteriorExteriorManager) == 0x0000B0, "Wrong size on UInteriorExteriorManager");
static_assert(offsetof(UInteriorExteriorManager, InteriorExteriorVolumes) == 0x0000A0, "Member 'UInteriorExteriorManager::InteriorExteriorVolumes' has a wrong offset!");

// Class SHProto.SHDynamicItem
// 0x0000 (0x03B0 - 0x03B0)
class ASHDynamicItem final : public ASHItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDynamicItem">();
	}
	static class ASHDynamicItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHDynamicItem>();
	}
};
static_assert(alignof(ASHDynamicItem) == 0x000008, "Wrong alignment on ASHDynamicItem");
static_assert(sizeof(ASHDynamicItem) == 0x0003B0, "Wrong size on ASHDynamicItem");

// Class SHProto.SHDynamicObjectsCustomStencilStatics
// 0x0000 (0x0028 - 0x0028)
class USHDynamicObjectsCustomStencilStatics final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetCustomStencilValue(const ESHCustomStencilDynamicObject DynamicObjectType);
	static void SetCustomStencilValue(class UPrimitiveComponent* InDynamicObjectPrimitive, const ESHCustomStencilDynamicObject DynamicObjectType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHDynamicObjectsCustomStencilStatics">();
	}
	static class USHDynamicObjectsCustomStencilStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHDynamicObjectsCustomStencilStatics>();
	}
};
static_assert(alignof(USHDynamicObjectsCustomStencilStatics) == 0x000008, "Wrong alignment on USHDynamicObjectsCustomStencilStatics");
static_assert(sizeof(USHDynamicObjectsCustomStencilStatics) == 0x000028, "Wrong size on USHDynamicObjectsCustomStencilStatics");

// Class SHProto.SHHealthBasedBorder
// 0x0020 (0x0390 - 0x0370)
class USHHealthBasedBorder final : public USHCustomBorder
{
public:
	float                                         ShowAnimationDurationSeconds;                      // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x0378(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_380[0x10];                                     // 0x0380(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHealthBasedBorder">();
	}
	static class USHHealthBasedBorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHHealthBasedBorder>();
	}
};
static_assert(alignof(USHHealthBasedBorder) == 0x000010, "Wrong alignment on USHHealthBasedBorder");
static_assert(sizeof(USHHealthBasedBorder) == 0x000390, "Wrong size on USHHealthBasedBorder");
static_assert(offsetof(USHHealthBasedBorder, ShowAnimationDurationSeconds) == 0x000370, "Member 'USHHealthBasedBorder::ShowAnimationDurationSeconds' has a wrong offset!");
static_assert(offsetof(USHHealthBasedBorder, OwnerCharacter) == 0x000378, "Member 'USHHealthBasedBorder::OwnerCharacter' has a wrong offset!");

// Class SHProto.SHEddieAnimComponent
// 0x00B8 (0x0548 - 0x0490)
class USHEddieAnimComponent final : public USHEnemyAnimComponent
{
public:
	struct FSHAnimHeadRotationBaseSubcompSettings HeadRotationSettings;                              // 0x0490(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSHAnimFootIKSubcompSettings           SHAnimFootIKSubcompSettings;                       // 0x04D8(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void SetEddieMovementState(ESHEddieAnimInstanceMovementState InMovementState, bool InMovementChangeInProgress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEddieAnimComponent">();
	}
	static class USHEddieAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEddieAnimComponent>();
	}
};
static_assert(alignof(USHEddieAnimComponent) == 0x000008, "Wrong alignment on USHEddieAnimComponent");
static_assert(sizeof(USHEddieAnimComponent) == 0x000548, "Wrong size on USHEddieAnimComponent");
static_assert(offsetof(USHEddieAnimComponent, HeadRotationSettings) == 0x000490, "Member 'USHEddieAnimComponent::HeadRotationSettings' has a wrong offset!");
static_assert(offsetof(USHEddieAnimComponent, SHAnimFootIKSubcompSettings) == 0x0004D8, "Member 'USHEddieAnimComponent::SHAnimFootIKSubcompSettings' has a wrong offset!");

// Class SHProto.SHProjectileFightable
// 0x0038 (0x0340 - 0x0308)
class ASHProjectileFightable final : public ASHProjectile
{
public:
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAllowedHeightDelta;                             // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAllowedDistanceToHitPoint2D;                    // 0x0314(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    SecondaryAttackDataRowHandle;                      // 0x0318(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x18];                                     // 0x0328(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDeactivated(const bool bDeactivated, const class UObject* Object);

	bool IsDeactivated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHProjectileFightable">();
	}
	static class ASHProjectileFightable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHProjectileFightable>();
	}
};
static_assert(alignof(ASHProjectileFightable) == 0x000008, "Wrong alignment on ASHProjectileFightable");
static_assert(sizeof(ASHProjectileFightable) == 0x000340, "Wrong size on ASHProjectileFightable");
static_assert(offsetof(ASHProjectileFightable, MaxAllowedHeightDelta) == 0x000310, "Member 'ASHProjectileFightable::MaxAllowedHeightDelta' has a wrong offset!");
static_assert(offsetof(ASHProjectileFightable, MaxAllowedDistanceToHitPoint2D) == 0x000314, "Member 'ASHProjectileFightable::MaxAllowedDistanceToHitPoint2D' has a wrong offset!");
static_assert(offsetof(ASHProjectileFightable, SecondaryAttackDataRowHandle) == 0x000318, "Member 'ASHProjectileFightable::SecondaryAttackDataRowHandle' has a wrong offset!");

// Class SHProto.SHEddieAnimInstanceStateData
// 0x0008 (0x0080 - 0x0078)
class USHEddieAnimInstanceStateData final : public USHMonsterAnimInstanceStateData
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEddieAnimInstanceStateData">();
	}
	static class USHEddieAnimInstanceStateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEddieAnimInstanceStateData>();
	}
};
static_assert(alignof(USHEddieAnimInstanceStateData) == 0x000008, "Wrong alignment on USHEddieAnimInstanceStateData");
static_assert(sizeof(USHEddieAnimInstanceStateData) == 0x000080, "Wrong size on USHEddieAnimInstanceStateData");

// Class SHProto.SHItemEmissiveDataHelper
// 0x0018 (0x00C8 - 0x00B0)
class USHItemEmissiveDataHelper final : public USHCustomPrimitiveDataHelper
{
public:
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InterpEmmisive(class UPrimitiveComponent* InComp, bool bShouldEmmisiveBeEnabled);
	void OverrideDisabledValue(class UObject* Requester, float InValue);
	void SetEmmisive(class UPrimitiveComponent* InComp, bool bShouldEmmisiveBeEnabled);

	float GetValue(bool bShouldEmmisiveBeEnabled) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemEmissiveDataHelper">();
	}
	static class USHItemEmissiveDataHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHItemEmissiveDataHelper>();
	}
};
static_assert(alignof(USHItemEmissiveDataHelper) == 0x000008, "Wrong alignment on USHItemEmissiveDataHelper");
static_assert(sizeof(USHItemEmissiveDataHelper) == 0x0000C8, "Wrong size on USHItemEmissiveDataHelper");

// Class SHProto.SHEddieLimpingLocomotionAnimInstance
// 0x0010 (0x03D0 - 0x03C0)
class USHEddieLimpingLocomotionAnimInstance final : public USHEddieLocomotionAnimInstance
{
public:
	ESHEddieLimpingAnimInstanceLocomotionState    LocomotionStateRequest;                            // 0x03C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C1[0xF];                                      // 0x03C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEddieLimpingLocomotionAnimInstance">();
	}
	static class USHEddieLimpingLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEddieLimpingLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHEddieLimpingLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHEddieLimpingLocomotionAnimInstance");
static_assert(sizeof(USHEddieLimpingLocomotionAnimInstance) == 0x0003D0, "Wrong size on USHEddieLimpingLocomotionAnimInstance");
static_assert(offsetof(USHEddieLimpingLocomotionAnimInstance, LocomotionStateRequest) == 0x0003C0, "Member 'USHEddieLimpingLocomotionAnimInstance::LocomotionStateRequest' has a wrong offset!");

// Class SHProto.SHEddieLookAtPlayerProvider
// 0x0008 (0x0070 - 0x0068)
class USHEddieLookAtPlayerProvider final : public USHLookAtTargetProvider
{
public:
	float                                         MaxDistance;                                       // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle;                                          // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEddieLookAtPlayerProvider">();
	}
	static class USHEddieLookAtPlayerProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEddieLookAtPlayerProvider>();
	}
};
static_assert(alignof(USHEddieLookAtPlayerProvider) == 0x000008, "Wrong alignment on USHEddieLookAtPlayerProvider");
static_assert(sizeof(USHEddieLookAtPlayerProvider) == 0x000070, "Wrong size on USHEddieLookAtPlayerProvider");
static_assert(offsetof(USHEddieLookAtPlayerProvider, MaxDistance) == 0x000068, "Member 'USHEddieLookAtPlayerProvider::MaxDistance' has a wrong offset!");
static_assert(offsetof(USHEddieLookAtPlayerProvider, MaxAngle) == 0x00006C, "Member 'USHEddieLookAtPlayerProvider::MaxAngle' has a wrong offset!");

// Class SHProto.SHGameplayControllerEffectsManager
// 0x00E8 (0x0188 - 0x00A0)
class USHGameplayControllerEffectsManager final : public UActorComponent
{
public:
	TMap<ESHControllerLightColorGameplayFeature, int32> GameplayFeatureLightPriority;                      // 0x00A0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<ESHControllerLightColorGameplayFeature, struct FSHControllerLightsSettings> CurrentGameplayFeaturesLightRequests;              // 0x00F0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class UControllerEffectsManager*              ControllerEffectManagerSubsystem;                  // 0x0140(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x40];                                     // 0x0148(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayControllerEffectsManager">();
	}
	static class USHGameplayControllerEffectsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayControllerEffectsManager>();
	}
};
static_assert(alignof(USHGameplayControllerEffectsManager) == 0x000008, "Wrong alignment on USHGameplayControllerEffectsManager");
static_assert(sizeof(USHGameplayControllerEffectsManager) == 0x000188, "Wrong size on USHGameplayControllerEffectsManager");
static_assert(offsetof(USHGameplayControllerEffectsManager, GameplayFeatureLightPriority) == 0x0000A0, "Member 'USHGameplayControllerEffectsManager::GameplayFeatureLightPriority' has a wrong offset!");
static_assert(offsetof(USHGameplayControllerEffectsManager, CurrentGameplayFeaturesLightRequests) == 0x0000F0, "Member 'USHGameplayControllerEffectsManager::CurrentGameplayFeaturesLightRequests' has a wrong offset!");
static_assert(offsetof(USHGameplayControllerEffectsManager, ControllerEffectManagerSubsystem) == 0x000140, "Member 'USHGameplayControllerEffectsManager::ControllerEffectManagerSubsystem' has a wrong offset!");

// Class SHProto.SHEddieRangedWeapon
// 0x0040 (0x0360 - 0x0320)
class ASHEddieRangedWeapon final : public ASHAIRangedWeapon
{
public:
	int32                                         AmmoCount;                                         // 0x0320(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxAmmoClip;                                       // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ReloadAmount;                                      // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Range;                                             // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CollisionRadius;                                   // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FireSocket;                                        // 0x0334(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MuzzleSocket;                                      // 0x033C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseCharacterMesh;                                  // 0x0344(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_345[0x3];                                      // 0x0345(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BBAmmoKeyName;                                     // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DebugTrace;                                        // 0x0350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          InfiniteAmmo;                                      // 0x0351(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_352[0xE];                                      // 0x0352(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Fire(struct FHitResult* FoundHit, class AActor* Parent);
	void OnFire();
	void OnReload();
	void Reload();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEddieRangedWeapon">();
	}
	static class ASHEddieRangedWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHEddieRangedWeapon>();
	}
};
static_assert(alignof(ASHEddieRangedWeapon) == 0x000010, "Wrong alignment on ASHEddieRangedWeapon");
static_assert(sizeof(ASHEddieRangedWeapon) == 0x000360, "Wrong size on ASHEddieRangedWeapon");
static_assert(offsetof(ASHEddieRangedWeapon, AmmoCount) == 0x000320, "Member 'ASHEddieRangedWeapon::AmmoCount' has a wrong offset!");
static_assert(offsetof(ASHEddieRangedWeapon, MaxAmmoClip) == 0x000324, "Member 'ASHEddieRangedWeapon::MaxAmmoClip' has a wrong offset!");
static_assert(offsetof(ASHEddieRangedWeapon, ReloadAmount) == 0x000328, "Member 'ASHEddieRangedWeapon::ReloadAmount' has a wrong offset!");
static_assert(offsetof(ASHEddieRangedWeapon, Range) == 0x00032C, "Member 'ASHEddieRangedWeapon::Range' has a wrong offset!");
static_assert(offsetof(ASHEddieRangedWeapon, CollisionRadius) == 0x000330, "Member 'ASHEddieRangedWeapon::CollisionRadius' has a wrong offset!");
static_assert(offsetof(ASHEddieRangedWeapon, FireSocket) == 0x000334, "Member 'ASHEddieRangedWeapon::FireSocket' has a wrong offset!");
static_assert(offsetof(ASHEddieRangedWeapon, MuzzleSocket) == 0x00033C, "Member 'ASHEddieRangedWeapon::MuzzleSocket' has a wrong offset!");
static_assert(offsetof(ASHEddieRangedWeapon, UseCharacterMesh) == 0x000344, "Member 'ASHEddieRangedWeapon::UseCharacterMesh' has a wrong offset!");
static_assert(offsetof(ASHEddieRangedWeapon, BBAmmoKeyName) == 0x000348, "Member 'ASHEddieRangedWeapon::BBAmmoKeyName' has a wrong offset!");
static_assert(offsetof(ASHEddieRangedWeapon, DebugTrace) == 0x000350, "Member 'ASHEddieRangedWeapon::DebugTrace' has a wrong offset!");
static_assert(offsetof(ASHEddieRangedWeapon, InfiniteAmmo) == 0x000351, "Member 'ASHEddieRangedWeapon::InfiniteAmmo' has a wrong offset!");

// Class SHProto.SHEffectsCmbSubcomp
// 0x0068 (0x00A0 - 0x0038)
class USHEffectsCmbSubcomp final : public USHCombatSubcomponentBase
{
public:
	class UMaterialInstanceDynamic*               DynamicMaterial;                                   // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x60];                                      // 0x0040(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEffectsCmbSubcomp">();
	}
	static class USHEffectsCmbSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEffectsCmbSubcomp>();
	}
};
static_assert(alignof(USHEffectsCmbSubcomp) == 0x000008, "Wrong alignment on USHEffectsCmbSubcomp");
static_assert(sizeof(USHEffectsCmbSubcomp) == 0x0000A0, "Wrong size on USHEffectsCmbSubcomp");
static_assert(offsetof(USHEffectsCmbSubcomp, DynamicMaterial) == 0x000038, "Member 'USHEffectsCmbSubcomp::DynamicMaterial' has a wrong offset!");

// Class SHProto.SHGameplayTutorialStatics
// 0x0000 (0x0028 - 0x0028)
class USHGameplayTutorialStatics final : public UBlueprintFunctionLibrary
{
public:
	static void ShowScriptedBreakGlassTutorial(class UObject* WorldContextObject);
	static void ShowScriptedBreakWallTutorial(class UObject* WorldContextObject);
	static void ShowScriptedPreTraversalTutorial(class UObject* WorldContextObject);
	static void ShowSprintTutorial(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayTutorialStatics">();
	}
	static class USHGameplayTutorialStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayTutorialStatics>();
	}
};
static_assert(alignof(USHGameplayTutorialStatics) == 0x000008, "Wrong alignment on USHGameplayTutorialStatics");
static_assert(sizeof(USHGameplayTutorialStatics) == 0x000028, "Wrong size on USHGameplayTutorialStatics");

// Class SHProto.SHEnemiesManageCmbSubcompSettings
// 0x0020 (0x0050 - 0x0030)
class USHEnemiesManageCmbSubcompSettings final : public UDataAsset
{
public:
	float                                         InDangerOnDelaySeconds;                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InDangerOffCooldownSeconds;                        // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyInSightClampRadius;                           // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyInSightMinDirectionDotProduct;                // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                LoudnessMeterRtpcObject;                           // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequiredLoudnessMeterRtpcValue;                    // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEnemiesManageCmbSubcompSettings">();
	}
	static class USHEnemiesManageCmbSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEnemiesManageCmbSubcompSettings>();
	}
};
static_assert(alignof(USHEnemiesManageCmbSubcompSettings) == 0x000008, "Wrong alignment on USHEnemiesManageCmbSubcompSettings");
static_assert(sizeof(USHEnemiesManageCmbSubcompSettings) == 0x000050, "Wrong size on USHEnemiesManageCmbSubcompSettings");
static_assert(offsetof(USHEnemiesManageCmbSubcompSettings, InDangerOnDelaySeconds) == 0x000030, "Member 'USHEnemiesManageCmbSubcompSettings::InDangerOnDelaySeconds' has a wrong offset!");
static_assert(offsetof(USHEnemiesManageCmbSubcompSettings, InDangerOffCooldownSeconds) == 0x000034, "Member 'USHEnemiesManageCmbSubcompSettings::InDangerOffCooldownSeconds' has a wrong offset!");
static_assert(offsetof(USHEnemiesManageCmbSubcompSettings, EnemyInSightClampRadius) == 0x000038, "Member 'USHEnemiesManageCmbSubcompSettings::EnemyInSightClampRadius' has a wrong offset!");
static_assert(offsetof(USHEnemiesManageCmbSubcompSettings, EnemyInSightMinDirectionDotProduct) == 0x00003C, "Member 'USHEnemiesManageCmbSubcompSettings::EnemyInSightMinDirectionDotProduct' has a wrong offset!");
static_assert(offsetof(USHEnemiesManageCmbSubcompSettings, LoudnessMeterRtpcObject) == 0x000040, "Member 'USHEnemiesManageCmbSubcompSettings::LoudnessMeterRtpcObject' has a wrong offset!");
static_assert(offsetof(USHEnemiesManageCmbSubcompSettings, RequiredLoudnessMeterRtpcValue) == 0x000048, "Member 'USHEnemiesManageCmbSubcompSettings::RequiredLoudnessMeterRtpcValue' has a wrong offset!");

// Class SHProto.SHEnemiesManageCmbSubcomp
// 0x0060 (0x0098 - 0x0038)
class USHEnemiesManageCmbSubcomp final : public USHCombatSubcomponentBase
{
public:
	class USHEnemiesManageCmbSubcompSettings*     Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x58];                                      // 0x0040(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableInDangerModeOverride(bool Override, bool Value);
	void RefreshInDangerInstant(const class UObject* Object);
	void SetCustomInDanger(const bool NewValue, const class UObject* Object);
	void SHDebug_Character_Combat_ForceDangerMode(bool Force, bool ForcedValue);

	TArray<class ACharacter*> FindNearbyDeadEnemies(float InRadius, float InMaxDeltaHeight) const;
	TArray<class ACharacter*> FindNearbyEnemies(float InRadius, float InMaxDeltaHeight) const;
	TArray<class ACharacter*> GetNearbyDeadEnemies() const;
	TArray<class ACharacter*> GetNearbyEnemies() const;
	bool HasAnyEnemyAggro(bool RequireAggressiveBehaviorStance) const;
	bool HasEnemyAggro(class APawn* CheckedEnemy, bool RequireAggressiveBehaviorStance) const;
	bool HasPrimaryEnemyAggro(bool RequireAggressiveBehaviorStance) const;
	bool IsDangerModeForced() const;
	bool IsInDanger() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEnemiesManageCmbSubcomp">();
	}
	static class USHEnemiesManageCmbSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEnemiesManageCmbSubcomp>();
	}
};
static_assert(alignof(USHEnemiesManageCmbSubcomp) == 0x000008, "Wrong alignment on USHEnemiesManageCmbSubcomp");
static_assert(sizeof(USHEnemiesManageCmbSubcomp) == 0x000098, "Wrong size on USHEnemiesManageCmbSubcomp");
static_assert(offsetof(USHEnemiesManageCmbSubcomp, Settings) == 0x000038, "Member 'USHEnemiesManageCmbSubcomp::Settings' has a wrong offset!");

// Class SHProto.SHEnemyCameraOverlapHandleComponent
// 0x0028 (0x00F0 - 0x00C8)
class USHEnemyCameraOverlapHandleComponent final : public USHPlayerCameraOverlapReceiveComponent
{
public:
	float                                         MinimumHiddenTime;                                 // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x24];                                      // 0x00CC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEnemyCameraOverlapHandleComponent">();
	}
	static class USHEnemyCameraOverlapHandleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEnemyCameraOverlapHandleComponent>();
	}
};
static_assert(alignof(USHEnemyCameraOverlapHandleComponent) == 0x000008, "Wrong alignment on USHEnemyCameraOverlapHandleComponent");
static_assert(sizeof(USHEnemyCameraOverlapHandleComponent) == 0x0000F0, "Wrong size on USHEnemyCameraOverlapHandleComponent");
static_assert(offsetof(USHEnemyCameraOverlapHandleComponent, MinimumHiddenTime) == 0x0000C8, "Member 'USHEnemyCameraOverlapHandleComponent::MinimumHiddenTime' has a wrong offset!");

// Class SHProto.SHFlickeringLightBase
// 0x00C0 (0x0370 - 0x02B0)
class ASHFlickeringLightBase : public AActor
{
public:
	class UAkAudioEvent*                          BuzzSound;                                         // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          OnOffSound;                                        // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnOffThreshold;                                    // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffThreshold;                                      // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuzzThreshold;                                     // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHFlickerGroupStatus>          GroupStates;                                       // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bEditModeEnabled;                                  // 0x02E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x5F];                                     // 0x02E1(0x005F)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           BuzzSoundComponent;                                // 0x0340(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSHFlickerGroup>                Groups;                                            // 0x0348(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSHFlickerLightSavedIntensities> SavedIntensities;                                  // 0x0358(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	bool                                          bEditModeEnabledPrev;                              // 0x0368(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_369[0x7];                                      // 0x0369(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<class ASHFlickeringLightBase*> GetAllFlickeringLights();

	ESHFlickerGroupState GetGroupState(class FName Group);
	void OnEditorRefresh();
	void OnPostConstruction();
	void PrepareFlickerGroups(float Temperature, float IntensityScale, bool ResetGroups);
	void SetGroupState(class FName Group, ESHFlickerGroupState State);
	void SetWantTickEnabled(bool bEnabled);
	void StartBuzzSound();
	void StepFlickersInEditor(float DeltaSeconds);
	void StopBuzzSound();
	void UpdateNativeFlickers(bool RandomFlickerEnabled, const struct FLinearColor& EmissionColor, bool EmissionReplaceMtl, bool EmissionReplaceLgh, float ExternalScaleLight, float ExternalScaleMaterial);
	void UpdateNativeParameters(bool EnableRandomFlicker, float LightIntensityMin, float LightIntensityMax, float BlinkingMin, float BlinkingMax, float ChangeTimeMin, float ChangeTimeMax, float ShutdownIntensity, float GentleShutdownTime, bool ForceGentleShutdown, bool BlinkingIsAbsolute);
	void UpdateOffTagsInGroups();
	void UpdateTemperatureAndBaseIntensity(float Temperature, float IntensityScale);

	bool EditModeEnabled() const;
	float GetAverageIntensity() const;
	int32 GetNumberOfBrokenComponents() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFlickeringLightBase">();
	}
	static class ASHFlickeringLightBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHFlickeringLightBase>();
	}
};
static_assert(alignof(ASHFlickeringLightBase) == 0x000008, "Wrong alignment on ASHFlickeringLightBase");
static_assert(sizeof(ASHFlickeringLightBase) == 0x000370, "Wrong size on ASHFlickeringLightBase");
static_assert(offsetof(ASHFlickeringLightBase, BuzzSound) == 0x0002B0, "Member 'ASHFlickeringLightBase::BuzzSound' has a wrong offset!");
static_assert(offsetof(ASHFlickeringLightBase, OnOffSound) == 0x0002B8, "Member 'ASHFlickeringLightBase::OnOffSound' has a wrong offset!");
static_assert(offsetof(ASHFlickeringLightBase, OnOffThreshold) == 0x0002C0, "Member 'ASHFlickeringLightBase::OnOffThreshold' has a wrong offset!");
static_assert(offsetof(ASHFlickeringLightBase, OffThreshold) == 0x0002C4, "Member 'ASHFlickeringLightBase::OffThreshold' has a wrong offset!");
static_assert(offsetof(ASHFlickeringLightBase, BuzzThreshold) == 0x0002C8, "Member 'ASHFlickeringLightBase::BuzzThreshold' has a wrong offset!");
static_assert(offsetof(ASHFlickeringLightBase, GroupStates) == 0x0002D0, "Member 'ASHFlickeringLightBase::GroupStates' has a wrong offset!");
static_assert(offsetof(ASHFlickeringLightBase, bEditModeEnabled) == 0x0002E0, "Member 'ASHFlickeringLightBase::bEditModeEnabled' has a wrong offset!");
static_assert(offsetof(ASHFlickeringLightBase, BuzzSoundComponent) == 0x000340, "Member 'ASHFlickeringLightBase::BuzzSoundComponent' has a wrong offset!");
static_assert(offsetof(ASHFlickeringLightBase, Groups) == 0x000348, "Member 'ASHFlickeringLightBase::Groups' has a wrong offset!");
static_assert(offsetof(ASHFlickeringLightBase, SavedIntensities) == 0x000358, "Member 'ASHFlickeringLightBase::SavedIntensities' has a wrong offset!");
static_assert(offsetof(ASHFlickeringLightBase, bEditModeEnabledPrev) == 0x000368, "Member 'ASHFlickeringLightBase::bEditModeEnabledPrev' has a wrong offset!");

// Class SHProto.SHMandarinUnderFXComponent
// 0x0008 (0x00F8 - 0x00F0)
class USHMandarinUnderFXComponent final : public USHFXComponent
{
public:
	class USHFXVisualHPSubcompSettings*           VisualHPSettings;                                  // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMandarinUnderFXComponent">();
	}
	static class USHMandarinUnderFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMandarinUnderFXComponent>();
	}
};
static_assert(alignof(USHMandarinUnderFXComponent) == 0x000008, "Wrong alignment on USHMandarinUnderFXComponent");
static_assert(sizeof(USHMandarinUnderFXComponent) == 0x0000F8, "Wrong size on USHMandarinUnderFXComponent");
static_assert(offsetof(USHMandarinUnderFXComponent, VisualHPSettings) == 0x0000F0, "Member 'USHMandarinUnderFXComponent::VisualHPSettings' has a wrong offset!");

// Class SHProto.SHPyramidHeadBossFXComponent
// 0x0008 (0x00F8 - 0x00F0)
class USHPyramidHeadBossFXComponent final : public USHFXComponent
{
public:
	class USHFXRaingWettingSubcompSettings*       RainWettingSettings;                               // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPyramidHeadBossFXComponent">();
	}
	static class USHPyramidHeadBossFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPyramidHeadBossFXComponent>();
	}
};
static_assert(alignof(USHPyramidHeadBossFXComponent) == 0x000008, "Wrong alignment on USHPyramidHeadBossFXComponent");
static_assert(sizeof(USHPyramidHeadBossFXComponent) == 0x0000F8, "Wrong size on USHPyramidHeadBossFXComponent");
static_assert(offsetof(USHPyramidHeadBossFXComponent, RainWettingSettings) == 0x0000F0, "Member 'USHPyramidHeadBossFXComponent::RainWettingSettings' has a wrong offset!");

// Class SHProto.SHEddieBossFXComponent
// 0x0010 (0x0120 - 0x0110)
class USHEddieBossFXComponent final : public USHBossBaseFXComponent
{
public:
	class USHFXBloodPuddleSubcompSettings*        BloodPuddleSettings;                               // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXFrozenBreathSubcompSettings*       FrozenBreathSettings;                              // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEddieBossFXComponent">();
	}
	static class USHEddieBossFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEddieBossFXComponent>();
	}
};
static_assert(alignof(USHEddieBossFXComponent) == 0x000008, "Wrong alignment on USHEddieBossFXComponent");
static_assert(sizeof(USHEddieBossFXComponent) == 0x000120, "Wrong size on USHEddieBossFXComponent");
static_assert(offsetof(USHEddieBossFXComponent, BloodPuddleSettings) == 0x000110, "Member 'USHEddieBossFXComponent::BloodPuddleSettings' has a wrong offset!");
static_assert(offsetof(USHEddieBossFXComponent, FrozenBreathSettings) == 0x000118, "Member 'USHEddieBossFXComponent::FrozenBreathSettings' has a wrong offset!");

// Class SHProto.SHFootstep
// 0x0000 (0x0500 - 0x0500)
class ASHFootstep final : public ABeingFootstep
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFootstep">();
	}
	static class ASHFootstep* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHFootstep>();
	}
};
static_assert(alignof(ASHFootstep) == 0x000008, "Wrong alignment on ASHFootstep");
static_assert(sizeof(ASHFootstep) == 0x000500, "Wrong size on ASHFootstep");

// Class SHProto.SHEnemyHitReactionSelectionComponent
// 0x0090 (0x0130 - 0x00A0)
class USHEnemyHitReactionSelectionComponent final : public UActorComponent
{
public:
	class USEnemyHitReactionSelection*            HitReactionSelectionConfiguration;                 // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSHEnemyHitReactionSelectionBoneGroup> BoneGroups;                                        // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bPrintDebug;                                       // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x77];                                      // 0x00B9(0x0077)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddHitReactionsBlocker(TScriptInterface<class ISHHitReactionSelectionHitReactionBlockerInterface> InHitReactionsBlocker);
	bool CountReceivedHitAndDecideResponse(float* OutDamageMultiplier, float* OutMaximumRemainingHealthFraction, ESHHitReactionSelectionHitResponseType* OutHitResponseType, class FName* OutHitResponseVariant, float* OutHitResponseDurationLimit, class FName* OutDeathVariant, const struct FVector& InDamageSourceLocation, const struct FHitResult& InHitInfo, const class UDamageType* InDamageType, class AActor* InDamageCauser, int32 InHitIdentifier, EMaiAggroStance InAggressionLevel, float InHealthFraction, const TArray<struct FSHHitReactionIdentifier>& InActiveHitReactions, const struct FSHEnemyHitReactionSelectionAllowedStates& InAllowedStates);
	void DecideHitResponse(float* OutDamageMultiplier, float* OutMaximumRemainingHealthFraction, ESHHitReactionSelectionHitResponseType* OutHitResponseType, class FName* OutHitResponseVariant, float* OutHitResponseDurationLimit, class FName* OutDeathVariant, TArray<class FName>* OutResetConsecutiveHitCounters, const struct FVector& InDamageSourceLocation, const struct FHitResult& InHitInfo, const class UDamageType* InDamageType, class AActor* InDamageCauser, EMaiAggroStance InAggressionLevel, float InHealthFraction, const TArray<struct FSHHitReactionIdentifier>& InActiveHitReactions, const struct FSHEnemyHitReactionSelectionAllowedStates& InAllowedStates);
	void IncrementActiveCountedHitsByDamage(int32 InHitIdentifier, const class UDamageType* InDamageType, class FName InHitBoneName, int32 InHitBoneShapeIndex);
	void RemoveHitReactionsBlocker(TScriptInterface<class ISHHitReactionSelectionHitReactionBlockerInterface> InHitReactionsBlocker);
	void ResetActiveCountedHitsOfCounterName(class FName InConsecutiveHitsCounterName);
	void ResetAllActiveCountedHits();
	void SetHitReactionSelectionConfiguration(class USEnemyHitReactionSelection* InConfiguration);
	void SetPrintHitReactionSelectionDebug(bool InPrintDebug);
	void StartHitResponseCooldownCounter(class FName InCounterName, float InCooldownTime, bool InResetCurrent);
	void StartHitResponseDefaultCooldownCounter(ESHHitReactionSelectionHitResponseType InHitResponse, float InCooldownTime, bool InResetCurrent);
	void StartHitResponseVariantCooldowns(ESHHitReactionSelectionHitResponseType InHitResponse, class FName InVariantName, float InAdditionalDuration, bool InResetCurrent);

	class FName FindHitsCounterNameUsedByBone(class FName InBoneName, int32 InBoneShapeIndex) const;
	class FName FindHitsCounterNameUsedByBonesGroup(class FName InBonesGroupName) const;
	int32 GetActiveCountedHitsOfCounterName(class FName InConsecutiveHitsCounterName) const;
	int32 GetActiveCountedHitsOfTimerUsedByBone(class FName InBoneName, int32 InBoneShapeIndex) const;
	int32 GetActiveCountedHitsOfTimerUsedByBoneGroup(class FName InBonesGroupName) const;
	float GetHitResponseCooldownCounterRemainingTime(class FName InCounterName) const;
	float GetHitResponseCooldownRemainingTime(ESHHitReactionSelectionHitResponseType InHitResponse, class FName InVariantName) const;
	float GetHitResponseDefaultCooldownRemainingTime(ESHHitReactionSelectionHitResponseType InHitResponse) const;
	bool IsUsingHitReactionSelectionConfiguration(class USEnemyHitReactionSelection* InConfiguration) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEnemyHitReactionSelectionComponent">();
	}
	static class USHEnemyHitReactionSelectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEnemyHitReactionSelectionComponent>();
	}
};
static_assert(alignof(USHEnemyHitReactionSelectionComponent) == 0x000008, "Wrong alignment on USHEnemyHitReactionSelectionComponent");
static_assert(sizeof(USHEnemyHitReactionSelectionComponent) == 0x000130, "Wrong size on USHEnemyHitReactionSelectionComponent");
static_assert(offsetof(USHEnemyHitReactionSelectionComponent, HitReactionSelectionConfiguration) == 0x0000A0, "Member 'USHEnemyHitReactionSelectionComponent::HitReactionSelectionConfiguration' has a wrong offset!");
static_assert(offsetof(USHEnemyHitReactionSelectionComponent, BoneGroups) == 0x0000A8, "Member 'USHEnemyHitReactionSelectionComponent::BoneGroups' has a wrong offset!");
static_assert(offsetof(USHEnemyHitReactionSelectionComponent, bPrintDebug) == 0x0000B8, "Member 'USHEnemyHitReactionSelectionComponent::bPrintDebug' has a wrong offset!");

// Class SHProto.SHHitReactionSelectionHitReactionBlockerInterface
// 0x0000 (0x0028 - 0x0028)
class ISHHitReactionSelectionHitReactionBlockerInterface final : public IInterface
{
public:
	struct FSHEnemyHitReactionSelectionAllowedStates GetHitReactionBlockerAllowedHitReactions() const;
	void GetHitReactionBlockerDebugDisplayName(class FString* OutDebugName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHitReactionSelectionHitReactionBlockerInterface">();
	}
	static class ISHHitReactionSelectionHitReactionBlockerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHHitReactionSelectionHitReactionBlockerInterface>();
	}
};
static_assert(alignof(ISHHitReactionSelectionHitReactionBlockerInterface) == 0x000008, "Wrong alignment on ISHHitReactionSelectionHitReactionBlockerInterface");
static_assert(sizeof(ISHHitReactionSelectionHitReactionBlockerInterface) == 0x000028, "Wrong size on ISHHitReactionSelectionHitReactionBlockerInterface");

// Class SHProto.SHFXWaterInteractionSubcomp
// 0x0030 (0x0068 - 0x0038)
class USHFXWaterInteractionSubcomp final : public USHFXSubcomponent
{
public:
	class USHFXWaterInteractionSubcompSettings*   Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetWaterInteractionBlocked(const bool IsBlock, const class UObject* Object);

	const TArray<struct FSHXWaterIntersection> GetCurrentIntersections() const;
	bool IsWaterInteractionBlocked() const;
	bool IsWaterInteractionBlockedBy(const class UObject* Object) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXWaterInteractionSubcomp">();
	}
	static class USHFXWaterInteractionSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXWaterInteractionSubcomp>();
	}
};
static_assert(alignof(USHFXWaterInteractionSubcomp) == 0x000008, "Wrong alignment on USHFXWaterInteractionSubcomp");
static_assert(sizeof(USHFXWaterInteractionSubcomp) == 0x000068, "Wrong size on USHFXWaterInteractionSubcomp");
static_assert(offsetof(USHFXWaterInteractionSubcomp, Settings) == 0x000038, "Member 'USHFXWaterInteractionSubcomp::Settings' has a wrong offset!");

// Class SHProto.SHEnemyLyingComponent
// 0x0200 (0x02A0 - 0x00A0)
class alignas(0x10) USHEnemyLyingComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             EventTransformationToLyingStarted;                 // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventTransformationToLyingPhaseChanged;            // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventTransformationToLyingEnded;                   // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventTransformationToStandingStarted;              // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventTransformationToStandingPhaseChanged;         // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventTransformationToStandingEnded;                // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventTransformationRequestsAIBlocking;             // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventTransformationRequestsControllerRotation;     // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bMoveMeshPivot;                                    // 0x0120(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TreatBaseMeshPivotHeightAsCapsuleScale;            // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMoveMesh;                                         // 0x0128(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TreatBaseMeshHeightAsCapsuleScale;                 // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoAssignLyingCapsules;                          // 0x0130(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LyingMeshAnchorMultiplier;                         // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LyingMeshAnchorHeightOffset;                       // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumLyingPitchAngle;                            // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumLyingPitchAngle;                            // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActorRotationToDesiredVelocityHalfTime;            // 0x0144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ActorRotationAllowUsingCurrentVelocityHACK;        // 0x0148(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_149[0x17];                                     // 0x0149(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class USHCaterpillarCapsuleComponent*         LyingCapsuleComponent;                             // 0x0160(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0xF0];                                     // 0x0168(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USHCaterpillarCapsuleComponent*> AdditionalExtendingCapsules;                       // 0x0258(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0x38];                                     // 0x0268(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAdditionalExtendingCapsule(class USHCaterpillarCapsuleComponent* InLyingCapsule);
	void AssignLyingCapsule(class USHCaterpillarCapsuleComponent* InLyingCapsule);
	void FinishDelayedRootRotation();
	void PostTeleportUpdate(bool InReExpandCapsules);
	void SetActorRotationAllowUsingCurrentVelocityHACK(bool InAllowVelocityHack);
	void SetLyingCapsulePosition(float InAnchorPosition, float InMaximumExtension);
	void SetManuallyDisabledLyingCapsuleCollisions(bool InDisableCollisions);
	void TransformToLying(class FName InTransformationReason, float InTransformationDuration, bool InDelayedRootRotation, bool InDisableAIDuringTransformation, bool InPreventControllerRotation, bool InRotateActorToDesiredVelocity, bool InRotateOutOfCollisionsDuringTransformation, bool InRotateOutOfCollisionsAfterTransformation, float InCapsuleAnchorPosition, float InMaximumCapsuleExtensionAlpha, bool InAlignCapsulesToSurface, bool InForceRestart);
	void TransformToStanding(class FName InTransformationReason, float InTransformationDuration, bool InDisableAIDuringTransformation, bool InPreventControllerRotation, bool InRotateActorToDesiredVelocity, bool InRotateActorToLyingCapsule, bool InForceRestart);

	void GetLyingExtensionScalars(float* OutTopScalar, float* OutBottomScalar, bool InClamped) const;
	float GetRemainingTransformationDuration() const;
	float GetTransformationAlpha() const;
	float GetTransformationProgress() const;
	bool IsLying(bool InIncludeTransformingInto, bool InIncludeTransformingOutOf) const;
	bool IsStanding(bool InIncludeTransformingInto, bool InIncludeTransformingOutOf) const;
	bool IsTransformationAwaitingDelayedRootRotation() const;
	bool IsTransformationWantingDisabledAI() const;
	bool IsTransformationWantingToPreventControllerRotation() const;
	bool IsTransforming() const;
	bool IsTransformingIntoLying() const;
	bool IsTransformingIntoStanding() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEnemyLyingComponent">();
	}
	static class USHEnemyLyingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEnemyLyingComponent>();
	}
};
static_assert(alignof(USHEnemyLyingComponent) == 0x000010, "Wrong alignment on USHEnemyLyingComponent");
static_assert(sizeof(USHEnemyLyingComponent) == 0x0002A0, "Wrong size on USHEnemyLyingComponent");
static_assert(offsetof(USHEnemyLyingComponent, EventTransformationToLyingStarted) == 0x0000A0, "Member 'USHEnemyLyingComponent::EventTransformationToLyingStarted' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, EventTransformationToLyingPhaseChanged) == 0x0000B0, "Member 'USHEnemyLyingComponent::EventTransformationToLyingPhaseChanged' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, EventTransformationToLyingEnded) == 0x0000C0, "Member 'USHEnemyLyingComponent::EventTransformationToLyingEnded' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, EventTransformationToStandingStarted) == 0x0000D0, "Member 'USHEnemyLyingComponent::EventTransformationToStandingStarted' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, EventTransformationToStandingPhaseChanged) == 0x0000E0, "Member 'USHEnemyLyingComponent::EventTransformationToStandingPhaseChanged' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, EventTransformationToStandingEnded) == 0x0000F0, "Member 'USHEnemyLyingComponent::EventTransformationToStandingEnded' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, EventTransformationRequestsAIBlocking) == 0x000100, "Member 'USHEnemyLyingComponent::EventTransformationRequestsAIBlocking' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, EventTransformationRequestsControllerRotation) == 0x000110, "Member 'USHEnemyLyingComponent::EventTransformationRequestsControllerRotation' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, bMoveMeshPivot) == 0x000120, "Member 'USHEnemyLyingComponent::bMoveMeshPivot' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, TreatBaseMeshPivotHeightAsCapsuleScale) == 0x000124, "Member 'USHEnemyLyingComponent::TreatBaseMeshPivotHeightAsCapsuleScale' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, bMoveMesh) == 0x000128, "Member 'USHEnemyLyingComponent::bMoveMesh' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, TreatBaseMeshHeightAsCapsuleScale) == 0x00012C, "Member 'USHEnemyLyingComponent::TreatBaseMeshHeightAsCapsuleScale' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, bAutoAssignLyingCapsules) == 0x000130, "Member 'USHEnemyLyingComponent::bAutoAssignLyingCapsules' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, LyingMeshAnchorMultiplier) == 0x000134, "Member 'USHEnemyLyingComponent::LyingMeshAnchorMultiplier' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, LyingMeshAnchorHeightOffset) == 0x000138, "Member 'USHEnemyLyingComponent::LyingMeshAnchorHeightOffset' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, MaximumLyingPitchAngle) == 0x00013C, "Member 'USHEnemyLyingComponent::MaximumLyingPitchAngle' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, MinimumLyingPitchAngle) == 0x000140, "Member 'USHEnemyLyingComponent::MinimumLyingPitchAngle' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, ActorRotationToDesiredVelocityHalfTime) == 0x000144, "Member 'USHEnemyLyingComponent::ActorRotationToDesiredVelocityHalfTime' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, ActorRotationAllowUsingCurrentVelocityHACK) == 0x000148, "Member 'USHEnemyLyingComponent::ActorRotationAllowUsingCurrentVelocityHACK' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, LyingCapsuleComponent) == 0x000160, "Member 'USHEnemyLyingComponent::LyingCapsuleComponent' has a wrong offset!");
static_assert(offsetof(USHEnemyLyingComponent, AdditionalExtendingCapsules) == 0x000258, "Member 'USHEnemyLyingComponent::AdditionalExtendingCapsules' has a wrong offset!");

// Class SHProto.SHEnemyTransformationStateComponent
// 0x0080 (0x0120 - 0x00A0)
class USHEnemyTransformationStateComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             EventTransformationStarted;                        // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventTransformationEnded;                          // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bDebugDisplayState;                                // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USHEnemyTransformationState*            ActiveTransformationState;                         // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ActiveTransformationVariant;                       // 0x00D0(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSHHitReactionSubcomponentSerializedData HitReactionsSaveData;                              // 0x00D8(0x0010)(Protected, NativeAccessSpecifierProtected)
	struct FSHBonePhysicsControllerPhysicsSerializedData BonePhysicsSaveData;                               // 0x00E8(0x0020)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyTransformationState(class USHEnemyTransformationState* InTransformationState, float InOverrideDuration, float InOverrideHitReactionsChangeDelay, float InOverrideLyingChangeDelay, float InOverrideLyingChangeDuration);
	void SetIsOtherWorldEnemy(bool InEnemyIsOW);

	class USHEnemyTransformationState* GetActiveTransformationState() const;
	float GetRemainingTransformationDuration() const;
	bool GetTransformationIsInProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHEnemyTransformationStateComponent">();
	}
	static class USHEnemyTransformationStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHEnemyTransformationStateComponent>();
	}
};
static_assert(alignof(USHEnemyTransformationStateComponent) == 0x000008, "Wrong alignment on USHEnemyTransformationStateComponent");
static_assert(sizeof(USHEnemyTransformationStateComponent) == 0x000120, "Wrong size on USHEnemyTransformationStateComponent");
static_assert(offsetof(USHEnemyTransformationStateComponent, EventTransformationStarted) == 0x0000A0, "Member 'USHEnemyTransformationStateComponent::EventTransformationStarted' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationStateComponent, EventTransformationEnded) == 0x0000B0, "Member 'USHEnemyTransformationStateComponent::EventTransformationEnded' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationStateComponent, bDebugDisplayState) == 0x0000C0, "Member 'USHEnemyTransformationStateComponent::bDebugDisplayState' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationStateComponent, ActiveTransformationState) == 0x0000C8, "Member 'USHEnemyTransformationStateComponent::ActiveTransformationState' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationStateComponent, ActiveTransformationVariant) == 0x0000D0, "Member 'USHEnemyTransformationStateComponent::ActiveTransformationVariant' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationStateComponent, HitReactionsSaveData) == 0x0000D8, "Member 'USHEnemyTransformationStateComponent::HitReactionsSaveData' has a wrong offset!");
static_assert(offsetof(USHEnemyTransformationStateComponent, BonePhysicsSaveData) == 0x0000E8, "Member 'USHEnemyTransformationStateComponent::BonePhysicsSaveData' has a wrong offset!");

// Class SHProto.SHFXAcidLayerSubcompSettings
// 0x0020 (0x0070 - 0x0050)
class USHFXAcidLayerSubcompSettings final : public USHFXMaterialModifierSubcompSettings
{
public:
	bool                                          EnableAcidLayer;                                   // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AcidCurve;                                         // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationTime;                                      // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AcidAudioEvent;                                    // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXAcidLayerSubcompSettings">();
	}
	static class USHFXAcidLayerSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXAcidLayerSubcompSettings>();
	}
};
static_assert(alignof(USHFXAcidLayerSubcompSettings) == 0x000008, "Wrong alignment on USHFXAcidLayerSubcompSettings");
static_assert(sizeof(USHFXAcidLayerSubcompSettings) == 0x000070, "Wrong size on USHFXAcidLayerSubcompSettings");
static_assert(offsetof(USHFXAcidLayerSubcompSettings, EnableAcidLayer) == 0x000050, "Member 'USHFXAcidLayerSubcompSettings::EnableAcidLayer' has a wrong offset!");
static_assert(offsetof(USHFXAcidLayerSubcompSettings, AcidCurve) == 0x000058, "Member 'USHFXAcidLayerSubcompSettings::AcidCurve' has a wrong offset!");
static_assert(offsetof(USHFXAcidLayerSubcompSettings, DurationTime) == 0x000060, "Member 'USHFXAcidLayerSubcompSettings::DurationTime' has a wrong offset!");
static_assert(offsetof(USHFXAcidLayerSubcompSettings, AcidAudioEvent) == 0x000068, "Member 'USHFXAcidLayerSubcompSettings::AcidAudioEvent' has a wrong offset!");

// Class SHProto.SHExtraHitAudioDataMappings
// 0x0050 (0x0080 - 0x0030)
class USHExtraHitAudioDataMappings final : public UDataAsset
{
public:
	TMap<TSubclassOf<class UDamageType>, struct FSHExtraHitAudioData> Mappings;                                          // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHExtraHitAudioDataMappings">();
	}
	static class USHExtraHitAudioDataMappings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHExtraHitAudioDataMappings>();
	}
};
static_assert(alignof(USHExtraHitAudioDataMappings) == 0x000008, "Wrong alignment on USHExtraHitAudioDataMappings");
static_assert(sizeof(USHExtraHitAudioDataMappings) == 0x000080, "Wrong size on USHExtraHitAudioDataMappings");
static_assert(offsetof(USHExtraHitAudioDataMappings, Mappings) == 0x000030, "Member 'USHExtraHitAudioDataMappings::Mappings' has a wrong offset!");

// Class SHProto.SHFakeDoorAnimationsSetData
// 0x0050 (0x0080 - 0x0030)
class USHFakeDoorAnimationsSetData final : public USHDoorAnimationsBaseSetData
{
public:
	TMap<class FName, struct FPlayAnimationData>  AutoLockedDoorCheckAnims;                          // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFakeDoorAnimationsSetData">();
	}
	static class USHFakeDoorAnimationsSetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFakeDoorAnimationsSetData>();
	}
};
static_assert(alignof(USHFakeDoorAnimationsSetData) == 0x000008, "Wrong alignment on USHFakeDoorAnimationsSetData");
static_assert(sizeof(USHFakeDoorAnimationsSetData) == 0x000080, "Wrong size on USHFakeDoorAnimationsSetData");
static_assert(offsetof(USHFakeDoorAnimationsSetData, AutoLockedDoorCheckAnims) == 0x000030, "Member 'USHFakeDoorAnimationsSetData::AutoLockedDoorCheckAnims' has a wrong offset!");

// Class SHProto.SHFakeMirrorComponent
// 0x0230 (0x0DA0 - 0x0B70)
class USHFakeMirrorComponent final : public USceneCaptureComponent2D
{
public:
	uint8                                         Pad_B70[0x154];                                    // 0x0B70(0x0154)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceFromCamera;                             // 0x0CC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClippingPlaneOffset;                               // 0x0CC8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CCC[0x4];                                      // 0x0CCC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MirrorEntityOffset;                                // 0x0CD0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MirrorEntityRotation;                              // 0x0CE8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MirrorBaseNormal;                                  // 0x0D00(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawContent;                                       // 0x0D18(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoNotMirror;                                       // 0x0D19(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoNotClip;                                         // 0x0D1A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1B[0x1];                                      // 0x0D1B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FrameCapture2DID;                                  // 0x0D1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoNotCheckVisibility;                              // 0x0D20(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GIShowFlags;                                       // 0x0D21(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowFakeInputs;                                   // 0x0D22(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FakePositionWhenNotVisible;                        // 0x0D23(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D24[0x4];                                      // 0x0D24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FakeCameraPosition;                                // 0x0D28(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FakeCameraRotation;                                // 0x0D40(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FakeCameraFOV;                                     // 0x0D58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5C[0x4];                                      // 0x0D5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MirrorCameraPosition;                              // 0x0D60(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MirrorCameraRotation;                              // 0x0D78(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MirrorCameraFOV;                                   // 0x0D90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D94[0xC];                                      // 0x0D94(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetRenderFactor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFakeMirrorComponent">();
	}
	static class USHFakeMirrorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFakeMirrorComponent>();
	}
};
static_assert(alignof(USHFakeMirrorComponent) == 0x000010, "Wrong alignment on USHFakeMirrorComponent");
static_assert(sizeof(USHFakeMirrorComponent) == 0x000DA0, "Wrong size on USHFakeMirrorComponent");
static_assert(offsetof(USHFakeMirrorComponent, MaxDistanceFromCamera) == 0x000CC4, "Member 'USHFakeMirrorComponent::MaxDistanceFromCamera' has a wrong offset!");
static_assert(offsetof(USHFakeMirrorComponent, ClippingPlaneOffset) == 0x000CC8, "Member 'USHFakeMirrorComponent::ClippingPlaneOffset' has a wrong offset!");
static_assert(offsetof(USHFakeMirrorComponent, MirrorEntityOffset) == 0x000CD0, "Member 'USHFakeMirrorComponent::MirrorEntityOffset' has a wrong offset!");
static_assert(offsetof(USHFakeMirrorComponent, MirrorEntityRotation) == 0x000CE8, "Member 'USHFakeMirrorComponent::MirrorEntityRotation' has a wrong offset!");
static_assert(offsetof(USHFakeMirrorComponent, MirrorBaseNormal) == 0x000D00, "Member 'USHFakeMirrorComponent::MirrorBaseNormal' has a wrong offset!");
static_assert(offsetof(USHFakeMirrorComponent, DrawContent) == 0x000D18, "Member 'USHFakeMirrorComponent::DrawContent' has a wrong offset!");
static_assert(offsetof(USHFakeMirrorComponent, DoNotMirror) == 0x000D19, "Member 'USHFakeMirrorComponent::DoNotMirror' has a wrong offset!");
static_assert(offsetof(USHFakeMirrorComponent, DoNotClip) == 0x000D1A, "Member 'USHFakeMirrorComponent::DoNotClip' has a wrong offset!");
static_assert(offsetof(USHFakeMirrorComponent, FrameCapture2DID) == 0x000D1C, "Member 'USHFakeMirrorComponent::FrameCapture2DID' has a wrong offset!");
static_assert(offsetof(USHFakeMirrorComponent, DoNotCheckVisibility) == 0x000D20, "Member 'USHFakeMirrorComponent::DoNotCheckVisibility' has a wrong offset!");
static_assert(offsetof(USHFakeMirrorComponent, GIShowFlags) == 0x000D21, "Member 'USHFakeMirrorComponent::GIShowFlags' has a wrong offset!");
static_assert(offsetof(USHFakeMirrorComponent, AllowFakeInputs) == 0x000D22, "Member 'USHFakeMirrorComponent::AllowFakeInputs' has a wrong offset!");
static_assert(offsetof(USHFakeMirrorComponent, FakePositionWhenNotVisible) == 0x000D23, "Member 'USHFakeMirrorComponent::FakePositionWhenNotVisible' has a wrong offset!");
static_assert(offsetof(USHFakeMirrorComponent, FakeCameraPosition) == 0x000D28, "Member 'USHFakeMirrorComponent::FakeCameraPosition' has a wrong offset!");
static_assert(offsetof(USHFakeMirrorComponent, FakeCameraRotation) == 0x000D40, "Member 'USHFakeMirrorComponent::FakeCameraRotation' has a wrong offset!");
static_assert(offsetof(USHFakeMirrorComponent, FakeCameraFOV) == 0x000D58, "Member 'USHFakeMirrorComponent::FakeCameraFOV' has a wrong offset!");
static_assert(offsetof(USHFakeMirrorComponent, MirrorCameraPosition) == 0x000D60, "Member 'USHFakeMirrorComponent::MirrorCameraPosition' has a wrong offset!");
static_assert(offsetof(USHFakeMirrorComponent, MirrorCameraRotation) == 0x000D78, "Member 'USHFakeMirrorComponent::MirrorCameraRotation' has a wrong offset!");
static_assert(offsetof(USHFakeMirrorComponent, MirrorCameraFOV) == 0x000D90, "Member 'USHFakeMirrorComponent::MirrorCameraFOV' has a wrong offset!");

// Class SHProto.SHGameplayMenuSectionsButton
// 0x0020 (0x0298 - 0x0278)
class USHGameplayMenuSectionsButton final : public UUserWidget
{
public:
	class UButton*                                ButtonCore;                                        // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ButtonTextBlock;                                   // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHGameplayMenuWidget*                  WidgetOwner;                                       // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ButtonPressed();
	void OnSetHighlight(bool Enable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayMenuSectionsButton">();
	}
	static class USHGameplayMenuSectionsButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayMenuSectionsButton>();
	}
};
static_assert(alignof(USHGameplayMenuSectionsButton) == 0x000008, "Wrong alignment on USHGameplayMenuSectionsButton");
static_assert(sizeof(USHGameplayMenuSectionsButton) == 0x000298, "Wrong size on USHGameplayMenuSectionsButton");
static_assert(offsetof(USHGameplayMenuSectionsButton, ButtonCore) == 0x000278, "Member 'USHGameplayMenuSectionsButton::ButtonCore' has a wrong offset!");
static_assert(offsetof(USHGameplayMenuSectionsButton, ButtonTextBlock) == 0x000280, "Member 'USHGameplayMenuSectionsButton::ButtonTextBlock' has a wrong offset!");
static_assert(offsetof(USHGameplayMenuSectionsButton, WidgetOwner) == 0x000288, "Member 'USHGameplayMenuSectionsButton::WidgetOwner' has a wrong offset!");

// Class SHProto.SHFlashlightLookAtTransformProcessor
// 0x0060 (0x0090 - 0x0030)
class USHFlashlightLookAtTransformProcessor final : public USHFlashlightTransformProcessor
{
public:
	class USceneComponent*                        LookAtRef;                                         // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFlashlightLookAtTransformProcessor">();
	}
	static class USHFlashlightLookAtTransformProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFlashlightLookAtTransformProcessor>();
	}
};
static_assert(alignof(USHFlashlightLookAtTransformProcessor) == 0x000008, "Wrong alignment on USHFlashlightLookAtTransformProcessor");
static_assert(sizeof(USHFlashlightLookAtTransformProcessor) == 0x000090, "Wrong size on USHFlashlightLookAtTransformProcessor");
static_assert(offsetof(USHFlashlightLookAtTransformProcessor, LookAtRef) == 0x000030, "Member 'USHFlashlightLookAtTransformProcessor::LookAtRef' has a wrong offset!");

// Class SHProto.SHFlashlightPlainSocketTransformProcessor
// 0x0050 (0x0080 - 0x0030)
class USHFlashlightPlainSocketTransformProcessor final : public USHFlashlightTransformProcessor
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFlashlightPlainSocketTransformProcessor">();
	}
	static class USHFlashlightPlainSocketTransformProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFlashlightPlainSocketTransformProcessor>();
	}
};
static_assert(alignof(USHFlashlightPlainSocketTransformProcessor) == 0x000008, "Wrong alignment on USHFlashlightPlainSocketTransformProcessor");
static_assert(sizeof(USHFlashlightPlainSocketTransformProcessor) == 0x000080, "Wrong size on USHFlashlightPlainSocketTransformProcessor");

// Class SHProto.SHFleshLipAnimComponent
// 0x0000 (0x0490 - 0x0490)
class USHFleshLipAnimComponent final : public USHEnemyAnimComponent
{
public:
	void SetFleshLipLeftArmIsReleased(bool InIsReleased);
	void SetFleshLipLegsAreReleased(bool InAreReleased);
	void SetFleshLipRightArmIsReleased(bool InIsReleased);
	void SetFleshLipTransformationState(ESHFleshLipAnimInstanceTransformationState InFleshLipTransformation, bool InIsTransforming);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFleshLipAnimComponent">();
	}
	static class USHFleshLipAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFleshLipAnimComponent>();
	}
};
static_assert(alignof(USHFleshLipAnimComponent) == 0x000008, "Wrong alignment on USHFleshLipAnimComponent");
static_assert(sizeof(USHFleshLipAnimComponent) == 0x000490, "Wrong size on USHFleshLipAnimComponent");

// Class SHProto.SHFleshLipAnimInstanceStateData
// 0x0008 (0x0080 - 0x0078)
class USHFleshLipAnimInstanceStateData final : public USHMonsterAnimInstanceStateData
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFleshLipAnimInstanceStateData">();
	}
	static class USHFleshLipAnimInstanceStateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFleshLipAnimInstanceStateData>();
	}
};
static_assert(alignof(USHFleshLipAnimInstanceStateData) == 0x000008, "Wrong alignment on USHFleshLipAnimInstanceStateData");
static_assert(sizeof(USHFleshLipAnimInstanceStateData) == 0x000080, "Wrong size on USHFleshLipAnimInstanceStateData");

// Class SHProto.SHFleshLipCeilingTileActor
// 0x0050 (0x0300 - 0x02B0)
class ASHFleshLipCeilingTileActor final : public AActor
{
public:
	FMulticastInlineDelegateProperty_             EventCeilingTileDisconnected;                      // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventCeilingTileDestroyed;                         // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x30];                                     // 0x02D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DamageCeilingTile(const struct FVector& InHitLocation, const struct FVector& InDropVelocity, const struct FVector& InDropRotation);
	void DisconnectCeilingTile(const struct FVector& InDropVelocity, const struct FVector& InDropRotation);
	void SetIgnoreCollisionsWithActor_Implementation(class AActor* InActor, bool InIgnoreCollision);
	void TileDamaged(const struct FVector& InHitLocation, const struct FVector& InDropVelocity, const struct FVector& InDropRotation);
	void TileDisconnected(bool InAsHanging, const struct FVector& InDropVelocity, const struct FVector& InDropRotation);
	void TileInitialized();

	void GetTileCoordinates(int32* OutTileX, int32* OutTileY) const;
	int32 GetTileDamageLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFleshLipCeilingTileActor">();
	}
	static class ASHFleshLipCeilingTileActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHFleshLipCeilingTileActor>();
	}
};
static_assert(alignof(ASHFleshLipCeilingTileActor) == 0x000008, "Wrong alignment on ASHFleshLipCeilingTileActor");
static_assert(sizeof(ASHFleshLipCeilingTileActor) == 0x000300, "Wrong size on ASHFleshLipCeilingTileActor");
static_assert(offsetof(ASHFleshLipCeilingTileActor, EventCeilingTileDisconnected) == 0x0002B0, "Member 'ASHFleshLipCeilingTileActor::EventCeilingTileDisconnected' has a wrong offset!");
static_assert(offsetof(ASHFleshLipCeilingTileActor, EventCeilingTileDestroyed) == 0x0002C0, "Member 'ASHFleshLipCeilingTileActor::EventCeilingTileDestroyed' has a wrong offset!");

// Class SHProto.SHFleshLipFallenLocomotionAnimInstance
// 0x0000 (0x0460 - 0x0460)
class USHFleshLipFallenLocomotionAnimInstance final : public USHFleshLipLocomotionAnimInstance
{
public:
	ESHFleshLipFallenAnimInstanceLocomotionState  LocomotionState;                                   // 0x0458(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_459[0x7];                                      // 0x0459(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFleshLipFallenLocomotionAnimInstance">();
	}
	static class USHFleshLipFallenLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFleshLipFallenLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHFleshLipFallenLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHFleshLipFallenLocomotionAnimInstance");
static_assert(sizeof(USHFleshLipFallenLocomotionAnimInstance) == 0x000460, "Wrong size on USHFleshLipFallenLocomotionAnimInstance");
static_assert(offsetof(USHFleshLipFallenLocomotionAnimInstance, LocomotionState) == 0x000458, "Member 'USHFleshLipFallenLocomotionAnimInstance::LocomotionState' has a wrong offset!");

// Class SHProto.SHFleshLipHangingLocomotionAnimInstance
// 0x0000 (0x0460 - 0x0460)
class USHFleshLipHangingLocomotionAnimInstance final : public USHFleshLipLocomotionAnimInstance
{
public:
	ESHFleshLipHangingAnimInstanceLocomotionState LocomotionState;                                   // 0x0458(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_459[0x7];                                      // 0x0459(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFleshLipHangingLocomotionAnimInstance">();
	}
	static class USHFleshLipHangingLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFleshLipHangingLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHFleshLipHangingLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHFleshLipHangingLocomotionAnimInstance");
static_assert(sizeof(USHFleshLipHangingLocomotionAnimInstance) == 0x000460, "Wrong size on USHFleshLipHangingLocomotionAnimInstance");
static_assert(offsetof(USHFleshLipHangingLocomotionAnimInstance, LocomotionState) == 0x000458, "Member 'USHFleshLipHangingLocomotionAnimInstance::LocomotionState' has a wrong offset!");

// Class SHProto.SHFleshLipTransformationState
// 0x0048 (0x0118 - 0x00D0)
class USHFleshLipTransformationState final : public USHEnemyTransformationState
{
public:
	ESHFleshLipTransformationState                FleshLipTransformationState;                       // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GrabPointSearchOffset;                             // 0x00D8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMaintainRotation;                                 // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseOverrides;                                     // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F2[0x2];                                       // 0x00F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHFleshLipTransformationStateCurves   TransformationCurveOverrides;                      // 0x00F4(0x0024)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	ESHFleshLipTransformationState GetFleshLipTransformationState() const;
	const struct FVector GetGrabPointSearchOffset() const;
	bool GetShouldRotationBeMaintained() const;
	void GetTransformationOverrides(bool* OutShouldBeUsed, struct FSHFleshLipTransformationStateCurves* OutCurves) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFleshLipTransformationState">();
	}
	static class USHFleshLipTransformationState* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFleshLipTransformationState>();
	}
};
static_assert(alignof(USHFleshLipTransformationState) == 0x000008, "Wrong alignment on USHFleshLipTransformationState");
static_assert(sizeof(USHFleshLipTransformationState) == 0x000118, "Wrong size on USHFleshLipTransformationState");
static_assert(offsetof(USHFleshLipTransformationState, FleshLipTransformationState) == 0x0000D0, "Member 'USHFleshLipTransformationState::FleshLipTransformationState' has a wrong offset!");
static_assert(offsetof(USHFleshLipTransformationState, GrabPointSearchOffset) == 0x0000D8, "Member 'USHFleshLipTransformationState::GrabPointSearchOffset' has a wrong offset!");
static_assert(offsetof(USHFleshLipTransformationState, bMaintainRotation) == 0x0000F0, "Member 'USHFleshLipTransformationState::bMaintainRotation' has a wrong offset!");
static_assert(offsetof(USHFleshLipTransformationState, bUseOverrides) == 0x0000F1, "Member 'USHFleshLipTransformationState::bUseOverrides' has a wrong offset!");
static_assert(offsetof(USHFleshLipTransformationState, TransformationCurveOverrides) == 0x0000F4, "Member 'USHFleshLipTransformationState::TransformationCurveOverrides' has a wrong offset!");

// Class SHProto.SHFlickeringLightManagerComponent
// 0x0020 (0x00C0 - 0x00A0)
class USHFlickeringLightManagerComponent final : public UActorComponent
{
public:
	TArray<class ASHFlickeringLightBase*>         RegisteredFlickeringLights;                        // 0x00A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class USpotLightWithShadowDistanceComponent*> RegisteredSpotLightsWithShadowDistance;            // 0x00B0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFlickeringLightManagerComponent">();
	}
	static class USHFlickeringLightManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFlickeringLightManagerComponent>();
	}
};
static_assert(alignof(USHFlickeringLightManagerComponent) == 0x000008, "Wrong alignment on USHFlickeringLightManagerComponent");
static_assert(sizeof(USHFlickeringLightManagerComponent) == 0x0000C0, "Wrong size on USHFlickeringLightManagerComponent");
static_assert(offsetof(USHFlickeringLightManagerComponent, RegisteredFlickeringLights) == 0x0000A0, "Member 'USHFlickeringLightManagerComponent::RegisteredFlickeringLights' has a wrong offset!");
static_assert(offsetof(USHFlickeringLightManagerComponent, RegisteredSpotLightsWithShadowDistance) == 0x0000B0, "Member 'USHFlickeringLightManagerComponent::RegisteredSpotLightsWithShadowDistance' has a wrong offset!");

// Class SHProto.SHFocusableComponent
// 0x02A0 (0x0340 - 0x00A0)
class alignas(0x10) USHFocusableComponent final : public UActorComponent
{
public:
	bool                                          bUseDynamicFocusableType;                          // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESHFocusableTypeEnum                          FocusableType;                                     // 0x00A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bManualQuitInputHandling;                          // 0x00A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A3[0x5];                                       // 0x00A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESHItemTypeEnum>                       MiniInventoryTypesFilter;                          // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDataTableRowHandle>            ControlTipsSet;                                    // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     FocusTranslucentMaterial;                          // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class UAkRtpc*, struct FVector2D>        HideShowRTPCsConfig;                               // 0x00D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bPlayOnSolvedAudio;                                // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideCharacterPlayWhileInteraction;                // 0x0121(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUnequipCharacterPlayWeaponOnInteraction;          // 0x0122(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTeleportPlayerOnInteraction;                      // 0x0123(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTeleportPlayerOnSolved;                           // 0x0124(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTeleportMariaWhenTeleportngPlayer;                // 0x0125(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowCameraRotation;                              // 0x0126(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_127[0x1];                                      // 0x0127(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraRotationPitchLimit;                          // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraRotationYawLimit;                            // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraRotationDeltaInputMul;                       // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraRotationScaleInputMul;                       // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraRotationInterpSpeed;                         // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeightedBlendable>             OnShowCameraBlendables;                            // 0x0140(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	ESHNavigationLoopOption                       GenericNavigationLoopOption;                       // 0x0150(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GenericNavigationPerpendicularIgnoreZoneDot;       // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GenericNavigationDistanceScoreMultiplier;          // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GenericNavigationDotScoreMultiplier;               // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEffectHandle                          SolveLightEffect;                                  // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bDisableOwnerTickWhenHidden;                       // 0x0168(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSetupShow;                                       // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShow;                                            // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHide;                                            // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBreak;                                           // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSolved;                                          // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMiniInventoryClosed;                             // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTranscriptionClosed;                             // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemSelected;                                    // 0x01E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInputAction;                                     // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ACharacter*                             InteractingCharacter;                              // 0x0200(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       FocusCamera;                                       // 0x0208(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionGenericComponent*         InteractionGeneric;                                // 0x0210(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      TeleportMariaCapsuleComponent;                     // 0x0218(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        FlashlightFocusSpotComponent;                      // 0x0220(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        FlashlightSourceSpotComponent;                     // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        FocusExtraLightsContainer;                         // 0x0230(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UCapsuleComponent*>              TeleportPlayerCapsuleComponents;                   // 0x0238(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsCompleted;                                      // 0x0248(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_249[0xF7];                                     // 0x0249(0x00F7)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConsumeCurrentItem(bool SetPuzzleAsSolved);
	void FocusableEvent__DelegateSignature();
	void FocusableExEvent__DelegateSignature(class USHFocusableComponent* ComponentPtr);
	void FocusableInputAction__DelegateSignature(ESHFocusableInputActionTypeEnum InputActionType, float KeyValue);
	void FocusableItemEvent__DelegateSignature(class FName ItemRowName);
	void HideMiniInventoryRequest(bool bInstant);
	void HideRequest();
	void Interact(class USHInteractionGenericComponent* Generic, class ASHCharacterPlay* Character);
	void PlayItemSelectedAudio(bool IsCorrectItem);
	void PlayWrongItemMiniInventoryAnim();
	void ProcessCombatInputModeChangedEvent(class USHCharacterPlayCombatComponent* CombatComp);
	void ProcessReceiveDamageEvent(class USHCharacterPlayCombatComponent* CombatComp);
	void RegisterComponents(class UCameraComponent* InCameraComponent, class USHInteractionGenericComponent* InInteractionGenericComponent);
	void RegisterExtraLightsContainer(class USceneComponent* InFocusExtraLightsContainer);
	void RegisterFlashlightFocusSpotComponent(class USceneComponent* InSceneComponent);
	void RegisterFlashlightSourceSpotComponent(class USceneComponent* InSceneComponent);
	void RegisterTeleportMariaCapsuleComponent(class UCapsuleComponent* InCapsuleComponent);
	void RegisterTeleportPlayerCapsuleComponent(class UCapsuleComponent* InCapsuleComponent);
	void RequestPlayOnSolvedAudio();
	void RequestUpdateFlashlightFocus();
	void ResetCameraRotation();
	void SetControlTips(const TArray<struct FDataTableRowHandle>& TipSet);
	void SetDefaultControlTips();
	void SetInputBlocked(const bool Blocked, const class UObject* Object);
	void SetInteractBlocked(const bool Blocked, const class UObject* Object);
	void SetSolved();
	void ShowCombinedTranscriptsRequest(const TArray<class USHTranscriptData*>& InTranscripts, const class FString& InJoinDelimiter);
	void ShowMiniInventoryRequest(bool bInstant);
	void ShowTranscriptRequest(TSoftObjectPtr<class USHTranscriptData> InTranscriptData);

	int32 GenericNavigation_CalculateIndex(const struct FVector2D& InInput, const TArray<class USceneComponent*>& InSlotArray, int32 InCurrentSlotIndex) const;
	int32 GenericNavigation_CalculateIndex_Impl(const struct FVector2D& InInput, const TArray<struct FVector>& InWorldLocationsArray, int32 InCurrentSlotIndex) const;
	struct FVector2D GenericNavigation_NavigateInputAction(const float InputValue, const struct FVector2D& CurrentInput, const ESHFocusableInputActionTypeEnum InputAction) const;
	class ACharacter* GetInteractingCharacter() const;
	TArray<ESHItemTypeEnum> GetMiniInventoryTypesFilter() const;
	bool IsCameraRotationAllowed() const;
	bool IsInputBlocked() const;
	bool IsInteractBlocked() const;
	bool IsMiniInventoryShown() const;
	bool IsShown() const;
	bool IsSolved() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFocusableComponent">();
	}
	static class USHFocusableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFocusableComponent>();
	}
};
static_assert(alignof(USHFocusableComponent) == 0x000010, "Wrong alignment on USHFocusableComponent");
static_assert(sizeof(USHFocusableComponent) == 0x000340, "Wrong size on USHFocusableComponent");
static_assert(offsetof(USHFocusableComponent, bUseDynamicFocusableType) == 0x0000A0, "Member 'USHFocusableComponent::bUseDynamicFocusableType' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, FocusableType) == 0x0000A1, "Member 'USHFocusableComponent::FocusableType' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, bManualQuitInputHandling) == 0x0000A2, "Member 'USHFocusableComponent::bManualQuitInputHandling' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, MiniInventoryTypesFilter) == 0x0000A8, "Member 'USHFocusableComponent::MiniInventoryTypesFilter' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, ControlTipsSet) == 0x0000B8, "Member 'USHFocusableComponent::ControlTipsSet' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, FocusTranslucentMaterial) == 0x0000C8, "Member 'USHFocusableComponent::FocusTranslucentMaterial' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, HideShowRTPCsConfig) == 0x0000D0, "Member 'USHFocusableComponent::HideShowRTPCsConfig' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, bPlayOnSolvedAudio) == 0x000120, "Member 'USHFocusableComponent::bPlayOnSolvedAudio' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, bHideCharacterPlayWhileInteraction) == 0x000121, "Member 'USHFocusableComponent::bHideCharacterPlayWhileInteraction' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, bUnequipCharacterPlayWeaponOnInteraction) == 0x000122, "Member 'USHFocusableComponent::bUnequipCharacterPlayWeaponOnInteraction' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, bTeleportPlayerOnInteraction) == 0x000123, "Member 'USHFocusableComponent::bTeleportPlayerOnInteraction' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, bTeleportPlayerOnSolved) == 0x000124, "Member 'USHFocusableComponent::bTeleportPlayerOnSolved' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, bTeleportMariaWhenTeleportngPlayer) == 0x000125, "Member 'USHFocusableComponent::bTeleportMariaWhenTeleportngPlayer' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, bAllowCameraRotation) == 0x000126, "Member 'USHFocusableComponent::bAllowCameraRotation' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, CameraRotationPitchLimit) == 0x000128, "Member 'USHFocusableComponent::CameraRotationPitchLimit' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, CameraRotationYawLimit) == 0x00012C, "Member 'USHFocusableComponent::CameraRotationYawLimit' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, CameraRotationDeltaInputMul) == 0x000130, "Member 'USHFocusableComponent::CameraRotationDeltaInputMul' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, CameraRotationScaleInputMul) == 0x000134, "Member 'USHFocusableComponent::CameraRotationScaleInputMul' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, CameraRotationInterpSpeed) == 0x000138, "Member 'USHFocusableComponent::CameraRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, OnShowCameraBlendables) == 0x000140, "Member 'USHFocusableComponent::OnShowCameraBlendables' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, GenericNavigationLoopOption) == 0x000150, "Member 'USHFocusableComponent::GenericNavigationLoopOption' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, GenericNavigationPerpendicularIgnoreZoneDot) == 0x000154, "Member 'USHFocusableComponent::GenericNavigationPerpendicularIgnoreZoneDot' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, GenericNavigationDistanceScoreMultiplier) == 0x000158, "Member 'USHFocusableComponent::GenericNavigationDistanceScoreMultiplier' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, GenericNavigationDotScoreMultiplier) == 0x00015C, "Member 'USHFocusableComponent::GenericNavigationDotScoreMultiplier' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, SolveLightEffect) == 0x000160, "Member 'USHFocusableComponent::SolveLightEffect' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, bDisableOwnerTickWhenHidden) == 0x000168, "Member 'USHFocusableComponent::bDisableOwnerTickWhenHidden' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, OnSetupShow) == 0x000170, "Member 'USHFocusableComponent::OnSetupShow' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, OnShow) == 0x000180, "Member 'USHFocusableComponent::OnShow' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, OnHide) == 0x000190, "Member 'USHFocusableComponent::OnHide' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, OnBreak) == 0x0001A0, "Member 'USHFocusableComponent::OnBreak' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, OnSolved) == 0x0001B0, "Member 'USHFocusableComponent::OnSolved' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, OnMiniInventoryClosed) == 0x0001C0, "Member 'USHFocusableComponent::OnMiniInventoryClosed' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, OnTranscriptionClosed) == 0x0001D0, "Member 'USHFocusableComponent::OnTranscriptionClosed' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, OnItemSelected) == 0x0001E0, "Member 'USHFocusableComponent::OnItemSelected' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, OnInputAction) == 0x0001F0, "Member 'USHFocusableComponent::OnInputAction' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, InteractingCharacter) == 0x000200, "Member 'USHFocusableComponent::InteractingCharacter' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, FocusCamera) == 0x000208, "Member 'USHFocusableComponent::FocusCamera' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, InteractionGeneric) == 0x000210, "Member 'USHFocusableComponent::InteractionGeneric' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, TeleportMariaCapsuleComponent) == 0x000218, "Member 'USHFocusableComponent::TeleportMariaCapsuleComponent' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, FlashlightFocusSpotComponent) == 0x000220, "Member 'USHFocusableComponent::FlashlightFocusSpotComponent' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, FlashlightSourceSpotComponent) == 0x000228, "Member 'USHFocusableComponent::FlashlightSourceSpotComponent' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, FocusExtraLightsContainer) == 0x000230, "Member 'USHFocusableComponent::FocusExtraLightsContainer' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, TeleportPlayerCapsuleComponents) == 0x000238, "Member 'USHFocusableComponent::TeleportPlayerCapsuleComponents' has a wrong offset!");
static_assert(offsetof(USHFocusableComponent, bIsCompleted) == 0x000248, "Member 'USHFocusableComponent::bIsCompleted' has a wrong offset!");

// Class SHProto.SHFogManager
// 0x00B0 (0x0150 - 0x00A0)
class USHFogManager final : public UActorComponent
{
public:
	class UMaterialParameterCollection*           FogMPCAsset;                                       // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, float>                            FogGridSizeZToScaleAdd;                            // 0x00A8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class ASHFogCutoutActor*>              RegisteredFogCutoutActors;                         // 0x00F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ASHLocalFogVolumetricActor*>     RegisteredLocalFogVolumetricActors;                // 0x0108(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_118[0x38];                                     // 0x0118(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRestoreWorldDependentSettingsNative(class USHGameInstance* OutGameInstance);
	void SHDebug_Fog_DrawDebug();
	void SHDebug_Fog_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFogManager">();
	}
	static class USHFogManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFogManager>();
	}
};
static_assert(alignof(USHFogManager) == 0x000008, "Wrong alignment on USHFogManager");
static_assert(sizeof(USHFogManager) == 0x000150, "Wrong size on USHFogManager");
static_assert(offsetof(USHFogManager, FogMPCAsset) == 0x0000A0, "Member 'USHFogManager::FogMPCAsset' has a wrong offset!");
static_assert(offsetof(USHFogManager, FogGridSizeZToScaleAdd) == 0x0000A8, "Member 'USHFogManager::FogGridSizeZToScaleAdd' has a wrong offset!");
static_assert(offsetof(USHFogManager, RegisteredFogCutoutActors) == 0x0000F8, "Member 'USHFogManager::RegisteredFogCutoutActors' has a wrong offset!");
static_assert(offsetof(USHFogManager, RegisteredLocalFogVolumetricActors) == 0x000108, "Member 'USHFogManager::RegisteredLocalFogVolumetricActors' has a wrong offset!");

// Class SHProto.SHFogStormNiagaraVolume
// 0x0000 (0x02F0 - 0x02F0)
class ASHFogStormNiagaraVolume final : public ASHNiagaraVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFogStormNiagaraVolume">();
	}
	static class ASHFogStormNiagaraVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHFogStormNiagaraVolume>();
	}
};
static_assert(alignof(ASHFogStormNiagaraVolume) == 0x000008, "Wrong alignment on ASHFogStormNiagaraVolume");
static_assert(sizeof(ASHFogStormNiagaraVolume) == 0x0002F0, "Wrong size on ASHFogStormNiagaraVolume");

// Class SHProto.SHFragileElevatorEngine
// 0x0018 (0x0428 - 0x0410)
class ASHFragileElevatorEngine final : public ASHElevatorEngine
{
public:
	bool                                          bIsMovementBroken;                                 // 0x0410(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_411[0x3];                                      // 0x0411(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetFloorOnBroken;                               // 0x0414(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementAlphaOnBroken;                             // 0x0418(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDoorBroken;                                     // 0x041C(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41D[0x3];                                      // 0x041D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoorAlphaOnBroken;                                 // 0x0420(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestBreakDoor();
	void RequestBreakDoorAt(float InAlpha);
	void RequestBreakMovement();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFragileElevatorEngine">();
	}
	static class ASHFragileElevatorEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHFragileElevatorEngine>();
	}
};
static_assert(alignof(ASHFragileElevatorEngine) == 0x000008, "Wrong alignment on ASHFragileElevatorEngine");
static_assert(sizeof(ASHFragileElevatorEngine) == 0x000428, "Wrong size on ASHFragileElevatorEngine");
static_assert(offsetof(ASHFragileElevatorEngine, bIsMovementBroken) == 0x000410, "Member 'ASHFragileElevatorEngine::bIsMovementBroken' has a wrong offset!");
static_assert(offsetof(ASHFragileElevatorEngine, TargetFloorOnBroken) == 0x000414, "Member 'ASHFragileElevatorEngine::TargetFloorOnBroken' has a wrong offset!");
static_assert(offsetof(ASHFragileElevatorEngine, MovementAlphaOnBroken) == 0x000418, "Member 'ASHFragileElevatorEngine::MovementAlphaOnBroken' has a wrong offset!");
static_assert(offsetof(ASHFragileElevatorEngine, bIsDoorBroken) == 0x00041C, "Member 'ASHFragileElevatorEngine::bIsDoorBroken' has a wrong offset!");
static_assert(offsetof(ASHFragileElevatorEngine, DoorAlphaOnBroken) == 0x000420, "Member 'ASHFragileElevatorEngine::DoorAlphaOnBroken' has a wrong offset!");

// Class SHProto.SHFreezingManagerComponent
// 0x0010 (0x00B0 - 0x00A0)
class USHFreezingManagerComponent final : public UActorComponent
{
public:
	TArray<class ASHFreezingVolume*>              RegisteredFreezingVolumes;                         // 0x00A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	class ASHFreezingVolume* GetEncompassedFreezingVolume(const struct FVector& InLocation) const;
	int32 GetRegisteredFreezingVolumeCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFreezingManagerComponent">();
	}
	static class USHFreezingManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFreezingManagerComponent>();
	}
};
static_assert(alignof(USHFreezingManagerComponent) == 0x000008, "Wrong alignment on USHFreezingManagerComponent");
static_assert(sizeof(USHFreezingManagerComponent) == 0x0000B0, "Wrong size on USHFreezingManagerComponent");
static_assert(offsetof(USHFreezingManagerComponent, RegisteredFreezingVolumes) == 0x0000A0, "Member 'USHFreezingManagerComponent::RegisteredFreezingVolumes' has a wrong offset!");

// Class SHProto.SHFriendAnimInstanceStateData
// 0x0000 (0x0070 - 0x0070)
class USHFriendAnimInstanceStateData final : public USHNPCAnimInstanceStateData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFriendAnimInstanceStateData">();
	}
	static class USHFriendAnimInstanceStateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFriendAnimInstanceStateData>();
	}
};
static_assert(alignof(USHFriendAnimInstanceStateData) == 0x000008, "Wrong alignment on USHFriendAnimInstanceStateData");
static_assert(sizeof(USHFriendAnimInstanceStateData) == 0x000070, "Wrong size on USHFriendAnimInstanceStateData");

// Class SHProto.SHFriendLocomotionAnimInstance
// 0x0030 (0x03D0 - 0x03A0)
class USHFriendLocomotionAnimInstance : public USHNPCLocomotionAnimInstance
{
public:
	ESHFriendAnimInstanceLocomotionState          LocomotionStateRequest;                            // 0x0398(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Speed;                                             // 0x039C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementPlayRate;                                  // 0x03A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementAnimationSpeed;                            // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveChangePlayRate;                                // 0x03A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CircularMovementRadius;                            // 0x03AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CircularMovementDirection;                         // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanValue;                                         // 0x03B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanInterpSpeed;                                   // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceAngle;                                  // 0x03BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalRotation;                                // 0x03C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveChangeStrafeAngle;                             // 0x03C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveChangeLegOnGround;                             // 0x03C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CC[0x4];                                      // 0x03CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USHFriendAnimInstanceStateData* GetFriendAnimInstanceStateData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFriendLocomotionAnimInstance">();
	}
	static class USHFriendLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFriendLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHFriendLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHFriendLocomotionAnimInstance");
static_assert(sizeof(USHFriendLocomotionAnimInstance) == 0x0003D0, "Wrong size on USHFriendLocomotionAnimInstance");
static_assert(offsetof(USHFriendLocomotionAnimInstance, LocomotionStateRequest) == 0x000398, "Member 'USHFriendLocomotionAnimInstance::LocomotionStateRequest' has a wrong offset!");
static_assert(offsetof(USHFriendLocomotionAnimInstance, Speed) == 0x00039C, "Member 'USHFriendLocomotionAnimInstance::Speed' has a wrong offset!");
static_assert(offsetof(USHFriendLocomotionAnimInstance, MovementPlayRate) == 0x0003A0, "Member 'USHFriendLocomotionAnimInstance::MovementPlayRate' has a wrong offset!");
static_assert(offsetof(USHFriendLocomotionAnimInstance, MovementAnimationSpeed) == 0x0003A4, "Member 'USHFriendLocomotionAnimInstance::MovementAnimationSpeed' has a wrong offset!");
static_assert(offsetof(USHFriendLocomotionAnimInstance, MoveChangePlayRate) == 0x0003A8, "Member 'USHFriendLocomotionAnimInstance::MoveChangePlayRate' has a wrong offset!");
static_assert(offsetof(USHFriendLocomotionAnimInstance, CircularMovementRadius) == 0x0003AC, "Member 'USHFriendLocomotionAnimInstance::CircularMovementRadius' has a wrong offset!");
static_assert(offsetof(USHFriendLocomotionAnimInstance, CircularMovementDirection) == 0x0003B0, "Member 'USHFriendLocomotionAnimInstance::CircularMovementDirection' has a wrong offset!");
static_assert(offsetof(USHFriendLocomotionAnimInstance, LeanValue) == 0x0003B4, "Member 'USHFriendLocomotionAnimInstance::LeanValue' has a wrong offset!");
static_assert(offsetof(USHFriendLocomotionAnimInstance, LeanInterpSpeed) == 0x0003B8, "Member 'USHFriendLocomotionAnimInstance::LeanInterpSpeed' has a wrong offset!");
static_assert(offsetof(USHFriendLocomotionAnimInstance, TurnInPlaceAngle) == 0x0003BC, "Member 'USHFriendLocomotionAnimInstance::TurnInPlaceAngle' has a wrong offset!");
static_assert(offsetof(USHFriendLocomotionAnimInstance, AdditionalRotation) == 0x0003C0, "Member 'USHFriendLocomotionAnimInstance::AdditionalRotation' has a wrong offset!");
static_assert(offsetof(USHFriendLocomotionAnimInstance, MoveChangeStrafeAngle) == 0x0003C4, "Member 'USHFriendLocomotionAnimInstance::MoveChangeStrafeAngle' has a wrong offset!");
static_assert(offsetof(USHFriendLocomotionAnimInstance, MoveChangeLegOnGround) == 0x0003C8, "Member 'USHFriendLocomotionAnimInstance::MoveChangeLegOnGround' has a wrong offset!");

// Class SHProto.SHFXMaterialModifierSubcomp
// 0x0048 (0x0080 - 0x0038)
class USHFXMaterialModifierSubcomp : public USHFXSubcomponent
{
public:
	class USHFXMaterialModifierSubcompSettings*   Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       _DynamicMaterials;                                 // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSHMaterialPropertyControlHandler> MaterialPropertyHandlers;                          // 0x0050(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x20];                                      // 0x0060(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMaterialLayerBlocked(const bool IsBlock, const class UObject* Object);

	int32 GetDynamicMaterialsCount() const;
	bool IsMaterialLayerBlocked() const;
	bool IsMaterialLayerBlockedBy(const class UObject* Object) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXMaterialModifierSubcomp">();
	}
	static class USHFXMaterialModifierSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXMaterialModifierSubcomp>();
	}
};
static_assert(alignof(USHFXMaterialModifierSubcomp) == 0x000008, "Wrong alignment on USHFXMaterialModifierSubcomp");
static_assert(sizeof(USHFXMaterialModifierSubcomp) == 0x000080, "Wrong size on USHFXMaterialModifierSubcomp");
static_assert(offsetof(USHFXMaterialModifierSubcomp, Settings) == 0x000038, "Member 'USHFXMaterialModifierSubcomp::Settings' has a wrong offset!");
static_assert(offsetof(USHFXMaterialModifierSubcomp, _DynamicMaterials) == 0x000040, "Member 'USHFXMaterialModifierSubcomp::_DynamicMaterials' has a wrong offset!");
static_assert(offsetof(USHFXMaterialModifierSubcomp, MaterialPropertyHandlers) == 0x000050, "Member 'USHFXMaterialModifierSubcomp::MaterialPropertyHandlers' has a wrong offset!");

// Class SHProto.SHFXAcidLayerSubcomp
// 0x0008 (0x0088 - 0x0080)
class USHFXAcidLayerSubcomp final : public USHFXMaterialModifierSubcomp
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RunAcidEffectOnPlayer();

	float GetCurrentEvaluateTimer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXAcidLayerSubcomp">();
	}
	static class USHFXAcidLayerSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXAcidLayerSubcomp>();
	}
};
static_assert(alignof(USHFXAcidLayerSubcomp) == 0x000008, "Wrong alignment on USHFXAcidLayerSubcomp");
static_assert(sizeof(USHFXAcidLayerSubcomp) == 0x000088, "Wrong size on USHFXAcidLayerSubcomp");

// Class SHProto.SHFXBleedingSubcomp
// 0x0050 (0x0088 - 0x0038)
class USHFXBleedingSubcomp final : public USHFXSubcomponent
{
public:
	class USHFXBleedingSubcompSettings*           Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x48];                                      // 0x0040(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBleedingBlocked(const bool IsBlock, const class UObject* Object);

	bool IsBleedingBlocked() const;
	bool IsBleedingBlockedBy(const class UObject* Object) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXBleedingSubcomp">();
	}
	static class USHFXBleedingSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXBleedingSubcomp>();
	}
};
static_assert(alignof(USHFXBleedingSubcomp) == 0x000008, "Wrong alignment on USHFXBleedingSubcomp");
static_assert(sizeof(USHFXBleedingSubcomp) == 0x000088, "Wrong size on USHFXBleedingSubcomp");
static_assert(offsetof(USHFXBleedingSubcomp, Settings) == 0x000038, "Member 'USHFXBleedingSubcomp::Settings' has a wrong offset!");

// Class SHProto.SHFXDirtLayerSubcomp
// 0x0018 (0x0098 - 0x0080)
class USHFXDirtLayerSubcomp final : public USHFXMaterialModifierSubcomp
{
public:
	float                                         _DirtBlendLayerValue;                              // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHMaterialPropertyDirtSet>     MaterialPropertyDirtSets;                          // 0x0088(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)

public:
	void ChangeDirtBlendLayerAmount(float DeltaValue);
	bool PreloadDirtState(int32 DirtSetIndex, ESHFXDirtState InDirtState);
	void SetDirtBlendLayerValue(float InDirtValue);
	bool SetDirtState(int32 DirtSetIndex, ESHFXDirtState InDirtState);

	bool CheckDynamicMaterialValid(int32 DirtSetIndex) const;
	float GetDirtBlendLayerValue() const;
	int32 GetDirtSetCount() const;
	ESHFXDirtState GetDirtState(int32 DirtSetIndex) const;
	const class FString GetDirtStateMaterialName(int32 DirtSetIndex) const;
	void GetDirtStateMaterialStats(int32 DirtSetIndex, int32* OutOverridedTextureParameterCount, int32* OutOverridedScalarParameterCount) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXDirtLayerSubcomp">();
	}
	static class USHFXDirtLayerSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXDirtLayerSubcomp>();
	}
};
static_assert(alignof(USHFXDirtLayerSubcomp) == 0x000008, "Wrong alignment on USHFXDirtLayerSubcomp");
static_assert(sizeof(USHFXDirtLayerSubcomp) == 0x000098, "Wrong size on USHFXDirtLayerSubcomp");
static_assert(offsetof(USHFXDirtLayerSubcomp, _DirtBlendLayerValue) == 0x000080, "Member 'USHFXDirtLayerSubcomp::_DirtBlendLayerValue' has a wrong offset!");
static_assert(offsetof(USHFXDirtLayerSubcomp, MaterialPropertyDirtSets) == 0x000088, "Member 'USHFXDirtLayerSubcomp::MaterialPropertyDirtSets' has a wrong offset!");

// Class SHProto.SHFXFrozenBreathSubcompSettings
// 0x0040 (0x0070 - 0x0030)
class USHFXFrozenBreathSubcompSettings final : public UDataAsset
{
public:
	bool                                          EnableFrozenBreath;                                // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          FrozenBreathTemplate;                              // 0x0038(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FrozenBreathSocketName;                            // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXFrozenBreathSubcompSettings">();
	}
	static class USHFXFrozenBreathSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXFrozenBreathSubcompSettings>();
	}
};
static_assert(alignof(USHFXFrozenBreathSubcompSettings) == 0x000008, "Wrong alignment on USHFXFrozenBreathSubcompSettings");
static_assert(sizeof(USHFXFrozenBreathSubcompSettings) == 0x000070, "Wrong size on USHFXFrozenBreathSubcompSettings");
static_assert(offsetof(USHFXFrozenBreathSubcompSettings, EnableFrozenBreath) == 0x000030, "Member 'USHFXFrozenBreathSubcompSettings::EnableFrozenBreath' has a wrong offset!");
static_assert(offsetof(USHFXFrozenBreathSubcompSettings, FrozenBreathTemplate) == 0x000038, "Member 'USHFXFrozenBreathSubcompSettings::FrozenBreathTemplate' has a wrong offset!");
static_assert(offsetof(USHFXFrozenBreathSubcompSettings, FrozenBreathSocketName) == 0x000068, "Member 'USHFXFrozenBreathSubcompSettings::FrozenBreathSocketName' has a wrong offset!");

// Class SHProto.SHFXFrozenBreathSubcomp
// 0x0030 (0x0068 - 0x0038)
class USHFXFrozenBreathSubcomp final : public USHFXSubcomponent
{
public:
	class USHFXFrozenBreathSubcompSettings*       Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      FrozenBreathComponent;                             // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFrozenBreathBlocked(const bool IsBlock, const class UObject* Object);

	int32 GetFreezingVolumesCount() const;
	bool IsFrozenBreathBlocked() const;
	bool IsFrozenBreathBlockedBy(const class UObject* Object) const;
	bool IsInFreezingZone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXFrozenBreathSubcomp">();
	}
	static class USHFXFrozenBreathSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXFrozenBreathSubcomp>();
	}
};
static_assert(alignof(USHFXFrozenBreathSubcomp) == 0x000008, "Wrong alignment on USHFXFrozenBreathSubcomp");
static_assert(sizeof(USHFXFrozenBreathSubcomp) == 0x000068, "Wrong size on USHFXFrozenBreathSubcomp");
static_assert(offsetof(USHFXFrozenBreathSubcomp, Settings) == 0x000038, "Member 'USHFXFrozenBreathSubcomp::Settings' has a wrong offset!");
static_assert(offsetof(USHFXFrozenBreathSubcomp, FrozenBreathComponent) == 0x000040, "Member 'USHFXFrozenBreathSubcomp::FrozenBreathComponent' has a wrong offset!");

// Class SHProto.SHFXPenetrateSplashSubcompSettings
// 0x0050 (0x0080 - 0x0030)
class USHFXPenetrateSplashSubcompSettings final : public UDataAsset
{
public:
	bool                                          EnableEnemyPenetrate;                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USHSystemFXData*                        PenetrateFXData;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PenetrateFXSpawnerClass;                           // 0x0040(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OverridePenetrateFadeOut;                          // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PenetrateFadeOutDelay;                             // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrateFadeOutDuration;                          // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXPenetrateSplashSubcompSettings">();
	}
	static class USHFXPenetrateSplashSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXPenetrateSplashSubcompSettings>();
	}
};
static_assert(alignof(USHFXPenetrateSplashSubcompSettings) == 0x000008, "Wrong alignment on USHFXPenetrateSplashSubcompSettings");
static_assert(sizeof(USHFXPenetrateSplashSubcompSettings) == 0x000080, "Wrong size on USHFXPenetrateSplashSubcompSettings");
static_assert(offsetof(USHFXPenetrateSplashSubcompSettings, EnableEnemyPenetrate) == 0x000030, "Member 'USHFXPenetrateSplashSubcompSettings::EnableEnemyPenetrate' has a wrong offset!");
static_assert(offsetof(USHFXPenetrateSplashSubcompSettings, PenetrateFXData) == 0x000038, "Member 'USHFXPenetrateSplashSubcompSettings::PenetrateFXData' has a wrong offset!");
static_assert(offsetof(USHFXPenetrateSplashSubcompSettings, PenetrateFXSpawnerClass) == 0x000040, "Member 'USHFXPenetrateSplashSubcompSettings::PenetrateFXSpawnerClass' has a wrong offset!");
static_assert(offsetof(USHFXPenetrateSplashSubcompSettings, OverridePenetrateFadeOut) == 0x000070, "Member 'USHFXPenetrateSplashSubcompSettings::OverridePenetrateFadeOut' has a wrong offset!");
static_assert(offsetof(USHFXPenetrateSplashSubcompSettings, PenetrateFadeOutDelay) == 0x000074, "Member 'USHFXPenetrateSplashSubcompSettings::PenetrateFadeOutDelay' has a wrong offset!");
static_assert(offsetof(USHFXPenetrateSplashSubcompSettings, PenetrateFadeOutDuration) == 0x000078, "Member 'USHFXPenetrateSplashSubcompSettings::PenetrateFadeOutDuration' has a wrong offset!");

// Class SHProto.SHFXPenetrateSplashSubcomp
// 0x0030 (0x0068 - 0x0038)
class USHFXPenetrateSplashSubcomp final : public USHFXSubcomponent
{
public:
	class USHFXPenetrateSplashSubcompSettings*    Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessOwnerDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* HitComponent, class FName BoneName, const struct FVector& ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXPenetrateSplashSubcomp">();
	}
	static class USHFXPenetrateSplashSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXPenetrateSplashSubcomp>();
	}
};
static_assert(alignof(USHFXPenetrateSplashSubcomp) == 0x000008, "Wrong alignment on USHFXPenetrateSplashSubcomp");
static_assert(sizeof(USHFXPenetrateSplashSubcomp) == 0x000068, "Wrong size on USHFXPenetrateSplashSubcomp");
static_assert(offsetof(USHFXPenetrateSplashSubcomp, Settings) == 0x000038, "Member 'USHFXPenetrateSplashSubcomp::Settings' has a wrong offset!");

// Class SHProto.SHFXPukeExplosionSubcompSettings
// 0x0090 (0x00C0 - 0x0030)
class USHFXPukeExplosionSubcompSettings final : public UDataAsset
{
public:
	class USHSystemFXData*                        PukePuddleFXData;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PukePuddleFXSpawnerClass;                          // 0x0038(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PukePuddleDelaySpawn;                              // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMaiFloatDiff                          PukeExplosionDamage;                               // 0x006C(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PukeExplosionRadius;                               // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PukeExplosionDamageDelay;                          // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                PukeExplosionDamageType;                           // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         PukeExplosionParticles;                            // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PukeExplosionSocket;                               // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEffectHandle                          LightEffect;                                       // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXPukeExplosionSubcompSettings">();
	}
	static class USHFXPukeExplosionSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXPukeExplosionSubcompSettings>();
	}
};
static_assert(alignof(USHFXPukeExplosionSubcompSettings) == 0x000008, "Wrong alignment on USHFXPukeExplosionSubcompSettings");
static_assert(sizeof(USHFXPukeExplosionSubcompSettings) == 0x0000C0, "Wrong size on USHFXPukeExplosionSubcompSettings");
static_assert(offsetof(USHFXPukeExplosionSubcompSettings, PukePuddleFXData) == 0x000030, "Member 'USHFXPukeExplosionSubcompSettings::PukePuddleFXData' has a wrong offset!");
static_assert(offsetof(USHFXPukeExplosionSubcompSettings, PukePuddleFXSpawnerClass) == 0x000038, "Member 'USHFXPukeExplosionSubcompSettings::PukePuddleFXSpawnerClass' has a wrong offset!");
static_assert(offsetof(USHFXPukeExplosionSubcompSettings, PukePuddleDelaySpawn) == 0x000068, "Member 'USHFXPukeExplosionSubcompSettings::PukePuddleDelaySpawn' has a wrong offset!");
static_assert(offsetof(USHFXPukeExplosionSubcompSettings, PukeExplosionDamage) == 0x00006C, "Member 'USHFXPukeExplosionSubcompSettings::PukeExplosionDamage' has a wrong offset!");
static_assert(offsetof(USHFXPukeExplosionSubcompSettings, PukeExplosionRadius) == 0x000094, "Member 'USHFXPukeExplosionSubcompSettings::PukeExplosionRadius' has a wrong offset!");
static_assert(offsetof(USHFXPukeExplosionSubcompSettings, PukeExplosionDamageDelay) == 0x000098, "Member 'USHFXPukeExplosionSubcompSettings::PukeExplosionDamageDelay' has a wrong offset!");
static_assert(offsetof(USHFXPukeExplosionSubcompSettings, PukeExplosionDamageType) == 0x0000A0, "Member 'USHFXPukeExplosionSubcompSettings::PukeExplosionDamageType' has a wrong offset!");
static_assert(offsetof(USHFXPukeExplosionSubcompSettings, PukeExplosionParticles) == 0x0000A8, "Member 'USHFXPukeExplosionSubcompSettings::PukeExplosionParticles' has a wrong offset!");
static_assert(offsetof(USHFXPukeExplosionSubcompSettings, PukeExplosionSocket) == 0x0000B0, "Member 'USHFXPukeExplosionSubcompSettings::PukeExplosionSocket' has a wrong offset!");
static_assert(offsetof(USHFXPukeExplosionSubcompSettings, LightEffect) == 0x0000B8, "Member 'USHFXPukeExplosionSubcompSettings::LightEffect' has a wrong offset!");

// Class SHProto.SHFXDeathPukeExplosionSubcomp
// 0x0000 (0x0060 - 0x0060)
class USHFXDeathPukeExplosionSubcomp final : public USHFXPukeExplosionSubcomp
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXDeathPukeExplosionSubcomp">();
	}
	static class USHFXDeathPukeExplosionSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXDeathPukeExplosionSubcomp>();
	}
};
static_assert(alignof(USHFXDeathPukeExplosionSubcomp) == 0x000008, "Wrong alignment on USHFXDeathPukeExplosionSubcomp");
static_assert(sizeof(USHFXDeathPukeExplosionSubcomp) == 0x000060, "Wrong size on USHFXDeathPukeExplosionSubcomp");

// Class SHProto.SHFXRaingWettingSubcompSettings
// 0x00B0 (0x0100 - 0x0050)
class USHFXRaingWettingSubcompSettings final : public USHFXMaterialModifierSubcompSettings
{
public:
	bool                                          EnableRainWetting;                                 // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TotalWettingTime;                                  // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalDryingTime;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            WetDryCurve;                                       // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableRainDripping;                                // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          RainDrippingTemplate;                              // 0x0070(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RainDrippingSocketName;                            // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RainDrippingSpawnRateParamName;                    // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RainDrippingIntensityParamName;                    // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainDrippingIntensityEvaluateTime;                 // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopDrippingWetDryFactor;                          // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainDrippingIntensityDiminishTime;                 // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableWading;                                      // 0x00D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WadeDryingSpeed;                                   // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            WadeDryingCurveSlowdown;                           // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            WadeSharpnessCurve;                                // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            WadeOffsetWetCurve;                                // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WadeCurvesTimeLength;                              // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXRaingWettingSubcompSettings">();
	}
	static class USHFXRaingWettingSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXRaingWettingSubcompSettings>();
	}
};
static_assert(alignof(USHFXRaingWettingSubcompSettings) == 0x000008, "Wrong alignment on USHFXRaingWettingSubcompSettings");
static_assert(sizeof(USHFXRaingWettingSubcompSettings) == 0x000100, "Wrong size on USHFXRaingWettingSubcompSettings");
static_assert(offsetof(USHFXRaingWettingSubcompSettings, EnableRainWetting) == 0x000050, "Member 'USHFXRaingWettingSubcompSettings::EnableRainWetting' has a wrong offset!");
static_assert(offsetof(USHFXRaingWettingSubcompSettings, TotalWettingTime) == 0x000054, "Member 'USHFXRaingWettingSubcompSettings::TotalWettingTime' has a wrong offset!");
static_assert(offsetof(USHFXRaingWettingSubcompSettings, TotalDryingTime) == 0x000058, "Member 'USHFXRaingWettingSubcompSettings::TotalDryingTime' has a wrong offset!");
static_assert(offsetof(USHFXRaingWettingSubcompSettings, WetDryCurve) == 0x000060, "Member 'USHFXRaingWettingSubcompSettings::WetDryCurve' has a wrong offset!");
static_assert(offsetof(USHFXRaingWettingSubcompSettings, EnableRainDripping) == 0x000068, "Member 'USHFXRaingWettingSubcompSettings::EnableRainDripping' has a wrong offset!");
static_assert(offsetof(USHFXRaingWettingSubcompSettings, RainDrippingTemplate) == 0x000070, "Member 'USHFXRaingWettingSubcompSettings::RainDrippingTemplate' has a wrong offset!");
static_assert(offsetof(USHFXRaingWettingSubcompSettings, RainDrippingSocketName) == 0x0000A0, "Member 'USHFXRaingWettingSubcompSettings::RainDrippingSocketName' has a wrong offset!");
static_assert(offsetof(USHFXRaingWettingSubcompSettings, RainDrippingSpawnRateParamName) == 0x0000A8, "Member 'USHFXRaingWettingSubcompSettings::RainDrippingSpawnRateParamName' has a wrong offset!");
static_assert(offsetof(USHFXRaingWettingSubcompSettings, RainDrippingIntensityParamName) == 0x0000B8, "Member 'USHFXRaingWettingSubcompSettings::RainDrippingIntensityParamName' has a wrong offset!");
static_assert(offsetof(USHFXRaingWettingSubcompSettings, RainDrippingIntensityEvaluateTime) == 0x0000C8, "Member 'USHFXRaingWettingSubcompSettings::RainDrippingIntensityEvaluateTime' has a wrong offset!");
static_assert(offsetof(USHFXRaingWettingSubcompSettings, StopDrippingWetDryFactor) == 0x0000CC, "Member 'USHFXRaingWettingSubcompSettings::StopDrippingWetDryFactor' has a wrong offset!");
static_assert(offsetof(USHFXRaingWettingSubcompSettings, RainDrippingIntensityDiminishTime) == 0x0000D0, "Member 'USHFXRaingWettingSubcompSettings::RainDrippingIntensityDiminishTime' has a wrong offset!");
static_assert(offsetof(USHFXRaingWettingSubcompSettings, EnableWading) == 0x0000D4, "Member 'USHFXRaingWettingSubcompSettings::EnableWading' has a wrong offset!");
static_assert(offsetof(USHFXRaingWettingSubcompSettings, WadeDryingSpeed) == 0x0000D8, "Member 'USHFXRaingWettingSubcompSettings::WadeDryingSpeed' has a wrong offset!");
static_assert(offsetof(USHFXRaingWettingSubcompSettings, WadeDryingCurveSlowdown) == 0x0000E0, "Member 'USHFXRaingWettingSubcompSettings::WadeDryingCurveSlowdown' has a wrong offset!");
static_assert(offsetof(USHFXRaingWettingSubcompSettings, WadeSharpnessCurve) == 0x0000E8, "Member 'USHFXRaingWettingSubcompSettings::WadeSharpnessCurve' has a wrong offset!");
static_assert(offsetof(USHFXRaingWettingSubcompSettings, WadeOffsetWetCurve) == 0x0000F0, "Member 'USHFXRaingWettingSubcompSettings::WadeOffsetWetCurve' has a wrong offset!");
static_assert(offsetof(USHFXRaingWettingSubcompSettings, WadeCurvesTimeLength) == 0x0000F8, "Member 'USHFXRaingWettingSubcompSettings::WadeCurvesTimeLength' has a wrong offset!");

// Class SHProto.SHFXRaingWettingSubcomp
// 0x0048 (0x00C8 - 0x0080)
class USHFXRaingWettingSubcomp final : public USHFXMaterialModifierSubcomp
{
public:
	FMulticastInlineDelegateProperty_             OnWetFactorChanged;                                // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UNiagaraComponent>       SpawnedRainDrippingNiagaraComponent;               // 0x0090(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x30];                                      // 0x0098(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UNiagaraComponent* GetSpawnedRainDrippingNiagaraComponent();
	bool IsRainDrippingActive();
	void SetRainDrippingBlocked(const bool IsBlock, const class UObject* Object);
	void SetRainDripSpawnRate(float InSpawnRate);
	void SetRainingBlocked(const bool IsBlock, const class UObject* Object);
	void SetRainSplashesBlocked(const bool IsBlock, const class UObject* Object);
	void SetWadingAltitudeRelative(float WadingHeight);
	void SetWadingAltitudeWorld(float WadingHeight);
	void SetWetDryFactor(float InWetFactor);
	void SHRainWettingFXEvent__DelegateSignature(class USHFXRaingWettingSubcomp* Component);

	float GetCurvesEvaluateTimer() const;
	float GetDripIntensityValue() const;
	float GetWadingAltitude() const;
	float GetWetDryFactor() const;
	bool IsInRainZone() const;
	bool IsRainDrippingBlocked() const;
	bool IsRainDrippingBlockedBy(const class UObject* Object) const;
	bool IsRainingBlocked() const;
	bool IsRainingBlockedBy(const class UObject* Object) const;
	bool IsRainSplashesBlocked() const;
	bool IsRainSplashesBlockedBy(const class UObject* Object) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXRaingWettingSubcomp">();
	}
	static class USHFXRaingWettingSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXRaingWettingSubcomp>();
	}
};
static_assert(alignof(USHFXRaingWettingSubcomp) == 0x000008, "Wrong alignment on USHFXRaingWettingSubcomp");
static_assert(sizeof(USHFXRaingWettingSubcomp) == 0x0000C8, "Wrong size on USHFXRaingWettingSubcomp");
static_assert(offsetof(USHFXRaingWettingSubcomp, OnWetFactorChanged) == 0x000080, "Member 'USHFXRaingWettingSubcomp::OnWetFactorChanged' has a wrong offset!");
static_assert(offsetof(USHFXRaingWettingSubcomp, SpawnedRainDrippingNiagaraComponent) == 0x000090, "Member 'USHFXRaingWettingSubcomp::SpawnedRainDrippingNiagaraComponent' has a wrong offset!");

// Class SHProto.SHFXSkitteringBloodTraceSubcompSettings
// 0x0010 (0x0040 - 0x0030)
class USHFXSkitteringBloodTraceSubcompSettings final : public UDataAsset
{
public:
	bool                                          EnableSkitteringBloodTrace;                        // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BloodTraceShowBelowHP;                             // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         SkitteringBloodTraceTemplate;                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXSkitteringBloodTraceSubcompSettings">();
	}
	static class USHFXSkitteringBloodTraceSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXSkitteringBloodTraceSubcompSettings>();
	}
};
static_assert(alignof(USHFXSkitteringBloodTraceSubcompSettings) == 0x000008, "Wrong alignment on USHFXSkitteringBloodTraceSubcompSettings");
static_assert(sizeof(USHFXSkitteringBloodTraceSubcompSettings) == 0x000040, "Wrong size on USHFXSkitteringBloodTraceSubcompSettings");
static_assert(offsetof(USHFXSkitteringBloodTraceSubcompSettings, EnableSkitteringBloodTrace) == 0x000030, "Member 'USHFXSkitteringBloodTraceSubcompSettings::EnableSkitteringBloodTrace' has a wrong offset!");
static_assert(offsetof(USHFXSkitteringBloodTraceSubcompSettings, BloodTraceShowBelowHP) == 0x000034, "Member 'USHFXSkitteringBloodTraceSubcompSettings::BloodTraceShowBelowHP' has a wrong offset!");
static_assert(offsetof(USHFXSkitteringBloodTraceSubcompSettings, SkitteringBloodTraceTemplate) == 0x000038, "Member 'USHFXSkitteringBloodTraceSubcompSettings::SkitteringBloodTraceTemplate' has a wrong offset!");

// Class SHProto.SHFXSplashPuddleSubcompSettings
// 0x0060 (0x0090 - 0x0030)
class USHFXSplashPuddleSubcompSettings final : public UDataAsset
{
public:
	bool                                          EnableSplashPuddle;                                // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USHSystemFXData*                        SplashPuddleFXData;                                // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SplashPuddleFXSpawnerClass;                        // 0x0040(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DelayToSpawnSplashPuddle;                          // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OverrideSplashPuddleFadeOut;                       // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SplashPuddleFadeOutDelay;                          // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplashPuddleFadeOutDuration;                       // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXSplashPuddleSubcompSettings">();
	}
	static class USHFXSplashPuddleSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXSplashPuddleSubcompSettings>();
	}
};
static_assert(alignof(USHFXSplashPuddleSubcompSettings) == 0x000008, "Wrong alignment on USHFXSplashPuddleSubcompSettings");
static_assert(sizeof(USHFXSplashPuddleSubcompSettings) == 0x000090, "Wrong size on USHFXSplashPuddleSubcompSettings");
static_assert(offsetof(USHFXSplashPuddleSubcompSettings, EnableSplashPuddle) == 0x000030, "Member 'USHFXSplashPuddleSubcompSettings::EnableSplashPuddle' has a wrong offset!");
static_assert(offsetof(USHFXSplashPuddleSubcompSettings, SplashPuddleFXData) == 0x000038, "Member 'USHFXSplashPuddleSubcompSettings::SplashPuddleFXData' has a wrong offset!");
static_assert(offsetof(USHFXSplashPuddleSubcompSettings, SplashPuddleFXSpawnerClass) == 0x000040, "Member 'USHFXSplashPuddleSubcompSettings::SplashPuddleFXSpawnerClass' has a wrong offset!");
static_assert(offsetof(USHFXSplashPuddleSubcompSettings, DelayToSpawnSplashPuddle) == 0x000070, "Member 'USHFXSplashPuddleSubcompSettings::DelayToSpawnSplashPuddle' has a wrong offset!");
static_assert(offsetof(USHFXSplashPuddleSubcompSettings, OverrideSplashPuddleFadeOut) == 0x000080, "Member 'USHFXSplashPuddleSubcompSettings::OverrideSplashPuddleFadeOut' has a wrong offset!");
static_assert(offsetof(USHFXSplashPuddleSubcompSettings, SplashPuddleFadeOutDelay) == 0x000084, "Member 'USHFXSplashPuddleSubcompSettings::SplashPuddleFadeOutDelay' has a wrong offset!");
static_assert(offsetof(USHFXSplashPuddleSubcompSettings, SplashPuddleFadeOutDuration) == 0x000088, "Member 'USHFXSplashPuddleSubcompSettings::SplashPuddleFadeOutDuration' has a wrong offset!");

// Class SHProto.SHFXSwarmSubcomp
// 0x0020 (0x0058 - 0x0038)
class USHFXSwarmSubcomp final : public USHFXSubcomponent
{
public:
	class USHFXSwarmSubcompSettings*              Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ASHSwarmVolume*>                 RegisteredSwarmVolumes;                            // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetCurrentZoneCount() const;
	int32 GetRegisteredSwarmVolumeCount() const;
	TArray<class ASHSwarmVolume*> GetRegisteredSwarmVolumes() const;
	bool IsInSwarmZone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXSwarmSubcomp">();
	}
	static class USHFXSwarmSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXSwarmSubcomp>();
	}
};
static_assert(alignof(USHFXSwarmSubcomp) == 0x000008, "Wrong alignment on USHFXSwarmSubcomp");
static_assert(sizeof(USHFXSwarmSubcomp) == 0x000058, "Wrong size on USHFXSwarmSubcomp");
static_assert(offsetof(USHFXSwarmSubcomp, Settings) == 0x000038, "Member 'USHFXSwarmSubcomp::Settings' has a wrong offset!");
static_assert(offsetof(USHFXSwarmSubcomp, RegisteredSwarmVolumes) == 0x000040, "Member 'USHFXSwarmSubcomp::RegisteredSwarmVolumes' has a wrong offset!");

// Class SHProto.SHFXVisualHPSubcompSettings
// 0x0018 (0x0068 - 0x0050)
class USHFXVisualHPSubcompSettings final : public USHFXMaterialModifierSubcompSettings
{
public:
	bool                                          EnableHPVisual;                                    // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            HPVisualCurve;                                     // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HPVisualNormalFactor;                              // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HPVisualReviveFactor;                              // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXVisualHPSubcompSettings">();
	}
	static class USHFXVisualHPSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXVisualHPSubcompSettings>();
	}
};
static_assert(alignof(USHFXVisualHPSubcompSettings) == 0x000008, "Wrong alignment on USHFXVisualHPSubcompSettings");
static_assert(sizeof(USHFXVisualHPSubcompSettings) == 0x000068, "Wrong size on USHFXVisualHPSubcompSettings");
static_assert(offsetof(USHFXVisualHPSubcompSettings, EnableHPVisual) == 0x000050, "Member 'USHFXVisualHPSubcompSettings::EnableHPVisual' has a wrong offset!");
static_assert(offsetof(USHFXVisualHPSubcompSettings, HPVisualCurve) == 0x000058, "Member 'USHFXVisualHPSubcompSettings::HPVisualCurve' has a wrong offset!");
static_assert(offsetof(USHFXVisualHPSubcompSettings, HPVisualNormalFactor) == 0x000060, "Member 'USHFXVisualHPSubcompSettings::HPVisualNormalFactor' has a wrong offset!");
static_assert(offsetof(USHFXVisualHPSubcompSettings, HPVisualReviveFactor) == 0x000064, "Member 'USHFXVisualHPSubcompSettings::HPVisualReviveFactor' has a wrong offset!");

// Class SHProto.SHFXVisualHPSubcomp
// 0x0010 (0x0090 - 0x0080)
class USHFXVisualHPSubcomp final : public USHFXMaterialModifierSubcomp
{
public:
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessHealthChangedAsAICharacter(int32 PrevHealth);
	void ProcessHealthChangedAsPlayer(class USHCharacterPlayHealthComponent* InHealthComponent);

	float GetCurrentCurveEvaluationValue() const;
	float GetCurrentErodeParameterValue() const;
	float GetOwnerHealthPercentage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXVisualHPSubcomp">();
	}
	static class USHFXVisualHPSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXVisualHPSubcomp>();
	}
};
static_assert(alignof(USHFXVisualHPSubcomp) == 0x000008, "Wrong alignment on USHFXVisualHPSubcomp");
static_assert(sizeof(USHFXVisualHPSubcomp) == 0x000090, "Wrong size on USHFXVisualHPSubcomp");

// Class SHProto.SHFXWaterInteractionSubcompSettings
// 0x0008 (0x0038 - 0x0030)
class USHFXWaterInteractionSubcompSettings final : public UDataAsset
{
public:
	bool                                          EnableWaterInteraction;                            // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BoneRadiusModifier;                                // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHFXWaterInteractionSubcompSettings">();
	}
	static class USHFXWaterInteractionSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHFXWaterInteractionSubcompSettings>();
	}
};
static_assert(alignof(USHFXWaterInteractionSubcompSettings) == 0x000008, "Wrong alignment on USHFXWaterInteractionSubcompSettings");
static_assert(sizeof(USHFXWaterInteractionSubcompSettings) == 0x000038, "Wrong size on USHFXWaterInteractionSubcompSettings");
static_assert(offsetof(USHFXWaterInteractionSubcompSettings, EnableWaterInteraction) == 0x000030, "Member 'USHFXWaterInteractionSubcompSettings::EnableWaterInteraction' has a wrong offset!");
static_assert(offsetof(USHFXWaterInteractionSubcompSettings, BoneRadiusModifier) == 0x000034, "Member 'USHFXWaterInteractionSubcompSettings::BoneRadiusModifier' has a wrong offset!");

// Class SHProto.SHGameInstance
// 0x0140 (0x03F8 - 0x02B8)
class USHGameInstance : public UBGameInstance
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDeathReload;                                      // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameOverCause                                LastDeathReason;                                   // 0x02C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2[0x6];                                      // 0x02C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAkRtpc>                 WWisePadHeadPhonesRTPC;                            // 0x02C8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class USHDebugManagerWidget>      DebugManagerWidgetClass;                           // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHDebugManager*                        DebugManager;                                      // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x90];                                     // 0x0308(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkRtpc*                                WWisePadHeadPhonesRTPCPtr;                         // 0x0398(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x58];                                     // 0x03A0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginCustomLevel(const struct FStreamableLevelHandle& LevelHandle);
	void OnChangeWorldDependentSettings();
	void OnRestoreWorldDependentSettings__DelegateSignature(class USHGameInstance* OutGameInstance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameInstance">();
	}
	static class USHGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameInstance>();
	}
};
static_assert(alignof(USHGameInstance) == 0x000008, "Wrong alignment on USHGameInstance");
static_assert(sizeof(USHGameInstance) == 0x0003F8, "Wrong size on USHGameInstance");
static_assert(offsetof(USHGameInstance, bDeathReload) == 0x0002C0, "Member 'USHGameInstance::bDeathReload' has a wrong offset!");
static_assert(offsetof(USHGameInstance, LastDeathReason) == 0x0002C1, "Member 'USHGameInstance::LastDeathReason' has a wrong offset!");
static_assert(offsetof(USHGameInstance, WWisePadHeadPhonesRTPC) == 0x0002C8, "Member 'USHGameInstance::WWisePadHeadPhonesRTPC' has a wrong offset!");
static_assert(offsetof(USHGameInstance, DebugManagerWidgetClass) == 0x0002F8, "Member 'USHGameInstance::DebugManagerWidgetClass' has a wrong offset!");
static_assert(offsetof(USHGameInstance, DebugManager) == 0x000300, "Member 'USHGameInstance::DebugManager' has a wrong offset!");
static_assert(offsetof(USHGameInstance, WWisePadHeadPhonesRTPCPtr) == 0x000398, "Member 'USHGameInstance::WWisePadHeadPhonesRTPCPtr' has a wrong offset!");

// Class SHProto.SHMovieGameMode
// 0x0008 (0x03B8 - 0x03B0)
class ASHMovieGameMode final : public ASHGameMode
{
public:
	class UDialogManager*                         DialogManager;                                     // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMovieGameMode">();
	}
	static class ASHMovieGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHMovieGameMode>();
	}
};
static_assert(alignof(ASHMovieGameMode) == 0x000008, "Wrong alignment on ASHMovieGameMode");
static_assert(sizeof(ASHMovieGameMode) == 0x0003B8, "Wrong size on ASHMovieGameMode");
static_assert(offsetof(ASHMovieGameMode, DialogManager) == 0x0003B0, "Member 'ASHMovieGameMode::DialogManager' has a wrong offset!");

// Class SHProto.MovieGameModeController
// 0x0000 (0x0130 - 0x0130)
class UMovieGameModeController final : public UBaseGameModeController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieGameModeController">();
	}
	static class UMovieGameModeController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieGameModeController>();
	}
};
static_assert(alignof(UMovieGameModeController) == 0x000008, "Wrong alignment on UMovieGameModeController");
static_assert(sizeof(UMovieGameModeController) == 0x000130, "Wrong size on UMovieGameModeController");

// Class SHProto.SHGameplayEndGameCreditsWidget
// 0x0010 (0x0300 - 0x02F0)
class USHGameplayEndGameCreditsWidget final : public UCreditsWidget
{
public:
	FMulticastInlineDelegateProperty_             OnContinue;                                        // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Continue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayEndGameCreditsWidget">();
	}
	static class USHGameplayEndGameCreditsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayEndGameCreditsWidget>();
	}
};
static_assert(alignof(USHGameplayEndGameCreditsWidget) == 0x000008, "Wrong alignment on USHGameplayEndGameCreditsWidget");
static_assert(sizeof(USHGameplayEndGameCreditsWidget) == 0x000300, "Wrong size on USHGameplayEndGameCreditsWidget");
static_assert(offsetof(USHGameplayEndGameCreditsWidget, OnContinue) == 0x0002F0, "Member 'USHGameplayEndGameCreditsWidget::OnContinue' has a wrong offset!");

// Class SHProto.SHGameplayEndGamePanelWidget
// 0x0018 (0x02B8 - 0x02A0)
class USHGameplayEndGamePanelWidget : public UBUserWidget
{
public:
	bool                                          bIsSkipable;                                       // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnContinue;                                        // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Continue();
	void OnHide();
	void OnShow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayEndGamePanelWidget">();
	}
	static class USHGameplayEndGamePanelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayEndGamePanelWidget>();
	}
};
static_assert(alignof(USHGameplayEndGamePanelWidget) == 0x000008, "Wrong alignment on USHGameplayEndGamePanelWidget");
static_assert(sizeof(USHGameplayEndGamePanelWidget) == 0x0002B8, "Wrong size on USHGameplayEndGamePanelWidget");
static_assert(offsetof(USHGameplayEndGamePanelWidget, bIsSkipable) == 0x0002A0, "Member 'USHGameplayEndGamePanelWidget::bIsSkipable' has a wrong offset!");
static_assert(offsetof(USHGameplayEndGamePanelWidget, OnContinue) == 0x0002A8, "Member 'USHGameplayEndGamePanelWidget::OnContinue' has a wrong offset!");

// Class SHProto.SHGameplayEndGameMovieWidget
// 0x0010 (0x02C8 - 0x02B8)
class USHGameplayEndGameMovieWidget final : public USHGameplayEndGamePanelWidget
{
public:
	class UImage*                                 Movie_img;                                         // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UBinkMediaPlayer>        MediaPlayer;                                       // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnMediaReachedEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayEndGameMovieWidget">();
	}
	static class USHGameplayEndGameMovieWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayEndGameMovieWidget>();
	}
};
static_assert(alignof(USHGameplayEndGameMovieWidget) == 0x000008, "Wrong alignment on USHGameplayEndGameMovieWidget");
static_assert(sizeof(USHGameplayEndGameMovieWidget) == 0x0002C8, "Wrong size on USHGameplayEndGameMovieWidget");
static_assert(offsetof(USHGameplayEndGameMovieWidget, Movie_img) == 0x0002B8, "Member 'USHGameplayEndGameMovieWidget::Movie_img' has a wrong offset!");
static_assert(offsetof(USHGameplayEndGameMovieWidget, MediaPlayer) == 0x0002C0, "Member 'USHGameplayEndGameMovieWidget::MediaPlayer' has a wrong offset!");

// Class SHProto.SHGameplayEndGameStatsWidget
// 0x0078 (0x0330 - 0x02B8)
class USHGameplayEndGameStatsWidget final : public USHGameplayEndGamePanelWidget
{
public:
	TArray<struct FKey>                           ContinueKeys;                                      // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FSHGameplayStatisticsData              GameplayStatisticsData;                            // 0x02C8(0x0068)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayEndGameStatsWidget">();
	}
	static class USHGameplayEndGameStatsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayEndGameStatsWidget>();
	}
};
static_assert(alignof(USHGameplayEndGameStatsWidget) == 0x000008, "Wrong alignment on USHGameplayEndGameStatsWidget");
static_assert(sizeof(USHGameplayEndGameStatsWidget) == 0x000330, "Wrong size on USHGameplayEndGameStatsWidget");
static_assert(offsetof(USHGameplayEndGameStatsWidget, ContinueKeys) == 0x0002B8, "Member 'USHGameplayEndGameStatsWidget::ContinueKeys' has a wrong offset!");
static_assert(offsetof(USHGameplayEndGameStatsWidget, GameplayStatisticsData) == 0x0002C8, "Member 'USHGameplayEndGameStatsWidget::GameplayStatisticsData' has a wrong offset!");

// Class SHProto.SHGameplayEndGameWidget
// 0x01E8 (0x0488 - 0x02A0)
class USHGameplayEndGameWidget final : public UBUserWidget
{
public:
	class UWidgetSwitcher*                        Main_switcher;                                     // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUCWSkipWidget*                         Skip_wdg;                                          // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeIn;                                            // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeOut;                                           // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkAudioEvent>           MusicStart;                                        // 0x02C0(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          MusicEnd;                                          // 0x02F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkAudioEvent>           LeaveEndingMusicStart;                             // 0x02F8(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkAudioEvent>           TrueLeaveEndingMusicStart;                         // 0x0328(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkAudioEvent>           InWaterEndingMusicStart;                           // 0x0358(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkAudioEvent>           TrueInWaterEndingMusicStart;                       // 0x0388(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkAudioEvent>           MariaEndingMusicStart;                             // 0x03B8(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkAudioEvent>           RebirthEndingMusicStart;                           // 0x03E8(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkAudioEvent>           DogEndingMusicStart;                               // 0x0418(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkAudioEvent>           UFOEndingMusicStart;                               // 0x0448(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEffectHandle                          LightEffect;                                       // 0x0478(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_480[0x8];                                      // 0x0480(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActiveWidgetChanged(class UWidget* ActiveWidget, int32 ActiveWidgetIndex);
	void Continue();
	void OnHide();
	void OnShow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayEndGameWidget">();
	}
	static class USHGameplayEndGameWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayEndGameWidget>();
	}
};
static_assert(alignof(USHGameplayEndGameWidget) == 0x000008, "Wrong alignment on USHGameplayEndGameWidget");
static_assert(sizeof(USHGameplayEndGameWidget) == 0x000488, "Wrong size on USHGameplayEndGameWidget");
static_assert(offsetof(USHGameplayEndGameWidget, Main_switcher) == 0x0002A0, "Member 'USHGameplayEndGameWidget::Main_switcher' has a wrong offset!");
static_assert(offsetof(USHGameplayEndGameWidget, Skip_wdg) == 0x0002A8, "Member 'USHGameplayEndGameWidget::Skip_wdg' has a wrong offset!");
static_assert(offsetof(USHGameplayEndGameWidget, FadeIn) == 0x0002B0, "Member 'USHGameplayEndGameWidget::FadeIn' has a wrong offset!");
static_assert(offsetof(USHGameplayEndGameWidget, FadeOut) == 0x0002B8, "Member 'USHGameplayEndGameWidget::FadeOut' has a wrong offset!");
static_assert(offsetof(USHGameplayEndGameWidget, MusicStart) == 0x0002C0, "Member 'USHGameplayEndGameWidget::MusicStart' has a wrong offset!");
static_assert(offsetof(USHGameplayEndGameWidget, MusicEnd) == 0x0002F0, "Member 'USHGameplayEndGameWidget::MusicEnd' has a wrong offset!");
static_assert(offsetof(USHGameplayEndGameWidget, LeaveEndingMusicStart) == 0x0002F8, "Member 'USHGameplayEndGameWidget::LeaveEndingMusicStart' has a wrong offset!");
static_assert(offsetof(USHGameplayEndGameWidget, TrueLeaveEndingMusicStart) == 0x000328, "Member 'USHGameplayEndGameWidget::TrueLeaveEndingMusicStart' has a wrong offset!");
static_assert(offsetof(USHGameplayEndGameWidget, InWaterEndingMusicStart) == 0x000358, "Member 'USHGameplayEndGameWidget::InWaterEndingMusicStart' has a wrong offset!");
static_assert(offsetof(USHGameplayEndGameWidget, TrueInWaterEndingMusicStart) == 0x000388, "Member 'USHGameplayEndGameWidget::TrueInWaterEndingMusicStart' has a wrong offset!");
static_assert(offsetof(USHGameplayEndGameWidget, MariaEndingMusicStart) == 0x0003B8, "Member 'USHGameplayEndGameWidget::MariaEndingMusicStart' has a wrong offset!");
static_assert(offsetof(USHGameplayEndGameWidget, RebirthEndingMusicStart) == 0x0003E8, "Member 'USHGameplayEndGameWidget::RebirthEndingMusicStart' has a wrong offset!");
static_assert(offsetof(USHGameplayEndGameWidget, DogEndingMusicStart) == 0x000418, "Member 'USHGameplayEndGameWidget::DogEndingMusicStart' has a wrong offset!");
static_assert(offsetof(USHGameplayEndGameWidget, UFOEndingMusicStart) == 0x000448, "Member 'USHGameplayEndGameWidget::UFOEndingMusicStart' has a wrong offset!");
static_assert(offsetof(USHGameplayEndGameWidget, LightEffect) == 0x000478, "Member 'USHGameplayEndGameWidget::LightEffect' has a wrong offset!");

// Class SHProto.SHGameplayFadeWidget
// 0x0028 (0x02A0 - 0x0278)
class USHGameplayFadeWidget final : public UUserWidget
{
public:
	float                                         DefaultFadeInDurationSeconds;                      // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultFadeOutDurationSeconds;                     // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_280[0x20];                                     // 0x0280(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintImplementableColorChanged();

	struct FLinearColor GetCurrentColor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayFadeWidget">();
	}
	static class USHGameplayFadeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayFadeWidget>();
	}
};
static_assert(alignof(USHGameplayFadeWidget) == 0x000008, "Wrong alignment on USHGameplayFadeWidget");
static_assert(sizeof(USHGameplayFadeWidget) == 0x0002A0, "Wrong size on USHGameplayFadeWidget");
static_assert(offsetof(USHGameplayFadeWidget, DefaultFadeInDurationSeconds) == 0x000278, "Member 'USHGameplayFadeWidget::DefaultFadeInDurationSeconds' has a wrong offset!");
static_assert(offsetof(USHGameplayFadeWidget, DefaultFadeOutDurationSeconds) == 0x00027C, "Member 'USHGameplayFadeWidget::DefaultFadeOutDurationSeconds' has a wrong offset!");

// Class SHProto.SHGameplayFocusControl
// 0x0008 (0x0280 - 0x0278)
class USHGameplayFocusControl final : public UUserWidget
{
public:
	class UTextBlock*                             ButtonTextBlock;                                   // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayFocusControl">();
	}
	static class USHGameplayFocusControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayFocusControl>();
	}
};
static_assert(alignof(USHGameplayFocusControl) == 0x000008, "Wrong alignment on USHGameplayFocusControl");
static_assert(sizeof(USHGameplayFocusControl) == 0x000280, "Wrong size on USHGameplayFocusControl");
static_assert(offsetof(USHGameplayFocusControl, ButtonTextBlock) == 0x000278, "Member 'USHGameplayFocusControl::ButtonTextBlock' has a wrong offset!");

// Class SHProto.SHGameplayFocusSlotsWidget
// 0x0098 (0x0310 - 0x0278)
class USHGameplayFocusSlotsWidget final : public UUserWidget
{
public:
	class UCanvasPanel*                           MainCanvas;                                        // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SlotsNavVector;                                    // 0x0280(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMinMaxVector2D                        InputBlockWaitTimeMinMax;                          // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InputThrottleAcceleration;                         // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USHGameplayFocusWidget*                 OwnerWidget;                                       // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x68];                                     // 0x02A8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayFocusSlotsWidget">();
	}
	static class USHGameplayFocusSlotsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayFocusSlotsWidget>();
	}
};
static_assert(alignof(USHGameplayFocusSlotsWidget) == 0x000008, "Wrong alignment on USHGameplayFocusSlotsWidget");
static_assert(sizeof(USHGameplayFocusSlotsWidget) == 0x000310, "Wrong size on USHGameplayFocusSlotsWidget");
static_assert(offsetof(USHGameplayFocusSlotsWidget, MainCanvas) == 0x000278, "Member 'USHGameplayFocusSlotsWidget::MainCanvas' has a wrong offset!");
static_assert(offsetof(USHGameplayFocusSlotsWidget, SlotsNavVector) == 0x000280, "Member 'USHGameplayFocusSlotsWidget::SlotsNavVector' has a wrong offset!");
static_assert(offsetof(USHGameplayFocusSlotsWidget, InputBlockWaitTimeMinMax) == 0x000290, "Member 'USHGameplayFocusSlotsWidget::InputBlockWaitTimeMinMax' has a wrong offset!");
static_assert(offsetof(USHGameplayFocusSlotsWidget, InputThrottleAcceleration) == 0x000298, "Member 'USHGameplayFocusSlotsWidget::InputThrottleAcceleration' has a wrong offset!");
static_assert(offsetof(USHGameplayFocusSlotsWidget, OwnerWidget) == 0x0002A0, "Member 'USHGameplayFocusSlotsWidget::OwnerWidget' has a wrong offset!");

// Class SHProto.SHInputKeysData
// 0x0050 (0x0080 - 0x0030)
class USHInputKeysData final : public UDataAsset
{
public:
	TMap<ESHFocusableInputActionTypeEnum, struct FSHInputKeyDataStruct> InputActionKeys;                                   // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInputKeysData">();
	}
	static class USHInputKeysData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHInputKeysData>();
	}
};
static_assert(alignof(USHInputKeysData) == 0x000008, "Wrong alignment on USHInputKeysData");
static_assert(sizeof(USHInputKeysData) == 0x000080, "Wrong size on USHInputKeysData");
static_assert(offsetof(USHInputKeysData, InputActionKeys) == 0x000030, "Member 'USHInputKeysData::InputActionKeys' has a wrong offset!");

// Class SHProto.SHGameplayHealingItemsNotificationRowWidget
// 0x00B8 (0x0330 - 0x0278)
class USHGameplayHealingItemsNotificationRowWidget final : public UUserWidget
{
public:
	class UTextBlock*                             ItemDisplayNameText;                               // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemCountText;                                     // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       PrimaryAnim;                                       // 0x0288(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       SecondaryAnim;                                     // 0x0290(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       NoItemAnim;                                        // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            AvailableItemsColor;                               // 0x02A0(0x0014)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            NoItemsColor;                                      // 0x02B4(0x0014)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AudioEvent_ItemCollected;                          // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AudioEvent_ItemUsed;                               // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AudioEvent_NoItem;                                 // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       OwnerCharacterPlay;                                // 0x02E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       CurrentItemAnimation;                              // 0x02E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x40];                                     // 0x02F0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessHealthItemAnimationFinishedEvent();
	void UpdateItemsCountText();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayHealingItemsNotificationRowWidget">();
	}
	static class USHGameplayHealingItemsNotificationRowWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayHealingItemsNotificationRowWidget>();
	}
};
static_assert(alignof(USHGameplayHealingItemsNotificationRowWidget) == 0x000008, "Wrong alignment on USHGameplayHealingItemsNotificationRowWidget");
static_assert(sizeof(USHGameplayHealingItemsNotificationRowWidget) == 0x000330, "Wrong size on USHGameplayHealingItemsNotificationRowWidget");
static_assert(offsetof(USHGameplayHealingItemsNotificationRowWidget, ItemDisplayNameText) == 0x000278, "Member 'USHGameplayHealingItemsNotificationRowWidget::ItemDisplayNameText' has a wrong offset!");
static_assert(offsetof(USHGameplayHealingItemsNotificationRowWidget, ItemCountText) == 0x000280, "Member 'USHGameplayHealingItemsNotificationRowWidget::ItemCountText' has a wrong offset!");
static_assert(offsetof(USHGameplayHealingItemsNotificationRowWidget, PrimaryAnim) == 0x000288, "Member 'USHGameplayHealingItemsNotificationRowWidget::PrimaryAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayHealingItemsNotificationRowWidget, SecondaryAnim) == 0x000290, "Member 'USHGameplayHealingItemsNotificationRowWidget::SecondaryAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayHealingItemsNotificationRowWidget, NoItemAnim) == 0x000298, "Member 'USHGameplayHealingItemsNotificationRowWidget::NoItemAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayHealingItemsNotificationRowWidget, AvailableItemsColor) == 0x0002A0, "Member 'USHGameplayHealingItemsNotificationRowWidget::AvailableItemsColor' has a wrong offset!");
static_assert(offsetof(USHGameplayHealingItemsNotificationRowWidget, NoItemsColor) == 0x0002B4, "Member 'USHGameplayHealingItemsNotificationRowWidget::NoItemsColor' has a wrong offset!");
static_assert(offsetof(USHGameplayHealingItemsNotificationRowWidget, AudioEvent_ItemCollected) == 0x0002C8, "Member 'USHGameplayHealingItemsNotificationRowWidget::AudioEvent_ItemCollected' has a wrong offset!");
static_assert(offsetof(USHGameplayHealingItemsNotificationRowWidget, AudioEvent_ItemUsed) == 0x0002D0, "Member 'USHGameplayHealingItemsNotificationRowWidget::AudioEvent_ItemUsed' has a wrong offset!");
static_assert(offsetof(USHGameplayHealingItemsNotificationRowWidget, AudioEvent_NoItem) == 0x0002D8, "Member 'USHGameplayHealingItemsNotificationRowWidget::AudioEvent_NoItem' has a wrong offset!");
static_assert(offsetof(USHGameplayHealingItemsNotificationRowWidget, OwnerCharacterPlay) == 0x0002E0, "Member 'USHGameplayHealingItemsNotificationRowWidget::OwnerCharacterPlay' has a wrong offset!");
static_assert(offsetof(USHGameplayHealingItemsNotificationRowWidget, CurrentItemAnimation) == 0x0002E8, "Member 'USHGameplayHealingItemsNotificationRowWidget::CurrentItemAnimation' has a wrong offset!");

// Class SHProto.SHGameplayHealingItemsNotificationWidget
// 0x0060 (0x02D8 - 0x0278)
class USHGameplayHealingItemsNotificationWidget final : public UUserWidget
{
public:
	class UCanvasPanel*                           MainContainer;                                     // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayHealingItemsNotificationRowWidget* TapHealingItemNotificationRowWidget;               // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayHealingItemsNotificationRowWidget* HoldHealingItemItemNotificationRowWidget;          // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ShowAnim;                                          // 0x0290(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       HideAnim;                                          // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HideWidgetDelayTime;                               // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASHCharacterPlay*                       OwnerCharacterPlay;                                // 0x02A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       CurrentShowHideAnimation;                          // 0x02B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x20];                                     // 0x02B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessShowHideAnimationFinishedEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayHealingItemsNotificationWidget">();
	}
	static class USHGameplayHealingItemsNotificationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayHealingItemsNotificationWidget>();
	}
};
static_assert(alignof(USHGameplayHealingItemsNotificationWidget) == 0x000008, "Wrong alignment on USHGameplayHealingItemsNotificationWidget");
static_assert(sizeof(USHGameplayHealingItemsNotificationWidget) == 0x0002D8, "Wrong size on USHGameplayHealingItemsNotificationWidget");
static_assert(offsetof(USHGameplayHealingItemsNotificationWidget, MainContainer) == 0x000278, "Member 'USHGameplayHealingItemsNotificationWidget::MainContainer' has a wrong offset!");
static_assert(offsetof(USHGameplayHealingItemsNotificationWidget, TapHealingItemNotificationRowWidget) == 0x000280, "Member 'USHGameplayHealingItemsNotificationWidget::TapHealingItemNotificationRowWidget' has a wrong offset!");
static_assert(offsetof(USHGameplayHealingItemsNotificationWidget, HoldHealingItemItemNotificationRowWidget) == 0x000288, "Member 'USHGameplayHealingItemsNotificationWidget::HoldHealingItemItemNotificationRowWidget' has a wrong offset!");
static_assert(offsetof(USHGameplayHealingItemsNotificationWidget, ShowAnim) == 0x000290, "Member 'USHGameplayHealingItemsNotificationWidget::ShowAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayHealingItemsNotificationWidget, HideAnim) == 0x000298, "Member 'USHGameplayHealingItemsNotificationWidget::HideAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayHealingItemsNotificationWidget, HideWidgetDelayTime) == 0x0002A0, "Member 'USHGameplayHealingItemsNotificationWidget::HideWidgetDelayTime' has a wrong offset!");
static_assert(offsetof(USHGameplayHealingItemsNotificationWidget, OwnerCharacterPlay) == 0x0002A8, "Member 'USHGameplayHealingItemsNotificationWidget::OwnerCharacterPlay' has a wrong offset!");
static_assert(offsetof(USHGameplayHealingItemsNotificationWidget, CurrentShowHideAnimation) == 0x0002B0, "Member 'USHGameplayHealingItemsNotificationWidget::CurrentShowHideAnimation' has a wrong offset!");

// Class SHProto.SHGameplayHealthIndicatorWidget
// 0x0020 (0x0298 - 0x0278)
class USHGameplayHealthIndicatorWidget final : public UUserWidget
{
public:
	class UCanvasPanel*                           MainContainer;                                     // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IndicatorImage;                                    // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESHHealthStateEnum                            IndicatorVisibility_MinimumHealthState;            // 0x0288(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ASHCharacterPlay*                       OwnerCharacterPlay;                                // 0x0290(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayHealthIndicatorWidget">();
	}
	static class USHGameplayHealthIndicatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayHealthIndicatorWidget>();
	}
};
static_assert(alignof(USHGameplayHealthIndicatorWidget) == 0x000008, "Wrong alignment on USHGameplayHealthIndicatorWidget");
static_assert(sizeof(USHGameplayHealthIndicatorWidget) == 0x000298, "Wrong size on USHGameplayHealthIndicatorWidget");
static_assert(offsetof(USHGameplayHealthIndicatorWidget, MainContainer) == 0x000278, "Member 'USHGameplayHealthIndicatorWidget::MainContainer' has a wrong offset!");
static_assert(offsetof(USHGameplayHealthIndicatorWidget, IndicatorImage) == 0x000280, "Member 'USHGameplayHealthIndicatorWidget::IndicatorImage' has a wrong offset!");
static_assert(offsetof(USHGameplayHealthIndicatorWidget, IndicatorVisibility_MinimumHealthState) == 0x000288, "Member 'USHGameplayHealthIndicatorWidget::IndicatorVisibility_MinimumHealthState' has a wrong offset!");
static_assert(offsetof(USHGameplayHealthIndicatorWidget, OwnerCharacterPlay) == 0x000290, "Member 'USHGameplayHealthIndicatorWidget::OwnerCharacterPlay' has a wrong offset!");

// Class SHProto.SHGameplayHudWidget
// 0x0070 (0x02E8 - 0x0278)
class USHGameplayHudWidget final : public UUserWidget
{
public:
	class UCanvasPanel*                           MainContainer;                                     // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCrosshairContainerWidget*            CrosshairContainer;                                // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayTutorialWidget*              TutorialWidget;                                    // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayItemNotificationWidget*      ItemNotificationWidget;                            // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayRangedWeaponDetailsWidget*   RangedWeaponDetailsWidget;                         // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayHealingItemsNotificationWidget* HealingItemsNotificationWidget;                    // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayFadeWidget*                  GameplayFadeWidget;                                // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayStruggleWidget*              GameplayStruggleWidget;                            // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayHealthIndicatorWidget*       HealthIndicatorWidget;                             // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayRadioIndicatorWidget*        RadioIndicatorWidget;                              // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x02C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x18];                                     // 0x02D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayHudWidget">();
	}
	static class USHGameplayHudWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayHudWidget>();
	}
};
static_assert(alignof(USHGameplayHudWidget) == 0x000008, "Wrong alignment on USHGameplayHudWidget");
static_assert(sizeof(USHGameplayHudWidget) == 0x0002E8, "Wrong size on USHGameplayHudWidget");
static_assert(offsetof(USHGameplayHudWidget, MainContainer) == 0x000278, "Member 'USHGameplayHudWidget::MainContainer' has a wrong offset!");
static_assert(offsetof(USHGameplayHudWidget, CrosshairContainer) == 0x000280, "Member 'USHGameplayHudWidget::CrosshairContainer' has a wrong offset!");
static_assert(offsetof(USHGameplayHudWidget, TutorialWidget) == 0x000288, "Member 'USHGameplayHudWidget::TutorialWidget' has a wrong offset!");
static_assert(offsetof(USHGameplayHudWidget, ItemNotificationWidget) == 0x000290, "Member 'USHGameplayHudWidget::ItemNotificationWidget' has a wrong offset!");
static_assert(offsetof(USHGameplayHudWidget, RangedWeaponDetailsWidget) == 0x000298, "Member 'USHGameplayHudWidget::RangedWeaponDetailsWidget' has a wrong offset!");
static_assert(offsetof(USHGameplayHudWidget, HealingItemsNotificationWidget) == 0x0002A0, "Member 'USHGameplayHudWidget::HealingItemsNotificationWidget' has a wrong offset!");
static_assert(offsetof(USHGameplayHudWidget, GameplayFadeWidget) == 0x0002A8, "Member 'USHGameplayHudWidget::GameplayFadeWidget' has a wrong offset!");
static_assert(offsetof(USHGameplayHudWidget, GameplayStruggleWidget) == 0x0002B0, "Member 'USHGameplayHudWidget::GameplayStruggleWidget' has a wrong offset!");
static_assert(offsetof(USHGameplayHudWidget, HealthIndicatorWidget) == 0x0002B8, "Member 'USHGameplayHudWidget::HealthIndicatorWidget' has a wrong offset!");
static_assert(offsetof(USHGameplayHudWidget, RadioIndicatorWidget) == 0x0002C0, "Member 'USHGameplayHudWidget::RadioIndicatorWidget' has a wrong offset!");
static_assert(offsetof(USHGameplayHudWidget, OwnerCharacter) == 0x0002C8, "Member 'USHGameplayHudWidget::OwnerCharacter' has a wrong offset!");

// Class SHProto.SHGameplayInventorySlider
// 0x0190 (0x0408 - 0x0278)
class USHGameplayInventorySlider final : public UUserWidget
{
public:
	bool                                          bAllowLoopItems;                                   // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowNewCollectedItemIndicator;                    // 0x0279(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A[0x6];                                      // 0x027A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               DebugTexture;                                      // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_MoveItem;                               // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_StopItem;                               // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             NoItemsNameWidget;                                 // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ItemNameWidget;                                    // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ItemNewIndicatorImage;                             // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ItemDescriptionWidget;                             // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewCenterItem;                                 // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewLeftItem_01;                                // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewLeftItem_02;                                // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewLeftItem_03;                                // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewRightItem_01;                               // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewRightItem_02;                               // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewRightItem_03;                               // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewRightItem_04;                               // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewRightItem_05;                               // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewRightItem_06;                               // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       MoveItemLeftAnim;                                  // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       MoveItemRightAnim;                                 // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       StopItemLeftAnim;                                  // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       StopItemRightAnim;                                 // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       ShowItemsAnim;                                     // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       HideItemsAnim;                                     // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x0338(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UWidget*>                        DynamicItemWidgets;                                // 0x0340(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       CurrentPlayingAnimation;                           // 0x0350(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0xB0];                                     // 0x0358(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessAnimationFinishedEvent();
	void RefreshItemNameAndDescription();
	void RefreshItemsZOrder();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayInventorySlider">();
	}
	static class USHGameplayInventorySlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayInventorySlider>();
	}
};
static_assert(alignof(USHGameplayInventorySlider) == 0x000008, "Wrong alignment on USHGameplayInventorySlider");
static_assert(sizeof(USHGameplayInventorySlider) == 0x000408, "Wrong size on USHGameplayInventorySlider");
static_assert(offsetof(USHGameplayInventorySlider, bAllowLoopItems) == 0x000278, "Member 'USHGameplayInventorySlider::bAllowLoopItems' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, bShowNewCollectedItemIndicator) == 0x000279, "Member 'USHGameplayInventorySlider::bShowNewCollectedItemIndicator' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, DebugTexture) == 0x000280, "Member 'USHGameplayInventorySlider::DebugTexture' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, AudioEvent_MoveItem) == 0x000288, "Member 'USHGameplayInventorySlider::AudioEvent_MoveItem' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, AudioEvent_StopItem) == 0x000290, "Member 'USHGameplayInventorySlider::AudioEvent_StopItem' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, NoItemsNameWidget) == 0x000298, "Member 'USHGameplayInventorySlider::NoItemsNameWidget' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, ItemNameWidget) == 0x0002A0, "Member 'USHGameplayInventorySlider::ItemNameWidget' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, ItemNewIndicatorImage) == 0x0002A8, "Member 'USHGameplayInventorySlider::ItemNewIndicatorImage' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, ItemDescriptionWidget) == 0x0002B0, "Member 'USHGameplayInventorySlider::ItemDescriptionWidget' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, PreviewCenterItem) == 0x0002B8, "Member 'USHGameplayInventorySlider::PreviewCenterItem' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, PreviewLeftItem_01) == 0x0002C0, "Member 'USHGameplayInventorySlider::PreviewLeftItem_01' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, PreviewLeftItem_02) == 0x0002C8, "Member 'USHGameplayInventorySlider::PreviewLeftItem_02' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, PreviewLeftItem_03) == 0x0002D0, "Member 'USHGameplayInventorySlider::PreviewLeftItem_03' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, PreviewRightItem_01) == 0x0002D8, "Member 'USHGameplayInventorySlider::PreviewRightItem_01' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, PreviewRightItem_02) == 0x0002E0, "Member 'USHGameplayInventorySlider::PreviewRightItem_02' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, PreviewRightItem_03) == 0x0002E8, "Member 'USHGameplayInventorySlider::PreviewRightItem_03' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, PreviewRightItem_04) == 0x0002F0, "Member 'USHGameplayInventorySlider::PreviewRightItem_04' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, PreviewRightItem_05) == 0x0002F8, "Member 'USHGameplayInventorySlider::PreviewRightItem_05' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, PreviewRightItem_06) == 0x000300, "Member 'USHGameplayInventorySlider::PreviewRightItem_06' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, MoveItemLeftAnim) == 0x000308, "Member 'USHGameplayInventorySlider::MoveItemLeftAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, MoveItemRightAnim) == 0x000310, "Member 'USHGameplayInventorySlider::MoveItemRightAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, StopItemLeftAnim) == 0x000318, "Member 'USHGameplayInventorySlider::StopItemLeftAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, StopItemRightAnim) == 0x000320, "Member 'USHGameplayInventorySlider::StopItemRightAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, ShowItemsAnim) == 0x000328, "Member 'USHGameplayInventorySlider::ShowItemsAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, HideItemsAnim) == 0x000330, "Member 'USHGameplayInventorySlider::HideItemsAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, OwnerCharacter) == 0x000338, "Member 'USHGameplayInventorySlider::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, DynamicItemWidgets) == 0x000340, "Member 'USHGameplayInventorySlider::DynamicItemWidgets' has a wrong offset!");
static_assert(offsetof(USHGameplayInventorySlider, CurrentPlayingAnimation) == 0x000350, "Member 'USHGameplayInventorySlider::CurrentPlayingAnimation' has a wrong offset!");

// Class SHProto.SHGameplayItemInvestigationWidget
// 0x0020 (0x0298 - 0x0278)
class USHGameplayItemInvestigationWidget final : public UUserWidget
{
public:
	class UCanvasPanel*                           MainContainer;                                     // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemNameTextBlock;                                 // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x0288(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayItemInvestigationWidget">();
	}
	static class USHGameplayItemInvestigationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayItemInvestigationWidget>();
	}
};
static_assert(alignof(USHGameplayItemInvestigationWidget) == 0x000008, "Wrong alignment on USHGameplayItemInvestigationWidget");
static_assert(sizeof(USHGameplayItemInvestigationWidget) == 0x000298, "Wrong size on USHGameplayItemInvestigationWidget");
static_assert(offsetof(USHGameplayItemInvestigationWidget, MainContainer) == 0x000278, "Member 'USHGameplayItemInvestigationWidget::MainContainer' has a wrong offset!");
static_assert(offsetof(USHGameplayItemInvestigationWidget, ItemNameTextBlock) == 0x000280, "Member 'USHGameplayItemInvestigationWidget::ItemNameTextBlock' has a wrong offset!");
static_assert(offsetof(USHGameplayItemInvestigationWidget, OwnerCharacter) == 0x000288, "Member 'USHGameplayItemInvestigationWidget::OwnerCharacter' has a wrong offset!");

// Class SHProto.SHGameplayMapObjectComponent
// 0x0020 (0x00C0 - 0x00A0)
class USHGameplayMapObjectComponent : public UActorComponent
{
public:
	ESHMapObjectTypeEnum                          MapObjectType;                                     // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHMapDataConfigStruct                 GameplayMapObjectConfig;                           // 0x00A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSHMapDataConfigStruct>         AdditionalGameplayMapObjectConfigs;                // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)

public:
	void SendDynamicObjectDataToGameplayMap(const struct FVector& WorldLoc, int32 DataValue) const;
	void SendObjectDataToGameplayMap(int32 DataValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayMapObjectComponent">();
	}
	static class USHGameplayMapObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayMapObjectComponent>();
	}
};
static_assert(alignof(USHGameplayMapObjectComponent) == 0x000008, "Wrong alignment on USHGameplayMapObjectComponent");
static_assert(sizeof(USHGameplayMapObjectComponent) == 0x0000C0, "Wrong size on USHGameplayMapObjectComponent");
static_assert(offsetof(USHGameplayMapObjectComponent, MapObjectType) == 0x0000A0, "Member 'USHGameplayMapObjectComponent::MapObjectType' has a wrong offset!");
static_assert(offsetof(USHGameplayMapObjectComponent, GameplayMapObjectConfig) == 0x0000A4, "Member 'USHGameplayMapObjectComponent::GameplayMapObjectConfig' has a wrong offset!");
static_assert(offsetof(USHGameplayMapObjectComponent, AdditionalGameplayMapObjectConfigs) == 0x0000B0, "Member 'USHGameplayMapObjectComponent::AdditionalGameplayMapObjectConfigs' has a wrong offset!");

// Class SHProto.SHGameplayMapDoorAttachmentComponent
// 0x0008 (0x00C8 - 0x00C0)
class USHGameplayMapDoorAttachmentComponent final : public USHGameplayMapObjectComponent
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFocusableShown(class USHFocusableComponent* FocusableComponent);
	void OnFocusableSolved(class USHFocusableComponent* FocusableComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayMapDoorAttachmentComponent">();
	}
	static class USHGameplayMapDoorAttachmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayMapDoorAttachmentComponent>();
	}
};
static_assert(alignof(USHGameplayMapDoorAttachmentComponent) == 0x000008, "Wrong alignment on USHGameplayMapDoorAttachmentComponent");
static_assert(sizeof(USHGameplayMapDoorAttachmentComponent) == 0x0000C8, "Wrong size on USHGameplayMapDoorAttachmentComponent");

// Class SHProto.SHGameplayMapDoorComponent
// 0x0010 (0x00D0 - 0x00C0)
class USHGameplayMapDoorComponent final : public USHGameplayMapObjectComponent
{
public:
	bool                                          bEnforceMode;                                      // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESHGameplayMapDoorMode                        ModeToEnforce;                                     // 0x00C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisplayCannotBePassedAsObstacle;                  // 0x00C2(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C3[0xD];                                       // 0x00C3(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisplayCannotBePassedAsObstacle();
	void OnAttachmentFocusableShown(class USHFocusableComponent* FocusableComponent);
	void OnAutoLockedAnimationPlayed(class USHDoorAnimationsComponent* DoorAnimationsComponent);
	void OnDoorLockStateChanged(class USHDoorLockBaseComponent* DoorLockBaseComponent);
	void OnLockedAnimationPlayed(class USHSlidingDoorAnimationsComponent* SlidingDoorAnimationsComponent);
	void OnOpenAnimationPlayed(class USHSlidingDoorAnimationsComponent* SlidingDoorAnimationsComponent);
	void OnPhysicMovementAppliedForceFromActor(class USHDoorMovementComponent* DoorMovementComponent, class AActor* ActorContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayMapDoorComponent">();
	}
	static class USHGameplayMapDoorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayMapDoorComponent>();
	}
};
static_assert(alignof(USHGameplayMapDoorComponent) == 0x000008, "Wrong alignment on USHGameplayMapDoorComponent");
static_assert(sizeof(USHGameplayMapDoorComponent) == 0x0000D0, "Wrong size on USHGameplayMapDoorComponent");
static_assert(offsetof(USHGameplayMapDoorComponent, bEnforceMode) == 0x0000C0, "Member 'USHGameplayMapDoorComponent::bEnforceMode' has a wrong offset!");
static_assert(offsetof(USHGameplayMapDoorComponent, ModeToEnforce) == 0x0000C1, "Member 'USHGameplayMapDoorComponent::ModeToEnforce' has a wrong offset!");
static_assert(offsetof(USHGameplayMapDoorComponent, bDisplayCannotBePassedAsObstacle) == 0x0000C2, "Member 'USHGameplayMapDoorComponent::bDisplayCannotBePassedAsObstacle' has a wrong offset!");

// Class SHProto.SHGameplayMapFocusableComponent
// 0x0020 (0x00E0 - 0x00C0)
class USHGameplayMapFocusableComponent final : public USHGameplayMapObjectComponent
{
public:
	int32                                         FocusableCustomOffset;                             // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWantAdditionalGameplayMapHintObject;              // 0x00C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHMapDataConfigStruct                 GameplayMapHintObjectConfig;                       // 0x00C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   GameplayMapHintArrowObjectID;                      // 0x00D4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWasFocusableAddedToMap;                           // 0x00DC(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWasHintAddedToMap;                                // 0x00DD(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DE[0x2];                                       // 0x00DE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessFocusableShownEvent(class USHFocusableComponent* FocusableComponentPtr);
	void ProcessFocusableSolvedEvent(class USHFocusableComponent* FocusableComponentPtr);
	void ProcessProximityBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayMapFocusableComponent">();
	}
	static class USHGameplayMapFocusableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayMapFocusableComponent>();
	}
};
static_assert(alignof(USHGameplayMapFocusableComponent) == 0x000008, "Wrong alignment on USHGameplayMapFocusableComponent");
static_assert(sizeof(USHGameplayMapFocusableComponent) == 0x0000E0, "Wrong size on USHGameplayMapFocusableComponent");
static_assert(offsetof(USHGameplayMapFocusableComponent, FocusableCustomOffset) == 0x0000C0, "Member 'USHGameplayMapFocusableComponent::FocusableCustomOffset' has a wrong offset!");
static_assert(offsetof(USHGameplayMapFocusableComponent, bWantAdditionalGameplayMapHintObject) == 0x0000C4, "Member 'USHGameplayMapFocusableComponent::bWantAdditionalGameplayMapHintObject' has a wrong offset!");
static_assert(offsetof(USHGameplayMapFocusableComponent, GameplayMapHintObjectConfig) == 0x0000C8, "Member 'USHGameplayMapFocusableComponent::GameplayMapHintObjectConfig' has a wrong offset!");
static_assert(offsetof(USHGameplayMapFocusableComponent, GameplayMapHintArrowObjectID) == 0x0000D4, "Member 'USHGameplayMapFocusableComponent::GameplayMapHintArrowObjectID' has a wrong offset!");
static_assert(offsetof(USHGameplayMapFocusableComponent, bWasFocusableAddedToMap) == 0x0000DC, "Member 'USHGameplayMapFocusableComponent::bWasFocusableAddedToMap' has a wrong offset!");
static_assert(offsetof(USHGameplayMapFocusableComponent, bWasHintAddedToMap) == 0x0000DD, "Member 'USHGameplayMapFocusableComponent::bWasHintAddedToMap' has a wrong offset!");

// Class SHProto.SHGameplayMapItemComponent
// 0x0018 (0x00D8 - 0x00C0)
class USHGameplayMapItemComponent final : public USHGameplayMapObjectComponent
{
public:
	bool                                          bWantAdditionalGameplayMapHintSignObject;          // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHMapDataConfigStruct                 GameplayMapHintSignObjectConfig;                   // 0x00C4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bWasAddedToMap;                                    // 0x00D0(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessItemCollected(class ASHItem* ItemPtr);
	void ProcessProximityBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayMapItemComponent">();
	}
	static class USHGameplayMapItemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayMapItemComponent>();
	}
};
static_assert(alignof(USHGameplayMapItemComponent) == 0x000008, "Wrong alignment on USHGameplayMapItemComponent");
static_assert(sizeof(USHGameplayMapItemComponent) == 0x0000D8, "Wrong size on USHGameplayMapItemComponent");
static_assert(offsetof(USHGameplayMapItemComponent, bWantAdditionalGameplayMapHintSignObject) == 0x0000C0, "Member 'USHGameplayMapItemComponent::bWantAdditionalGameplayMapHintSignObject' has a wrong offset!");
static_assert(offsetof(USHGameplayMapItemComponent, GameplayMapHintSignObjectConfig) == 0x0000C4, "Member 'USHGameplayMapItemComponent::GameplayMapHintSignObjectConfig' has a wrong offset!");
static_assert(offsetof(USHGameplayMapItemComponent, bWasAddedToMap) == 0x0000D0, "Member 'USHGameplayMapItemComponent::bWasAddedToMap' has a wrong offset!");

// Class SHProto.SHGameplayMapLadderComponent
// 0x0000 (0x00C0 - 0x00C0)
class USHGameplayMapLadderComponent final : public USHGameplayMapObjectComponent
{
public:
	void ProcessProximityBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayMapLadderComponent">();
	}
	static class USHGameplayMapLadderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayMapLadderComponent>();
	}
};
static_assert(alignof(USHGameplayMapLadderComponent) == 0x000008, "Wrong alignment on USHGameplayMapLadderComponent");
static_assert(sizeof(USHGameplayMapLadderComponent) == 0x0000C0, "Wrong size on USHGameplayMapLadderComponent");

// Class SHProto.SHGameplayMapObstacleComponent
// 0x0000 (0x00C0 - 0x00C0)
class USHGameplayMapObstacleComponent final : public USHGameplayMapObjectComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayMapObstacleComponent">();
	}
	static class USHGameplayMapObstacleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayMapObstacleComponent>();
	}
};
static_assert(alignof(USHGameplayMapObstacleComponent) == 0x000008, "Wrong alignment on USHGameplayMapObstacleComponent");
static_assert(sizeof(USHGameplayMapObstacleComponent) == 0x0000C0, "Wrong size on USHGameplayMapObstacleComponent");

// Class SHProto.SHGameplayMapPushableComponent
// 0x0008 (0x00C8 - 0x00C0)
class USHGameplayMapPushableComponent final : public USHGameplayMapObjectComponent
{
public:
	int32                                         CurrentValue;                                      // 0x00C0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessComponentBlockedChangedEvent(class USHPushableComponent* PushableComponent);
	void ProcessComponentMovementEvent(class USHPushableComponent* PushableComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayMapPushableComponent">();
	}
	static class USHGameplayMapPushableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayMapPushableComponent>();
	}
};
static_assert(alignof(USHGameplayMapPushableComponent) == 0x000008, "Wrong alignment on USHGameplayMapPushableComponent");
static_assert(sizeof(USHGameplayMapPushableComponent) == 0x0000C8, "Wrong size on USHGameplayMapPushableComponent");
static_assert(offsetof(USHGameplayMapPushableComponent, CurrentValue) == 0x0000C0, "Member 'USHGameplayMapPushableComponent::CurrentValue' has a wrong offset!");

// Class SHProto.SHGameplayMapRenderWidget
// 0x0030 (0x02A8 - 0x0278)
class USHGameplayMapRenderWidget final : public UUserWidget
{
public:
	class UWidgetSwitcher*                        MapsWidgetSwitcher;                                // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScaleBox*                              MapScaleBox;                                       // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULocalizedFont*                         LocalizedFont;                                     // 0x0288(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x0290(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayMapBaseWidget*               CurrentMapWidget;                                  // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayMapRenderWidget">();
	}
	static class USHGameplayMapRenderWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayMapRenderWidget>();
	}
};
static_assert(alignof(USHGameplayMapRenderWidget) == 0x000008, "Wrong alignment on USHGameplayMapRenderWidget");
static_assert(sizeof(USHGameplayMapRenderWidget) == 0x0002A8, "Wrong size on USHGameplayMapRenderWidget");
static_assert(offsetof(USHGameplayMapRenderWidget, MapsWidgetSwitcher) == 0x000278, "Member 'USHGameplayMapRenderWidget::MapsWidgetSwitcher' has a wrong offset!");
static_assert(offsetof(USHGameplayMapRenderWidget, MapScaleBox) == 0x000280, "Member 'USHGameplayMapRenderWidget::MapScaleBox' has a wrong offset!");
static_assert(offsetof(USHGameplayMapRenderWidget, LocalizedFont) == 0x000288, "Member 'USHGameplayMapRenderWidget::LocalizedFont' has a wrong offset!");
static_assert(offsetof(USHGameplayMapRenderWidget, OwnerCharacter) == 0x000290, "Member 'USHGameplayMapRenderWidget::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHGameplayMapRenderWidget, CurrentMapWidget) == 0x000298, "Member 'USHGameplayMapRenderWidget::CurrentMapWidget' has a wrong offset!");

// Class SHProto.SHGameplayMapSavePointComponent
// 0x0000 (0x00C0 - 0x00C0)
class USHGameplayMapSavePointComponent final : public USHGameplayMapObjectComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayMapSavePointComponent">();
	}
	static class USHGameplayMapSavePointComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayMapSavePointComponent>();
	}
};
static_assert(alignof(USHGameplayMapSavePointComponent) == 0x000008, "Wrong alignment on USHGameplayMapSavePointComponent");
static_assert(sizeof(USHGameplayMapSavePointComponent) == 0x0000C0, "Wrong size on USHGameplayMapSavePointComponent");

// Class SHProto.SHGameplayMapVolume
// 0x0008 (0x02F0 - 0x02E8)
class ASHGameplayMapVolume final : public AVolume
{
public:
	ESHMapsEnum                                   Map;                                               // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayMapVolume">();
	}
	static class ASHGameplayMapVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHGameplayMapVolume>();
	}
};
static_assert(alignof(ASHGameplayMapVolume) == 0x000008, "Wrong alignment on ASHGameplayMapVolume");
static_assert(sizeof(ASHGameplayMapVolume) == 0x0002F0, "Wrong size on ASHGameplayMapVolume");
static_assert(offsetof(ASHGameplayMapVolume, Map) == 0x0002E8, "Member 'ASHGameplayMapVolume::Map' has a wrong offset!");

// Class SHProto.SHGameplayMenuWidget
// 0x0070 (0x02E8 - 0x0278)
class USHGameplayMenuWidget final : public UUserWidget
{
public:
	class UCanvasPanel*                           MainCanvas;                                        // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        SectionSwitcher;                                   // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           EmptySection;                                      // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHGMSectionInventoryWidget*            InventoryWidget;                                   // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHGameplaySectionCombineWidget*        CombineWidget;                                     // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       SectionFadeIn;                                     // 0x02A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       SectionFadeOut;                                    // 0x02A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          NonInventoryAudioModEvent;                         // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          InventorySectionState_On;                          // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          InventorySectionState_Off;                         // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEffectHandle                          LightEffect;                                       // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x02D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplaySectionBaseWidget*           CurrentCastedWidget;                               // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayMenuWidget">();
	}
	static class USHGameplayMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayMenuWidget>();
	}
};
static_assert(alignof(USHGameplayMenuWidget) == 0x000008, "Wrong alignment on USHGameplayMenuWidget");
static_assert(sizeof(USHGameplayMenuWidget) == 0x0002E8, "Wrong size on USHGameplayMenuWidget");
static_assert(offsetof(USHGameplayMenuWidget, MainCanvas) == 0x000278, "Member 'USHGameplayMenuWidget::MainCanvas' has a wrong offset!");
static_assert(offsetof(USHGameplayMenuWidget, SectionSwitcher) == 0x000280, "Member 'USHGameplayMenuWidget::SectionSwitcher' has a wrong offset!");
static_assert(offsetof(USHGameplayMenuWidget, EmptySection) == 0x000288, "Member 'USHGameplayMenuWidget::EmptySection' has a wrong offset!");
static_assert(offsetof(USHGameplayMenuWidget, InventoryWidget) == 0x000290, "Member 'USHGameplayMenuWidget::InventoryWidget' has a wrong offset!");
static_assert(offsetof(USHGameplayMenuWidget, CombineWidget) == 0x000298, "Member 'USHGameplayMenuWidget::CombineWidget' has a wrong offset!");
static_assert(offsetof(USHGameplayMenuWidget, SectionFadeIn) == 0x0002A0, "Member 'USHGameplayMenuWidget::SectionFadeIn' has a wrong offset!");
static_assert(offsetof(USHGameplayMenuWidget, SectionFadeOut) == 0x0002A8, "Member 'USHGameplayMenuWidget::SectionFadeOut' has a wrong offset!");
static_assert(offsetof(USHGameplayMenuWidget, NonInventoryAudioModEvent) == 0x0002B0, "Member 'USHGameplayMenuWidget::NonInventoryAudioModEvent' has a wrong offset!");
static_assert(offsetof(USHGameplayMenuWidget, InventorySectionState_On) == 0x0002B8, "Member 'USHGameplayMenuWidget::InventorySectionState_On' has a wrong offset!");
static_assert(offsetof(USHGameplayMenuWidget, InventorySectionState_Off) == 0x0002C0, "Member 'USHGameplayMenuWidget::InventorySectionState_Off' has a wrong offset!");
static_assert(offsetof(USHGameplayMenuWidget, LightEffect) == 0x0002C8, "Member 'USHGameplayMenuWidget::LightEffect' has a wrong offset!");
static_assert(offsetof(USHGameplayMenuWidget, OwnerCharacter) == 0x0002D0, "Member 'USHGameplayMenuWidget::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHGameplayMenuWidget, CurrentCastedWidget) == 0x0002D8, "Member 'USHGameplayMenuWidget::CurrentCastedWidget' has a wrong offset!");

// Class SHProto.SHGameplayRadioIndicatorWidget
// 0x0040 (0x02B8 - 0x0278)
class USHGameplayRadioIndicatorWidget final : public UUserWidget
{
public:
	class UImage*                                 BackgroundImage;                                   // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 NoiseImage;                                        // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHMaterialPropertyControlSettings*     MaterialPropertyControlSettings;                   // 0x0288(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSHMaterialPropertyControlHandler> MaterialPropertyControlHandlers;                   // 0x0290(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x18];                                     // 0x02A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessOwnerCharacterItemCollectedEvent(class USHCharacterPlayItemsComponent* ComponentPtr, class FName ItemContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayRadioIndicatorWidget">();
	}
	static class USHGameplayRadioIndicatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayRadioIndicatorWidget>();
	}
};
static_assert(alignof(USHGameplayRadioIndicatorWidget) == 0x000008, "Wrong alignment on USHGameplayRadioIndicatorWidget");
static_assert(sizeof(USHGameplayRadioIndicatorWidget) == 0x0002B8, "Wrong size on USHGameplayRadioIndicatorWidget");
static_assert(offsetof(USHGameplayRadioIndicatorWidget, BackgroundImage) == 0x000278, "Member 'USHGameplayRadioIndicatorWidget::BackgroundImage' has a wrong offset!");
static_assert(offsetof(USHGameplayRadioIndicatorWidget, NoiseImage) == 0x000280, "Member 'USHGameplayRadioIndicatorWidget::NoiseImage' has a wrong offset!");
static_assert(offsetof(USHGameplayRadioIndicatorWidget, MaterialPropertyControlSettings) == 0x000288, "Member 'USHGameplayRadioIndicatorWidget::MaterialPropertyControlSettings' has a wrong offset!");
static_assert(offsetof(USHGameplayRadioIndicatorWidget, MaterialPropertyControlHandlers) == 0x000290, "Member 'USHGameplayRadioIndicatorWidget::MaterialPropertyControlHandlers' has a wrong offset!");

// Class SHProto.SHGameplayRainVolume
// 0x0000 (0x02F0 - 0x02F0)
class ASHGameplayRainVolume final : public ASHNiagaraVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayRainVolume">();
	}
	static class ASHGameplayRainVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHGameplayRainVolume>();
	}
};
static_assert(alignof(ASHGameplayRainVolume) == 0x000008, "Wrong alignment on ASHGameplayRainVolume");
static_assert(sizeof(ASHGameplayRainVolume) == 0x0002F0, "Wrong size on ASHGameplayRainVolume");

// Class SHProto.SHGameplayReadingWidget
// 0x0088 (0x0300 - 0x0278)
class USHGameplayReadingWidget final : public UUserWidget
{
public:
	class UCanvasPanel*                           MainCanvas;                                        // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScrollBox*                             TextScroller;                                      // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStyledRichTextBlock*                   MainTextBlock;                                     // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       FadeIn;                                            // 0x0290(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       FadeOut;                                           // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHGameTextsConfig*                     GameTextsConfig;                                   // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInheritTextColor;                                 // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SingleScrollValue;                                 // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ContinousScrollValue;                              // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x02B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x40];                                     // 0x02C0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessPlayerSettingsChanged();
	void ProcessShow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayReadingWidget">();
	}
	static class USHGameplayReadingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayReadingWidget>();
	}
};
static_assert(alignof(USHGameplayReadingWidget) == 0x000008, "Wrong alignment on USHGameplayReadingWidget");
static_assert(sizeof(USHGameplayReadingWidget) == 0x000300, "Wrong size on USHGameplayReadingWidget");
static_assert(offsetof(USHGameplayReadingWidget, MainCanvas) == 0x000278, "Member 'USHGameplayReadingWidget::MainCanvas' has a wrong offset!");
static_assert(offsetof(USHGameplayReadingWidget, TextScroller) == 0x000280, "Member 'USHGameplayReadingWidget::TextScroller' has a wrong offset!");
static_assert(offsetof(USHGameplayReadingWidget, MainTextBlock) == 0x000288, "Member 'USHGameplayReadingWidget::MainTextBlock' has a wrong offset!");
static_assert(offsetof(USHGameplayReadingWidget, FadeIn) == 0x000290, "Member 'USHGameplayReadingWidget::FadeIn' has a wrong offset!");
static_assert(offsetof(USHGameplayReadingWidget, FadeOut) == 0x000298, "Member 'USHGameplayReadingWidget::FadeOut' has a wrong offset!");
static_assert(offsetof(USHGameplayReadingWidget, GameTextsConfig) == 0x0002A0, "Member 'USHGameplayReadingWidget::GameTextsConfig' has a wrong offset!");
static_assert(offsetof(USHGameplayReadingWidget, bInheritTextColor) == 0x0002A8, "Member 'USHGameplayReadingWidget::bInheritTextColor' has a wrong offset!");
static_assert(offsetof(USHGameplayReadingWidget, SingleScrollValue) == 0x0002AC, "Member 'USHGameplayReadingWidget::SingleScrollValue' has a wrong offset!");
static_assert(offsetof(USHGameplayReadingWidget, ContinousScrollValue) == 0x0002B0, "Member 'USHGameplayReadingWidget::ContinousScrollValue' has a wrong offset!");
static_assert(offsetof(USHGameplayReadingWidget, OwnerCharacter) == 0x0002B8, "Member 'USHGameplayReadingWidget::OwnerCharacter' has a wrong offset!");

// Class SHProto.SHGameplaySaveMenuWidget
// 0x00E8 (0x0388 - 0x02A0)
class USHGameplaySaveMenuWidget final : public UBUserWidget
{
public:
	TArray<struct FKey>                           BackKeys;                                          // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           SaveKeys;                                          // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bShowTooltips;                                     // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           MainCanvas;                                        // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHSaveSlotsListWidget*                 SlotsList_wdg;                                     // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBButton*                               Back_but;                                          // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBButton*                               Save_but;                                          // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       Setup;                                             // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       FadeIn;                                            // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       FadeOut;                                           // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       ShowSaved;                                         // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEffectHandle                          LightEffect;                                       // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x0310(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHSavePoint*                           ActualSavePoint;                                   // 0x0318(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x68];                                     // 0x0320(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool HideInstant();
	bool PlayHide();
	bool PlaySetup(class ASHSavePoint* SavePoint);
	bool PlayShow();

	bool IsAvailable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplaySaveMenuWidget">();
	}
	static class USHGameplaySaveMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplaySaveMenuWidget>();
	}
};
static_assert(alignof(USHGameplaySaveMenuWidget) == 0x000008, "Wrong alignment on USHGameplaySaveMenuWidget");
static_assert(sizeof(USHGameplaySaveMenuWidget) == 0x000388, "Wrong size on USHGameplaySaveMenuWidget");
static_assert(offsetof(USHGameplaySaveMenuWidget, BackKeys) == 0x0002A0, "Member 'USHGameplaySaveMenuWidget::BackKeys' has a wrong offset!");
static_assert(offsetof(USHGameplaySaveMenuWidget, SaveKeys) == 0x0002B0, "Member 'USHGameplaySaveMenuWidget::SaveKeys' has a wrong offset!");
static_assert(offsetof(USHGameplaySaveMenuWidget, bShowTooltips) == 0x0002C0, "Member 'USHGameplaySaveMenuWidget::bShowTooltips' has a wrong offset!");
static_assert(offsetof(USHGameplaySaveMenuWidget, MainCanvas) == 0x0002C8, "Member 'USHGameplaySaveMenuWidget::MainCanvas' has a wrong offset!");
static_assert(offsetof(USHGameplaySaveMenuWidget, SlotsList_wdg) == 0x0002D0, "Member 'USHGameplaySaveMenuWidget::SlotsList_wdg' has a wrong offset!");
static_assert(offsetof(USHGameplaySaveMenuWidget, Back_but) == 0x0002D8, "Member 'USHGameplaySaveMenuWidget::Back_but' has a wrong offset!");
static_assert(offsetof(USHGameplaySaveMenuWidget, Save_but) == 0x0002E0, "Member 'USHGameplaySaveMenuWidget::Save_but' has a wrong offset!");
static_assert(offsetof(USHGameplaySaveMenuWidget, Setup) == 0x0002E8, "Member 'USHGameplaySaveMenuWidget::Setup' has a wrong offset!");
static_assert(offsetof(USHGameplaySaveMenuWidget, FadeIn) == 0x0002F0, "Member 'USHGameplaySaveMenuWidget::FadeIn' has a wrong offset!");
static_assert(offsetof(USHGameplaySaveMenuWidget, FadeOut) == 0x0002F8, "Member 'USHGameplaySaveMenuWidget::FadeOut' has a wrong offset!");
static_assert(offsetof(USHGameplaySaveMenuWidget, ShowSaved) == 0x000300, "Member 'USHGameplaySaveMenuWidget::ShowSaved' has a wrong offset!");
static_assert(offsetof(USHGameplaySaveMenuWidget, LightEffect) == 0x000308, "Member 'USHGameplaySaveMenuWidget::LightEffect' has a wrong offset!");
static_assert(offsetof(USHGameplaySaveMenuWidget, OwnerCharacter) == 0x000310, "Member 'USHGameplaySaveMenuWidget::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHGameplaySaveMenuWidget, ActualSavePoint) == 0x000318, "Member 'USHGameplaySaveMenuWidget::ActualSavePoint' has a wrong offset!");

// Class SHProto.SHGameplayStatics
// 0x0000 (0x0028 - 0x0028)
class USHGameplayStatics final : public UBlueprintFunctionLibrary
{
public:
	static void AddFutureViewLocation(const struct FVector& Location);
	static void CreateAutoSave(const class UObject* WorldContextObject, class FName InAutoSaveName);
	static void DestroyChildActorChild(class UChildActorComponent* ChildActorComponent);
	static void EnsurePlayerHasFullHealth(const class UObject* WorldContextObject, const bool bInInvisibleHeal);
	static void GameEnded(const class UObject* WorldContextObject);
	static void GameOver(const class UObject* WorldContextObject, EGameOverCause Cause);
	static ECombatDifficulty GetCombatDifficulty(const class UObject* WorldContextObject);
	static EPuzzlesDifficulty GetPuzzlesDifficulty(const class UObject* WorldContextObject);
	static bool IsCharacterOverlappingProximitySphere(class ACharacter* InCharacter, class USphereComponent* InProximitySphere);
	static void RecordCombatState(const class UObject* WorldContextObject, const class FString& InContextString);
	static void RecordEndingsFactorsState(const class UObject* WorldContextObject, const class FString& InContextString);
	static void RecordInventoryState(const class UObject* WorldContextObject, const class FString& InContextString);
	static void ReCreateChildActorChild(class UChildActorComponent* ChildActorComponent, bool Force);
	static void SaveAndReloadGame(const class UObject* WorldContextObject, class FName InAutoSaveName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayStatics">();
	}
	static class USHGameplayStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayStatics>();
	}
};
static_assert(alignof(USHGameplayStatics) == 0x000008, "Wrong alignment on USHGameplayStatics");
static_assert(sizeof(USHGameplayStatics) == 0x000028, "Wrong size on USHGameplayStatics");

// Class SHProto.SHGameplayStruggleWidget
// 0x00B0 (0x0328 - 0x0278)
class USHGameplayStruggleWidget final : public UUserWidget
{
public:
	struct FUE4InputHandle                        InputHandle;                                       // 0x0278(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EStruggleInputSize, float>               InputScaleMultipliers;                             // 0x0288(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_MainContainer;                         // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_InputContainer;                        // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTipTextBlock*                          TipTextBlock_ActionTip;                            // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ShowAnim;                                          // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       LoopAnim;                                          // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       HideAnim_Success;                                  // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       HideAnim_Fail;                                     // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x18];                                     // 0x0310(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHide();
	void OnInstantHide();
	void OnShow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayStruggleWidget">();
	}
	static class USHGameplayStruggleWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayStruggleWidget>();
	}
};
static_assert(alignof(USHGameplayStruggleWidget) == 0x000008, "Wrong alignment on USHGameplayStruggleWidget");
static_assert(sizeof(USHGameplayStruggleWidget) == 0x000328, "Wrong size on USHGameplayStruggleWidget");
static_assert(offsetof(USHGameplayStruggleWidget, InputHandle) == 0x000278, "Member 'USHGameplayStruggleWidget::InputHandle' has a wrong offset!");
static_assert(offsetof(USHGameplayStruggleWidget, InputScaleMultipliers) == 0x000288, "Member 'USHGameplayStruggleWidget::InputScaleMultipliers' has a wrong offset!");
static_assert(offsetof(USHGameplayStruggleWidget, CanvasPanel_MainContainer) == 0x0002D8, "Member 'USHGameplayStruggleWidget::CanvasPanel_MainContainer' has a wrong offset!");
static_assert(offsetof(USHGameplayStruggleWidget, CanvasPanel_InputContainer) == 0x0002E0, "Member 'USHGameplayStruggleWidget::CanvasPanel_InputContainer' has a wrong offset!");
static_assert(offsetof(USHGameplayStruggleWidget, TipTextBlock_ActionTip) == 0x0002E8, "Member 'USHGameplayStruggleWidget::TipTextBlock_ActionTip' has a wrong offset!");
static_assert(offsetof(USHGameplayStruggleWidget, ShowAnim) == 0x0002F0, "Member 'USHGameplayStruggleWidget::ShowAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayStruggleWidget, LoopAnim) == 0x0002F8, "Member 'USHGameplayStruggleWidget::LoopAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayStruggleWidget, HideAnim_Success) == 0x000300, "Member 'USHGameplayStruggleWidget::HideAnim_Success' has a wrong offset!");
static_assert(offsetof(USHGameplayStruggleWidget, HideAnim_Fail) == 0x000308, "Member 'USHGameplayStruggleWidget::HideAnim_Fail' has a wrong offset!");

// Class SHProto.SHGameplayTutorialsDatabase
// 0x00A0 (0x00D0 - 0x0030)
class USHGameplayTutorialsDatabase final : public UDataAsset
{
public:
	TMap<ESHGameplayTutorialEnum, struct FSHGameplayTutorialData> Database;                                          // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ESHGameplayTutorialEnum, struct FSHGameplayTutorialCoreData> ScriptedDatabase;                                  // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayTutorialsDatabase">();
	}
	static class USHGameplayTutorialsDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayTutorialsDatabase>();
	}
};
static_assert(alignof(USHGameplayTutorialsDatabase) == 0x000008, "Wrong alignment on USHGameplayTutorialsDatabase");
static_assert(sizeof(USHGameplayTutorialsDatabase) == 0x0000D0, "Wrong size on USHGameplayTutorialsDatabase");
static_assert(offsetof(USHGameplayTutorialsDatabase, Database) == 0x000030, "Member 'USHGameplayTutorialsDatabase::Database' has a wrong offset!");
static_assert(offsetof(USHGameplayTutorialsDatabase, ScriptedDatabase) == 0x000080, "Member 'USHGameplayTutorialsDatabase::ScriptedDatabase' has a wrong offset!");

// Class SHProto.SHGameplayTutorialWidget
// 0x00A0 (0x0318 - 0x0278)
class USHGameplayTutorialWidget final : public UUserWidget
{
public:
	class UStyledRichTextBlock*                   TutorialRichText;                                  // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           MainContainer;                                     // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ShowAnim;                                          // 0x0288(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       HideAnim;                                          // 0x0290(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumDisplayTime;                                // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USHGameTextsConfig*                     GameTextsConfig;                                   // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ShowAudioEvent;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x68];                                     // 0x02B0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayTutorialWidget">();
	}
	static class USHGameplayTutorialWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayTutorialWidget>();
	}
};
static_assert(alignof(USHGameplayTutorialWidget) == 0x000008, "Wrong alignment on USHGameplayTutorialWidget");
static_assert(sizeof(USHGameplayTutorialWidget) == 0x000318, "Wrong size on USHGameplayTutorialWidget");
static_assert(offsetof(USHGameplayTutorialWidget, TutorialRichText) == 0x000278, "Member 'USHGameplayTutorialWidget::TutorialRichText' has a wrong offset!");
static_assert(offsetof(USHGameplayTutorialWidget, MainContainer) == 0x000280, "Member 'USHGameplayTutorialWidget::MainContainer' has a wrong offset!");
static_assert(offsetof(USHGameplayTutorialWidget, ShowAnim) == 0x000288, "Member 'USHGameplayTutorialWidget::ShowAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayTutorialWidget, HideAnim) == 0x000290, "Member 'USHGameplayTutorialWidget::HideAnim' has a wrong offset!");
static_assert(offsetof(USHGameplayTutorialWidget, MinimumDisplayTime) == 0x000298, "Member 'USHGameplayTutorialWidget::MinimumDisplayTime' has a wrong offset!");
static_assert(offsetof(USHGameplayTutorialWidget, GameTextsConfig) == 0x0002A0, "Member 'USHGameplayTutorialWidget::GameTextsConfig' has a wrong offset!");
static_assert(offsetof(USHGameplayTutorialWidget, ShowAudioEvent) == 0x0002A8, "Member 'USHGameplayTutorialWidget::ShowAudioEvent' has a wrong offset!");

// Class SHProto.SHGameplayUIStatics
// 0x0000 (0x0028 - 0x0028)
class USHGameplayUIStatics final : public UBlueprintFunctionLibrary
{
public:
	static void HideTips(class UObject* WorldContextObject);
	static void LatentGameplayFadeIn(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void LatentGameplayFadeOut(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void RemoveGameplayFadeInstant(class UObject* WorldContextObject);
	static float RequestCustomGameplayFadeIn(class UObject* WorldContextObject, float InFadeTime);
	static float RequestCustomGameplayFadeOut(class UObject* WorldContextObject, float InFadeTime);
	static float RequestGameplayFadeIn(class UObject* WorldContextObject);
	static float RequestGameplayFadeOut(class UObject* WorldContextObject);
	static void RequestItemNotification(class UObject* WorldContextObject, class FName ItemDataRowName, int32 ItemQuantity, ESHGameplayItemNotificationType ItemNotificationType);
	static void SetGameplayFadeColor(class UObject* WorldContextObject, const struct FLinearColor& InColor);
	static bool ShowEnviromentalSubtitle(class UObject* WorldContextObject, const struct FDialogLine& DialogLineID);
	static void ShowTips(class UObject* WorldContextObject, const TArray<class FName>& Tips, bool WithBackground, bool UseVisibilitySettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameplayUIStatics">();
	}
	static class USHGameplayUIStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameplayUIStatics>();
	}
};
static_assert(alignof(USHGameplayUIStatics) == 0x000008, "Wrong alignment on USHGameplayUIStatics");
static_assert(sizeof(USHGameplayUIStatics) == 0x000028, "Wrong size on USHGameplayUIStatics");

// Class SHProto.SHGameStateMenu
// 0x0000 (0x0300 - 0x0300)
class ASHGameStateMenu final : public ASHGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameStateMenu">();
	}
	static class ASHGameStateMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHGameStateMenu>();
	}
};
static_assert(alignof(ASHGameStateMenu) == 0x000008, "Wrong alignment on ASHGameStateMenu");
static_assert(sizeof(ASHGameStateMenu) == 0x000300, "Wrong size on ASHGameStateMenu");

// Class SHProto.SHGameStatePlay
// 0x0000 (0x0300 - 0x0300)
class ASHGameStatePlay final : public ASHGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameStatePlay">();
	}
	static class ASHGameStatePlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHGameStatePlay>();
	}
};
static_assert(alignof(ASHGameStatePlay) == 0x000008, "Wrong alignment on ASHGameStatePlay");
static_assert(sizeof(ASHGameStatePlay) == 0x000300, "Wrong size on ASHGameStatePlay");

// Class SHProto.SHGameTextsConfig
// 0x0330 (0x07B0 - 0x0480)
class USHGameTextsConfig final : public UGameTextsConfig
{
public:
	struct FGameTextData                          TranscriptionTextData;                             // 0x0480(0x0170)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameTextData                          TutorialsTextData;                                 // 0x05F0(0x0170)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EInteractionIconSize, float>             InteractionIconScaleMultiplier;                    // 0x0760(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGameTextsConfig">();
	}
	static class USHGameTextsConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGameTextsConfig>();
	}
};
static_assert(alignof(USHGameTextsConfig) == 0x000008, "Wrong alignment on USHGameTextsConfig");
static_assert(sizeof(USHGameTextsConfig) == 0x0007B0, "Wrong size on USHGameTextsConfig");
static_assert(offsetof(USHGameTextsConfig, TranscriptionTextData) == 0x000480, "Member 'USHGameTextsConfig::TranscriptionTextData' has a wrong offset!");
static_assert(offsetof(USHGameTextsConfig, TutorialsTextData) == 0x0005F0, "Member 'USHGameTextsConfig::TutorialsTextData' has a wrong offset!");
static_assert(offsetof(USHGameTextsConfig, InteractionIconScaleMultiplier) == 0x000760, "Member 'USHGameTextsConfig::InteractionIconScaleMultiplier' has a wrong offset!");

// Class SHProto.SHGeometryCollectionActor
// 0x0000 (0x02C0 - 0x02C0)
class ASHGeometryCollectionActor final : public AGeometryCollectionActor
{
public:
	int32 GetNumElements();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGeometryCollectionActor">();
	}
	static class ASHGeometryCollectionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHGeometryCollectionActor>();
	}
};
static_assert(alignof(ASHGeometryCollectionActor) == 0x000008, "Wrong alignment on ASHGeometryCollectionActor");
static_assert(sizeof(ASHGeometryCollectionActor) == 0x0002C0, "Wrong size on ASHGeometryCollectionActor");

// Class SHProto.SHGMSectionInventoryWidget
// 0x0118 (0x03A8 - 0x0290)
class USHGMSectionInventoryWidget final : public USHGameplaySectionBaseWidget
{
public:
	class USHGameplayInventorySlider*             GameplayInventorySliderWidget;                     // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSHInventoryCategoryConfig>     CategoriesConfig;                                  // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAllowLoopCategories;                              // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinMaxVector2D                        InputBlockWaitTimeMinMax;                          // 0x02AC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InputThrottleAcceleration;                         // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShowItemsWaitTime;                                 // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class USHInventoryCategoryWidget> CategoryWidgetSubclass;                            // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class USHInventoryCategoryWidget> SubcategoryWidgetSubclass;                         // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_OpenInventory;                          // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_CloseInventory;                         // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_MoveCategory;                           // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_OpenTranscription;                      // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_CloseTransription;                      // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_NotUsableItem;                          // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHHealthBasedBorder*                   Border;                                            // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHHealthBasedRetainerBox*              RetainerBox;                                       // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScrollBox*                             CategoriesContainerScrollBox;                      // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           CombineIndicatorContainer;                         // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_320[0x88];                                     // 0x0320(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHGMSectionInventoryWidget">();
	}
	static class USHGMSectionInventoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHGMSectionInventoryWidget>();
	}
};
static_assert(alignof(USHGMSectionInventoryWidget) == 0x000008, "Wrong alignment on USHGMSectionInventoryWidget");
static_assert(sizeof(USHGMSectionInventoryWidget) == 0x0003A8, "Wrong size on USHGMSectionInventoryWidget");
static_assert(offsetof(USHGMSectionInventoryWidget, GameplayInventorySliderWidget) == 0x000290, "Member 'USHGMSectionInventoryWidget::GameplayInventorySliderWidget' has a wrong offset!");
static_assert(offsetof(USHGMSectionInventoryWidget, CategoriesConfig) == 0x000298, "Member 'USHGMSectionInventoryWidget::CategoriesConfig' has a wrong offset!");
static_assert(offsetof(USHGMSectionInventoryWidget, bAllowLoopCategories) == 0x0002A8, "Member 'USHGMSectionInventoryWidget::bAllowLoopCategories' has a wrong offset!");
static_assert(offsetof(USHGMSectionInventoryWidget, InputBlockWaitTimeMinMax) == 0x0002AC, "Member 'USHGMSectionInventoryWidget::InputBlockWaitTimeMinMax' has a wrong offset!");
static_assert(offsetof(USHGMSectionInventoryWidget, InputThrottleAcceleration) == 0x0002B4, "Member 'USHGMSectionInventoryWidget::InputThrottleAcceleration' has a wrong offset!");
static_assert(offsetof(USHGMSectionInventoryWidget, ShowItemsWaitTime) == 0x0002B8, "Member 'USHGMSectionInventoryWidget::ShowItemsWaitTime' has a wrong offset!");
static_assert(offsetof(USHGMSectionInventoryWidget, CategoryWidgetSubclass) == 0x0002C0, "Member 'USHGMSectionInventoryWidget::CategoryWidgetSubclass' has a wrong offset!");
static_assert(offsetof(USHGMSectionInventoryWidget, SubcategoryWidgetSubclass) == 0x0002C8, "Member 'USHGMSectionInventoryWidget::SubcategoryWidgetSubclass' has a wrong offset!");
static_assert(offsetof(USHGMSectionInventoryWidget, AudioEvent_OpenInventory) == 0x0002D0, "Member 'USHGMSectionInventoryWidget::AudioEvent_OpenInventory' has a wrong offset!");
static_assert(offsetof(USHGMSectionInventoryWidget, AudioEvent_CloseInventory) == 0x0002D8, "Member 'USHGMSectionInventoryWidget::AudioEvent_CloseInventory' has a wrong offset!");
static_assert(offsetof(USHGMSectionInventoryWidget, AudioEvent_MoveCategory) == 0x0002E0, "Member 'USHGMSectionInventoryWidget::AudioEvent_MoveCategory' has a wrong offset!");
static_assert(offsetof(USHGMSectionInventoryWidget, AudioEvent_OpenTranscription) == 0x0002E8, "Member 'USHGMSectionInventoryWidget::AudioEvent_OpenTranscription' has a wrong offset!");
static_assert(offsetof(USHGMSectionInventoryWidget, AudioEvent_CloseTransription) == 0x0002F0, "Member 'USHGMSectionInventoryWidget::AudioEvent_CloseTransription' has a wrong offset!");
static_assert(offsetof(USHGMSectionInventoryWidget, AudioEvent_NotUsableItem) == 0x0002F8, "Member 'USHGMSectionInventoryWidget::AudioEvent_NotUsableItem' has a wrong offset!");
static_assert(offsetof(USHGMSectionInventoryWidget, Border) == 0x000300, "Member 'USHGMSectionInventoryWidget::Border' has a wrong offset!");
static_assert(offsetof(USHGMSectionInventoryWidget, RetainerBox) == 0x000308, "Member 'USHGMSectionInventoryWidget::RetainerBox' has a wrong offset!");
static_assert(offsetof(USHGMSectionInventoryWidget, CategoriesContainerScrollBox) == 0x000310, "Member 'USHGMSectionInventoryWidget::CategoriesContainerScrollBox' has a wrong offset!");
static_assert(offsetof(USHGMSectionInventoryWidget, CombineIndicatorContainer) == 0x000318, "Member 'USHGMSectionInventoryWidget::CombineIndicatorContainer' has a wrong offset!");

// Class SHProto.SHHealthBasedRetainerBox
// 0x0018 (0x0218 - 0x0200)
class USHHealthBasedRetainerBox final : public USHCustomRetainerBox
{
public:
	float                                         ShowAnimationDurationSeconds;                      // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x0208(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_210[0x8];                                      // 0x0210(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHealthBasedRetainerBox">();
	}
	static class USHHealthBasedRetainerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHHealthBasedRetainerBox>();
	}
};
static_assert(alignof(USHHealthBasedRetainerBox) == 0x000008, "Wrong alignment on USHHealthBasedRetainerBox");
static_assert(sizeof(USHHealthBasedRetainerBox) == 0x000218, "Wrong size on USHHealthBasedRetainerBox");
static_assert(offsetof(USHHealthBasedRetainerBox, ShowAnimationDurationSeconds) == 0x000200, "Member 'USHHealthBasedRetainerBox::ShowAnimationDurationSeconds' has a wrong offset!");
static_assert(offsetof(USHHealthBasedRetainerBox, OwnerCharacter) == 0x000208, "Member 'USHHealthBasedRetainerBox::OwnerCharacter' has a wrong offset!");

// Class SHProto.SHHitReactionCooldownComponent
// 0x0288 (0x0328 - 0x00A0)
class USHHitReactionCooldownComponent final : public UActorComponent
{
public:
	TMap<class FName, float>                      NormalCooldowns;                                   // 0x00A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      FalterCooldowns;                                   // 0x00F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      StaggerCooldowns;                                  // 0x0140(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      KnockdownCooldowns;                                // 0x0190(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E0[0x140];                                    // 0x01E0(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          PrintDebug;                                        // 0x0320(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_321[0x7];                                      // 0x0321(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FName> GetVariantsOnCooldown(ESHHitReactionResponseType Reaction);
	bool IsReactionOnCooldown(ESHHitReactionResponseType Reaction, class FName Variant);
	void SetCooldownTimerForHitReaction(ESHHitReactionResponseType Reaction, class FName Variant);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHitReactionCooldownComponent">();
	}
	static class USHHitReactionCooldownComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHHitReactionCooldownComponent>();
	}
};
static_assert(alignof(USHHitReactionCooldownComponent) == 0x000008, "Wrong alignment on USHHitReactionCooldownComponent");
static_assert(sizeof(USHHitReactionCooldownComponent) == 0x000328, "Wrong size on USHHitReactionCooldownComponent");
static_assert(offsetof(USHHitReactionCooldownComponent, NormalCooldowns) == 0x0000A0, "Member 'USHHitReactionCooldownComponent::NormalCooldowns' has a wrong offset!");
static_assert(offsetof(USHHitReactionCooldownComponent, FalterCooldowns) == 0x0000F0, "Member 'USHHitReactionCooldownComponent::FalterCooldowns' has a wrong offset!");
static_assert(offsetof(USHHitReactionCooldownComponent, StaggerCooldowns) == 0x000140, "Member 'USHHitReactionCooldownComponent::StaggerCooldowns' has a wrong offset!");
static_assert(offsetof(USHHitReactionCooldownComponent, KnockdownCooldowns) == 0x000190, "Member 'USHHitReactionCooldownComponent::KnockdownCooldowns' has a wrong offset!");
static_assert(offsetof(USHHitReactionCooldownComponent, PrintDebug) == 0x000320, "Member 'USHHitReactionCooldownComponent::PrintDebug' has a wrong offset!");

// Class SHProto.SHHitReactionState
// 0x0070 (0x0098 - 0x0028)
class USHHitReactionState final : public UObject
{
public:
	class USHHitReactionStatesContext*            HitReactionStateContext;                           // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USHAnimMontagePlayer*>           BoundAnimations;                                   // 0x0030(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPlayAnimationData>             FinishingAnimations;                               // 0x0040(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x48];                                      // 0x0050(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BoundAnimationBlendingOut(class UAnimMontage* InMontage, ESHAnimEndType InAnimEndType);
	void BoundAnimationEnded(class UAnimMontage* InMontage, ESHAnimEndType InAnimEndType);
	bool CancelState(bool InInstant);
	bool StartFinishingState();

	float GetRemainingStateDuration() const;
	void GetStateHitReactionIdentifier(struct FSHHitReactionIdentifier* OutIdentifier) const;
	ESHHitReactionResponseType GetStateHitReactionType() const;
	class FName GetStateHitReactionVariant() const;
	bool HasStateEnded() const;
	bool HasStateStarted() const;
	bool IsStateFinishing() const;
	bool IsStateInProgress(bool InIncludeFinishing) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHitReactionState">();
	}
	static class USHHitReactionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHHitReactionState>();
	}
};
static_assert(alignof(USHHitReactionState) == 0x000008, "Wrong alignment on USHHitReactionState");
static_assert(sizeof(USHHitReactionState) == 0x000098, "Wrong size on USHHitReactionState");
static_assert(offsetof(USHHitReactionState, HitReactionStateContext) == 0x000028, "Member 'USHHitReactionState::HitReactionStateContext' has a wrong offset!");
static_assert(offsetof(USHHitReactionState, BoundAnimations) == 0x000030, "Member 'USHHitReactionState::BoundAnimations' has a wrong offset!");
static_assert(offsetof(USHHitReactionState, FinishingAnimations) == 0x000040, "Member 'USHHitReactionState::FinishingAnimations' has a wrong offset!");

// Class SHProto.SHHitReactionStatesContext
// 0x0038 (0x0060 - 0x0028)
class USHHitReactionStatesContext final : public UObject
{
public:
	class USHHitReactionSubcomponent*             OwningHitReactionSubcomponent;                     // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAnimComponent*                       OwningAnimComponent;                               // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAsyncLoaderComponent*                AssignedAsyncLoader;                               // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USHAnimMontagePlayer*>           MontagePlayersPool;                                // 0x0040(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class USHAnimMontagePlayer*>           OccupiedMontagePlayersPool;                        // 0x0050(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void MontagePlayerAnimationStopped(class UAnimMontage* InMontage, ESHAnimEndType InAnimEndType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHitReactionStatesContext">();
	}
	static class USHHitReactionStatesContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHHitReactionStatesContext>();
	}
};
static_assert(alignof(USHHitReactionStatesContext) == 0x000008, "Wrong alignment on USHHitReactionStatesContext");
static_assert(sizeof(USHHitReactionStatesContext) == 0x000060, "Wrong size on USHHitReactionStatesContext");
static_assert(offsetof(USHHitReactionStatesContext, OwningHitReactionSubcomponent) == 0x000028, "Member 'USHHitReactionStatesContext::OwningHitReactionSubcomponent' has a wrong offset!");
static_assert(offsetof(USHHitReactionStatesContext, OwningAnimComponent) == 0x000030, "Member 'USHHitReactionStatesContext::OwningAnimComponent' has a wrong offset!");
static_assert(offsetof(USHHitReactionStatesContext, AssignedAsyncLoader) == 0x000038, "Member 'USHHitReactionStatesContext::AssignedAsyncLoader' has a wrong offset!");
static_assert(offsetof(USHHitReactionStatesContext, MontagePlayersPool) == 0x000040, "Member 'USHHitReactionStatesContext::MontagePlayersPool' has a wrong offset!");
static_assert(offsetof(USHHitReactionStatesContext, OccupiedMontagePlayersPool) == 0x000050, "Member 'USHHitReactionStatesContext::OccupiedMontagePlayersPool' has a wrong offset!");

// Class SHProto.SHHitReactionArtificialConfig
// 0x0078 (0x00A8 - 0x0030)
class USHHitReactionArtificialConfig final : public UDataAsset
{
public:
	struct FSHHitReactionArtificialHitConfiguration HitReaction;                                       // 0x0030(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHitReactionArtificialConfig">();
	}
	static class USHHitReactionArtificialConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHHitReactionArtificialConfig>();
	}
};
static_assert(alignof(USHHitReactionArtificialConfig) == 0x000008, "Wrong alignment on USHHitReactionArtificialConfig");
static_assert(sizeof(USHHitReactionArtificialConfig) == 0x0000A8, "Wrong size on USHHitReactionArtificialConfig");
static_assert(offsetof(USHHitReactionArtificialConfig, HitReaction) == 0x000030, "Member 'USHHitReactionArtificialConfig::HitReaction' has a wrong offset!");

// Class SHProto.SHHitReactionsBodyMap
// 0x0010 (0x0040 - 0x0030)
class USHHitReactionsBodyMap final : public UDataAsset
{
public:
	TArray<struct FSHHitReactionBodyMapBoneResponse> BoneHitReactionResponses;                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHitReactionsBodyMap">();
	}
	static class USHHitReactionsBodyMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHHitReactionsBodyMap>();
	}
};
static_assert(alignof(USHHitReactionsBodyMap) == 0x000008, "Wrong alignment on USHHitReactionsBodyMap");
static_assert(sizeof(USHHitReactionsBodyMap) == 0x000040, "Wrong size on USHHitReactionsBodyMap");
static_assert(offsetof(USHHitReactionsBodyMap, BoneHitReactionResponses) == 0x000030, "Member 'USHHitReactionsBodyMap::BoneHitReactionResponses' has a wrong offset!");

// Class SHProto.SHHitReactionsSet
// 0x0060 (0x0090 - 0x0030)
class USHHitReactionsSet final : public UDataAsset
{
public:
	TArray<struct FSHHitReactionVariantConfig>    DeathVariantHitReactions;                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSHHitReactionVariantConfig>    KnockdownVariantHitReactions;                      // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSHHitReactionVariantConfig>    FalterVariantHitReactions;                         // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSHHitReactionVariantConfig>    StaggerVariantHitReactions;                        // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSHHitReactionVariantConfig>    NormalVariantHitReactions;                         // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSHHitReactionVariantConfig>    TwitchVariantHitReactions;                         // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	TArray<TSoftObjectPtr<class UObject>> GetDeathSoftObjects() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHitReactionsSet">();
	}
	static class USHHitReactionsSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHHitReactionsSet>();
	}
};
static_assert(alignof(USHHitReactionsSet) == 0x000008, "Wrong alignment on USHHitReactionsSet");
static_assert(sizeof(USHHitReactionsSet) == 0x000090, "Wrong size on USHHitReactionsSet");
static_assert(offsetof(USHHitReactionsSet, DeathVariantHitReactions) == 0x000030, "Member 'USHHitReactionsSet::DeathVariantHitReactions' has a wrong offset!");
static_assert(offsetof(USHHitReactionsSet, KnockdownVariantHitReactions) == 0x000040, "Member 'USHHitReactionsSet::KnockdownVariantHitReactions' has a wrong offset!");
static_assert(offsetof(USHHitReactionsSet, FalterVariantHitReactions) == 0x000050, "Member 'USHHitReactionsSet::FalterVariantHitReactions' has a wrong offset!");
static_assert(offsetof(USHHitReactionsSet, StaggerVariantHitReactions) == 0x000060, "Member 'USHHitReactionsSet::StaggerVariantHitReactions' has a wrong offset!");
static_assert(offsetof(USHHitReactionsSet, NormalVariantHitReactions) == 0x000070, "Member 'USHHitReactionsSet::NormalVariantHitReactions' has a wrong offset!");
static_assert(offsetof(USHHitReactionsSet, TwitchVariantHitReactions) == 0x000080, "Member 'USHHitReactionsSet::TwitchVariantHitReactions' has a wrong offset!");

// Class SHProto.SHHospitalFWLyingMariaInteractionsEndingFactor
// 0x0000 (0x0088 - 0x0088)
class USHHospitalFWLyingMariaInteractionsEndingFactor final : public USHBoolEndingFactor
{
public:
	void SHDebug_Character_Endings_HospitalFWLyingMariaInteractionsEndingFactor_SetDebugValue(bool InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHospitalFWLyingMariaInteractionsEndingFactor">();
	}
	static class USHHospitalFWLyingMariaInteractionsEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHHospitalFWLyingMariaInteractionsEndingFactor>();
	}
};
static_assert(alignof(USHHospitalFWLyingMariaInteractionsEndingFactor) == 0x000008, "Wrong alignment on USHHospitalFWLyingMariaInteractionsEndingFactor");
static_assert(sizeof(USHHospitalFWLyingMariaInteractionsEndingFactor) == 0x000088, "Wrong size on USHHospitalFWLyingMariaInteractionsEndingFactor");

// Class SHProto.SHHotelFWListenedSickbedConversationEndingFactor
// 0x0000 (0x0088 - 0x0088)
class USHHotelFWListenedSickbedConversationEndingFactor final : public USHBoolEndingFactor
{
public:
	void SHDebug_Character_Endings_HotelFWListenedSickbedConversationEndingFactor_SetDebugValue(bool InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHotelFWListenedSickbedConversationEndingFactor">();
	}
	static class USHHotelFWListenedSickbedConversationEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHHotelFWListenedSickbedConversationEndingFactor>();
	}
};
static_assert(alignof(USHHotelFWListenedSickbedConversationEndingFactor) == 0x000008, "Wrong alignment on USHHotelFWListenedSickbedConversationEndingFactor");
static_assert(sizeof(USHHotelFWListenedSickbedConversationEndingFactor) == 0x000088, "Wrong size on USHHotelFWListenedSickbedConversationEndingFactor");

// Class SHProto.SHHotelFWPyramidHeadBossAftermathEndingFactor
// 0x0058 (0x0088 - 0x0030)
class USHHotelFWPyramidHeadBossAftermathEndingFactor final : public USHEndingFactor
{
public:
	TMap<ESHHotelFWPyramidHeadBossAftermathEndingFactorValue, struct FSHEndingScoreChanger> ValueToScoreChangeMap;                             // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	ESHHotelFWPyramidHeadBossAftermathEndingFactorValue Value;                                             // 0x0080(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Character_Endings_Factors_HotelFWPyramidHeadBossAftermath_SetDebugValue(int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHotelFWPyramidHeadBossAftermathEndingFactor">();
	}
	static class USHHotelFWPyramidHeadBossAftermathEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHHotelFWPyramidHeadBossAftermathEndingFactor>();
	}
};
static_assert(alignof(USHHotelFWPyramidHeadBossAftermathEndingFactor) == 0x000008, "Wrong alignment on USHHotelFWPyramidHeadBossAftermathEndingFactor");
static_assert(sizeof(USHHotelFWPyramidHeadBossAftermathEndingFactor) == 0x000088, "Wrong size on USHHotelFWPyramidHeadBossAftermathEndingFactor");
static_assert(offsetof(USHHotelFWPyramidHeadBossAftermathEndingFactor, ValueToScoreChangeMap) == 0x000030, "Member 'USHHotelFWPyramidHeadBossAftermathEndingFactor::ValueToScoreChangeMap' has a wrong offset!");
static_assert(offsetof(USHHotelFWPyramidHeadBossAftermathEndingFactor, Value) == 0x000080, "Member 'USHHotelFWPyramidHeadBossAftermathEndingFactor::Value' has a wrong offset!");

// Class SHProto.SHHotelOWMirrorPuzzleEndingFactor
// 0x0058 (0x0088 - 0x0030)
class USHHotelOWMirrorPuzzleEndingFactor final : public USHEndingFactor
{
public:
	TMap<ESHHotelOWMirrorPuzzleEndingFactorValue, struct FSHEndingScoreChanger> ValueToScoreChangeMap;                             // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	ESHHotelOWMirrorPuzzleEndingFactorValue       Value;                                             // 0x0080(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Character_Endings_Factors_HotelOWMirrorPuzzle_SetDebugValue(int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHotelOWMirrorPuzzleEndingFactor">();
	}
	static class USHHotelOWMirrorPuzzleEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHHotelOWMirrorPuzzleEndingFactor>();
	}
};
static_assert(alignof(USHHotelOWMirrorPuzzleEndingFactor) == 0x000008, "Wrong alignment on USHHotelOWMirrorPuzzleEndingFactor");
static_assert(sizeof(USHHotelOWMirrorPuzzleEndingFactor) == 0x000088, "Wrong size on USHHotelOWMirrorPuzzleEndingFactor");
static_assert(offsetof(USHHotelOWMirrorPuzzleEndingFactor, ValueToScoreChangeMap) == 0x000030, "Member 'USHHotelOWMirrorPuzzleEndingFactor::ValueToScoreChangeMap' has a wrong offset!");
static_assert(offsetof(USHHotelOWMirrorPuzzleEndingFactor, Value) == 0x000080, "Member 'USHHotelOWMirrorPuzzleEndingFactor::Value' has a wrong offset!");

// Class SHProto.SHHudMenu
// 0x0000 (0x0610 - 0x0610)
class ASHHudMenu final : public ASHHud
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHudMenu">();
	}
	static class ASHHudMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHHudMenu>();
	}
};
static_assert(alignof(ASHHudMenu) == 0x000008, "Wrong alignment on ASHHudMenu");
static_assert(sizeof(ASHHudMenu) == 0x000610, "Wrong size on ASHHudMenu");

// Class SHProto.SHHudPlay
// 0x0060 (0x0670 - 0x0610)
class ASHHudPlay final : public ASHHud
{
public:
	bool                                          bDrawPostDebug;                                    // 0x0610(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDOFDebug;                                     // 0x0611(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawPlayerLocation;                               // 0x0612(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_613[0x5D];                                     // 0x0613(0x005D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHHudPlay">();
	}
	static class ASHHudPlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHHudPlay>();
	}
};
static_assert(alignof(ASHHudPlay) == 0x000008, "Wrong alignment on ASHHudPlay");
static_assert(sizeof(ASHHudPlay) == 0x000670, "Wrong size on ASHHudPlay");
static_assert(offsetof(ASHHudPlay, bDrawPostDebug) == 0x000610, "Member 'ASHHudPlay::bDrawPostDebug' has a wrong offset!");
static_assert(offsetof(ASHHudPlay, bDrawDOFDebug) == 0x000611, "Member 'ASHHudPlay::bDrawDOFDebug' has a wrong offset!");
static_assert(offsetof(ASHHudPlay, bDrawPlayerLocation) == 0x000612, "Member 'ASHHudPlay::bDrawPlayerLocation' has a wrong offset!");

// Class SHProto.SHInGameMenuWidget
// 0x0068 (0x03D8 - 0x0370)
class USHInGameMenuWidget final : public USHBaseMainMenuWidget
{
public:
	TArray<struct FKey>                           ResumeKeys;                                        // 0x0370(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FSpawnPointHandle                      NewGameSpawnPoint;                                 // 0x0380(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UBButton*                               Load_but;                                          // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBButton*                               ToMainMenu_but;                                    // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBButton*                               Quit_but;                                          // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAskQuitDialogWidget*                 AskQuit_dialog;                                    // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeIn_anim;                                       // 0x03C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C8[0x10];                                     // 0x03C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AskQuit(EInGameQuitTarget _QuitTarget);
	void FadedOut();
	void FadeOut();
	void OnAskQuit(EInGameQuitTarget _QuitTarget);
	bool OnResume();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInGameMenuWidget">();
	}
	static class USHInGameMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHInGameMenuWidget>();
	}
};
static_assert(alignof(USHInGameMenuWidget) == 0x000008, "Wrong alignment on USHInGameMenuWidget");
static_assert(sizeof(USHInGameMenuWidget) == 0x0003D8, "Wrong size on USHInGameMenuWidget");
static_assert(offsetof(USHInGameMenuWidget, ResumeKeys) == 0x000370, "Member 'USHInGameMenuWidget::ResumeKeys' has a wrong offset!");
static_assert(offsetof(USHInGameMenuWidget, NewGameSpawnPoint) == 0x000380, "Member 'USHInGameMenuWidget::NewGameSpawnPoint' has a wrong offset!");
static_assert(offsetof(USHInGameMenuWidget, Load_but) == 0x0003A0, "Member 'USHInGameMenuWidget::Load_but' has a wrong offset!");
static_assert(offsetof(USHInGameMenuWidget, ToMainMenu_but) == 0x0003A8, "Member 'USHInGameMenuWidget::ToMainMenu_but' has a wrong offset!");
static_assert(offsetof(USHInGameMenuWidget, Quit_but) == 0x0003B0, "Member 'USHInGameMenuWidget::Quit_but' has a wrong offset!");
static_assert(offsetof(USHInGameMenuWidget, AskQuit_dialog) == 0x0003B8, "Member 'USHInGameMenuWidget::AskQuit_dialog' has a wrong offset!");
static_assert(offsetof(USHInGameMenuWidget, FadeIn_anim) == 0x0003C0, "Member 'USHInGameMenuWidget::FadeIn_anim' has a wrong offset!");

// Class SHProto.SHInMenuCreditsWidget
// 0x0068 (0x0308 - 0x02A0)
class USHInMenuCreditsWidget final : public UBUserWidget
{
public:
	class UWidgetSwitcher*                        Main_switcher;                                     // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCreditsWidget*                         Credits_wdg;                                       // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUCWSkipWidget*                         Skip_wdg;                                          // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          MusicStart;                                        // 0x02B8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          MusicEnd;                                          // 0x02C0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeIn;                                            // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeOut;                                           // 0x02D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEffectHandle                          LightEffect;                                       // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             K2_OnBack;                                         // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x18];                                     // 0x02F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActiveWidgetChanged(class UWidget* ActiveWidget, int32 ActiveWidgetIndex);
	void Continue();
	void Hide();
	void OnHide();
	void OnShow();
	void Show();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInMenuCreditsWidget">();
	}
	static class USHInMenuCreditsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHInMenuCreditsWidget>();
	}
};
static_assert(alignof(USHInMenuCreditsWidget) == 0x000008, "Wrong alignment on USHInMenuCreditsWidget");
static_assert(sizeof(USHInMenuCreditsWidget) == 0x000308, "Wrong size on USHInMenuCreditsWidget");
static_assert(offsetof(USHInMenuCreditsWidget, Main_switcher) == 0x0002A0, "Member 'USHInMenuCreditsWidget::Main_switcher' has a wrong offset!");
static_assert(offsetof(USHInMenuCreditsWidget, Credits_wdg) == 0x0002A8, "Member 'USHInMenuCreditsWidget::Credits_wdg' has a wrong offset!");
static_assert(offsetof(USHInMenuCreditsWidget, Skip_wdg) == 0x0002B0, "Member 'USHInMenuCreditsWidget::Skip_wdg' has a wrong offset!");
static_assert(offsetof(USHInMenuCreditsWidget, MusicStart) == 0x0002B8, "Member 'USHInMenuCreditsWidget::MusicStart' has a wrong offset!");
static_assert(offsetof(USHInMenuCreditsWidget, MusicEnd) == 0x0002C0, "Member 'USHInMenuCreditsWidget::MusicEnd' has a wrong offset!");
static_assert(offsetof(USHInMenuCreditsWidget, FadeIn) == 0x0002C8, "Member 'USHInMenuCreditsWidget::FadeIn' has a wrong offset!");
static_assert(offsetof(USHInMenuCreditsWidget, FadeOut) == 0x0002D0, "Member 'USHInMenuCreditsWidget::FadeOut' has a wrong offset!");
static_assert(offsetof(USHInMenuCreditsWidget, LightEffect) == 0x0002D8, "Member 'USHInMenuCreditsWidget::LightEffect' has a wrong offset!");
static_assert(offsetof(USHInMenuCreditsWidget, K2_OnBack) == 0x0002E0, "Member 'USHInMenuCreditsWidget::K2_OnBack' has a wrong offset!");

// Class SHProto.SHInputBufferCmbSubcomp
// 0x00D0 (0x0108 - 0x0038)
class USHInputBufferCmbSubcomp final : public USHCombatSubcomponentBase
{
public:
	uint8                                         Pad_38[0xD0];                                      // 0x0038(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessCombatInputModeChangedEvent(class USHCharacterPlayCombatComponent* CombatComp);
	void SHDebug_Character_Combat_InputBuffer_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInputBufferCmbSubcomp">();
	}
	static class USHInputBufferCmbSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHInputBufferCmbSubcomp>();
	}
};
static_assert(alignof(USHInputBufferCmbSubcomp) == 0x000008, "Wrong alignment on USHInputBufferCmbSubcomp");
static_assert(sizeof(USHInputBufferCmbSubcomp) == 0x000108, "Wrong size on USHInputBufferCmbSubcomp");

// Class SHProto.SHInputReceiver
// 0x0000 (0x0028 - 0x0028)
class ISHInputReceiver final : public IInputReceiver
{
public:
	void ProcessBoatForwardInputAction(class UBInputAction* InputSource, class UInputEventState* State, const EBInputActionChangeType ChangeType);
	void ProcessBoatLeftInputAction(class UBInputAction* InputSource, class UInputEventState* State, const EBInputActionChangeType ChangeType);
	void ProcessBoatRightInputAction(class UBInputAction* InputSource, class UInputEventState* State, const EBInputActionChangeType ChangeType);
	void ProcessDodgeInputAction(class UBInputAction* InputSource, class UInputEventState* State, const EBInputActionChangeType ChangeType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInputReceiver">();
	}
	static class ISHInputReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHInputReceiver>();
	}
};
static_assert(alignof(ISHInputReceiver) == 0x000008, "Wrong alignment on ISHInputReceiver");
static_assert(sizeof(ISHInputReceiver) == 0x000028, "Wrong size on ISHInputReceiver");

// Class SHProto.SHInteractionGeneric
// 0x0000 (0x0028 - 0x0028)
class ISHInteractionGeneric final : public ISHInteraction
{
public:
	class USHInteractionGenericComponent* GetGeneric();
	void StopGenericInteraction(const struct FSHInteractionGenericStopData& StopData);

	struct FSHInteractionGenericConfig GetGenericConfig() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInteractionGeneric">();
	}
	static class ISHInteractionGeneric* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHInteractionGeneric>();
	}
};
static_assert(alignof(ISHInteractionGeneric) == 0x000008, "Wrong alignment on ISHInteractionGeneric");
static_assert(sizeof(ISHInteractionGeneric) == 0x000028, "Wrong size on ISHInteractionGeneric");

// Class SHProto.SHInteractionGenericComponent
// 0x0120 (0x03C0 - 0x02A0)
class USHInteractionGenericComponent final : public USceneComponent
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnGrabbedByCharacterBP;                            // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnReleasedByCharacterBP;                           // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnHeldByCharacterBP;                               // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnProcessInput;                                    // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FSHInteractionGenericConfig            Config;                                            // 0x02E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	ESHInteractionGenericBehaviour                Behaviour;                                         // 0x0338(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MaintainInteractionOnVisibilityLost;               // 0x0339(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          OverrideCleanupConfig;                             // 0x033A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33B[0x1];                                      // 0x033B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHManagedInteractionSlotCleanupConfig CleanupConfig;                                     // 0x033C(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TScriptInterface<class ISHInteractionGenericSlot> ActiveSlot;                                        // 0x0350(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       ActiveCharacter;                                   // 0x0360(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x58];                                     // 0x0368(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GrabbedByCharacterBP__DelegateSignature(class USHInteractionGenericComponent* Generic, class ASHCharacterPlay* Character);
	void HeldByCharacterBP__DelegateSignature(class USHInteractionGenericComponent* Generic, class ASHCharacterPlay* Character, float DeltaTime);
	void ProcessInputBP__DelegateSignature(class USHInteractionGenericComponent* Generic, class ASHCharacterPlay* Character, const struct FVector2D& Input, EGameBaseInputDevice Device);
	void ReleasedByCharacterBP__DelegateSignature(class USHInteractionGenericComponent* Generic, class ASHCharacterPlay* Character);

	ESHInteractionGenericBehaviour GetBehaviour() const;
	bool IsClickable() const;
	bool IsHeldByCharacter() const;
	bool IsHoldable() const;
	bool IsUsed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInteractionGenericComponent">();
	}
	static class USHInteractionGenericComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHInteractionGenericComponent>();
	}
};
static_assert(alignof(USHInteractionGenericComponent) == 0x000010, "Wrong alignment on USHInteractionGenericComponent");
static_assert(sizeof(USHInteractionGenericComponent) == 0x0003C0, "Wrong size on USHInteractionGenericComponent");
static_assert(offsetof(USHInteractionGenericComponent, OnGrabbedByCharacterBP) == 0x0002A8, "Member 'USHInteractionGenericComponent::OnGrabbedByCharacterBP' has a wrong offset!");
static_assert(offsetof(USHInteractionGenericComponent, OnReleasedByCharacterBP) == 0x0002B8, "Member 'USHInteractionGenericComponent::OnReleasedByCharacterBP' has a wrong offset!");
static_assert(offsetof(USHInteractionGenericComponent, OnHeldByCharacterBP) == 0x0002C8, "Member 'USHInteractionGenericComponent::OnHeldByCharacterBP' has a wrong offset!");
static_assert(offsetof(USHInteractionGenericComponent, OnProcessInput) == 0x0002D8, "Member 'USHInteractionGenericComponent::OnProcessInput' has a wrong offset!");
static_assert(offsetof(USHInteractionGenericComponent, Config) == 0x0002E8, "Member 'USHInteractionGenericComponent::Config' has a wrong offset!");
static_assert(offsetof(USHInteractionGenericComponent, Behaviour) == 0x000338, "Member 'USHInteractionGenericComponent::Behaviour' has a wrong offset!");
static_assert(offsetof(USHInteractionGenericComponent, MaintainInteractionOnVisibilityLost) == 0x000339, "Member 'USHInteractionGenericComponent::MaintainInteractionOnVisibilityLost' has a wrong offset!");
static_assert(offsetof(USHInteractionGenericComponent, OverrideCleanupConfig) == 0x00033A, "Member 'USHInteractionGenericComponent::OverrideCleanupConfig' has a wrong offset!");
static_assert(offsetof(USHInteractionGenericComponent, CleanupConfig) == 0x00033C, "Member 'USHInteractionGenericComponent::CleanupConfig' has a wrong offset!");
static_assert(offsetof(USHInteractionGenericComponent, ActiveSlot) == 0x000350, "Member 'USHInteractionGenericComponent::ActiveSlot' has a wrong offset!");
static_assert(offsetof(USHInteractionGenericComponent, ActiveCharacter) == 0x000360, "Member 'USHInteractionGenericComponent::ActiveCharacter' has a wrong offset!");

// Class SHProto.SHInteractionIconComponent
// 0x00A0 (0x0340 - 0x02A0)
class USHInteractionIconComponent final : public USceneComponent
{
public:
	struct FUE4InputHandle                        InputHandle;                                       // 0x02A0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESHInteractionIconType                        Type;                                              // 0x02AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESHInteractionIconOpacityState                OpacityState;                                      // 0x02AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          OpacityIgnoreSelf;                                 // 0x02AE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          OpacityIgnoreFriend;                               // 0x02AF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HasDisabledSlotsManagement;                        // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          TrackSlotLocation;                                 // 0x02B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B2[0x2];                                      // 0x02B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmallestSlotDistanceImprovement;                   // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SlotManagementIgnoreOwnerActor;                    // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SlotManagementIgnoreObservedActor;                 // 0x02B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESHInteractionIconState                       State;                                             // 0x02BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BB[0x5];                                      // 0x02BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class USHInteractionIconManagerComponent*     IconManager;                                       // 0x02C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconWidget*               IconWidget;                                        // 0x02C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconSlotComponent*        CurrentSlot;                                       // 0x02D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USHInteractionIconSlotComponent*> Slots;                                             // 0x02D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 ObservedActor;                                     // 0x02E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 FriendActor;                                       // 0x02F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ScaleDistanceCurve;                                // 0x02F8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ScaleResolutionCurve;                              // 0x0300(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ScaleFovCurve;                                     // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        OriginalParent;                                    // 0x0310(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x28];                                     // 0x0318(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFriendActor(const class AActor* Actor);
	void SetState(const ESHInteractionIconState NewState);

	float CalculateDesiredScale() const;
	class AActor* GetFriendActor() const;
	class AActor* GetObservedActor() const;
	float GetTargetOpacity() const;
	bool HasFriendActor() const;
	bool HasObservedActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInteractionIconComponent">();
	}
	static class USHInteractionIconComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHInteractionIconComponent>();
	}
};
static_assert(alignof(USHInteractionIconComponent) == 0x000010, "Wrong alignment on USHInteractionIconComponent");
static_assert(sizeof(USHInteractionIconComponent) == 0x000340, "Wrong size on USHInteractionIconComponent");
static_assert(offsetof(USHInteractionIconComponent, InputHandle) == 0x0002A0, "Member 'USHInteractionIconComponent::InputHandle' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, Type) == 0x0002AC, "Member 'USHInteractionIconComponent::Type' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, OpacityState) == 0x0002AD, "Member 'USHInteractionIconComponent::OpacityState' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, OpacityIgnoreSelf) == 0x0002AE, "Member 'USHInteractionIconComponent::OpacityIgnoreSelf' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, OpacityIgnoreFriend) == 0x0002AF, "Member 'USHInteractionIconComponent::OpacityIgnoreFriend' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, HasDisabledSlotsManagement) == 0x0002B0, "Member 'USHInteractionIconComponent::HasDisabledSlotsManagement' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, TrackSlotLocation) == 0x0002B1, "Member 'USHInteractionIconComponent::TrackSlotLocation' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, SmallestSlotDistanceImprovement) == 0x0002B4, "Member 'USHInteractionIconComponent::SmallestSlotDistanceImprovement' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, SlotManagementIgnoreOwnerActor) == 0x0002B8, "Member 'USHInteractionIconComponent::SlotManagementIgnoreOwnerActor' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, SlotManagementIgnoreObservedActor) == 0x0002B9, "Member 'USHInteractionIconComponent::SlotManagementIgnoreObservedActor' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, State) == 0x0002BA, "Member 'USHInteractionIconComponent::State' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, IconManager) == 0x0002C0, "Member 'USHInteractionIconComponent::IconManager' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, IconWidget) == 0x0002C8, "Member 'USHInteractionIconComponent::IconWidget' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, CurrentSlot) == 0x0002D0, "Member 'USHInteractionIconComponent::CurrentSlot' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, Slots) == 0x0002D8, "Member 'USHInteractionIconComponent::Slots' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, ObservedActor) == 0x0002E8, "Member 'USHInteractionIconComponent::ObservedActor' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, FriendActor) == 0x0002F0, "Member 'USHInteractionIconComponent::FriendActor' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, ScaleDistanceCurve) == 0x0002F8, "Member 'USHInteractionIconComponent::ScaleDistanceCurve' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, ScaleResolutionCurve) == 0x000300, "Member 'USHInteractionIconComponent::ScaleResolutionCurve' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, ScaleFovCurve) == 0x000308, "Member 'USHInteractionIconComponent::ScaleFovCurve' has a wrong offset!");
static_assert(offsetof(USHInteractionIconComponent, OriginalParent) == 0x000310, "Member 'USHInteractionIconComponent::OriginalParent' has a wrong offset!");

// Class SHProto.SHInteractionIconManagerComponent
// 0x00A0 (0x0140 - 0x00A0)
class USHInteractionIconManagerComponent final : public UActorComponent
{
public:
	TSubclassOf<class USHInteractionIconWidget>   IconWidgetClass;                                   // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IconCount;                                         // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IconZOrder;                                        // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            IconDistanceScaleCurve;                            // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            IconFovScaleCurve;                                 // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            IconScaleResolutionCurve;                          // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IconScaleMultiplier;                               // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IconTemporalDisableOpacityMultiplier;              // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameTextsConfig*                     GameTextsConfig;                                   // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USHInteractionIconWidget*>       AvailableIcons;                                    // 0x00D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class USHInteractionIconWidget*>       UsedIcons;                                         // 0x00E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class USHInteractionIconWidget*>       AllIcons;                                          // 0x00F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x38];                                     // 0x0108(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInteractionIconManagerComponent">();
	}
	static class USHInteractionIconManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHInteractionIconManagerComponent>();
	}
};
static_assert(alignof(USHInteractionIconManagerComponent) == 0x000008, "Wrong alignment on USHInteractionIconManagerComponent");
static_assert(sizeof(USHInteractionIconManagerComponent) == 0x000140, "Wrong size on USHInteractionIconManagerComponent");
static_assert(offsetof(USHInteractionIconManagerComponent, IconWidgetClass) == 0x0000A0, "Member 'USHInteractionIconManagerComponent::IconWidgetClass' has a wrong offset!");
static_assert(offsetof(USHInteractionIconManagerComponent, IconCount) == 0x0000A8, "Member 'USHInteractionIconManagerComponent::IconCount' has a wrong offset!");
static_assert(offsetof(USHInteractionIconManagerComponent, IconZOrder) == 0x0000AC, "Member 'USHInteractionIconManagerComponent::IconZOrder' has a wrong offset!");
static_assert(offsetof(USHInteractionIconManagerComponent, IconDistanceScaleCurve) == 0x0000B0, "Member 'USHInteractionIconManagerComponent::IconDistanceScaleCurve' has a wrong offset!");
static_assert(offsetof(USHInteractionIconManagerComponent, IconFovScaleCurve) == 0x0000B8, "Member 'USHInteractionIconManagerComponent::IconFovScaleCurve' has a wrong offset!");
static_assert(offsetof(USHInteractionIconManagerComponent, IconScaleResolutionCurve) == 0x0000C0, "Member 'USHInteractionIconManagerComponent::IconScaleResolutionCurve' has a wrong offset!");
static_assert(offsetof(USHInteractionIconManagerComponent, IconScaleMultiplier) == 0x0000C8, "Member 'USHInteractionIconManagerComponent::IconScaleMultiplier' has a wrong offset!");
static_assert(offsetof(USHInteractionIconManagerComponent, IconTemporalDisableOpacityMultiplier) == 0x0000CC, "Member 'USHInteractionIconManagerComponent::IconTemporalDisableOpacityMultiplier' has a wrong offset!");
static_assert(offsetof(USHInteractionIconManagerComponent, GameTextsConfig) == 0x0000D0, "Member 'USHInteractionIconManagerComponent::GameTextsConfig' has a wrong offset!");
static_assert(offsetof(USHInteractionIconManagerComponent, AvailableIcons) == 0x0000D8, "Member 'USHInteractionIconManagerComponent::AvailableIcons' has a wrong offset!");
static_assert(offsetof(USHInteractionIconManagerComponent, UsedIcons) == 0x0000E8, "Member 'USHInteractionIconManagerComponent::UsedIcons' has a wrong offset!");
static_assert(offsetof(USHInteractionIconManagerComponent, AllIcons) == 0x0000F8, "Member 'USHInteractionIconManagerComponent::AllIcons' has a wrong offset!");

// Class SHProto.SHInteractionIconSlotComponent
// 0x0000 (0x02A0 - 0x02A0)
class USHInteractionIconSlotComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInteractionIconSlotComponent">();
	}
	static class USHInteractionIconSlotComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHInteractionIconSlotComponent>();
	}
};
static_assert(alignof(USHInteractionIconSlotComponent) == 0x000010, "Wrong alignment on USHInteractionIconSlotComponent");
static_assert(sizeof(USHInteractionIconSlotComponent) == 0x0002A0, "Wrong size on USHInteractionIconSlotComponent");

// Class SHProto.SHInteractionManagerComponent
// 0x00C0 (0x0160 - 0x00A0)
class USHInteractionManagerComponent final : public UActorComponent
{
public:
	bool                                          bDoNotManageProximityGenerateOverlap;              // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoNotPerformDefaultInitializationOnBeginPlay;     // 0x00A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnInteractionManagerInitializeBP;                  // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UShapeComponent*                        ProximityDetector;                                 // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHRaycastDetectableComponent*          VisibilityDetector;                                // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x80];                                      // 0x00E0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindProximityDetector(const class UShapeComponent* NewProximityDetector);
	void BindVisibilityDetector(const class USHRaycastDetectableComponent* NewVisibilityDetector);
	void InteractionManagerInitializeBP__DelegateSignature(class USHInteractionManagerComponent* Manager);
	void InterruptCurrentInteraction();
	void PerformDefaultInitialization();
	void ProcessProximityBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void ProcessProximityEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex);
	bool RegisterGeneric(const class USHInteractionGenericComponent* Generic, const class USHRaycastDetectableComponent* Detectable, const class USHInteractionIconComponent* Icon, const TArray<class USHInteractionIconSlotComponent*>& Slots);
	void SetDetectionEnabled(const bool Enable, const class UObject* Enabler);
	void SetObjectDetectionEnabled(const class UObject* Object, const bool Enable, const class UObject* Enabler);

	bool HasActiveInteraction() const;
	bool HasUsableActorNearby() const;
	bool IsDetectionEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInteractionManagerComponent">();
	}
	static class USHInteractionManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHInteractionManagerComponent>();
	}
};
static_assert(alignof(USHInteractionManagerComponent) == 0x000008, "Wrong alignment on USHInteractionManagerComponent");
static_assert(sizeof(USHInteractionManagerComponent) == 0x000160, "Wrong size on USHInteractionManagerComponent");
static_assert(offsetof(USHInteractionManagerComponent, bDoNotManageProximityGenerateOverlap) == 0x0000A0, "Member 'USHInteractionManagerComponent::bDoNotManageProximityGenerateOverlap' has a wrong offset!");
static_assert(offsetof(USHInteractionManagerComponent, bDoNotPerformDefaultInitializationOnBeginPlay) == 0x0000A1, "Member 'USHInteractionManagerComponent::bDoNotPerformDefaultInitializationOnBeginPlay' has a wrong offset!");
static_assert(offsetof(USHInteractionManagerComponent, OnInteractionManagerInitializeBP) == 0x0000A8, "Member 'USHInteractionManagerComponent::OnInteractionManagerInitializeBP' has a wrong offset!");
static_assert(offsetof(USHInteractionManagerComponent, ProximityDetector) == 0x0000D0, "Member 'USHInteractionManagerComponent::ProximityDetector' has a wrong offset!");
static_assert(offsetof(USHInteractionManagerComponent, VisibilityDetector) == 0x0000D8, "Member 'USHInteractionManagerComponent::VisibilityDetector' has a wrong offset!");

// Class SHProto.SHInteractionStarter
// 0x0000 (0x0028 - 0x0028)
class ISHInteractionStarter final : public IInterface
{
public:
	TScriptInterface<class ISHInteractionSlot> TryStartInteraction(const TScriptInterface<class ISHInteraction>& Interaction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInteractionStarter">();
	}
	static class ISHInteractionStarter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHInteractionStarter>();
	}
};
static_assert(alignof(ISHInteractionStarter) == 0x000008, "Wrong alignment on ISHInteractionStarter");
static_assert(sizeof(ISHInteractionStarter) == 0x000028, "Wrong size on ISHInteractionStarter");

// Class SHProto.SHInteractionStatics
// 0x0000 (0x0028 - 0x0028)
class USHInteractionStatics final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInteractionStatics">();
	}
	static class USHInteractionStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHInteractionStatics>();
	}
};
static_assert(alignof(USHInteractionStatics) == 0x000008, "Wrong alignment on USHInteractionStatics");
static_assert(sizeof(USHInteractionStatics) == 0x000028, "Wrong size on USHInteractionStatics");

// Class SHProto.SHInventoryCategoryWidget
// 0x0038 (0x02B0 - 0x0278)
class USHInventoryCategoryWidget final : public UUserWidget
{
public:
	class UTextBlock*                             CategoryTextBlock;                                 // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_280[0x30];                                     // 0x0280(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCategoryWithNewItems(bool InValue);
	void SetHoveredCategory(bool IsHovered_0);
	void SetHoveredSubCategory(bool IsHovered_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInventoryCategoryWidget">();
	}
	static class USHInventoryCategoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHInventoryCategoryWidget>();
	}
};
static_assert(alignof(USHInventoryCategoryWidget) == 0x000008, "Wrong alignment on USHInventoryCategoryWidget");
static_assert(sizeof(USHInventoryCategoryWidget) == 0x0002B0, "Wrong size on USHInventoryCategoryWidget");
static_assert(offsetof(USHInventoryCategoryWidget, CategoryTextBlock) == 0x000278, "Member 'USHInventoryCategoryWidget::CategoryTextBlock' has a wrong offset!");

// Class SHProto.SHInventoryRenderer
// 0x0008 (0x02B8 - 0x02B0)
class ASHInventoryRenderer final : public AActor
{
public:
	class UWidgetComponent*                       Widget;                                            // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UTextureRenderTarget2D* GetRenderTarget() const;
	class USHGameplaySectionBaseWidget* GetUserWidgetObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInventoryRenderer">();
	}
	static class ASHInventoryRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHInventoryRenderer>();
	}
};
static_assert(alignof(ASHInventoryRenderer) == 0x000008, "Wrong alignment on ASHInventoryRenderer");
static_assert(sizeof(ASHInventoryRenderer) == 0x0002B8, "Wrong size on ASHInventoryRenderer");
static_assert(offsetof(ASHInventoryRenderer, Widget) == 0x0002B0, "Member 'ASHInventoryRenderer::Widget' has a wrong offset!");

// Class SHProto.SHInvestigatedItemAnimInstance
// 0x0010 (0x0360 - 0x0350)
class USHInvestigatedItemAnimInstance final : public UAnimInstance
{
public:
	TSubclassOf<class USHItemInvestigationMainLoopAnimInstance> MainLoopState;                                     // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MainLoopStateTag;                                  // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInvestigatedItemAnimInstance">();
	}
	static class USHInvestigatedItemAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHInvestigatedItemAnimInstance>();
	}
};
static_assert(alignof(USHInvestigatedItemAnimInstance) == 0x000010, "Wrong alignment on USHInvestigatedItemAnimInstance");
static_assert(sizeof(USHInvestigatedItemAnimInstance) == 0x000360, "Wrong size on USHInvestigatedItemAnimInstance");
static_assert(offsetof(USHInvestigatedItemAnimInstance, MainLoopState) == 0x000348, "Member 'USHInvestigatedItemAnimInstance::MainLoopState' has a wrong offset!");
static_assert(offsetof(USHInvestigatedItemAnimInstance, MainLoopStateTag) == 0x000350, "Member 'USHInvestigatedItemAnimInstance::MainLoopStateTag' has a wrong offset!");

// Class SHProto.SHInWaterVolume
// 0x0000 (0x02E8 - 0x02E8)
class ASHInWaterVolume final : public AVolume
{
public:
	bool IsPointWithin(const struct FVector& Point) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHInWaterVolume">();
	}
	static class ASHInWaterVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHInWaterVolume>();
	}
};
static_assert(alignof(ASHInWaterVolume) == 0x000008, "Wrong alignment on ASHInWaterVolume");
static_assert(sizeof(ASHInWaterVolume) == 0x0002E8, "Wrong size on ASHInWaterVolume");

// Class SHProto.SHItemAnimInterface
// 0x0000 (0x0028 - 0x0028)
class ISHItemAnimInterface final : public IInterface
{
public:
	void InvestigationFlipSettingsChanged(float InvestigationFlipPlayRate, float InvestigationFlipStartTime, int32 InvestigationFlipSide, bool InvestigationFlip);
	void InvestigationInputChanged(float InvestigationAnimationFrame);
	void InvestigationTypeSettingChanged(EItemInvestigationType InvestigationType);
	void PlayIntroInvestigation();
	void PlayMainInvestigation(EItemInvestigationType InvestigationType);
	void PlayOutroInvestigation();
	void PlayPostInvestigation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemAnimInterface">();
	}
	static class ISHItemAnimInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHItemAnimInterface>();
	}
};
static_assert(alignof(ISHItemAnimInterface) == 0x000008, "Wrong alignment on ISHItemAnimInterface");
static_assert(sizeof(ISHItemAnimInterface) == 0x000028, "Wrong size on ISHItemAnimInterface");

// Class SHProto.SHItemAudioComponent
// 0x0020 (0x04D0 - 0x04B0)
class USHItemAudioComponent final : public USHAkComponent
{
public:
	class UAkAudioEvent*                          GrabSound;                                         // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          HideSound;                                         // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          FlipSound;                                         // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          InvestigateSound;                                  // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkSwitchValue*                         SavedSwitchValue;                                  // 0x04C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemAudioComponent">();
	}
	static class USHItemAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHItemAudioComponent>();
	}
};
static_assert(alignof(USHItemAudioComponent) == 0x000010, "Wrong alignment on USHItemAudioComponent");
static_assert(sizeof(USHItemAudioComponent) == 0x0004D0, "Wrong size on USHItemAudioComponent");
static_assert(offsetof(USHItemAudioComponent, GrabSound) == 0x0004A8, "Member 'USHItemAudioComponent::GrabSound' has a wrong offset!");
static_assert(offsetof(USHItemAudioComponent, HideSound) == 0x0004B0, "Member 'USHItemAudioComponent::HideSound' has a wrong offset!");
static_assert(offsetof(USHItemAudioComponent, FlipSound) == 0x0004B8, "Member 'USHItemAudioComponent::FlipSound' has a wrong offset!");
static_assert(offsetof(USHItemAudioComponent, InvestigateSound) == 0x0004C0, "Member 'USHItemAudioComponent::InvestigateSound' has a wrong offset!");
static_assert(offsetof(USHItemAudioComponent, SavedSwitchValue) == 0x0004C8, "Member 'USHItemAudioComponent::SavedSwitchValue' has a wrong offset!");

// Class SHProto.SHItemExeCameraManagerComponent
// 0x01C0 (0x0260 - 0x00A0)
class USHItemExeCameraManagerComponent final : public UActorComponent
{
public:
	bool                                          bUseStartCameraAnimation;                          // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartCameraAnimationDuration;                      // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StartCameraAnimationFirstFrameRelPose;             // 0x00B0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             StartCameraAnimationLastFrameRelPose;              // 0x0110(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableCameraMovement;                             // 0x0170(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ZoomedOutMovementClamp;                            // 0x0178(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ZoomedInMovementClamp;                             // 0x0188(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementMaxSpeed;                                  // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementAcceleration;                              // 0x019C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementDeceleration;                              // 0x01A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableCameraZoom;                                 // 0x01A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A5[0x3];                                      // 0x01A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZoomFocialLength;                                  // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomInTime;                                        // 0x01AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ZoomInCurve;                                       // 0x01B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomOutTime;                                       // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ZoomOutCurve;                                      // 0x01C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C8[0x98];                                     // 0x01C8(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCameraMovementBlocked(const bool Blocked, const class UObject* Object);
	void SetCameraZoomBlocked(const bool Blocked, const class UObject* Object);

	bool IsCameraMovementBlocked() const;
	bool IsCameraZoomBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemExeCameraManagerComponent">();
	}
	static class USHItemExeCameraManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHItemExeCameraManagerComponent>();
	}
};
static_assert(alignof(USHItemExeCameraManagerComponent) == 0x000010, "Wrong alignment on USHItemExeCameraManagerComponent");
static_assert(sizeof(USHItemExeCameraManagerComponent) == 0x000260, "Wrong size on USHItemExeCameraManagerComponent");
static_assert(offsetof(USHItemExeCameraManagerComponent, bUseStartCameraAnimation) == 0x0000A0, "Member 'USHItemExeCameraManagerComponent::bUseStartCameraAnimation' has a wrong offset!");
static_assert(offsetof(USHItemExeCameraManagerComponent, StartCameraAnimationDuration) == 0x0000A4, "Member 'USHItemExeCameraManagerComponent::StartCameraAnimationDuration' has a wrong offset!");
static_assert(offsetof(USHItemExeCameraManagerComponent, StartCameraAnimationFirstFrameRelPose) == 0x0000B0, "Member 'USHItemExeCameraManagerComponent::StartCameraAnimationFirstFrameRelPose' has a wrong offset!");
static_assert(offsetof(USHItemExeCameraManagerComponent, StartCameraAnimationLastFrameRelPose) == 0x000110, "Member 'USHItemExeCameraManagerComponent::StartCameraAnimationLastFrameRelPose' has a wrong offset!");
static_assert(offsetof(USHItemExeCameraManagerComponent, bEnableCameraMovement) == 0x000170, "Member 'USHItemExeCameraManagerComponent::bEnableCameraMovement' has a wrong offset!");
static_assert(offsetof(USHItemExeCameraManagerComponent, ZoomedOutMovementClamp) == 0x000178, "Member 'USHItemExeCameraManagerComponent::ZoomedOutMovementClamp' has a wrong offset!");
static_assert(offsetof(USHItemExeCameraManagerComponent, ZoomedInMovementClamp) == 0x000188, "Member 'USHItemExeCameraManagerComponent::ZoomedInMovementClamp' has a wrong offset!");
static_assert(offsetof(USHItemExeCameraManagerComponent, MovementMaxSpeed) == 0x000198, "Member 'USHItemExeCameraManagerComponent::MovementMaxSpeed' has a wrong offset!");
static_assert(offsetof(USHItemExeCameraManagerComponent, MovementAcceleration) == 0x00019C, "Member 'USHItemExeCameraManagerComponent::MovementAcceleration' has a wrong offset!");
static_assert(offsetof(USHItemExeCameraManagerComponent, MovementDeceleration) == 0x0001A0, "Member 'USHItemExeCameraManagerComponent::MovementDeceleration' has a wrong offset!");
static_assert(offsetof(USHItemExeCameraManagerComponent, bEnableCameraZoom) == 0x0001A4, "Member 'USHItemExeCameraManagerComponent::bEnableCameraZoom' has a wrong offset!");
static_assert(offsetof(USHItemExeCameraManagerComponent, ZoomFocialLength) == 0x0001A8, "Member 'USHItemExeCameraManagerComponent::ZoomFocialLength' has a wrong offset!");
static_assert(offsetof(USHItemExeCameraManagerComponent, ZoomInTime) == 0x0001AC, "Member 'USHItemExeCameraManagerComponent::ZoomInTime' has a wrong offset!");
static_assert(offsetof(USHItemExeCameraManagerComponent, ZoomInCurve) == 0x0001B0, "Member 'USHItemExeCameraManagerComponent::ZoomInCurve' has a wrong offset!");
static_assert(offsetof(USHItemExeCameraManagerComponent, ZoomOutTime) == 0x0001B8, "Member 'USHItemExeCameraManagerComponent::ZoomOutTime' has a wrong offset!");
static_assert(offsetof(USHItemExeCameraManagerComponent, ZoomOutCurve) == 0x0001C0, "Member 'USHItemExeCameraManagerComponent::ZoomOutCurve' has a wrong offset!");

// Class SHProto.SHItemExecutiveBase
// 0x0048 (0x02F8 - 0x02B0)
class ASHItemExecutiveBase : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnFinished;                                        // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x02C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHItemBase*                            ItemContext;                                       // 0x02C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x28];                                     // 0x02D0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnExecutiveInitialized();
	void RequestManualAbort();
	void SHItemExecutiveBlueprintEvent__DelegateSignature(class ASHItemExecutiveBase* ExecutivePtr);

	class ASHItemBase* GetItemContextActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemExecutiveBase">();
	}
	static class ASHItemExecutiveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHItemExecutiveBase>();
	}
};
static_assert(alignof(ASHItemExecutiveBase) == 0x000008, "Wrong alignment on ASHItemExecutiveBase");
static_assert(sizeof(ASHItemExecutiveBase) == 0x0002F8, "Wrong size on ASHItemExecutiveBase");
static_assert(offsetof(ASHItemExecutiveBase, OnFinished) == 0x0002B0, "Member 'ASHItemExecutiveBase::OnFinished' has a wrong offset!");
static_assert(offsetof(ASHItemExecutiveBase, OwnerCharacter) == 0x0002C0, "Member 'ASHItemExecutiveBase::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ASHItemExecutiveBase, ItemContext) == 0x0002C8, "Member 'ASHItemExecutiveBase::ItemContext' has a wrong offset!");

// Class SHProto.SHItemExeFlashlightManagerComponent
// 0x0030 (0x00D0 - 0x00A0)
class USHItemExeFlashlightManagerComponent final : public UActorComponent
{
public:
	bool                                          bHideFlashlightMesh;                               // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InvestigationFlashlightIntensity;                  // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FlashlightRelLocOverride;                          // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemExeFlashlightManagerComponent">();
	}
	static class USHItemExeFlashlightManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHItemExeFlashlightManagerComponent>();
	}
};
static_assert(alignof(USHItemExeFlashlightManagerComponent) == 0x000008, "Wrong alignment on USHItemExeFlashlightManagerComponent");
static_assert(sizeof(USHItemExeFlashlightManagerComponent) == 0x0000D0, "Wrong size on USHItemExeFlashlightManagerComponent");
static_assert(offsetof(USHItemExeFlashlightManagerComponent, bHideFlashlightMesh) == 0x0000A0, "Member 'USHItemExeFlashlightManagerComponent::bHideFlashlightMesh' has a wrong offset!");
static_assert(offsetof(USHItemExeFlashlightManagerComponent, InvestigationFlashlightIntensity) == 0x0000A4, "Member 'USHItemExeFlashlightManagerComponent::InvestigationFlashlightIntensity' has a wrong offset!");
static_assert(offsetof(USHItemExeFlashlightManagerComponent, FlashlightRelLocOverride) == 0x0000A8, "Member 'USHItemExeFlashlightManagerComponent::FlashlightRelLocOverride' has a wrong offset!");

// Class SHProto.SHItemGrabExecutive
// 0x0010 (0x0308 - 0x02F8)
class ASHItemGrabExecutive final : public ASHItemExecutiveBase
{
public:
	uint8                                         Pad_2F8[0x10];                                     // 0x02F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGrabStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemGrabExecutive">();
	}
	static class ASHItemGrabExecutive* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHItemGrabExecutive>();
	}
};
static_assert(alignof(ASHItemGrabExecutive) == 0x000008, "Wrong alignment on ASHItemGrabExecutive");
static_assert(sizeof(ASHItemGrabExecutive) == 0x000308, "Wrong size on ASHItemGrabExecutive");

// Class SHProto.SHItemHealingUseExecutive
// 0x0028 (0x0198 - 0x0170)
class USHItemHealingUseExecutive final : public USHAnimatedItemUseExecutive
{
public:
	float                                         HealValueToApply;                                  // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEffectHandle                          SpecialEffectHeal;                                 // 0x0174(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_17C[0x1C];                                     // 0x017C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemHealingUseExecutive">();
	}
	static class USHItemHealingUseExecutive* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHItemHealingUseExecutive>();
	}
};
static_assert(alignof(USHItemHealingUseExecutive) == 0x000008, "Wrong alignment on USHItemHealingUseExecutive");
static_assert(sizeof(USHItemHealingUseExecutive) == 0x000198, "Wrong size on USHItemHealingUseExecutive");
static_assert(offsetof(USHItemHealingUseExecutive, HealValueToApply) == 0x000170, "Member 'USHItemHealingUseExecutive::HealValueToApply' has a wrong offset!");
static_assert(offsetof(USHItemHealingUseExecutive, SpecialEffectHeal) == 0x000174, "Member 'USHItemHealingUseExecutive::SpecialEffectHeal' has a wrong offset!");

// Class SHProto.SHItemInteractionAnimInstance
// 0x0080 (0x03D0 - 0x0350)
class USHItemInteractionAnimInstance final : public UAnimInstance
{
public:
	EItemInteractionType                          InteractionType;                                   // 0x0348(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bItemTakeStartGuard;                               // 0x0349(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTakeItemRightHand;                                // 0x034A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34B[0x1];                                      // 0x034B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TakeItemDirection;                                 // 0x034C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TakeItemHeight;                                    // 0x0350(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace*                            TakeItemBlendspace;                                // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ItemInHandPoseOverride;                            // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          WeaponHandPoseOverride;                            // 0x0368(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemHandPoseOverrideAlpha;                         // 0x0370(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvestigationStart;                               // 0x0374(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvestigationEnd;                                 // 0x0375(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvestigationInstant;                             // 0x0376(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvestigationBreak;                               // 0x0377(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvestigationItemSwitch;                          // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            InvestigationInputSpeedCurve;                      // 0x0380(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvestigationAnimationFrame;                       // 0x0388(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvestigationFlip;                                // 0x038C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38D[0x3];                                      // 0x038D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InvestigationFlipSide;                             // 0x0390(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemInvestigationType                        InvestigationType;                                 // 0x0394(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_395[0x3];                                      // 0x0395(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InvestigationFlipPlayRate;                         // 0x0398(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvestigationFlipStartTime;                        // 0x039C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SetupAnimation;                                    // 0x03A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          InvestigationLoopAnimation;                        // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FinishAnimation;                                   // 0x03B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          TakeAnimation;                                     // 0x03B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FingersPose;                                       // 0x03C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemInteractionAnimInstance">();
	}
	static class USHItemInteractionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHItemInteractionAnimInstance>();
	}
};
static_assert(alignof(USHItemInteractionAnimInstance) == 0x000010, "Wrong alignment on USHItemInteractionAnimInstance");
static_assert(sizeof(USHItemInteractionAnimInstance) == 0x0003D0, "Wrong size on USHItemInteractionAnimInstance");
static_assert(offsetof(USHItemInteractionAnimInstance, InteractionType) == 0x000348, "Member 'USHItemInteractionAnimInstance::InteractionType' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, bItemTakeStartGuard) == 0x000349, "Member 'USHItemInteractionAnimInstance::bItemTakeStartGuard' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, bTakeItemRightHand) == 0x00034A, "Member 'USHItemInteractionAnimInstance::bTakeItemRightHand' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, TakeItemDirection) == 0x00034C, "Member 'USHItemInteractionAnimInstance::TakeItemDirection' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, TakeItemHeight) == 0x000350, "Member 'USHItemInteractionAnimInstance::TakeItemHeight' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, TakeItemBlendspace) == 0x000358, "Member 'USHItemInteractionAnimInstance::TakeItemBlendspace' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, ItemInHandPoseOverride) == 0x000360, "Member 'USHItemInteractionAnimInstance::ItemInHandPoseOverride' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, WeaponHandPoseOverride) == 0x000368, "Member 'USHItemInteractionAnimInstance::WeaponHandPoseOverride' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, ItemHandPoseOverrideAlpha) == 0x000370, "Member 'USHItemInteractionAnimInstance::ItemHandPoseOverrideAlpha' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, bInvestigationStart) == 0x000374, "Member 'USHItemInteractionAnimInstance::bInvestigationStart' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, bInvestigationEnd) == 0x000375, "Member 'USHItemInteractionAnimInstance::bInvestigationEnd' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, bInvestigationInstant) == 0x000376, "Member 'USHItemInteractionAnimInstance::bInvestigationInstant' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, bInvestigationBreak) == 0x000377, "Member 'USHItemInteractionAnimInstance::bInvestigationBreak' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, bInvestigationItemSwitch) == 0x000378, "Member 'USHItemInteractionAnimInstance::bInvestigationItemSwitch' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, InvestigationInputSpeedCurve) == 0x000380, "Member 'USHItemInteractionAnimInstance::InvestigationInputSpeedCurve' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, InvestigationAnimationFrame) == 0x000388, "Member 'USHItemInteractionAnimInstance::InvestigationAnimationFrame' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, bInvestigationFlip) == 0x00038C, "Member 'USHItemInteractionAnimInstance::bInvestigationFlip' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, InvestigationFlipSide) == 0x000390, "Member 'USHItemInteractionAnimInstance::InvestigationFlipSide' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, InvestigationType) == 0x000394, "Member 'USHItemInteractionAnimInstance::InvestigationType' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, InvestigationFlipPlayRate) == 0x000398, "Member 'USHItemInteractionAnimInstance::InvestigationFlipPlayRate' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, InvestigationFlipStartTime) == 0x00039C, "Member 'USHItemInteractionAnimInstance::InvestigationFlipStartTime' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, SetupAnimation) == 0x0003A0, "Member 'USHItemInteractionAnimInstance::SetupAnimation' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, InvestigationLoopAnimation) == 0x0003A8, "Member 'USHItemInteractionAnimInstance::InvestigationLoopAnimation' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, FinishAnimation) == 0x0003B0, "Member 'USHItemInteractionAnimInstance::FinishAnimation' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, TakeAnimation) == 0x0003B8, "Member 'USHItemInteractionAnimInstance::TakeAnimation' has a wrong offset!");
static_assert(offsetof(USHItemInteractionAnimInstance, FingersPose) == 0x0003C0, "Member 'USHItemInteractionAnimInstance::FingersPose' has a wrong offset!");

// Class SHProto.SHItemInvestigationExecutive
// 0x0218 (0x0510 - 0x02F8)
class ASHItemInvestigationExecutive final : public ASHItemExecutiveBase
{
public:
	class USHCineCameraComponent*                 InvestigationCamera;                               // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpotLightComponent*                    InvestigationSpotLight;                            // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        FlashlightTarget;                                  // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHItemExeCameraManagerComponent*       CameraManager;                                     // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHItemExeFlashlightManagerComponent*   FlashlightManager;                                 // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideDLCSkinDuringMainInvestigation;               // 0x0320(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_321[0x3];                                      // 0x0321(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtAlphaBlendInSpeed;                           // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtAlphaBlendOutSpeed;                          // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ASHMapRenderer>             MapRendererClass;                                  // 0x0330(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnPreInvestigationStartedEvent;                    // 0x0338(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnMainInvestigationStartedEvent;                   // 0x0348(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnPostInvestigationStartedEvent;                   // 0x0358(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ASHMapRenderer*                         MapRenderer;                                       // 0x0370(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_378[0x198];                                    // 0x0378(0x0198)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandlePreInvestigationSetupFinish();
	void OnItemSwitched();
	void OnStartInvestigation();
	void SetAllActionsBlocked(const bool Blocked, const class UObject* Object);
	void SetCustomTranscriptData(TSoftObjectPtr<class USHTranscriptData> InCustomTranscriptData);
	void SetExitBlocked(const bool Blocked, const class UObject* Object);
	void SetRotateItemBlocked(const bool Blocked, const class UObject* Object);
	void SetSwitchItemBlocked(const bool Blocked, const class UObject* Object);
	void SetTranscirptBlocked(const bool Blocked, const class UObject* Object);
	void SHItemInvestigationExeEvent__DelegateSignature(class ASHItemInvestigationExecutive* ExecutivePtr);

	bool IsAllActionsBlocked() const;
	bool IsExitBlocked() const;
	bool IsRotateItemBlocked() const;
	bool IsSwitchItemBlocked() const;
	bool IsTranscirptBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemInvestigationExecutive">();
	}
	static class ASHItemInvestigationExecutive* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHItemInvestigationExecutive>();
	}
};
static_assert(alignof(ASHItemInvestigationExecutive) == 0x000008, "Wrong alignment on ASHItemInvestigationExecutive");
static_assert(sizeof(ASHItemInvestigationExecutive) == 0x000510, "Wrong size on ASHItemInvestigationExecutive");
static_assert(offsetof(ASHItemInvestigationExecutive, InvestigationCamera) == 0x0002F8, "Member 'ASHItemInvestigationExecutive::InvestigationCamera' has a wrong offset!");
static_assert(offsetof(ASHItemInvestigationExecutive, InvestigationSpotLight) == 0x000300, "Member 'ASHItemInvestigationExecutive::InvestigationSpotLight' has a wrong offset!");
static_assert(offsetof(ASHItemInvestigationExecutive, FlashlightTarget) == 0x000308, "Member 'ASHItemInvestigationExecutive::FlashlightTarget' has a wrong offset!");
static_assert(offsetof(ASHItemInvestigationExecutive, CameraManager) == 0x000310, "Member 'ASHItemInvestigationExecutive::CameraManager' has a wrong offset!");
static_assert(offsetof(ASHItemInvestigationExecutive, FlashlightManager) == 0x000318, "Member 'ASHItemInvestigationExecutive::FlashlightManager' has a wrong offset!");
static_assert(offsetof(ASHItemInvestigationExecutive, bHideDLCSkinDuringMainInvestigation) == 0x000320, "Member 'ASHItemInvestigationExecutive::bHideDLCSkinDuringMainInvestigation' has a wrong offset!");
static_assert(offsetof(ASHItemInvestigationExecutive, LookAtAlphaBlendInSpeed) == 0x000324, "Member 'ASHItemInvestigationExecutive::LookAtAlphaBlendInSpeed' has a wrong offset!");
static_assert(offsetof(ASHItemInvestigationExecutive, LookAtAlphaBlendOutSpeed) == 0x000328, "Member 'ASHItemInvestigationExecutive::LookAtAlphaBlendOutSpeed' has a wrong offset!");
static_assert(offsetof(ASHItemInvestigationExecutive, MapRendererClass) == 0x000330, "Member 'ASHItemInvestigationExecutive::MapRendererClass' has a wrong offset!");
static_assert(offsetof(ASHItemInvestigationExecutive, OnPreInvestigationStartedEvent) == 0x000338, "Member 'ASHItemInvestigationExecutive::OnPreInvestigationStartedEvent' has a wrong offset!");
static_assert(offsetof(ASHItemInvestigationExecutive, OnMainInvestigationStartedEvent) == 0x000348, "Member 'ASHItemInvestigationExecutive::OnMainInvestigationStartedEvent' has a wrong offset!");
static_assert(offsetof(ASHItemInvestigationExecutive, OnPostInvestigationStartedEvent) == 0x000358, "Member 'ASHItemInvestigationExecutive::OnPostInvestigationStartedEvent' has a wrong offset!");
static_assert(offsetof(ASHItemInvestigationExecutive, MapRenderer) == 0x000370, "Member 'ASHItemInvestigationExecutive::MapRenderer' has a wrong offset!");

// Class SHProto.SHItemInvestigationMainLoopAnimInstance
// 0x0030 (0x0380 - 0x0350)
class USHItemInvestigationMainLoopAnimInstance final : public UAnimInstance
{
public:
	float                                         InvestigationAnimationFrame;                       // 0x0348(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvestigationFlip;                                // 0x034C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34D[0x3];                                      // 0x034D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InvestigationFlipSide;                             // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemInvestigationType                        InvestigationType;                                 // 0x0354(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_355[0x3];                                      // 0x0355(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InvestigationFlipPlayRate;                         // 0x0358(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvestigationFlipStartTime;                        // 0x035C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          InvestigationLoopAnimation;                        // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseLoopAnimationReverse;                           // 0x0368(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_369[0x7];                                      // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          InvestigationLoopAnimationReverse;                 // 0x0370(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemFlipCachedProgress;                            // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ItemFlipCurrentProgress;                           // 0x037C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemInvestigationMainLoopAnimInstance">();
	}
	static class USHItemInvestigationMainLoopAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHItemInvestigationMainLoopAnimInstance>();
	}
};
static_assert(alignof(USHItemInvestigationMainLoopAnimInstance) == 0x000010, "Wrong alignment on USHItemInvestigationMainLoopAnimInstance");
static_assert(sizeof(USHItemInvestigationMainLoopAnimInstance) == 0x000380, "Wrong size on USHItemInvestigationMainLoopAnimInstance");
static_assert(offsetof(USHItemInvestigationMainLoopAnimInstance, InvestigationAnimationFrame) == 0x000348, "Member 'USHItemInvestigationMainLoopAnimInstance::InvestigationAnimationFrame' has a wrong offset!");
static_assert(offsetof(USHItemInvestigationMainLoopAnimInstance, bInvestigationFlip) == 0x00034C, "Member 'USHItemInvestigationMainLoopAnimInstance::bInvestigationFlip' has a wrong offset!");
static_assert(offsetof(USHItemInvestigationMainLoopAnimInstance, InvestigationFlipSide) == 0x000350, "Member 'USHItemInvestigationMainLoopAnimInstance::InvestigationFlipSide' has a wrong offset!");
static_assert(offsetof(USHItemInvestigationMainLoopAnimInstance, InvestigationType) == 0x000354, "Member 'USHItemInvestigationMainLoopAnimInstance::InvestigationType' has a wrong offset!");
static_assert(offsetof(USHItemInvestigationMainLoopAnimInstance, InvestigationFlipPlayRate) == 0x000358, "Member 'USHItemInvestigationMainLoopAnimInstance::InvestigationFlipPlayRate' has a wrong offset!");
static_assert(offsetof(USHItemInvestigationMainLoopAnimInstance, InvestigationFlipStartTime) == 0x00035C, "Member 'USHItemInvestigationMainLoopAnimInstance::InvestigationFlipStartTime' has a wrong offset!");
static_assert(offsetof(USHItemInvestigationMainLoopAnimInstance, InvestigationLoopAnimation) == 0x000360, "Member 'USHItemInvestigationMainLoopAnimInstance::InvestigationLoopAnimation' has a wrong offset!");
static_assert(offsetof(USHItemInvestigationMainLoopAnimInstance, UseLoopAnimationReverse) == 0x000368, "Member 'USHItemInvestigationMainLoopAnimInstance::UseLoopAnimationReverse' has a wrong offset!");
static_assert(offsetof(USHItemInvestigationMainLoopAnimInstance, InvestigationLoopAnimationReverse) == 0x000370, "Member 'USHItemInvestigationMainLoopAnimInstance::InvestigationLoopAnimationReverse' has a wrong offset!");
static_assert(offsetof(USHItemInvestigationMainLoopAnimInstance, ItemFlipCachedProgress) == 0x000378, "Member 'USHItemInvestigationMainLoopAnimInstance::ItemFlipCachedProgress' has a wrong offset!");
static_assert(offsetof(USHItemInvestigationMainLoopAnimInstance, ItemFlipCurrentProgress) == 0x00037C, "Member 'USHItemInvestigationMainLoopAnimInstance::ItemFlipCurrentProgress' has a wrong offset!");

// Class SHProto.SHItemsContainer
// 0x0060 (0x0310 - 0x02B0)
class ASHItemsContainer final : public AActor
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 ContainerMesh;                                     // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionGenericComponent*         InteractionGeneric;                                // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractionProximitySphere;                        // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            InteractionIcon;                                   // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHRaycastDetectableComponent*          InteractionDetectable;                             // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractionDetectableShape;                        // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionManagerComponent*         InteractionManager;                                // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOpenedOnBeginPlay;                              // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOpen;                                           // 0x02F1(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F2[0x1E];                                     // 0x02F2(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Interact(class USHInteractionGenericComponent* Generic, class ASHCharacterPlay* Character);
	void ProcessInteractionManagerInitialized(class USHInteractionManagerComponent* Manager);
	void SetDisabledState(const bool bInDisabled, const class UObject* InObject);

	bool IsInDisabledState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemsContainer">();
	}
	static class ASHItemsContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHItemsContainer>();
	}
};
static_assert(alignof(ASHItemsContainer) == 0x000008, "Wrong alignment on ASHItemsContainer");
static_assert(sizeof(ASHItemsContainer) == 0x000310, "Wrong size on ASHItemsContainer");
static_assert(offsetof(ASHItemsContainer, ContainerMesh) == 0x0002B8, "Member 'ASHItemsContainer::ContainerMesh' has a wrong offset!");
static_assert(offsetof(ASHItemsContainer, InteractionGeneric) == 0x0002C0, "Member 'ASHItemsContainer::InteractionGeneric' has a wrong offset!");
static_assert(offsetof(ASHItemsContainer, InteractionProximitySphere) == 0x0002C8, "Member 'ASHItemsContainer::InteractionProximitySphere' has a wrong offset!");
static_assert(offsetof(ASHItemsContainer, InteractionIcon) == 0x0002D0, "Member 'ASHItemsContainer::InteractionIcon' has a wrong offset!");
static_assert(offsetof(ASHItemsContainer, InteractionDetectable) == 0x0002D8, "Member 'ASHItemsContainer::InteractionDetectable' has a wrong offset!");
static_assert(offsetof(ASHItemsContainer, InteractionDetectableShape) == 0x0002E0, "Member 'ASHItemsContainer::InteractionDetectableShape' has a wrong offset!");
static_assert(offsetof(ASHItemsContainer, InteractionManager) == 0x0002E8, "Member 'ASHItemsContainer::InteractionManager' has a wrong offset!");
static_assert(offsetof(ASHItemsContainer, bIsOpenedOnBeginPlay) == 0x0002F0, "Member 'ASHItemsContainer::bIsOpenedOnBeginPlay' has a wrong offset!");
static_assert(offsetof(ASHItemsContainer, bIsOpen) == 0x0002F1, "Member 'ASHItemsContainer::bIsOpen' has a wrong offset!");

// Class SHProto.SHItemsInvestigationStatisticsValueProcessor
// 0x0008 (0x0038 - 0x0030)
class USHItemsInvestigationStatisticsValueProcessor final : public USHStatisticsValueProcessor
{
public:
	int32                                         MapItemsInvestigated;                              // 0x0030(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasEverEnabledRadio;                              // 0x0034(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsWatchingEverEnabledRadio;                       // 0x0035(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessCollectedOrLevelItemInvestigated(class USHCharacterPlayItemsComponent* ComponentPtr, class FName ItemContext);
	void ProcessEquipmentItemSpawned(class USHCharacterPlayItemsComponent* ComponentPtr, class FName ItemContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemsInvestigationStatisticsValueProcessor">();
	}
	static class USHItemsInvestigationStatisticsValueProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHItemsInvestigationStatisticsValueProcessor>();
	}
};
static_assert(alignof(USHItemsInvestigationStatisticsValueProcessor) == 0x000008, "Wrong alignment on USHItemsInvestigationStatisticsValueProcessor");
static_assert(sizeof(USHItemsInvestigationStatisticsValueProcessor) == 0x000038, "Wrong size on USHItemsInvestigationStatisticsValueProcessor");
static_assert(offsetof(USHItemsInvestigationStatisticsValueProcessor, MapItemsInvestigated) == 0x000030, "Member 'USHItemsInvestigationStatisticsValueProcessor::MapItemsInvestigated' has a wrong offset!");
static_assert(offsetof(USHItemsInvestigationStatisticsValueProcessor, bHasEverEnabledRadio) == 0x000034, "Member 'USHItemsInvestigationStatisticsValueProcessor::bHasEverEnabledRadio' has a wrong offset!");
static_assert(offsetof(USHItemsInvestigationStatisticsValueProcessor, bIsWatchingEverEnabledRadio) == 0x000035, "Member 'USHItemsInvestigationStatisticsValueProcessor::bIsWatchingEverEnabledRadio' has a wrong offset!");

// Class SHProto.SHItemSpawner
// 0x0060 (0x0310 - 0x02B0)
class ASHItemSpawner final : public AActor
{
public:
	class UMeshComponent*                         DebugMeshPreview;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          DebugInteractionDetectableShapePreview;            // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoRespawnOnStreaming;                           // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHItemAndQuantityHandle               ItemToSpawnData;                                   // 0x02C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             RuntimeItemSpawnedEvent;                           // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             RuntimeItemCollectedEvent;                         // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bShouldRespawnItem;                                // 0x0300(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ASHItem*                                SpawnedItemPtr;                                    // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ProcessSpawnedItemCollected(class ASHItem* ItemRef);
	void SHItemSpawnerEvent__DelegateSignature(class ASHItemSpawner* ItemSpawnerPtr);
	class ASHItem* SpawnRuntimeItem();

	class ASHItem* GetSpawnedItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemSpawner">();
	}
	static class ASHItemSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHItemSpawner>();
	}
};
static_assert(alignof(ASHItemSpawner) == 0x000008, "Wrong alignment on ASHItemSpawner");
static_assert(sizeof(ASHItemSpawner) == 0x000310, "Wrong size on ASHItemSpawner");
static_assert(offsetof(ASHItemSpawner, DebugMeshPreview) == 0x0002B0, "Member 'ASHItemSpawner::DebugMeshPreview' has a wrong offset!");
static_assert(offsetof(ASHItemSpawner, DebugInteractionDetectableShapePreview) == 0x0002B8, "Member 'ASHItemSpawner::DebugInteractionDetectableShapePreview' has a wrong offset!");
static_assert(offsetof(ASHItemSpawner, bAutoRespawnOnStreaming) == 0x0002C0, "Member 'ASHItemSpawner::bAutoRespawnOnStreaming' has a wrong offset!");
static_assert(offsetof(ASHItemSpawner, ItemToSpawnData) == 0x0002C8, "Member 'ASHItemSpawner::ItemToSpawnData' has a wrong offset!");
static_assert(offsetof(ASHItemSpawner, RuntimeItemSpawnedEvent) == 0x0002E0, "Member 'ASHItemSpawner::RuntimeItemSpawnedEvent' has a wrong offset!");
static_assert(offsetof(ASHItemSpawner, RuntimeItemCollectedEvent) == 0x0002F0, "Member 'ASHItemSpawner::RuntimeItemCollectedEvent' has a wrong offset!");
static_assert(offsetof(ASHItemSpawner, bShouldRespawnItem) == 0x000300, "Member 'ASHItemSpawner::bShouldRespawnItem' has a wrong offset!");
static_assert(offsetof(ASHItemSpawner, SpawnedItemPtr) == 0x000308, "Member 'ASHItemSpawner::SpawnedItemPtr' has a wrong offset!");

// Class SHProto.SHItemsPickedUpStatisticsValueProcessor
// 0x0018 (0x0048 - 0x0030)
class USHItemsPickedUpStatisticsValueProcessor final : public USHStatisticsValueProcessor
{
public:
	int32                                         ConsumableItemsPickedUp;                           // 0x0030(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           MemosItemsPickedUp;                                // 0x0038(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)

public:
	void ProcessItemCollected(class USHCharacterPlayItemsComponent* ComponentPtr, class FName ItemContext);
	void ProcessLevelItemGrabbedOrInvestigated(class USHCharacterPlayItemsComponent* ComponentPtr, class FName ItemContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemsPickedUpStatisticsValueProcessor">();
	}
	static class USHItemsPickedUpStatisticsValueProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHItemsPickedUpStatisticsValueProcessor>();
	}
};
static_assert(alignof(USHItemsPickedUpStatisticsValueProcessor) == 0x000008, "Wrong alignment on USHItemsPickedUpStatisticsValueProcessor");
static_assert(sizeof(USHItemsPickedUpStatisticsValueProcessor) == 0x000048, "Wrong size on USHItemsPickedUpStatisticsValueProcessor");
static_assert(offsetof(USHItemsPickedUpStatisticsValueProcessor, ConsumableItemsPickedUp) == 0x000030, "Member 'USHItemsPickedUpStatisticsValueProcessor::ConsumableItemsPickedUp' has a wrong offset!");
static_assert(offsetof(USHItemsPickedUpStatisticsValueProcessor, MemosItemsPickedUp) == 0x000038, "Member 'USHItemsPickedUpStatisticsValueProcessor::MemosItemsPickedUp' has a wrong offset!");

// Class SHProto.SHItemsSettings
// 0x0120 (0x0158 - 0x0038)
class USHItemsSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UDataTable>              ItemsDataTable;                                    // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              WeaponsDataTable;                                  // 0x0068(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              EquipmentDataTable;                                // 0x0098(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              UseablesDataTable;                                 // 0x00C8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              MapsDataTable;                                     // 0x00F8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              CombineItemsRecipesDataTable;                      // 0x0128(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemsSettings">();
	}
	static class USHItemsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHItemsSettings>();
	}
};
static_assert(alignof(USHItemsSettings) == 0x000008, "Wrong alignment on USHItemsSettings");
static_assert(sizeof(USHItemsSettings) == 0x000158, "Wrong size on USHItemsSettings");
static_assert(offsetof(USHItemsSettings, ItemsDataTable) == 0x000038, "Member 'USHItemsSettings::ItemsDataTable' has a wrong offset!");
static_assert(offsetof(USHItemsSettings, WeaponsDataTable) == 0x000068, "Member 'USHItemsSettings::WeaponsDataTable' has a wrong offset!");
static_assert(offsetof(USHItemsSettings, EquipmentDataTable) == 0x000098, "Member 'USHItemsSettings::EquipmentDataTable' has a wrong offset!");
static_assert(offsetof(USHItemsSettings, UseablesDataTable) == 0x0000C8, "Member 'USHItemsSettings::UseablesDataTable' has a wrong offset!");
static_assert(offsetof(USHItemsSettings, MapsDataTable) == 0x0000F8, "Member 'USHItemsSettings::MapsDataTable' has a wrong offset!");
static_assert(offsetof(USHItemsSettings, CombineItemsRecipesDataTable) == 0x000128, "Member 'USHItemsSettings::CombineItemsRecipesDataTable' has a wrong offset!");

// Class SHProto.SHItemsStorageStatics
// 0x0000 (0x0028 - 0x0028)
class USHItemsStorageStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool HasItemByConfig(const TArray<struct FSHCollectedItemData>& InItems, const struct FSHItemsStorageConfig& ItemsStorageConfig);
	static bool HasPlayerCollectedItemByConfig(class UObject* Context, const struct FSHItemsStorageConfig& ItemsStorageConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemsStorageStatics">();
	}
	static class USHItemsStorageStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHItemsStorageStatics>();
	}
};
static_assert(alignof(USHItemsStorageStatics) == 0x000008, "Wrong alignment on USHItemsStorageStatics");
static_assert(sizeof(USHItemsStorageStatics) == 0x000028, "Wrong size on USHItemsStorageStatics");

// Class SHProto.SHItemsStorageComponent
// 0x0020 (0x00C0 - 0x00A0)
class USHItemsStorageComponent final : public UActorComponent
{
public:
	TArray<struct FSHCollectedItemData>           BeginPlayStoredItems;                              // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSHCollectedItemData>           StoredItems;                                       // 0x00B0(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)

public:
	void RetrieveAll(class ACharacter* InteractingCharacter);
	void RetrieveAllByConfig(class ACharacter* InteractingCharacter, const struct FSHItemsStorageConfig& ItemsStorageConfig);
	void RetrieveSpecified(class ACharacter* InteractingCharacter, const TArray<struct FSHCollectedItemData>& ItemsToRetrieve);
	void StoreAll(class ACharacter* InteractingCharacter, const TArray<class FName>& SkipItems, const TArray<ESHItemTypeEnum>& SkipItemsCategories);
	void StoreAllByConfig(class ACharacter* InteractingCharacter, const struct FSHItemsStorageConfig& ItemsStorageConfig);
	void StoreSpecified(class ACharacter* InteractingCharacter, const TArray<struct FSHCollectedItemData>& ItemsToStore);

	TArray<struct FSHCollectedItemData> GetCurrentItems() const;
	bool IsStorageEmpty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemsStorageComponent">();
	}
	static class USHItemsStorageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHItemsStorageComponent>();
	}
};
static_assert(alignof(USHItemsStorageComponent) == 0x000008, "Wrong alignment on USHItemsStorageComponent");
static_assert(sizeof(USHItemsStorageComponent) == 0x0000C0, "Wrong size on USHItemsStorageComponent");
static_assert(offsetof(USHItemsStorageComponent, BeginPlayStoredItems) == 0x0000A0, "Member 'USHItemsStorageComponent::BeginPlayStoredItems' has a wrong offset!");
static_assert(offsetof(USHItemsStorageComponent, StoredItems) == 0x0000B0, "Member 'USHItemsStorageComponent::StoredItems' has a wrong offset!");

// Class SHProto.SHItemWeaponChainsawAnimsExtensionComponent
// 0x0018 (0x00B8 - 0x00A0)
class USHItemWeaponChainsawAnimsExtensionComponent final : public USHItemWeaponExtensionComponent
{
public:
	TSubclassOf<class USHCharacterPlayAnimActionExe> InDangerIntroAnimActionExeClass;                   // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USHCharacterPlayAnimActionExe> InDangerOutroAnimActionExeClass;                   // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessEquipWeaponMontageEndEvent(class UAnimMontage* InMontage, ESHAnimEndType AnimEndType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemWeaponChainsawAnimsExtensionComponent">();
	}
	static class USHItemWeaponChainsawAnimsExtensionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHItemWeaponChainsawAnimsExtensionComponent>();
	}
};
static_assert(alignof(USHItemWeaponChainsawAnimsExtensionComponent) == 0x000008, "Wrong alignment on USHItemWeaponChainsawAnimsExtensionComponent");
static_assert(sizeof(USHItemWeaponChainsawAnimsExtensionComponent) == 0x0000B8, "Wrong size on USHItemWeaponChainsawAnimsExtensionComponent");
static_assert(offsetof(USHItemWeaponChainsawAnimsExtensionComponent, InDangerIntroAnimActionExeClass) == 0x0000A0, "Member 'USHItemWeaponChainsawAnimsExtensionComponent::InDangerIntroAnimActionExeClass' has a wrong offset!");
static_assert(offsetof(USHItemWeaponChainsawAnimsExtensionComponent, InDangerOutroAnimActionExeClass) == 0x0000A8, "Member 'USHItemWeaponChainsawAnimsExtensionComponent::InDangerOutroAnimActionExeClass' has a wrong offset!");

// Class SHProto.SHItemWeaponMelee
// 0x0228 (0x08B8 - 0x0690)
class ASHItemWeaponMelee final : public ASHItemWeapon
{
public:
	class UDataTable*                             MeleeAttacksDataTable;                             // 0x0690(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MeleeSecondaryAttacksDataTable;                    // 0x0698(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroundAttackMaxViewPitch;                          // 0x06A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StandingBehindRequiredDotProduct;                  // 0x06A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForceFeedbackEffect*                   ForceFeedbackOnDamage;                             // 0x06A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEffectHandle                          LightEffect;                                       // 0x06B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class ASHCameraAnimationExecutive*            CameraAnimExe;                                     // 0x06B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C0[0x1F8];                                    // 0x06C0(0x01F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString CalcAttackRowName(class ACharacter* AttackCandidate);
	void OnComboWindowFailed();
	void OnComboWindowOpened();
	void OnComboWindowSuccess();
	void OnMeleeAttackAnyCharacter();
	void OnMeleeAttackFinished();
	void OnMeleeAttackInterupted();
	void OnMeleeAttackStarted();
	void SHItemWeaponMeleeWithContextEvent__DelegateSignature(class ASHItemWeaponMelee* WeaponPtr, class AActor* ActorContext);

	struct FSHCharacterPlayAttackStruct GetAttackDataCopy(class FName AttackRowName) const;
	class ACharacter* GetCurrentMeleeAttackEnemyTarget() const;
	class FString GetLastUsedAttack() const;
	bool IsOwnerStandingBehind(class ACharacter* CheckedCharacter) const;
	bool ShouldUseGroundAttack() const;
	bool SlideDistanceCheck(class ACharacter* CheckedCharacter, float MaxSlideDistance) const;
	bool WillKillCharacter(class ACharacter* CheckedCharacter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemWeaponMelee">();
	}
	static class ASHItemWeaponMelee* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHItemWeaponMelee>();
	}
};
static_assert(alignof(ASHItemWeaponMelee) == 0x000008, "Wrong alignment on ASHItemWeaponMelee");
static_assert(sizeof(ASHItemWeaponMelee) == 0x0008B8, "Wrong size on ASHItemWeaponMelee");
static_assert(offsetof(ASHItemWeaponMelee, MeleeAttacksDataTable) == 0x000690, "Member 'ASHItemWeaponMelee::MeleeAttacksDataTable' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponMelee, MeleeSecondaryAttacksDataTable) == 0x000698, "Member 'ASHItemWeaponMelee::MeleeSecondaryAttacksDataTable' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponMelee, GroundAttackMaxViewPitch) == 0x0006A0, "Member 'ASHItemWeaponMelee::GroundAttackMaxViewPitch' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponMelee, StandingBehindRequiredDotProduct) == 0x0006A4, "Member 'ASHItemWeaponMelee::StandingBehindRequiredDotProduct' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponMelee, ForceFeedbackOnDamage) == 0x0006A8, "Member 'ASHItemWeaponMelee::ForceFeedbackOnDamage' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponMelee, LightEffect) == 0x0006B0, "Member 'ASHItemWeaponMelee::LightEffect' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponMelee, CameraAnimExe) == 0x0006B8, "Member 'ASHItemWeaponMelee::CameraAnimExe' has a wrong offset!");

// Class SHProto.SHItemWeaponRangedSingleAction
// 0x00E8 (0x0D20 - 0x0C38)
class ASHItemWeaponRangedSingleAction final : public ASHItemWeaponRanged
{
public:
	TSoftObjectPtr<class UAnimationAsset>         SingleActionPrepareWeaponAnim;                     // 0x0C38(0x0030)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPlayAnimationData                     SingleActionPrepareAnimData;                       // 0x0C68(0x00B0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D18[0x8];                                      // 0x0D18(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHItemWeaponRangedSingleAction">();
	}
	static class ASHItemWeaponRangedSingleAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHItemWeaponRangedSingleAction>();
	}
};
static_assert(alignof(ASHItemWeaponRangedSingleAction) == 0x000008, "Wrong alignment on ASHItemWeaponRangedSingleAction");
static_assert(sizeof(ASHItemWeaponRangedSingleAction) == 0x000D20, "Wrong size on ASHItemWeaponRangedSingleAction");
static_assert(offsetof(ASHItemWeaponRangedSingleAction, SingleActionPrepareWeaponAnim) == 0x000C38, "Member 'ASHItemWeaponRangedSingleAction::SingleActionPrepareWeaponAnim' has a wrong offset!");
static_assert(offsetof(ASHItemWeaponRangedSingleAction, SingleActionPrepareAnimData) == 0x000C68, "Member 'ASHItemWeaponRangedSingleAction::SingleActionPrepareAnimData' has a wrong offset!");

// Class SHProto.SHJumpIntoHole
// 0x0438 (0x06E8 - 0x02B0)
class ASHJumpIntoHole final : public AActor
{
public:
	class USHCineCameraComponent*                 FocusCamera;                                       // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionGenericComponent*         InteractionGeneric;                                // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractionProximitySphere;                        // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            InteractionIcon;                                   // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHRaycastDetectableComponent*          InteractionDetectable;                             // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractionDetectableShape;                        // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      InteractionAnimSpot;                               // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      TeleportToOnPlayingEndComponent;                   // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        FlashlightFocusSpot;                               // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionManagerComponent*         InteractionManager;                                // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFocusableComponent*                  FocusableComponent;                                // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StageChangeAnimationTime;                          // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayAnimationData                     JumpAnimation;                                     // 0x0310(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPlayAnimationData                     LandAnimation;                                     // 0x03C0(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   AnimInstanceClass;                                 // 0x0470(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCameraFadingOnTeleport;                        // 0x04A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A1[0x3];                                      // 0x04A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraFadeInTime;                                  // 0x04A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraFadeKeepTime;                                // 0x04A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraFadeOutTime;                                 // 0x04AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseFocusCameraChangeTransformPerStage;            // 0x04B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B1[0x7];                                      // 0x04B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     FocusCameraRelativeTransforms;                     // 0x04B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseFocusTracking;                                 // 0x04C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C9[0x7];                                      // 0x04C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHCameraAnimationData                 CameraAnimationJump;                               // 0x04D0(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSHCameraAnimationData                 CameraAnimationLand;                               // 0x0550(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FEffectHandle                          LightEffect;                                       // 0x05D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             InteractionStartedEventBlueprint;                  // 0x05D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             StageChangedEventBlueprint;                        // 0x05E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             StageReadyEventBlueprint;                          // 0x05F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             JumpPlayedEventBlueprint;                          // 0x0608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             LandPlayedEventBlueprint;                          // 0x0618(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             InteractionFinishedEventBlueprint;                 // 0x0628(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             InteractionAbortedEventBlueprint;                  // 0x0638(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class ACharacter*                             InteractingCharacter;                              // 0x0648(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHJumpIntoHoleAnimInstance*            LinkedAnimGraphInstance;                           // 0x0650(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAnimMontagePlayer*                   AnimMontagePlayer;                                 // 0x0658(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ASHCameraAnimationExecutive> PlayingCameraAnimExe;                              // 0x0660(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_668[0x80];                                     // 0x0668(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessAnimInstStageAdvanced(class USHJumpIntoHoleAnimInstance* AnimInst);
	void ProcessAnimInstStartedInteraction(class USHJumpIntoHoleAnimInstance* AnimInst);
	void ProcessFocusableInputActionEvent(ESHFocusableInputActionTypeEnum InputActionType, float KeyValue);
	void ProcessInteractingCharacterCombatInputModeChanged(class USHCharacterPlayCombatComponent* CombatComp);
	void ProcessInteractingCharacterReceiveDamage(class USHCharacterPlayCombatComponent* CombatComp);
	void ProcessInteractionGenericGrabbed(class USHInteractionGenericComponent* Generic, class ASHCharacterPlay* Character);
	void ProcessInteractionManagerInitialized(class USHInteractionManagerComponent* Manager);
	void ProcessJumpAnimEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void ProcessLandAnimEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void ProcessLandCameraAnimBlendOutOrEnd();
	void ProcessMoveCharacterToSpotFinished(bool WasCompleted);
	void ProcessProximityBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void ProcessProximityEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex);
	void SHJumpIntoHoleEvent__DelegateSignature(class ASHJumpIntoHole* Actor);

	int32 GetCurrentFocusStageIndex() const;
	bool IsInInteraction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHJumpIntoHole">();
	}
	static class ASHJumpIntoHole* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHJumpIntoHole>();
	}
};
static_assert(alignof(ASHJumpIntoHole) == 0x000008, "Wrong alignment on ASHJumpIntoHole");
static_assert(sizeof(ASHJumpIntoHole) == 0x0006E8, "Wrong size on ASHJumpIntoHole");
static_assert(offsetof(ASHJumpIntoHole, FocusCamera) == 0x0002B0, "Member 'ASHJumpIntoHole::FocusCamera' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, InteractionGeneric) == 0x0002B8, "Member 'ASHJumpIntoHole::InteractionGeneric' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, InteractionProximitySphere) == 0x0002C0, "Member 'ASHJumpIntoHole::InteractionProximitySphere' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, InteractionIcon) == 0x0002C8, "Member 'ASHJumpIntoHole::InteractionIcon' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, InteractionDetectable) == 0x0002D0, "Member 'ASHJumpIntoHole::InteractionDetectable' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, InteractionDetectableShape) == 0x0002D8, "Member 'ASHJumpIntoHole::InteractionDetectableShape' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, InteractionAnimSpot) == 0x0002E0, "Member 'ASHJumpIntoHole::InteractionAnimSpot' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, TeleportToOnPlayingEndComponent) == 0x0002E8, "Member 'ASHJumpIntoHole::TeleportToOnPlayingEndComponent' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, FlashlightFocusSpot) == 0x0002F0, "Member 'ASHJumpIntoHole::FlashlightFocusSpot' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, InteractionManager) == 0x0002F8, "Member 'ASHJumpIntoHole::InteractionManager' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, FocusableComponent) == 0x000300, "Member 'ASHJumpIntoHole::FocusableComponent' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, StageChangeAnimationTime) == 0x000308, "Member 'ASHJumpIntoHole::StageChangeAnimationTime' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, JumpAnimation) == 0x000310, "Member 'ASHJumpIntoHole::JumpAnimation' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, LandAnimation) == 0x0003C0, "Member 'ASHJumpIntoHole::LandAnimation' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, AnimInstanceClass) == 0x000470, "Member 'ASHJumpIntoHole::AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, bUseCameraFadingOnTeleport) == 0x0004A0, "Member 'ASHJumpIntoHole::bUseCameraFadingOnTeleport' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, CameraFadeInTime) == 0x0004A4, "Member 'ASHJumpIntoHole::CameraFadeInTime' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, CameraFadeKeepTime) == 0x0004A8, "Member 'ASHJumpIntoHole::CameraFadeKeepTime' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, CameraFadeOutTime) == 0x0004AC, "Member 'ASHJumpIntoHole::CameraFadeOutTime' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, bUseFocusCameraChangeTransformPerStage) == 0x0004B0, "Member 'ASHJumpIntoHole::bUseFocusCameraChangeTransformPerStage' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, FocusCameraRelativeTransforms) == 0x0004B8, "Member 'ASHJumpIntoHole::FocusCameraRelativeTransforms' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, bUseFocusTracking) == 0x0004C8, "Member 'ASHJumpIntoHole::bUseFocusTracking' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, CameraAnimationJump) == 0x0004D0, "Member 'ASHJumpIntoHole::CameraAnimationJump' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, CameraAnimationLand) == 0x000550, "Member 'ASHJumpIntoHole::CameraAnimationLand' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, LightEffect) == 0x0005D0, "Member 'ASHJumpIntoHole::LightEffect' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, InteractionStartedEventBlueprint) == 0x0005D8, "Member 'ASHJumpIntoHole::InteractionStartedEventBlueprint' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, StageChangedEventBlueprint) == 0x0005E8, "Member 'ASHJumpIntoHole::StageChangedEventBlueprint' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, StageReadyEventBlueprint) == 0x0005F8, "Member 'ASHJumpIntoHole::StageReadyEventBlueprint' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, JumpPlayedEventBlueprint) == 0x000608, "Member 'ASHJumpIntoHole::JumpPlayedEventBlueprint' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, LandPlayedEventBlueprint) == 0x000618, "Member 'ASHJumpIntoHole::LandPlayedEventBlueprint' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, InteractionFinishedEventBlueprint) == 0x000628, "Member 'ASHJumpIntoHole::InteractionFinishedEventBlueprint' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, InteractionAbortedEventBlueprint) == 0x000638, "Member 'ASHJumpIntoHole::InteractionAbortedEventBlueprint' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, InteractingCharacter) == 0x000648, "Member 'ASHJumpIntoHole::InteractingCharacter' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, LinkedAnimGraphInstance) == 0x000650, "Member 'ASHJumpIntoHole::LinkedAnimGraphInstance' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, AnimMontagePlayer) == 0x000658, "Member 'ASHJumpIntoHole::AnimMontagePlayer' has a wrong offset!");
static_assert(offsetof(ASHJumpIntoHole, PlayingCameraAnimExe) == 0x000660, "Member 'ASHJumpIntoHole::PlayingCameraAnimExe' has a wrong offset!");

// Class SHProto.SHJumpIntoHoleAnimInstance
// 0x0020 (0x0370 - 0x0350)
class USHJumpIntoHoleAnimInstance final : public UAnimInstance
{
public:
	bool                                          bPlayInteraction;                                  // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAdvanceStage;                                     // 0x0349(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34A[0x26];                                     // 0x034A(0x0026)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyFinalStageReached();
	void ApplyInteractionStarted();
	void ApplyInteractionStartedAndItsFinalStage();
	void ApplyStageAdvanced();
	void SHJumpIntoHoleAnimInstanceEvent__DelegateSignature(class USHJumpIntoHoleAnimInstance* AnimInst);

	bool CanReceiveInput() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHJumpIntoHoleAnimInstance">();
	}
	static class USHJumpIntoHoleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHJumpIntoHoleAnimInstance>();
	}
};
static_assert(alignof(USHJumpIntoHoleAnimInstance) == 0x000010, "Wrong alignment on USHJumpIntoHoleAnimInstance");
static_assert(sizeof(USHJumpIntoHoleAnimInstance) == 0x000370, "Wrong size on USHJumpIntoHoleAnimInstance");
static_assert(offsetof(USHJumpIntoHoleAnimInstance, bPlayInteraction) == 0x000348, "Member 'USHJumpIntoHoleAnimInstance::bPlayInteraction' has a wrong offset!");
static_assert(offsetof(USHJumpIntoHoleAnimInstance, bAdvanceStage) == 0x000349, "Member 'USHJumpIntoHoleAnimInstance::bAdvanceStage' has a wrong offset!");

// Class SHProto.SHLauraLocomotionAnimInstance
// 0x0000 (0x03D0 - 0x03D0)
class USHLauraLocomotionAnimInstance final : public USHFriendLocomotionAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLauraLocomotionAnimInstance">();
	}
	static class USHLauraLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLauraLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHLauraLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHLauraLocomotionAnimInstance");
static_assert(sizeof(USHLauraLocomotionAnimInstance) == 0x0003D0, "Wrong size on USHLauraLocomotionAnimInstance");

// Class SHProto.SHLauraLookAtPlayerProvider
// 0x0008 (0x0070 - 0x0068)
class USHLauraLookAtPlayerProvider final : public USHLookAtTargetProvider
{
public:
	float                                         MaxDistance;                                       // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle;                                          // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLauraLookAtPlayerProvider">();
	}
	static class USHLauraLookAtPlayerProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLauraLookAtPlayerProvider>();
	}
};
static_assert(alignof(USHLauraLookAtPlayerProvider) == 0x000008, "Wrong alignment on USHLauraLookAtPlayerProvider");
static_assert(sizeof(USHLauraLookAtPlayerProvider) == 0x000070, "Wrong size on USHLauraLookAtPlayerProvider");
static_assert(offsetof(USHLauraLookAtPlayerProvider, MaxDistance) == 0x000068, "Member 'USHLauraLookAtPlayerProvider::MaxDistance' has a wrong offset!");
static_assert(offsetof(USHLauraLookAtPlayerProvider, MaxAngle) == 0x00006C, "Member 'USHLauraLookAtPlayerProvider::MaxAngle' has a wrong offset!");

// Class SHProto.SHLightingChannelsStatics
// 0x0000 (0x0028 - 0x0028)
class USHLightingChannelsStatics final : public UBlueprintFunctionLibrary
{
public:
	static struct FSHLightingChannelsPack GetLightingChannelsPack(const ESHLightingChannelsProfile Profile);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLightingChannelsStatics">();
	}
	static class USHLightingChannelsStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLightingChannelsStatics>();
	}
};
static_assert(alignof(USHLightingChannelsStatics) == 0x000008, "Wrong alignment on USHLightingChannelsStatics");
static_assert(sizeof(USHLightingChannelsStatics) == 0x000028, "Wrong size on USHLightingChannelsStatics");

// Class SHProto.SHLoadingScreenWidget
// 0x01A0 (0x0490 - 0x02F0)
class alignas(0x10) USHLoadingScreenWidget final : public ULoadScreenWidget
{
public:
	class UImage*                                 BackgroundMovie_img;                               // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UBinkMediaPlayer>        MediaPlayer;                                       // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                HintText_lbl;                                      // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class ULoadingHints>           LoadingHints;                                      // 0x0308(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UUE4KeyTexts>            KeyTexts;                                          // 0x0338(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 KeyTagText;                                        // 0x0368(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SeparatorText;                                     // 0x0378(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HintMaxTime;                                       // 0x0388(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   QTEHoldTip;                                        // 0x038C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   QTEMashTip;                                        // 0x0394(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39C[0xF4];                                     // 0x039C(0x00F4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnShowHint(bool Show);

	EGameOverCause GetDeathReason() const;
	bool IsDeathReload() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLoadingScreenWidget">();
	}
	static class USHLoadingScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLoadingScreenWidget>();
	}
};
static_assert(alignof(USHLoadingScreenWidget) == 0x000010, "Wrong alignment on USHLoadingScreenWidget");
static_assert(sizeof(USHLoadingScreenWidget) == 0x000490, "Wrong size on USHLoadingScreenWidget");
static_assert(offsetof(USHLoadingScreenWidget, BackgroundMovie_img) == 0x0002F0, "Member 'USHLoadingScreenWidget::BackgroundMovie_img' has a wrong offset!");
static_assert(offsetof(USHLoadingScreenWidget, MediaPlayer) == 0x0002F8, "Member 'USHLoadingScreenWidget::MediaPlayer' has a wrong offset!");
static_assert(offsetof(USHLoadingScreenWidget, HintText_lbl) == 0x000300, "Member 'USHLoadingScreenWidget::HintText_lbl' has a wrong offset!");
static_assert(offsetof(USHLoadingScreenWidget, LoadingHints) == 0x000308, "Member 'USHLoadingScreenWidget::LoadingHints' has a wrong offset!");
static_assert(offsetof(USHLoadingScreenWidget, KeyTexts) == 0x000338, "Member 'USHLoadingScreenWidget::KeyTexts' has a wrong offset!");
static_assert(offsetof(USHLoadingScreenWidget, KeyTagText) == 0x000368, "Member 'USHLoadingScreenWidget::KeyTagText' has a wrong offset!");
static_assert(offsetof(USHLoadingScreenWidget, SeparatorText) == 0x000378, "Member 'USHLoadingScreenWidget::SeparatorText' has a wrong offset!");
static_assert(offsetof(USHLoadingScreenWidget, HintMaxTime) == 0x000388, "Member 'USHLoadingScreenWidget::HintMaxTime' has a wrong offset!");
static_assert(offsetof(USHLoadingScreenWidget, QTEHoldTip) == 0x00038C, "Member 'USHLoadingScreenWidget::QTEHoldTip' has a wrong offset!");
static_assert(offsetof(USHLoadingScreenWidget, QTEMashTip) == 0x000394, "Member 'USHLoadingScreenWidget::QTEMashTip' has a wrong offset!");

// Class SHProto.SHLocalFogVolumetricActor
// 0x0020 (0x02D0 - 0x02B0)
class ASHLocalFogVolumetricActor final : public ALocalFogVolumeActor
{
public:
	bool                                          bUseCameraInsteadOfPlayerLocation;                 // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x1F];                                     // 0x02B1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEnableStateChanged();
	void SetEnabled(const bool bInEnabled, const class UObject* Object);

	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLocalFogVolumetricActor">();
	}
	static class ASHLocalFogVolumetricActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHLocalFogVolumetricActor>();
	}
};
static_assert(alignof(ASHLocalFogVolumetricActor) == 0x000008, "Wrong alignment on ASHLocalFogVolumetricActor");
static_assert(sizeof(ASHLocalFogVolumetricActor) == 0x0002D0, "Wrong size on ASHLocalFogVolumetricActor");
static_assert(offsetof(ASHLocalFogVolumetricActor, bUseCameraInsteadOfPlayerLocation) == 0x0002B0, "Member 'ASHLocalFogVolumetricActor::bUseCameraInsteadOfPlayerLocation' has a wrong offset!");

// Class SHProto.SHLookAtActorInterface
// 0x0000 (0x0028 - 0x0028)
class ISHLookAtActorInterface final : public IInterface
{
public:
	bool CanBeLookedAt() const;
	class USceneComponent* GetLookAtTargetComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLookAtActorInterface">();
	}
	static class ISHLookAtActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHLookAtActorInterface>();
	}
};
static_assert(alignof(ISHLookAtActorInterface) == 0x000008, "Wrong alignment on ISHLookAtActorInterface");
static_assert(sizeof(ISHLookAtActorInterface) == 0x000028, "Wrong size on ISHLookAtActorInterface");

// Class SHProto.SHLyingFigureAnimComponent
// 0x0070 (0x0500 - 0x0490)
class USHLyingFigureAnimComponent final : public USHEnemyAnimComponent
{
public:
	struct FSHAnimFootIKSubcompSettings           SHAnimFootIKSubcompSettings;                       // 0x0490(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLyingFigureAnimComponent">();
	}
	static class USHLyingFigureAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLyingFigureAnimComponent>();
	}
};
static_assert(alignof(USHLyingFigureAnimComponent) == 0x000008, "Wrong alignment on USHLyingFigureAnimComponent");
static_assert(sizeof(USHLyingFigureAnimComponent) == 0x000500, "Wrong size on USHLyingFigureAnimComponent");
static_assert(offsetof(USHLyingFigureAnimComponent, SHAnimFootIKSubcompSettings) == 0x000490, "Member 'USHLyingFigureAnimComponent::SHAnimFootIKSubcompSettings' has a wrong offset!");

// Class SHProto.SHLyingFigureAnimInstance
// 0x0010 (0x03F0 - 0x03E0)
class USHLyingFigureAnimInstance final : public USHMonsterAnimInstance
{
public:
	bool                                          bIsCrawling;                                       // 0x03E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0xF];                                      // 0x03E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USHLyingFigureLocomotionAnimInstance* GetActiveLyingFigureLocomotionAnimInstance() const;
	class USHLyingFigureAnimInstanceStateData* GetLyingFigureAnimInstanceStateData() const;
	class USHLyingFigureCrawlingLocomotionAnimInstance* GetLyingFigureCrawlingLocomotionAnimInstance() const;
	class USHLyingFigureStandingLocomotionAnimInstance* GetLyingFigureStandingLocomotionAnimInstance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLyingFigureAnimInstance">();
	}
	static class USHLyingFigureAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLyingFigureAnimInstance>();
	}
};
static_assert(alignof(USHLyingFigureAnimInstance) == 0x000010, "Wrong alignment on USHLyingFigureAnimInstance");
static_assert(sizeof(USHLyingFigureAnimInstance) == 0x0003F0, "Wrong size on USHLyingFigureAnimInstance");
static_assert(offsetof(USHLyingFigureAnimInstance, bIsCrawling) == 0x0003E0, "Member 'USHLyingFigureAnimInstance::bIsCrawling' has a wrong offset!");

// Class SHProto.SHLyingFigureAnimInstanceStateData
// 0x0010 (0x0088 - 0x0078)
class USHLyingFigureAnimInstanceStateData final : public USHMonsterAnimInstanceStateData
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetAreAllowedInaccurateLocomotionAnimationsOfDistance(float InAnimationDistance) const;
	bool GetAreInaccurateLocomotionAnimationsAllowed() const;
	float GetCrawlBendPitchAngle() const;
	float GetCrawlBendYawAngle() const;
	float GetInaccurateLocomotionAnimationsDistanceAccuracy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLyingFigureAnimInstanceStateData">();
	}
	static class USHLyingFigureAnimInstanceStateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLyingFigureAnimInstanceStateData>();
	}
};
static_assert(alignof(USHLyingFigureAnimInstanceStateData) == 0x000008, "Wrong alignment on USHLyingFigureAnimInstanceStateData");
static_assert(sizeof(USHLyingFigureAnimInstanceStateData) == 0x000088, "Wrong size on USHLyingFigureAnimInstanceStateData");

// Class SHProto.SHLyingFigureFXComponent
// 0x0008 (0x0130 - 0x0128)
class USHLyingFigureFXComponent : public USHEnemyBaseFXComponent
{
public:
	class USHFXSkitteringBloodTraceSubcompSettings* SkitteringBloodTraceSettings;                      // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLyingFigureFXComponent">();
	}
	static class USHLyingFigureFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLyingFigureFXComponent>();
	}
};
static_assert(alignof(USHLyingFigureFXComponent) == 0x000008, "Wrong alignment on USHLyingFigureFXComponent");
static_assert(sizeof(USHLyingFigureFXComponent) == 0x000130, "Wrong size on USHLyingFigureFXComponent");
static_assert(offsetof(USHLyingFigureFXComponent, SkitteringBloodTraceSettings) == 0x000128, "Member 'USHLyingFigureFXComponent::SkitteringBloodTraceSettings' has a wrong offset!");

// Class SHProto.SHLyingFigureOWFXComponent
// 0x0010 (0x0140 - 0x0130)
class USHLyingFigureOWFXComponent final : public USHLyingFigureFXComponent
{
public:
	class USHFXPukeExplosionSubcompSettings*      DeathPukeExplosionSettings;                        // 0x0130(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFXPukeExplosionSubcompSettings*      AtackPukeExplosionSettings;                        // 0x0138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLyingFigureOWFXComponent">();
	}
	static class USHLyingFigureOWFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLyingFigureOWFXComponent>();
	}
};
static_assert(alignof(USHLyingFigureOWFXComponent) == 0x000008, "Wrong alignment on USHLyingFigureOWFXComponent");
static_assert(sizeof(USHLyingFigureOWFXComponent) == 0x000140, "Wrong size on USHLyingFigureOWFXComponent");
static_assert(offsetof(USHLyingFigureOWFXComponent, DeathPukeExplosionSettings) == 0x000130, "Member 'USHLyingFigureOWFXComponent::DeathPukeExplosionSettings' has a wrong offset!");
static_assert(offsetof(USHLyingFigureOWFXComponent, AtackPukeExplosionSettings) == 0x000138, "Member 'USHLyingFigureOWFXComponent::AtackPukeExplosionSettings' has a wrong offset!");

// Class SHProto.SHLyingFigureStandingLocomotionAnimInstance
// 0x00B0 (0x0460 - 0x03B0)
class USHLyingFigureStandingLocomotionAnimInstance final : public USHLyingFigureLocomotionAnimInstance
{
public:
	ESHLyingFigureAnimInstanceStandingLocomotionState LocomotionState;                                   // 0x03A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DesiredVelocityIncrementHalfTime;                  // 0x03B0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DesiredVelocityDecrementHalfTime;                  // 0x03C8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetDesiredVelocity;                             // 0x03E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DesiredYawAdjustmentHalfTime;                      // 0x03F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetDesiredRotationYaw;                          // 0x03FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtAlphaIncrementHalfTime;                      // 0x0400(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtAlphaDecrementHalfTime;                      // 0x0404(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StruggleAlphaIncrementHalfTime;                    // 0x0408(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StruggleAlphaDecrementHalfTime;                    // 0x040C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SmoothedStruggleAlpha;                             // 0x0410(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StrugglePlayRate;                                  // 0x0414(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x48];                                     // 0x0418(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetStruggle(float ALPHA, float PlayRate);

	void GetSmoothedDesiredRotationYaw(float* OutYaw) const;
	void GetSmoothedDesiredVelocity(struct FVector* OutVelocity) const;
	void GetSmoothedDesiredVelocitySizeAndYaw(float* OutVelocitySize, float* OutVelocityYaw) const;
	void GetSmoothedLookAt(struct FRotator* OutRotation, float* OutAlpha) const;
	void GetSmoothedStruggle(float* OutPlayRate, float* OutAlpha) const;
	void GetTargetDesiredRotationYaw(float* OutYaw) const;
	void GetTargetDesiredVelocity(struct FVector* OutVelocity) const;
	void GetTargetDesiredVelocitySizeAndYaw(float* OutVelocitySize, float* OutVelocityYaw) const;
	void GetTargetLookAtAlpha(float* OutAlpha) const;
	void GetTargetStruggleAlpha(float* OutAlpha) const;
	void GetTransformationToCrawlingAnimation(const struct FRotator& InLocalRotation, class UAnimSequenceBase** OutAnimation, float* OutPlayRate, float* OutBlendInDuration, float* OutBlendOutDuration, struct FRotator* OutAnimaitonRotation, struct FRotator* OutRemainderRotation, bool* OutUsesDelayedRootRotation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLyingFigureStandingLocomotionAnimInstance">();
	}
	static class USHLyingFigureStandingLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLyingFigureStandingLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHLyingFigureStandingLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHLyingFigureStandingLocomotionAnimInstance");
static_assert(sizeof(USHLyingFigureStandingLocomotionAnimInstance) == 0x000460, "Wrong size on USHLyingFigureStandingLocomotionAnimInstance");
static_assert(offsetof(USHLyingFigureStandingLocomotionAnimInstance, LocomotionState) == 0x0003A8, "Member 'USHLyingFigureStandingLocomotionAnimInstance::LocomotionState' has a wrong offset!");
static_assert(offsetof(USHLyingFigureStandingLocomotionAnimInstance, DesiredVelocityIncrementHalfTime) == 0x0003B0, "Member 'USHLyingFigureStandingLocomotionAnimInstance::DesiredVelocityIncrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHLyingFigureStandingLocomotionAnimInstance, DesiredVelocityDecrementHalfTime) == 0x0003C8, "Member 'USHLyingFigureStandingLocomotionAnimInstance::DesiredVelocityDecrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHLyingFigureStandingLocomotionAnimInstance, TargetDesiredVelocity) == 0x0003E0, "Member 'USHLyingFigureStandingLocomotionAnimInstance::TargetDesiredVelocity' has a wrong offset!");
static_assert(offsetof(USHLyingFigureStandingLocomotionAnimInstance, DesiredYawAdjustmentHalfTime) == 0x0003F8, "Member 'USHLyingFigureStandingLocomotionAnimInstance::DesiredYawAdjustmentHalfTime' has a wrong offset!");
static_assert(offsetof(USHLyingFigureStandingLocomotionAnimInstance, TargetDesiredRotationYaw) == 0x0003FC, "Member 'USHLyingFigureStandingLocomotionAnimInstance::TargetDesiredRotationYaw' has a wrong offset!");
static_assert(offsetof(USHLyingFigureStandingLocomotionAnimInstance, LookAtAlphaIncrementHalfTime) == 0x000400, "Member 'USHLyingFigureStandingLocomotionAnimInstance::LookAtAlphaIncrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHLyingFigureStandingLocomotionAnimInstance, LookAtAlphaDecrementHalfTime) == 0x000404, "Member 'USHLyingFigureStandingLocomotionAnimInstance::LookAtAlphaDecrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHLyingFigureStandingLocomotionAnimInstance, StruggleAlphaIncrementHalfTime) == 0x000408, "Member 'USHLyingFigureStandingLocomotionAnimInstance::StruggleAlphaIncrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHLyingFigureStandingLocomotionAnimInstance, StruggleAlphaDecrementHalfTime) == 0x00040C, "Member 'USHLyingFigureStandingLocomotionAnimInstance::StruggleAlphaDecrementHalfTime' has a wrong offset!");
static_assert(offsetof(USHLyingFigureStandingLocomotionAnimInstance, SmoothedStruggleAlpha) == 0x000410, "Member 'USHLyingFigureStandingLocomotionAnimInstance::SmoothedStruggleAlpha' has a wrong offset!");
static_assert(offsetof(USHLyingFigureStandingLocomotionAnimInstance, StrugglePlayRate) == 0x000414, "Member 'USHLyingFigureStandingLocomotionAnimInstance::StrugglePlayRate' has a wrong offset!");

// Class SHProto.SHMainMenuWidget
// 0x0098 (0x0408 - 0x0370)
class USHMainMenuWidget final : public USHBaseMainMenuWidget
{
public:
	bool                                          IsDemo;                                            // 0x0370(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpawnPointHandle                      NewGameSpawnPoint;                                 // 0x0378(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKey>                           FocusSpawnPointListKeys;                           // 0x03A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UBButton*                               Continue_but;                                      // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBButton*                               NewGame_but;                                       // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBButton*                               Load_but;                                          // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBButton*                               Settings_but;                                      // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBButton*                               Quit_but;                                          // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpawnPointsPanelWidget*                SpawnPointsPanel_wdg;                              // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpawnPointsListWidget*                 SpawnPoints_wdg;                                   // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BackgroundMovie_img;                               // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHNGInfoDialog*                        NGInfoDialog;                                      // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UBinkMediaPlayer>        MediaPlayer;                                       // 0x03F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginCustomLevel(const struct FStreamableLevelHandle& LevelHandle);
	void BeginGameFromSpawnPoint(const struct FSpawnPointData& SpawnPointData, class UMovieConfig* Movie, float NonSkippableLen, bool IsNewGame);
	bool BeginGameFromSpawnPointHandle(const struct FSpawnPointHandle& SpawnPointHandle, class UMovieConfig* Movie, float NonSkippableLen, bool IsNewGame);
	bool BeginNewGameFromSpawnPoint(class UMovieConfig* Movie, float NonSkippableLen);
	void OnFocusSpawnPointList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMainMenuWidget">();
	}
	static class USHMainMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMainMenuWidget>();
	}
};
static_assert(alignof(USHMainMenuWidget) == 0x000008, "Wrong alignment on USHMainMenuWidget");
static_assert(sizeof(USHMainMenuWidget) == 0x000408, "Wrong size on USHMainMenuWidget");
static_assert(offsetof(USHMainMenuWidget, IsDemo) == 0x000370, "Member 'USHMainMenuWidget::IsDemo' has a wrong offset!");
static_assert(offsetof(USHMainMenuWidget, NewGameSpawnPoint) == 0x000378, "Member 'USHMainMenuWidget::NewGameSpawnPoint' has a wrong offset!");
static_assert(offsetof(USHMainMenuWidget, FocusSpawnPointListKeys) == 0x0003A0, "Member 'USHMainMenuWidget::FocusSpawnPointListKeys' has a wrong offset!");
static_assert(offsetof(USHMainMenuWidget, Continue_but) == 0x0003B0, "Member 'USHMainMenuWidget::Continue_but' has a wrong offset!");
static_assert(offsetof(USHMainMenuWidget, NewGame_but) == 0x0003B8, "Member 'USHMainMenuWidget::NewGame_but' has a wrong offset!");
static_assert(offsetof(USHMainMenuWidget, Load_but) == 0x0003C0, "Member 'USHMainMenuWidget::Load_but' has a wrong offset!");
static_assert(offsetof(USHMainMenuWidget, Settings_but) == 0x0003C8, "Member 'USHMainMenuWidget::Settings_but' has a wrong offset!");
static_assert(offsetof(USHMainMenuWidget, Quit_but) == 0x0003D0, "Member 'USHMainMenuWidget::Quit_but' has a wrong offset!");
static_assert(offsetof(USHMainMenuWidget, SpawnPointsPanel_wdg) == 0x0003D8, "Member 'USHMainMenuWidget::SpawnPointsPanel_wdg' has a wrong offset!");
static_assert(offsetof(USHMainMenuWidget, SpawnPoints_wdg) == 0x0003E0, "Member 'USHMainMenuWidget::SpawnPoints_wdg' has a wrong offset!");
static_assert(offsetof(USHMainMenuWidget, BackgroundMovie_img) == 0x0003E8, "Member 'USHMainMenuWidget::BackgroundMovie_img' has a wrong offset!");
static_assert(offsetof(USHMainMenuWidget, NGInfoDialog) == 0x0003F0, "Member 'USHMainMenuWidget::NGInfoDialog' has a wrong offset!");
static_assert(offsetof(USHMainMenuWidget, MediaPlayer) == 0x0003F8, "Member 'USHMainMenuWidget::MediaPlayer' has a wrong offset!");

// Class SHProto.SHMandarinAnimComponent
// 0x00A0 (0x0530 - 0x0490)
class USHMandarinAnimComponent final : public USHEnemyAnimComponent
{
public:
	bool                                          WasLastStepRight;                                  // 0x0490(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_491[0x7];                                      // 0x0491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHAnimFootIKSubcompSettings           SHAnimFootIKSubcompSettings;                       // 0x0498(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FMandarinIKSettings                    SHMandarinIKSettings;                              // 0x0508(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void ChangeLocomotion(bool ToAggressive);
	void RequestStopOnHit();
	void SetHanging(bool IsHanging);
	void SetLastStep(bool WasRight);
	void SetTongueSnapLocation(const struct FVector& Location);
	void SetTongueSnapRotation(const struct FRotator& Rotation);
	void SetTongueTransformationAlpha(bool Enable);
	void ToggleLegsRagdoll(bool Activate_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMandarinAnimComponent">();
	}
	static class USHMandarinAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMandarinAnimComponent>();
	}
};
static_assert(alignof(USHMandarinAnimComponent) == 0x000008, "Wrong alignment on USHMandarinAnimComponent");
static_assert(sizeof(USHMandarinAnimComponent) == 0x000530, "Wrong size on USHMandarinAnimComponent");
static_assert(offsetof(USHMandarinAnimComponent, WasLastStepRight) == 0x000490, "Member 'USHMandarinAnimComponent::WasLastStepRight' has a wrong offset!");
static_assert(offsetof(USHMandarinAnimComponent, SHAnimFootIKSubcompSettings) == 0x000498, "Member 'USHMandarinAnimComponent::SHAnimFootIKSubcompSettings' has a wrong offset!");
static_assert(offsetof(USHMandarinAnimComponent, SHMandarinIKSettings) == 0x000508, "Member 'USHMandarinAnimComponent::SHMandarinIKSettings' has a wrong offset!");

// Class SHProto.SHMandarinAnimInstanceStateData
// 0x0010 (0x0088 - 0x0078)
class USHMandarinAnimInstanceStateData final : public USHMonsterAnimInstanceStateData
{
public:
	struct FTimerHandle                           ReEnableMovementTimerHandle;                       // 0x0078(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsMovementCanceled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMandarinAnimInstanceStateData">();
	}
	static class USHMandarinAnimInstanceStateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMandarinAnimInstanceStateData>();
	}
};
static_assert(alignof(USHMandarinAnimInstanceStateData) == 0x000008, "Wrong alignment on USHMandarinAnimInstanceStateData");
static_assert(sizeof(USHMandarinAnimInstanceStateData) == 0x000088, "Wrong size on USHMandarinAnimInstanceStateData");
static_assert(offsetof(USHMandarinAnimInstanceStateData, ReEnableMovementTimerHandle) == 0x000078, "Member 'USHMandarinAnimInstanceStateData::ReEnableMovementTimerHandle' has a wrong offset!");

// Class SHProto.SHMandarinAnimLookAtSubcomp
// 0x0000 (0x0060 - 0x0060)
class USHMandarinAnimLookAtSubcomp final : public USHAnimLookAtSubcomp
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMandarinAnimLookAtSubcomp">();
	}
	static class USHMandarinAnimLookAtSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMandarinAnimLookAtSubcomp>();
	}
};
static_assert(alignof(USHMandarinAnimLookAtSubcomp) == 0x000008, "Wrong alignment on USHMandarinAnimLookAtSubcomp");
static_assert(sizeof(USHMandarinAnimLookAtSubcomp) == 0x000060, "Wrong size on USHMandarinAnimLookAtSubcomp");

// Class SHProto.SHMandarinTransformationState
// 0x0020 (0x00F0 - 0x00D0)
class USHMandarinTransformationState final : public USHEnemyTransformationState
{
public:
	ESHMandarinTransformationState                MandarinTransformationState;                       // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TransformationStateHeightOffset;                   // 0x00D8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	ESHMandarinTransformationState GetMandarinTransformationState() const;
	struct FVector GetTransformationStateHeightOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMandarinTransformationState">();
	}
	static class USHMandarinTransformationState* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMandarinTransformationState>();
	}
};
static_assert(alignof(USHMandarinTransformationState) == 0x000008, "Wrong alignment on USHMandarinTransformationState");
static_assert(sizeof(USHMandarinTransformationState) == 0x0000F0, "Wrong size on USHMandarinTransformationState");
static_assert(offsetof(USHMandarinTransformationState, MandarinTransformationState) == 0x0000D0, "Member 'USHMandarinTransformationState::MandarinTransformationState' has a wrong offset!");
static_assert(offsetof(USHMandarinTransformationState, TransformationStateHeightOffset) == 0x0000D8, "Member 'USHMandarinTransformationState::TransformationStateHeightOffset' has a wrong offset!");

// Class SHProto.SHMannequinAnimComponent
// 0x0070 (0x0500 - 0x0490)
class USHMannequinAnimComponent final : public USHEnemyAnimComponent
{
public:
	struct FSHAnimFootIKSubcompSettings           SHAnimFootIKSubcompSettings;                       // 0x0490(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMannequinAnimComponent">();
	}
	static class USHMannequinAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMannequinAnimComponent>();
	}
};
static_assert(alignof(USHMannequinAnimComponent) == 0x000008, "Wrong alignment on USHMannequinAnimComponent");
static_assert(sizeof(USHMannequinAnimComponent) == 0x000500, "Wrong size on USHMannequinAnimComponent");
static_assert(offsetof(USHMannequinAnimComponent, SHAnimFootIKSubcompSettings) == 0x000490, "Member 'USHMannequinAnimComponent::SHAnimFootIKSubcompSettings' has a wrong offset!");

// Class SHProto.SHMannequinAnimInstance
// 0x0000 (0x03E0 - 0x03E0)
class USHMannequinAnimInstance final : public USHMonsterAnimInstance
{
public:
	class USHMannequinAnimInstanceStateData* GetMannequinAnimInstanceStateData() const;
	class USHMannequinLocomotionAnimInstance* GetMannequinLocomotionAnimInstance(int32 SlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMannequinAnimInstance">();
	}
	static class USHMannequinAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMannequinAnimInstance>();
	}
};
static_assert(alignof(USHMannequinAnimInstance) == 0x000010, "Wrong alignment on USHMannequinAnimInstance");
static_assert(sizeof(USHMannequinAnimInstance) == 0x0003E0, "Wrong size on USHMannequinAnimInstance");

// Class SHProto.SHMannequinCrawlingLocomotionAnimInstance
// 0x0000 (0x03B0 - 0x03B0)
class USHMannequinCrawlingLocomotionAnimInstance final : public USHMannequinLocomotionAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMannequinCrawlingLocomotionAnimInstance">();
	}
	static class USHMannequinCrawlingLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMannequinCrawlingLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHMannequinCrawlingLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHMannequinCrawlingLocomotionAnimInstance");
static_assert(sizeof(USHMannequinCrawlingLocomotionAnimInstance) == 0x0003B0, "Wrong size on USHMannequinCrawlingLocomotionAnimInstance");

// Class SHProto.SHMQSpiderAnimComponent
// 0x0000 (0x0490 - 0x0490)
class USHMQSpiderAnimComponent final : public USHEnemyAnimComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMQSpiderAnimComponent">();
	}
	static class USHMQSpiderAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMQSpiderAnimComponent>();
	}
};
static_assert(alignof(USHMQSpiderAnimComponent) == 0x000008, "Wrong alignment on USHMQSpiderAnimComponent");
static_assert(sizeof(USHMQSpiderAnimComponent) == 0x000490, "Wrong size on USHMQSpiderAnimComponent");

// Class SHProto.SHMapRenderer
// 0x0028 (0x02D8 - 0x02B0)
class ASHMapRenderer final : public AActor
{
public:
	class UWidgetComponent*                       Widget;                                            // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               ReceiverDynamicMaterial;                           // 0x02B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x18];                                     // 0x02C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHMapRendererEvent__DelegateSignature(class ASHMapRenderer* RendererPtr);

	class UTextureRenderTarget2D* GetRenderTarget() const;
	class USHGameplayMapRenderWidget* GetUserWidgetObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMapRenderer">();
	}
	static class ASHMapRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHMapRenderer>();
	}
};
static_assert(alignof(ASHMapRenderer) == 0x000008, "Wrong alignment on ASHMapRenderer");
static_assert(sizeof(ASHMapRenderer) == 0x0002D8, "Wrong size on ASHMapRenderer");
static_assert(offsetof(ASHMapRenderer, Widget) == 0x0002B0, "Member 'ASHMapRenderer::Widget' has a wrong offset!");
static_assert(offsetof(ASHMapRenderer, ReceiverDynamicMaterial) == 0x0002B8, "Member 'ASHMapRenderer::ReceiverDynamicMaterial' has a wrong offset!");

// Class SHProto.SHMapTutorialHandler
// 0x0008 (0x0040 - 0x0038)
class USHMapTutorialHandler final : public USHTutorialHandlerBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMapTutorialHandler">();
	}
	static class USHMapTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMapTutorialHandler>();
	}
};
static_assert(alignof(USHMapTutorialHandler) == 0x000008, "Wrong alignment on USHMapTutorialHandler");
static_assert(sizeof(USHMapTutorialHandler) == 0x000040, "Wrong size on USHMapTutorialHandler");

// Class SHProto.SHMariaAnimComponent
// 0x01F0 (0x0480 - 0x0290)
class USHMariaAnimComponent final : public USHAnimComponent
{
public:
	struct FSHAnimFootIKSubcompSettings           SHAnimFootIKSubcompSettings;                       // 0x0290(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSHAnimHeadRotationBaseSubcompSettings HeadRotationSettings;                              // 0x0300(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSHMariaFlashlightReactionAnimSubcompSettings FlashlightReactionSettings;                        // 0x0348(0x0118)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class USHNPCLocomotionAnimInstance> DefaultLocomotionAnimInstClass;                    // 0x0460(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USHNPCLocomotionAnimInstance> InjuredLocomotionAnimInstClass;                    // 0x0468(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USHNPCLocomotionAnimInstance> InDangerLocomotionAnimInstClass;                   // 0x0470(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RefreshAnimGraphs();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMariaAnimComponent">();
	}
	static class USHMariaAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMariaAnimComponent>();
	}
};
static_assert(alignof(USHMariaAnimComponent) == 0x000008, "Wrong alignment on USHMariaAnimComponent");
static_assert(sizeof(USHMariaAnimComponent) == 0x000480, "Wrong size on USHMariaAnimComponent");
static_assert(offsetof(USHMariaAnimComponent, SHAnimFootIKSubcompSettings) == 0x000290, "Member 'USHMariaAnimComponent::SHAnimFootIKSubcompSettings' has a wrong offset!");
static_assert(offsetof(USHMariaAnimComponent, HeadRotationSettings) == 0x000300, "Member 'USHMariaAnimComponent::HeadRotationSettings' has a wrong offset!");
static_assert(offsetof(USHMariaAnimComponent, FlashlightReactionSettings) == 0x000348, "Member 'USHMariaAnimComponent::FlashlightReactionSettings' has a wrong offset!");
static_assert(offsetof(USHMariaAnimComponent, DefaultLocomotionAnimInstClass) == 0x000460, "Member 'USHMariaAnimComponent::DefaultLocomotionAnimInstClass' has a wrong offset!");
static_assert(offsetof(USHMariaAnimComponent, InjuredLocomotionAnimInstClass) == 0x000468, "Member 'USHMariaAnimComponent::InjuredLocomotionAnimInstClass' has a wrong offset!");
static_assert(offsetof(USHMariaAnimComponent, InDangerLocomotionAnimInstClass) == 0x000470, "Member 'USHMariaAnimComponent::InDangerLocomotionAnimInstClass' has a wrong offset!");

// Class SHProto.SHMariaDeathPlayer
// 0x0020 (0x0320 - 0x0300)
class ASHMariaDeathPlayer final : public ASHDeathPlayer
{
public:
	class UBoxComponent*                          FullAreaWork;                                      // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      MariaSpot;                                         // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   MariaStartPreviewMesh;                             // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   MariaEndPreviewMesh;                               // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMariaDeathPlayer">();
	}
	static class ASHMariaDeathPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHMariaDeathPlayer>();
	}
};
static_assert(alignof(ASHMariaDeathPlayer) == 0x000008, "Wrong alignment on ASHMariaDeathPlayer");
static_assert(sizeof(ASHMariaDeathPlayer) == 0x000320, "Wrong size on ASHMariaDeathPlayer");
static_assert(offsetof(ASHMariaDeathPlayer, FullAreaWork) == 0x000300, "Member 'ASHMariaDeathPlayer::FullAreaWork' has a wrong offset!");
static_assert(offsetof(ASHMariaDeathPlayer, MariaSpot) == 0x000308, "Member 'ASHMariaDeathPlayer::MariaSpot' has a wrong offset!");
static_assert(offsetof(ASHMariaDeathPlayer, MariaStartPreviewMesh) == 0x000310, "Member 'ASHMariaDeathPlayer::MariaStartPreviewMesh' has a wrong offset!");
static_assert(offsetof(ASHMariaDeathPlayer, MariaEndPreviewMesh) == 0x000318, "Member 'ASHMariaDeathPlayer::MariaEndPreviewMesh' has a wrong offset!");

// Class SHProto.SHMariaFlashlightReactionAnimSubcomp
// 0x0158 (0x0190 - 0x0038)
class USHMariaFlashlightReactionAnimSubcomp final : public USHAnimSubcomponentBase
{
public:
	struct FSHMariaFlashlightReactionAnimSubcompSettings Settings;                                          // 0x0038(0x0118)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         EyesCoverAlpha;                                    // 0x0150(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_154[0x3C];                                     // 0x0154(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlockAndInterruptFlashlightReactions(const class UObject* Object);
	void BlockFlashlightReactions(const bool Blocked, const class UObject* Object);

	float GetEyesCoverAlpha() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMariaFlashlightReactionAnimSubcomp">();
	}
	static class USHMariaFlashlightReactionAnimSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMariaFlashlightReactionAnimSubcomp>();
	}
};
static_assert(alignof(USHMariaFlashlightReactionAnimSubcomp) == 0x000008, "Wrong alignment on USHMariaFlashlightReactionAnimSubcomp");
static_assert(sizeof(USHMariaFlashlightReactionAnimSubcomp) == 0x000190, "Wrong size on USHMariaFlashlightReactionAnimSubcomp");
static_assert(offsetof(USHMariaFlashlightReactionAnimSubcomp, Settings) == 0x000038, "Member 'USHMariaFlashlightReactionAnimSubcomp::Settings' has a wrong offset!");
static_assert(offsetof(USHMariaFlashlightReactionAnimSubcomp, EyesCoverAlpha) == 0x000150, "Member 'USHMariaFlashlightReactionAnimSubcomp::EyesCoverAlpha' has a wrong offset!");

// Class SHProto.SHMariaInterface
// 0x0000 (0x0028 - 0x0028)
class ISHMariaInterface final : public IInterface
{
public:
	void ChangeBlockingAiming(bool bShouldAimAt);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMariaInterface">();
	}
	static class ISHMariaInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHMariaInterface>();
	}
};
static_assert(alignof(ISHMariaInterface) == 0x000008, "Wrong alignment on ISHMariaInterface");
static_assert(sizeof(ISHMariaInterface) == 0x000028, "Wrong size on ISHMariaInterface");

// Class SHProto.SHMariaLightsComponent
// 0x0018 (0x00B8 - 0x00A0)
class USHMariaLightsComponent final : public UActorComponent
{
public:
	TSubclassOf<class ASHMariaLightingActor>      LightingActorClass;                                // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMariaLightsComponent">();
	}
	static class USHMariaLightsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMariaLightsComponent>();
	}
};
static_assert(alignof(USHMariaLightsComponent) == 0x000008, "Wrong alignment on USHMariaLightsComponent");
static_assert(sizeof(USHMariaLightsComponent) == 0x0000B8, "Wrong size on USHMariaLightsComponent");
static_assert(offsetof(USHMariaLightsComponent, LightingActorClass) == 0x0000A0, "Member 'USHMariaLightsComponent::LightingActorClass' has a wrong offset!");

// Class SHProto.SHMariaLocomotionAnimInstance
// 0x0000 (0x03D0 - 0x03D0)
class USHMariaLocomotionAnimInstance final : public USHFriendLocomotionAnimInstance
{
public:
	float GetFlashlightCoverEyesAnimBlendWeigth() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMariaLocomotionAnimInstance">();
	}
	static class USHMariaLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMariaLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHMariaLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHMariaLocomotionAnimInstance");
static_assert(sizeof(USHMariaLocomotionAnimInstance) == 0x0003D0, "Wrong size on USHMariaLocomotionAnimInstance");

// Class SHProto.SHMariaLookAtAnimInstance
// 0x0000 (0x0360 - 0x0360)
class USHMariaLookAtAnimInstance final : public USHAimOffsetAnimInstance
{
public:
	float GetFlashlightCoverEyesAnimBlendWeigth() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMariaLookAtAnimInstance">();
	}
	static class USHMariaLookAtAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMariaLookAtAnimInstance>();
	}
};
static_assert(alignof(USHMariaLookAtAnimInstance) == 0x000010, "Wrong alignment on USHMariaLookAtAnimInstance");
static_assert(sizeof(USHMariaLookAtAnimInstance) == 0x000360, "Wrong size on USHMariaLookAtAnimInstance");

// Class SHProto.SHMariaLookAtLogicComponent
// 0x0010 (0x0190 - 0x0180)
class USHMariaLookAtLogicComponent final : public USHCharacterLookAtLogicComponent
{
public:
	uint8                                         Pad_180[0x10];                                     // 0x0180(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMariaLookAtLogicComponent">();
	}
	static class USHMariaLookAtLogicComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMariaLookAtLogicComponent>();
	}
};
static_assert(alignof(USHMariaLookAtLogicComponent) == 0x000008, "Wrong alignment on USHMariaLookAtLogicComponent");
static_assert(sizeof(USHMariaLookAtLogicComponent) == 0x000190, "Wrong size on USHMariaLookAtLogicComponent");

// Class SHProto.SHMariaReceivedDamageEndingValueProcessor
// 0x0000 (0x0030 - 0x0030)
class USHMariaReceivedDamageEndingValueProcessor final : public USHEndingValueProcessor
{
public:
	void ProcessMariaHealthChanged(class UMaiHealth* HealthComponent, int32 PreviousHealthValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMariaReceivedDamageEndingValueProcessor">();
	}
	static class USHMariaReceivedDamageEndingValueProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMariaReceivedDamageEndingValueProcessor>();
	}
};
static_assert(alignof(USHMariaReceivedDamageEndingValueProcessor) == 0x000008, "Wrong alignment on USHMariaReceivedDamageEndingValueProcessor");
static_assert(sizeof(USHMariaReceivedDamageEndingValueProcessor) == 0x000030, "Wrong size on USHMariaReceivedDamageEndingValueProcessor");

// Class SHProto.SHMariaVerbalReactionsComponent
// 0x0068 (0x0108 - 0x00A0)
class USHMariaVerbalReactionsComponent final : public UActorComponent
{
public:
	float                                         MaxAllowedCoreDistance2D;                          // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASHAICharacter*                         OwnerAICharacter;                                  // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCompleted;                                      // 0x00B0(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x57];                                      // 0x00B1(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FString> GenerateCustomValuesDebug();
	TArray<struct FDialogTalkID> GetDialogsToPreload();
	void HandleMariaInDangerModeChanged(class USHMariaCombatComponent* CombatComponent);
	void HandlePlayerMeleePrimaryAttackStarted(class USHMeleeCmbSubcomp* MeleeCombatSubcomponent, class ASHItemWeapon* ItemWeaponContext);
	void HandlePlayerMeleeSecondaryAttackStarted(class USHMeleeCmbSubcomp* MeleeCombatSubcomponent, class ASHItemWeapon* ItemWeaponContext);
	void HandlePlayerRangedFireSuccess(class USHRangedCmbSubcomp* RangedCombatSubcomponent, class ASHItemWeapon* ItemWeaponContext);
	void MarkAsCompleted();
	void ProcessPlayerMeleePrimaryAttackStarted(class USHMeleeCmbSubcomp* MeleeCombatSubcomponent, class ASHItemWeapon* ItemWeaponContext);
	void ProcessPlayerMeleeSecondaryAttackStarted(class USHMeleeCmbSubcomp* MeleeCombatSubcomponent, class ASHItemWeapon* ItemWeaponContext);
	void ProcessPlayerRangedAimPointingActorChanged(class USHRangedCmbSubcomp* RangedCombatSubcomponent);
	void ProcessPlayerRangedFireSuccess(class USHRangedCmbSubcomp* RangedCombatSubcomponent, class ASHItemWeapon* ItemWeaponContext);
	void SetDangerModeChangedCommentBlocked(const bool Blocked, const class UObject* Object);
	void SetGeneralBlocked(const bool Blocked, const class UObject* Object);

	bool AreAllConditionsMeet() const;
	bool AreCustomConditionsMeet() const;
	bool IsBehaviourStateConditionsMeet() const;
	bool IsCompleted() const;
	bool IsCoreDistance2DConditionsMeet() const;
	bool IsCutsceneStateConditionsMeet() const;
	bool IsDangerModeChangedCommentBlocked() const;
	bool IsGeneralBlocked() const;
	bool IsPlayerCombatStateConditionsMeet() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMariaVerbalReactionsComponent">();
	}
	static class USHMariaVerbalReactionsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMariaVerbalReactionsComponent>();
	}
};
static_assert(alignof(USHMariaVerbalReactionsComponent) == 0x000008, "Wrong alignment on USHMariaVerbalReactionsComponent");
static_assert(sizeof(USHMariaVerbalReactionsComponent) == 0x000108, "Wrong size on USHMariaVerbalReactionsComponent");
static_assert(offsetof(USHMariaVerbalReactionsComponent, MaxAllowedCoreDistance2D) == 0x0000A0, "Member 'USHMariaVerbalReactionsComponent::MaxAllowedCoreDistance2D' has a wrong offset!");
static_assert(offsetof(USHMariaVerbalReactionsComponent, OwnerAICharacter) == 0x0000A8, "Member 'USHMariaVerbalReactionsComponent::OwnerAICharacter' has a wrong offset!");
static_assert(offsetof(USHMariaVerbalReactionsComponent, bIsCompleted) == 0x0000B0, "Member 'USHMariaVerbalReactionsComponent::bIsCompleted' has a wrong offset!");

// Class SHProto.SHMaryAnimInstance
// 0x0080 (0x0460 - 0x03E0)
class USHMaryAnimInstance final : public USHMonsterAnimInstance
{
public:
	struct FRotator                               LookRotation;                                      // 0x03E0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         LookRotationAlpha;                                 // 0x03F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESHMaryAnimInstanceMovementState              MovementState;                                     // 0x03FC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESHMariaBossFaceExpression                    CurrentFaceExpression;                             // 0x03FD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3FE[0x2];                                      // 0x03FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESHMariaBossFaceExpression, struct FVector> FaceExpressionMap;                                 // 0x0400(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_450[0x10];                                     // 0x0450(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnMaryMovementStateChanged(ESHMaryAnimInstanceMovementState InMovementState);
	void ResetFaceExpression();
	void SetFaceExpression(const ESHMariaBossFaceExpression Expression, const float Duration);

	class USHMaryLocomotionAnimInstance* GetActiveMaryLocomotionAnimInstance() const;
	class USHMaryAnimInstanceStateData* GetMaryAnimInstanceStateData() const;
	class USHMaryLocomotionAnimInstance* GetMaryLocomotionAnimInstance(int32 SlotIndex) const;
	class USHMarySpiderLocomotionAnimInstance* GetMarySpiderLocomotionAnimInstance(int32 SlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMaryAnimInstance">();
	}
	static class USHMaryAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMaryAnimInstance>();
	}
};
static_assert(alignof(USHMaryAnimInstance) == 0x000010, "Wrong alignment on USHMaryAnimInstance");
static_assert(sizeof(USHMaryAnimInstance) == 0x000460, "Wrong size on USHMaryAnimInstance");
static_assert(offsetof(USHMaryAnimInstance, LookRotation) == 0x0003E0, "Member 'USHMaryAnimInstance::LookRotation' has a wrong offset!");
static_assert(offsetof(USHMaryAnimInstance, LookRotationAlpha) == 0x0003F8, "Member 'USHMaryAnimInstance::LookRotationAlpha' has a wrong offset!");
static_assert(offsetof(USHMaryAnimInstance, MovementState) == 0x0003FC, "Member 'USHMaryAnimInstance::MovementState' has a wrong offset!");
static_assert(offsetof(USHMaryAnimInstance, CurrentFaceExpression) == 0x0003FD, "Member 'USHMaryAnimInstance::CurrentFaceExpression' has a wrong offset!");
static_assert(offsetof(USHMaryAnimInstance, FaceExpressionMap) == 0x000400, "Member 'USHMaryAnimInstance::FaceExpressionMap' has a wrong offset!");

// Class SHProto.SHMaryAnimInstanceStateData
// 0x0008 (0x0080 - 0x0078)
class USHMaryAnimInstanceStateData final : public USHMonsterAnimInstanceStateData
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMaryAnimInstanceStateData">();
	}
	static class USHMaryAnimInstanceStateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMaryAnimInstanceStateData>();
	}
};
static_assert(alignof(USHMaryAnimInstanceStateData) == 0x000008, "Wrong alignment on USHMaryAnimInstanceStateData");
static_assert(sizeof(USHMaryAnimInstanceStateData) == 0x000080, "Wrong size on USHMaryAnimInstanceStateData");

// Class SHProto.SHMaryItemsInvestigationEndingFactor
// 0x0000 (0x0088 - 0x0088)
class USHMaryItemsInvestigationEndingFactor final : public USHIntEndingFactor
{
public:
	void SHDebug_Character_Endings_MaryItemsInvestigationEndingFactor_SetDebugValue(int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMaryItemsInvestigationEndingFactor">();
	}
	static class USHMaryItemsInvestigationEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMaryItemsInvestigationEndingFactor>();
	}
};
static_assert(alignof(USHMaryItemsInvestigationEndingFactor) == 0x000008, "Wrong alignment on USHMaryItemsInvestigationEndingFactor");
static_assert(sizeof(USHMaryItemsInvestigationEndingFactor) == 0x000088, "Wrong size on USHMaryItemsInvestigationEndingFactor");

// Class SHProto.SHMarySpiderLocomotionAnimInstance
// 0x0000 (0x03C0 - 0x03C0)
class USHMarySpiderLocomotionAnimInstance final : public USHMaryLocomotionAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMarySpiderLocomotionAnimInstance">();
	}
	static class USHMarySpiderLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMarySpiderLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHMarySpiderLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHMarySpiderLocomotionAnimInstance");
static_assert(sizeof(USHMarySpiderLocomotionAnimInstance) == 0x0003C0, "Wrong size on USHMarySpiderLocomotionAnimInstance");

// Class SHProto.SHMaryTransformationState
// 0x0048 (0x0118 - 0x00D0)
class USHMaryTransformationState final : public USHEnemyTransformationState
{
public:
	ESHMaryTransformationState                    MaryTransformationState;                           // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMaintainRotation;                                 // 0x00D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GrabPointSearchOffset;                             // 0x00D8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseOverrides;                                     // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHMaryTransformationStateCurves       TransformationCurveOverrides;                      // 0x00F4(0x0024)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	const struct FVector GetGrabPointSearchOffset() const;
	ESHMaryTransformationState GetMaryTransformationState() const;
	bool GetShouldRotationBeMaintained() const;
	void GetTransformationOverrides(bool* OutShouldBeUsed, struct FSHMaryTransformationStateCurves* OutCurves) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMaryTransformationState">();
	}
	static class USHMaryTransformationState* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMaryTransformationState>();
	}
};
static_assert(alignof(USHMaryTransformationState) == 0x000008, "Wrong alignment on USHMaryTransformationState");
static_assert(sizeof(USHMaryTransformationState) == 0x000118, "Wrong size on USHMaryTransformationState");
static_assert(offsetof(USHMaryTransformationState, MaryTransformationState) == 0x0000D0, "Member 'USHMaryTransformationState::MaryTransformationState' has a wrong offset!");
static_assert(offsetof(USHMaryTransformationState, bMaintainRotation) == 0x0000D1, "Member 'USHMaryTransformationState::bMaintainRotation' has a wrong offset!");
static_assert(offsetof(USHMaryTransformationState, GrabPointSearchOffset) == 0x0000D8, "Member 'USHMaryTransformationState::GrabPointSearchOffset' has a wrong offset!");
static_assert(offsetof(USHMaryTransformationState, bUseOverrides) == 0x0000F0, "Member 'USHMaryTransformationState::bUseOverrides' has a wrong offset!");
static_assert(offsetof(USHMaryTransformationState, TransformationCurveOverrides) == 0x0000F4, "Member 'USHMaryTransformationState::TransformationCurveOverrides' has a wrong offset!");

// Class SHProto.SHMaterialPropertyControlSettings
// 0x0010 (0x0040 - 0x0030)
class USHMaterialPropertyControlSettings final : public UDataAsset
{
public:
	TArray<struct FSHMaterialPropertyControlData> MaterialPropertyControlConfigs;                    // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMaterialPropertyControlSettings">();
	}
	static class USHMaterialPropertyControlSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMaterialPropertyControlSettings>();
	}
};
static_assert(alignof(USHMaterialPropertyControlSettings) == 0x000008, "Wrong alignment on USHMaterialPropertyControlSettings");
static_assert(sizeof(USHMaterialPropertyControlSettings) == 0x000040, "Wrong size on USHMaterialPropertyControlSettings");
static_assert(offsetof(USHMaterialPropertyControlSettings, MaterialPropertyControlConfigs) == 0x000030, "Member 'USHMaterialPropertyControlSettings::MaterialPropertyControlConfigs' has a wrong offset!");

// Class SHProto.SHMeatConveyorBase
// 0x0078 (0x0328 - 0x02B0)
class ASHMeatConveyorBase final : public AActor
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   RailStaticMeshComponent;                           // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ASHHookedMeatBase*>              ManagedMeats;                                      // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ConveyorMovementCurve;                             // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeBetweenMovements;                              // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPushableDistance;                               // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorkingAreaRadius;                                 // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorkingAreaHeightOffset;                           // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinPushableChunkAmount;                            // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             MovementRoutineStartedEvent;                       // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             MovementRoutineFinishedEvent;                      // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             MotionChangedEvent;                                // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindToBossDispatch(class AActor* Target);
	void FinishMovementRoutine(const bool bInstant);
	void SHMeatConveyorBaseBoolContextEvent__DelegateSignature(class ASHMeatConveyorBase* Conveyor, bool Value);
	void SHMeatConveyorBaseEvent__DelegateSignature(class ASHMeatConveyorBase* Conveyor);
	void StartMovementRoutine();
	void UnbindFromBossDispatch(class AActor* Target);

	bool IsCharacterInWorkArea(class ACharacter* InCharacter, bool AllowCapsuleTouch) const;
	bool IsInMotion() const;
	bool IsMovementRoutineRequested() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMeatConveyorBase">();
	}
	static class ASHMeatConveyorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHMeatConveyorBase>();
	}
};
static_assert(alignof(ASHMeatConveyorBase) == 0x000008, "Wrong alignment on ASHMeatConveyorBase");
static_assert(sizeof(ASHMeatConveyorBase) == 0x000328, "Wrong size on ASHMeatConveyorBase");
static_assert(offsetof(ASHMeatConveyorBase, SplineComponent) == 0x0002B0, "Member 'ASHMeatConveyorBase::SplineComponent' has a wrong offset!");
static_assert(offsetof(ASHMeatConveyorBase, RailStaticMeshComponent) == 0x0002B8, "Member 'ASHMeatConveyorBase::RailStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ASHMeatConveyorBase, ManagedMeats) == 0x0002C0, "Member 'ASHMeatConveyorBase::ManagedMeats' has a wrong offset!");
static_assert(offsetof(ASHMeatConveyorBase, ConveyorMovementCurve) == 0x0002D0, "Member 'ASHMeatConveyorBase::ConveyorMovementCurve' has a wrong offset!");
static_assert(offsetof(ASHMeatConveyorBase, TimeBetweenMovements) == 0x0002D8, "Member 'ASHMeatConveyorBase::TimeBetweenMovements' has a wrong offset!");
static_assert(offsetof(ASHMeatConveyorBase, MaxPushableDistance) == 0x0002DC, "Member 'ASHMeatConveyorBase::MaxPushableDistance' has a wrong offset!");
static_assert(offsetof(ASHMeatConveyorBase, WorkingAreaRadius) == 0x0002E0, "Member 'ASHMeatConveyorBase::WorkingAreaRadius' has a wrong offset!");
static_assert(offsetof(ASHMeatConveyorBase, WorkingAreaHeightOffset) == 0x0002E4, "Member 'ASHMeatConveyorBase::WorkingAreaHeightOffset' has a wrong offset!");
static_assert(offsetof(ASHMeatConveyorBase, MinPushableChunkAmount) == 0x0002E8, "Member 'ASHMeatConveyorBase::MinPushableChunkAmount' has a wrong offset!");
static_assert(offsetof(ASHMeatConveyorBase, MovementRoutineStartedEvent) == 0x0002F0, "Member 'ASHMeatConveyorBase::MovementRoutineStartedEvent' has a wrong offset!");
static_assert(offsetof(ASHMeatConveyorBase, MovementRoutineFinishedEvent) == 0x000300, "Member 'ASHMeatConveyorBase::MovementRoutineFinishedEvent' has a wrong offset!");
static_assert(offsetof(ASHMeatConveyorBase, MotionChangedEvent) == 0x000310, "Member 'ASHMeatConveyorBase::MotionChangedEvent' has a wrong offset!");

// Class SHProto.SHMeleeCmbSubcomp
// 0x00A0 (0x00D8 - 0x0038)
class USHMeleeCmbSubcomp final : public USHCombatSubcomponentBase
{
public:
	FMulticastInlineDelegateProperty_             OnPrimaryAttackStarted;                            // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSecondaryAttackStarted;                          // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<TScriptInterface<class ISHMeleeAttackSecondaryTargetInterface>> RegisteredSecondaryTargets;                        // 0x0058(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x70];                                      // 0x0068(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMeleeAttackBlendingOut(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void OnMeleeAttackEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void ProcessEquippedWeaponModifiedEvent(class USHWeaponManageCmbSubcomp* WeaponManager);
	void SHMeleeCombatWeaponContextEvent__DelegateSignature(class USHMeleeCmbSubcomp* MeleeCombatSubcomponent, class ASHItemWeapon* ItemWeaponContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMeleeCmbSubcomp">();
	}
	static class USHMeleeCmbSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMeleeCmbSubcomp>();
	}
};
static_assert(alignof(USHMeleeCmbSubcomp) == 0x000008, "Wrong alignment on USHMeleeCmbSubcomp");
static_assert(sizeof(USHMeleeCmbSubcomp) == 0x0000D8, "Wrong size on USHMeleeCmbSubcomp");
static_assert(offsetof(USHMeleeCmbSubcomp, OnPrimaryAttackStarted) == 0x000038, "Member 'USHMeleeCmbSubcomp::OnPrimaryAttackStarted' has a wrong offset!");
static_assert(offsetof(USHMeleeCmbSubcomp, OnSecondaryAttackStarted) == 0x000048, "Member 'USHMeleeCmbSubcomp::OnSecondaryAttackStarted' has a wrong offset!");
static_assert(offsetof(USHMeleeCmbSubcomp, RegisteredSecondaryTargets) == 0x000058, "Member 'USHMeleeCmbSubcomp::RegisteredSecondaryTargets' has a wrong offset!");

// Class SHProto.SHMenuTutorialWidget
// 0x0180 (0x0420 - 0x02A0)
class USHMenuTutorialWidget final : public UBUserWidget
{
public:
	TArray<struct FKey>                           BackKeys;                                          // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMenuTutorialsConfig>    TutorialsData;                                     // 0x02B0(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UUE4KeyTexts>            KeyTexts;                                          // 0x02E0(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 KeyTagText;                                        // 0x0310(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SeparatorText;                                     // 0x0320(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHUserButton*                          Healing_but;                                       // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHUserButton*                          HealingAmount_but;                                 // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHUserButton*                          Traversal_but;                                     // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHUserButton*                          Window_but;                                        // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHUserButton*                          Melee_but;                                         // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHUserButton*                          RangedWeapons_but;                                 // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHUserButton*                          Radio_but;                                         // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHUserButton*                          Map_but;                                           // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         Healing_rtx;                                       // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         HealingAmount_rtx;                                 // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         Traversal_rtx;                                     // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         Window_rtx;                                        // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         Melee_rtx;                                         // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         RangedWeapons_rtx;                                 // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         Radio_rtx;                                         // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         Map_rtx;                                           // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             K2_OnBack;                                         // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C0[0x60];                                     // 0x03C0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Back();
	void BP_OnBack();
	void Hide();
	void OnHide();
	void OnShow();
	void Show();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMenuTutorialWidget">();
	}
	static class USHMenuTutorialWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMenuTutorialWidget>();
	}
};
static_assert(alignof(USHMenuTutorialWidget) == 0x000008, "Wrong alignment on USHMenuTutorialWidget");
static_assert(sizeof(USHMenuTutorialWidget) == 0x000420, "Wrong size on USHMenuTutorialWidget");
static_assert(offsetof(USHMenuTutorialWidget, BackKeys) == 0x0002A0, "Member 'USHMenuTutorialWidget::BackKeys' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, TutorialsData) == 0x0002B0, "Member 'USHMenuTutorialWidget::TutorialsData' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, KeyTexts) == 0x0002E0, "Member 'USHMenuTutorialWidget::KeyTexts' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, KeyTagText) == 0x000310, "Member 'USHMenuTutorialWidget::KeyTagText' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, SeparatorText) == 0x000320, "Member 'USHMenuTutorialWidget::SeparatorText' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, Healing_but) == 0x000330, "Member 'USHMenuTutorialWidget::Healing_but' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, HealingAmount_but) == 0x000338, "Member 'USHMenuTutorialWidget::HealingAmount_but' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, Traversal_but) == 0x000340, "Member 'USHMenuTutorialWidget::Traversal_but' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, Window_but) == 0x000348, "Member 'USHMenuTutorialWidget::Window_but' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, Melee_but) == 0x000350, "Member 'USHMenuTutorialWidget::Melee_but' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, RangedWeapons_but) == 0x000358, "Member 'USHMenuTutorialWidget::RangedWeapons_but' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, Radio_but) == 0x000360, "Member 'USHMenuTutorialWidget::Radio_but' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, Map_but) == 0x000368, "Member 'USHMenuTutorialWidget::Map_but' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, Healing_rtx) == 0x000370, "Member 'USHMenuTutorialWidget::Healing_rtx' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, HealingAmount_rtx) == 0x000378, "Member 'USHMenuTutorialWidget::HealingAmount_rtx' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, Traversal_rtx) == 0x000380, "Member 'USHMenuTutorialWidget::Traversal_rtx' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, Window_rtx) == 0x000388, "Member 'USHMenuTutorialWidget::Window_rtx' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, Melee_rtx) == 0x000390, "Member 'USHMenuTutorialWidget::Melee_rtx' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, RangedWeapons_rtx) == 0x000398, "Member 'USHMenuTutorialWidget::RangedWeapons_rtx' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, Radio_rtx) == 0x0003A0, "Member 'USHMenuTutorialWidget::Radio_rtx' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, Map_rtx) == 0x0003A8, "Member 'USHMenuTutorialWidget::Map_rtx' has a wrong offset!");
static_assert(offsetof(USHMenuTutorialWidget, K2_OnBack) == 0x0003B0, "Member 'USHMenuTutorialWidget::K2_OnBack' has a wrong offset!");

// Class SHProto.MenuTutorialsConfig
// 0x0050 (0x0080 - 0x0030)
class UMenuTutorialsConfig final : public UDataAsset
{
public:
	TMap<ESHMenuTutorialEnum, struct FMenuTutorial> Tutorials;                                         // 0x0030(0x0050)(Edit, EditFixedSize, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuTutorialsConfig">();
	}
	static class UMenuTutorialsConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuTutorialsConfig>();
	}
};
static_assert(alignof(UMenuTutorialsConfig) == 0x000008, "Wrong alignment on UMenuTutorialsConfig");
static_assert(sizeof(UMenuTutorialsConfig) == 0x000080, "Wrong size on UMenuTutorialsConfig");
static_assert(offsetof(UMenuTutorialsConfig, Tutorials) == 0x000030, "Member 'UMenuTutorialsConfig::Tutorials' has a wrong offset!");

// Class SHProto.SHMiniInventoryWidget
// 0x0178 (0x03F0 - 0x0278)
class USHMiniInventoryWidget final : public UUserWidget
{
public:
	bool                                          bAllowLoopItems;                                   // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InputThrottleAcceleration;                         // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   NoItemsAtAllDisplayText;                           // 0x0280(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture*                               DebugTexture;                                      // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           InvBackground;                                     // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           PreviewsContainerCanvas;                           // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ItemNameWidget;                                    // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewCenterItem;                                 // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewUpItem_01;                                  // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewUpItem_02;                                  // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewUpItem_03;                                  // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewUpItem_04;                                  // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewDownItem_01;                                // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewDownItem_02;                                // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewDownItem_03;                                // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PreviewDownItem_04;                                // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       MoveItemUpAnim;                                    // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       MoveItemDownAnim;                                  // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       FadeInAnim;                                        // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       FadeOutAnim;                                       // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       WrongItemAnim;                                     // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_OpenMiniInventory;                      // 0x0328(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_CloseMiniInventory;                     // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_MoveItem;                               // 0x0338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_UseCorrectItem;                         // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent_UseIncorrectItem;                       // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASHCharacterPlay*                       OwnerCharacter;                                    // 0x0350(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayFocusWidget*                 OwnerWidget;                                       // 0x0358(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       CurrentPlayingAnimation;                           // 0x0360(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UWidget*>                        DynamicItemWidgets;                                // 0x0368(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<ESHItemTypeEnum>                       RequestedItemTypes;                                // 0x0378(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x68];                                     // 0x0388(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimFinished();
	void OnItemMoveNameAndDescriptionUpdate();
	void OnItemMoveZOrderUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMiniInventoryWidget">();
	}
	static class USHMiniInventoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMiniInventoryWidget>();
	}
};
static_assert(alignof(USHMiniInventoryWidget) == 0x000008, "Wrong alignment on USHMiniInventoryWidget");
static_assert(sizeof(USHMiniInventoryWidget) == 0x0003F0, "Wrong size on USHMiniInventoryWidget");
static_assert(offsetof(USHMiniInventoryWidget, bAllowLoopItems) == 0x000278, "Member 'USHMiniInventoryWidget::bAllowLoopItems' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, InputThrottleAcceleration) == 0x00027C, "Member 'USHMiniInventoryWidget::InputThrottleAcceleration' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, NoItemsAtAllDisplayText) == 0x000280, "Member 'USHMiniInventoryWidget::NoItemsAtAllDisplayText' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, DebugTexture) == 0x000298, "Member 'USHMiniInventoryWidget::DebugTexture' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, InvBackground) == 0x0002A0, "Member 'USHMiniInventoryWidget::InvBackground' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, PreviewsContainerCanvas) == 0x0002A8, "Member 'USHMiniInventoryWidget::PreviewsContainerCanvas' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, ItemNameWidget) == 0x0002B0, "Member 'USHMiniInventoryWidget::ItemNameWidget' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, PreviewCenterItem) == 0x0002B8, "Member 'USHMiniInventoryWidget::PreviewCenterItem' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, PreviewUpItem_01) == 0x0002C0, "Member 'USHMiniInventoryWidget::PreviewUpItem_01' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, PreviewUpItem_02) == 0x0002C8, "Member 'USHMiniInventoryWidget::PreviewUpItem_02' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, PreviewUpItem_03) == 0x0002D0, "Member 'USHMiniInventoryWidget::PreviewUpItem_03' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, PreviewUpItem_04) == 0x0002D8, "Member 'USHMiniInventoryWidget::PreviewUpItem_04' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, PreviewDownItem_01) == 0x0002E0, "Member 'USHMiniInventoryWidget::PreviewDownItem_01' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, PreviewDownItem_02) == 0x0002E8, "Member 'USHMiniInventoryWidget::PreviewDownItem_02' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, PreviewDownItem_03) == 0x0002F0, "Member 'USHMiniInventoryWidget::PreviewDownItem_03' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, PreviewDownItem_04) == 0x0002F8, "Member 'USHMiniInventoryWidget::PreviewDownItem_04' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, MoveItemUpAnim) == 0x000300, "Member 'USHMiniInventoryWidget::MoveItemUpAnim' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, MoveItemDownAnim) == 0x000308, "Member 'USHMiniInventoryWidget::MoveItemDownAnim' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, FadeInAnim) == 0x000310, "Member 'USHMiniInventoryWidget::FadeInAnim' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, FadeOutAnim) == 0x000318, "Member 'USHMiniInventoryWidget::FadeOutAnim' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, WrongItemAnim) == 0x000320, "Member 'USHMiniInventoryWidget::WrongItemAnim' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, AudioEvent_OpenMiniInventory) == 0x000328, "Member 'USHMiniInventoryWidget::AudioEvent_OpenMiniInventory' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, AudioEvent_CloseMiniInventory) == 0x000330, "Member 'USHMiniInventoryWidget::AudioEvent_CloseMiniInventory' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, AudioEvent_MoveItem) == 0x000338, "Member 'USHMiniInventoryWidget::AudioEvent_MoveItem' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, AudioEvent_UseCorrectItem) == 0x000340, "Member 'USHMiniInventoryWidget::AudioEvent_UseCorrectItem' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, AudioEvent_UseIncorrectItem) == 0x000348, "Member 'USHMiniInventoryWidget::AudioEvent_UseIncorrectItem' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, OwnerCharacter) == 0x000350, "Member 'USHMiniInventoryWidget::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, OwnerWidget) == 0x000358, "Member 'USHMiniInventoryWidget::OwnerWidget' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, CurrentPlayingAnimation) == 0x000360, "Member 'USHMiniInventoryWidget::CurrentPlayingAnimation' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, DynamicItemWidgets) == 0x000368, "Member 'USHMiniInventoryWidget::DynamicItemWidgets' has a wrong offset!");
static_assert(offsetof(USHMiniInventoryWidget, RequestedItemTypes) == 0x000378, "Member 'USHMiniInventoryWidget::RequestedItemTypes' has a wrong offset!");

// Class SHProto.SHCharacterPlayMovementSettings
// 0x00A0 (0x00D0 - 0x0030)
class USHCharacterPlayMovementSettings final : public UDataAsset
{
public:
	TMap<ESHMovementProfile, struct FSHMovementDataStruct> MovementProfiles;                                  // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ESHMovementSprintCameraFOVProfile, struct FSHCameraFOVBlendData> FOVProfiles;                                       // 0x0080(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHCharacterPlayMovementSettings">();
	}
	static class USHCharacterPlayMovementSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHCharacterPlayMovementSettings>();
	}
};
static_assert(alignof(USHCharacterPlayMovementSettings) == 0x000008, "Wrong alignment on USHCharacterPlayMovementSettings");
static_assert(sizeof(USHCharacterPlayMovementSettings) == 0x0000D0, "Wrong size on USHCharacterPlayMovementSettings");
static_assert(offsetof(USHCharacterPlayMovementSettings, MovementProfiles) == 0x000030, "Member 'USHCharacterPlayMovementSettings::MovementProfiles' has a wrong offset!");
static_assert(offsetof(USHCharacterPlayMovementSettings, FOVProfiles) == 0x000080, "Member 'USHCharacterPlayMovementSettings::FOVProfiles' has a wrong offset!");

// Class SHProto.SHMovementObstacleDetection
// 0x0040 (0x0068 - 0x0028)
class USHMovementObstacleDetection final : public UObject
{
public:
	float                                         StopMovementThreshold;                             // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockSprintThreshold;                              // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USHCharacterPlayMovementComponent*      MovementComponent;                                 // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      Capsule;                                           // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacter*                             OwnerCharacter;                                    // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Initialized;                                       // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x1F];                                      // 0x0049(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Character_MovementObstacleDetection_DrawDebug();
	void SHDebug_Character_MovementObstacleDetection_Enabled(bool Enable);
	void SHDebug_Character_MovementObstacleDetection_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMovementObstacleDetection">();
	}
	static class USHMovementObstacleDetection* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMovementObstacleDetection>();
	}
};
static_assert(alignof(USHMovementObstacleDetection) == 0x000008, "Wrong alignment on USHMovementObstacleDetection");
static_assert(sizeof(USHMovementObstacleDetection) == 0x000068, "Wrong size on USHMovementObstacleDetection");
static_assert(offsetof(USHMovementObstacleDetection, StopMovementThreshold) == 0x000028, "Member 'USHMovementObstacleDetection::StopMovementThreshold' has a wrong offset!");
static_assert(offsetof(USHMovementObstacleDetection, BlockSprintThreshold) == 0x00002C, "Member 'USHMovementObstacleDetection::BlockSprintThreshold' has a wrong offset!");
static_assert(offsetof(USHMovementObstacleDetection, MovementComponent) == 0x000030, "Member 'USHMovementObstacleDetection::MovementComponent' has a wrong offset!");
static_assert(offsetof(USHMovementObstacleDetection, Capsule) == 0x000038, "Member 'USHMovementObstacleDetection::Capsule' has a wrong offset!");
static_assert(offsetof(USHMovementObstacleDetection, OwnerCharacter) == 0x000040, "Member 'USHMovementObstacleDetection::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(USHMovementObstacleDetection, Initialized) == 0x000048, "Member 'USHMovementObstacleDetection::Initialized' has a wrong offset!");

// Class SHProto.SHMovingWheelStaticMeshComponent
// 0x0020 (0x0620 - 0x0600)
class USHMovingWheelStaticMeshComponent final : public UStaticMeshComponent
{
public:
	float                                         InterpSpeedMultiplier;                             // 0x05F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          InverseRotationDirection;                          // 0x05FC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FD[0x23];                                     // 0x05FD(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessPushingFinishedOrInterupted(class USHPushableComponent* InComponent);
	void ProcessPushingStarted(class USHPushableComponent* InComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMovingWheelStaticMeshComponent">();
	}
	static class USHMovingWheelStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMovingWheelStaticMeshComponent>();
	}
};
static_assert(alignof(USHMovingWheelStaticMeshComponent) == 0x000010, "Wrong alignment on USHMovingWheelStaticMeshComponent");
static_assert(sizeof(USHMovingWheelStaticMeshComponent) == 0x000620, "Wrong size on USHMovingWheelStaticMeshComponent");
static_assert(offsetof(USHMovingWheelStaticMeshComponent, InterpSpeedMultiplier) == 0x0005F8, "Member 'USHMovingWheelStaticMeshComponent::InterpSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(USHMovingWheelStaticMeshComponent, InverseRotationDirection) == 0x0005FC, "Member 'USHMovingWheelStaticMeshComponent::InverseRotationDirection' has a wrong offset!");

// Class SHProto.SHMQSpiderAnimInstanceStateData
// 0x0000 (0x0078 - 0x0078)
class USHMQSpiderAnimInstanceStateData final : public USHMonsterAnimInstanceStateData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMQSpiderAnimInstanceStateData">();
	}
	static class USHMQSpiderAnimInstanceStateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMQSpiderAnimInstanceStateData>();
	}
};
static_assert(alignof(USHMQSpiderAnimInstanceStateData) == 0x000008, "Wrong alignment on USHMQSpiderAnimInstanceStateData");
static_assert(sizeof(USHMQSpiderAnimInstanceStateData) == 0x000078, "Wrong size on USHMQSpiderAnimInstanceStateData");

// Class SHProto.SHMQSpiderLocomotionAnimInstance
// 0x0010 (0x03C0 - 0x03B0)
class USHMQSpiderLocomotionAnimInstance final : public USHMonsterLocomotionAnimInstance
{
public:
	ESHMQSpiderAnimInstanceLocomotionState        LocomotionStateRequest;                            // 0x03A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Speed;                                             // 0x03AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeAngle;                                       // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallStrideScale;                                   // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceAngle;                                  // 0x03B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMQSpiderLocomotionAnimInstance">();
	}
	static class USHMQSpiderLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHMQSpiderLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHMQSpiderLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHMQSpiderLocomotionAnimInstance");
static_assert(sizeof(USHMQSpiderLocomotionAnimInstance) == 0x0003C0, "Wrong size on USHMQSpiderLocomotionAnimInstance");
static_assert(offsetof(USHMQSpiderLocomotionAnimInstance, LocomotionStateRequest) == 0x0003A8, "Member 'USHMQSpiderLocomotionAnimInstance::LocomotionStateRequest' has a wrong offset!");
static_assert(offsetof(USHMQSpiderLocomotionAnimInstance, Speed) == 0x0003AC, "Member 'USHMQSpiderLocomotionAnimInstance::Speed' has a wrong offset!");
static_assert(offsetof(USHMQSpiderLocomotionAnimInstance, StrafeAngle) == 0x0003B0, "Member 'USHMQSpiderLocomotionAnimInstance::StrafeAngle' has a wrong offset!");
static_assert(offsetof(USHMQSpiderLocomotionAnimInstance, WallStrideScale) == 0x0003B4, "Member 'USHMQSpiderLocomotionAnimInstance::WallStrideScale' has a wrong offset!");
static_assert(offsetof(USHMQSpiderLocomotionAnimInstance, TurnInPlaceAngle) == 0x0003B8, "Member 'USHMQSpiderLocomotionAnimInstance::TurnInPlaceAngle' has a wrong offset!");

// Class SHProto.SHMusicRTPCVolume
// 0x0070 (0x0358 - 0x02E8)
class ASHMusicRTPCVolume final : public AVolume
{
public:
	TMap<TSoftObjectPtr<class UAkRtpc>, float>    RTPCParams;                                        // 0x02E8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsEnabledOnBegin;                                 // 0x0338(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_339[0x1F];                                     // 0x0339(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnabled(const class UObject* Enabler, bool InEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHMusicRTPCVolume">();
	}
	static class ASHMusicRTPCVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHMusicRTPCVolume>();
	}
};
static_assert(alignof(ASHMusicRTPCVolume) == 0x000008, "Wrong alignment on ASHMusicRTPCVolume");
static_assert(sizeof(ASHMusicRTPCVolume) == 0x000358, "Wrong size on ASHMusicRTPCVolume");
static_assert(offsetof(ASHMusicRTPCVolume, RTPCParams) == 0x0002E8, "Member 'ASHMusicRTPCVolume::RTPCParams' has a wrong offset!");
static_assert(offsetof(ASHMusicRTPCVolume, bIsEnabledOnBegin) == 0x000338, "Member 'ASHMusicRTPCVolume::bIsEnabledOnBegin' has a wrong offset!");

// Class SHProto.SHNewGamePlusControllerActor
// 0x0008 (0x02C0 - 0x02B8)
class ASHNewGamePlusControllerActor final : public ASHActorsManagementBaseControllerActor
{
public:
	ESHNewGamePlusControllerBehaviourType         BehaviourType;                                     // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHNewGamePlusControllerActor">();
	}
	static class ASHNewGamePlusControllerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHNewGamePlusControllerActor>();
	}
};
static_assert(alignof(ASHNewGamePlusControllerActor) == 0x000008, "Wrong alignment on ASHNewGamePlusControllerActor");
static_assert(sizeof(ASHNewGamePlusControllerActor) == 0x0002C0, "Wrong size on ASHNewGamePlusControllerActor");
static_assert(offsetof(ASHNewGamePlusControllerActor, BehaviourType) == 0x0002B8, "Member 'ASHNewGamePlusControllerActor::BehaviourType' has a wrong offset!");

// Class SHProto.SHNGInfoDialog
// 0x0000 (0x0398 - 0x0398)
class USHNGInfoDialog final : public UAskDialogWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHNGInfoDialog">();
	}
	static class USHNGInfoDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHNGInfoDialog>();
	}
};
static_assert(alignof(USHNGInfoDialog) == 0x000008, "Wrong alignment on USHNGInfoDialog");
static_assert(sizeof(USHNGInfoDialog) == 0x000398, "Wrong size on USHNGInfoDialog");

// Class SHProto.SHNiagaraVolumeCutoutComponent
// 0x0040 (0x02E0 - 0x02A0)
class USHNiagaraVolumeCutoutComponent final : public USceneComponent
{
public:
	struct FVector                                BoxExtent;                                         // 0x02A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 ShapeColor;                                        // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x24];                                     // 0x02BC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCutOutDisabled(const bool IsDisable, const class UObject* Object);

	bool IsCutOutDisabled() const;
	bool IsCutOutDisabledBy(const class UObject* Object) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHNiagaraVolumeCutoutComponent">();
	}
	static class USHNiagaraVolumeCutoutComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHNiagaraVolumeCutoutComponent>();
	}
};
static_assert(alignof(USHNiagaraVolumeCutoutComponent) == 0x000010, "Wrong alignment on USHNiagaraVolumeCutoutComponent");
static_assert(sizeof(USHNiagaraVolumeCutoutComponent) == 0x0002E0, "Wrong size on USHNiagaraVolumeCutoutComponent");
static_assert(offsetof(USHNiagaraVolumeCutoutComponent, BoxExtent) == 0x0002A0, "Member 'USHNiagaraVolumeCutoutComponent::BoxExtent' has a wrong offset!");
static_assert(offsetof(USHNiagaraVolumeCutoutComponent, ShapeColor) == 0x0002B8, "Member 'USHNiagaraVolumeCutoutComponent::ShapeColor' has a wrong offset!");

// Class SHProto.SHNurseAnimInstance
// 0x0030 (0x0410 - 0x03E0)
class USHNurseAnimInstance final : public USHMonsterAnimInstance
{
public:
	float                                         HeadShakeAlpha;                                    // 0x03E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeadShakeSnapshotPoseAlpha;                        // 0x03E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               LookRotation;                                      // 0x03E8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         LookRotationAlpha;                                 // 0x0400(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThighRotationForSkirt;                             // 0x0404(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0x8];                                      // 0x0408(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USHNurseAnimInstanceStateData* GetNurseAnimInstanceStateData() const;
	class USHNurseLocomotionAnimInstance* GetNurseLocomotionAnimInstance(int32 SlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHNurseAnimInstance">();
	}
	static class USHNurseAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHNurseAnimInstance>();
	}
};
static_assert(alignof(USHNurseAnimInstance) == 0x000010, "Wrong alignment on USHNurseAnimInstance");
static_assert(sizeof(USHNurseAnimInstance) == 0x000410, "Wrong size on USHNurseAnimInstance");
static_assert(offsetof(USHNurseAnimInstance, HeadShakeAlpha) == 0x0003E0, "Member 'USHNurseAnimInstance::HeadShakeAlpha' has a wrong offset!");
static_assert(offsetof(USHNurseAnimInstance, HeadShakeSnapshotPoseAlpha) == 0x0003E4, "Member 'USHNurseAnimInstance::HeadShakeSnapshotPoseAlpha' has a wrong offset!");
static_assert(offsetof(USHNurseAnimInstance, LookRotation) == 0x0003E8, "Member 'USHNurseAnimInstance::LookRotation' has a wrong offset!");
static_assert(offsetof(USHNurseAnimInstance, LookRotationAlpha) == 0x000400, "Member 'USHNurseAnimInstance::LookRotationAlpha' has a wrong offset!");
static_assert(offsetof(USHNurseAnimInstance, ThighRotationForSkirt) == 0x000404, "Member 'USHNurseAnimInstance::ThighRotationForSkirt' has a wrong offset!");

// Class SHProto.SHNurseAnimInstanceStateData
// 0x0000 (0x0078 - 0x0078)
class USHNurseAnimInstanceStateData final : public USHMonsterAnimInstanceStateData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHNurseAnimInstanceStateData">();
	}
	static class USHNurseAnimInstanceStateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHNurseAnimInstanceStateData>();
	}
};
static_assert(alignof(USHNurseAnimInstanceStateData) == 0x000008, "Wrong alignment on USHNurseAnimInstanceStateData");
static_assert(sizeof(USHNurseAnimInstanceStateData) == 0x000078, "Wrong size on USHNurseAnimInstanceStateData");

// Class SHProto.NurseHoldOntoDamage
// 0x0000 (0x0068 - 0x0068)
class UNurseHoldOntoDamage final : public UMeleeDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NurseHoldOntoDamage">();
	}
	static class UNurseHoldOntoDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNurseHoldOntoDamage>();
	}
};
static_assert(alignof(UNurseHoldOntoDamage) == 0x000008, "Wrong alignment on UNurseHoldOntoDamage");
static_assert(sizeof(UNurseHoldOntoDamage) == 0x000068, "Wrong size on UNurseHoldOntoDamage");

// Class SHProto.NurseScoldDamage
// 0x0000 (0x0068 - 0x0068)
class UNurseScoldDamage final : public UMeleeDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NurseScoldDamage">();
	}
	static class UNurseScoldDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNurseScoldDamage>();
	}
};
static_assert(alignof(UNurseScoldDamage) == 0x000008, "Wrong alignment on UNurseScoldDamage");
static_assert(sizeof(UNurseScoldDamage) == 0x000068, "Wrong size on UNurseScoldDamage");

// Class SHProto.NursePenetrateDamage
// 0x0000 (0x0068 - 0x0068)
class UNursePenetrateDamage final : public UMeleeDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NursePenetrateDamage">();
	}
	static class UNursePenetrateDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNursePenetrateDamage>();
	}
};
static_assert(alignof(UNursePenetrateDamage) == 0x000008, "Wrong alignment on UNursePenetrateDamage");
static_assert(sizeof(UNursePenetrateDamage) == 0x000068, "Wrong size on UNursePenetrateDamage");

// Class SHProto.NurseCutDamage
// 0x0000 (0x0068 - 0x0068)
class UNurseCutDamage final : public UMeleeDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NurseCutDamage">();
	}
	static class UNurseCutDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNurseCutDamage>();
	}
};
static_assert(alignof(UNurseCutDamage) == 0x000008, "Wrong alignment on UNurseCutDamage");
static_assert(sizeof(UNurseCutDamage) == 0x000068, "Wrong size on UNurseCutDamage");

// Class SHProto.SHNurseLocomotionAnimInstance
// 0x0020 (0x03D0 - 0x03B0)
class USHNurseLocomotionAnimInstance final : public USHMonsterLocomotionAnimInstance
{
public:
	ESHNurseAnimInstanceLocomotionState           LocomotionStateRequest;                            // 0x03A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveChangeLegOnGround;                             // 0x03AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveChangeStrafeAngle;                             // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredSpeed;                                      // 0x03B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeAngle;                                       // 0x03B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredStrafeAngle;                                // 0x03BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceAngle;                                  // 0x03C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C4[0xC];                                      // 0x03C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USHNurseAnimInstanceStateData* GetNurseAnimInstanceStateData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHNurseLocomotionAnimInstance">();
	}
	static class USHNurseLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHNurseLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHNurseLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHNurseLocomotionAnimInstance");
static_assert(sizeof(USHNurseLocomotionAnimInstance) == 0x0003D0, "Wrong size on USHNurseLocomotionAnimInstance");
static_assert(offsetof(USHNurseLocomotionAnimInstance, LocomotionStateRequest) == 0x0003A8, "Member 'USHNurseLocomotionAnimInstance::LocomotionStateRequest' has a wrong offset!");
static_assert(offsetof(USHNurseLocomotionAnimInstance, MoveChangeLegOnGround) == 0x0003AC, "Member 'USHNurseLocomotionAnimInstance::MoveChangeLegOnGround' has a wrong offset!");
static_assert(offsetof(USHNurseLocomotionAnimInstance, MoveChangeStrafeAngle) == 0x0003B0, "Member 'USHNurseLocomotionAnimInstance::MoveChangeStrafeAngle' has a wrong offset!");
static_assert(offsetof(USHNurseLocomotionAnimInstance, DesiredSpeed) == 0x0003B4, "Member 'USHNurseLocomotionAnimInstance::DesiredSpeed' has a wrong offset!");
static_assert(offsetof(USHNurseLocomotionAnimInstance, StrafeAngle) == 0x0003B8, "Member 'USHNurseLocomotionAnimInstance::StrafeAngle' has a wrong offset!");
static_assert(offsetof(USHNurseLocomotionAnimInstance, DesiredStrafeAngle) == 0x0003BC, "Member 'USHNurseLocomotionAnimInstance::DesiredStrafeAngle' has a wrong offset!");
static_assert(offsetof(USHNurseLocomotionAnimInstance, TurnInPlaceAngle) == 0x0003C0, "Member 'USHNurseLocomotionAnimInstance::TurnInPlaceAngle' has a wrong offset!");

// Class SHProto.SHNurseWalkingProfileDA
// 0x0050 (0x0080 - 0x0030)
class USHNurseWalkingProfileDA final : public UDataAsset
{
public:
	TMap<ENurseWalkingProfile, struct FNurseWalkingProfileData> Profiles;                                          // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHNurseWalkingProfileDA">();
	}
	static class USHNurseWalkingProfileDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHNurseWalkingProfileDA>();
	}
};
static_assert(alignof(USHNurseWalkingProfileDA) == 0x000008, "Wrong alignment on USHNurseWalkingProfileDA");
static_assert(sizeof(USHNurseWalkingProfileDA) == 0x000080, "Wrong size on USHNurseWalkingProfileDA");
static_assert(offsetof(USHNurseWalkingProfileDA, Profiles) == 0x000030, "Member 'USHNurseWalkingProfileDA::Profiles' has a wrong offset!");

// Class SHProto.SHOperationEvents
// 0x0020 (0x0048 - 0x0028)
class USHOperationEvents final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnFinished;                                        // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHOperationEvents">();
	}
	static class USHOperationEvents* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHOperationEvents>();
	}
};
static_assert(alignof(USHOperationEvents) == 0x000008, "Wrong alignment on USHOperationEvents");
static_assert(sizeof(USHOperationEvents) == 0x000048, "Wrong size on USHOperationEvents");
static_assert(offsetof(USHOperationEvents, OnFinished) == 0x000028, "Member 'USHOperationEvents::OnFinished' has a wrong offset!");

// Class SHProto.SHPawn
// 0x0000 (0x0338 - 0x0338)
class ASHPawn final : public APawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPawn">();
	}
	static class ASHPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHPawn>();
	}
};
static_assert(alignof(ASHPawn) == 0x000008, "Wrong alignment on ASHPawn");
static_assert(sizeof(ASHPawn) == 0x000338, "Wrong size on ASHPawn");

// Class SHProto.SHPHAnimInstance
// 0x0000 (0x03E0 - 0x03E0)
class USHPHAnimInstance final : public USHMonsterAnimInstance
{
public:
	void SetLookAtEnable(bool NewLookAtEnable);
	void SetMovementSpeedMultiplier(float NewSpeed, float Time, float BlendInTime, float BlendOutTime);

	class USHPHAnimInstanceStateData* GetPHAnimInstanceStateData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPHAnimInstance">();
	}
	static class USHPHAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPHAnimInstance>();
	}
};
static_assert(alignof(USHPHAnimInstance) == 0x000010, "Wrong alignment on USHPHAnimInstance");
static_assert(sizeof(USHPHAnimInstance) == 0x0003E0, "Wrong size on USHPHAnimInstance");

// Class SHProto.SHPHAnimInstanceStateData
// 0x0008 (0x0080 - 0x0078)
class USHPHAnimInstanceStateData final : public USHMonsterAnimInstanceStateData
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPHAnimInstanceStateData">();
	}
	static class USHPHAnimInstanceStateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPHAnimInstanceStateData>();
	}
};
static_assert(alignof(USHPHAnimInstanceStateData) == 0x000008, "Wrong alignment on USHPHAnimInstanceStateData");
static_assert(sizeof(USHPHAnimInstanceStateData) == 0x000080, "Wrong size on USHPHAnimInstanceStateData");

// Class SHProto.SHPHLocomotionAnimInstance
// 0x0040 (0x03F0 - 0x03B0)
class USHPHLocomotionAnimInstance final : public USHMonsterLocomotionAnimInstance
{
public:
	ESHPHAnimInstanceLocomotionState              LocomotionStateRequest;                            // 0x03A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DesiredSpeed;                                      // 0x03AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredStrafeAngle;                                // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTurnInPlace;                                   // 0x03B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B5[0x3];                                      // 0x03B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementSpeedMultiplierTarget;                     // 0x03B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementSpeedMultiplierCurrent;                    // 0x03BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementSpeedMultiplierTime;                       // 0x03C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementSpeedMultiplierTimer;                      // 0x03C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementSpeedMultiplierBlendInSpeed;               // 0x03C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementSpeedMultiplierBlendOutSpeed;              // 0x03CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveChangeLegOnGround;                             // 0x03D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveChangeStrafeAngle;                             // 0x03D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceAngle;                                  // 0x03D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtAngleYaw;                                    // 0x03DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAtTarget;                                     // 0x03E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E1[0xF];                                      // 0x03E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetLookAtAngle(const struct FVector& LookAtTargetLocation);
	void SetLookAtEnable(bool NewLookAtEnable);
	void SetMovementSpeedMultiplier(float NewMovementSpeed, float Time, float BlendInTime, float BlendOutTime);

	class USHPHAnimInstanceStateData* GetPHAnimInstanceStateData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPHLocomotionAnimInstance">();
	}
	static class USHPHLocomotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPHLocomotionAnimInstance>();
	}
};
static_assert(alignof(USHPHLocomotionAnimInstance) == 0x000010, "Wrong alignment on USHPHLocomotionAnimInstance");
static_assert(sizeof(USHPHLocomotionAnimInstance) == 0x0003F0, "Wrong size on USHPHLocomotionAnimInstance");
static_assert(offsetof(USHPHLocomotionAnimInstance, LocomotionStateRequest) == 0x0003A8, "Member 'USHPHLocomotionAnimInstance::LocomotionStateRequest' has a wrong offset!");
static_assert(offsetof(USHPHLocomotionAnimInstance, DesiredSpeed) == 0x0003AC, "Member 'USHPHLocomotionAnimInstance::DesiredSpeed' has a wrong offset!");
static_assert(offsetof(USHPHLocomotionAnimInstance, DesiredStrafeAngle) == 0x0003B0, "Member 'USHPHLocomotionAnimInstance::DesiredStrafeAngle' has a wrong offset!");
static_assert(offsetof(USHPHLocomotionAnimInstance, bUseTurnInPlace) == 0x0003B4, "Member 'USHPHLocomotionAnimInstance::bUseTurnInPlace' has a wrong offset!");
static_assert(offsetof(USHPHLocomotionAnimInstance, MovementSpeedMultiplierTarget) == 0x0003B8, "Member 'USHPHLocomotionAnimInstance::MovementSpeedMultiplierTarget' has a wrong offset!");
static_assert(offsetof(USHPHLocomotionAnimInstance, MovementSpeedMultiplierCurrent) == 0x0003BC, "Member 'USHPHLocomotionAnimInstance::MovementSpeedMultiplierCurrent' has a wrong offset!");
static_assert(offsetof(USHPHLocomotionAnimInstance, MovementSpeedMultiplierTime) == 0x0003C0, "Member 'USHPHLocomotionAnimInstance::MovementSpeedMultiplierTime' has a wrong offset!");
static_assert(offsetof(USHPHLocomotionAnimInstance, MovementSpeedMultiplierTimer) == 0x0003C4, "Member 'USHPHLocomotionAnimInstance::MovementSpeedMultiplierTimer' has a wrong offset!");
static_assert(offsetof(USHPHLocomotionAnimInstance, MovementSpeedMultiplierBlendInSpeed) == 0x0003C8, "Member 'USHPHLocomotionAnimInstance::MovementSpeedMultiplierBlendInSpeed' has a wrong offset!");
static_assert(offsetof(USHPHLocomotionAnimInstance, MovementSpeedMultiplierBlendOutSpeed) == 0x0003CC, "Member 'USHPHLocomotionAnimInstance::MovementSpeedMultiplierBlendOutSpeed' has a wrong offset!");
static_assert(offsetof(USHPHLocomotionAnimInstance, MoveChangeLegOnGround) == 0x0003D0, "Member 'USHPHLocomotionAnimInstance::MoveChangeLegOnGround' has a wrong offset!");
static_assert(offsetof(USHPHLocomotionAnimInstance, MoveChangeStrafeAngle) == 0x0003D4, "Member 'USHPHLocomotionAnimInstance::MoveChangeStrafeAngle' has a wrong offset!");
static_assert(offsetof(USHPHLocomotionAnimInstance, TurnInPlaceAngle) == 0x0003D8, "Member 'USHPHLocomotionAnimInstance::TurnInPlaceAngle' has a wrong offset!");
static_assert(offsetof(USHPHLocomotionAnimInstance, LookAtAngleYaw) == 0x0003DC, "Member 'USHPHLocomotionAnimInstance::LookAtAngleYaw' has a wrong offset!");
static_assert(offsetof(USHPHLocomotionAnimInstance, bLookAtTarget) == 0x0003E0, "Member 'USHPHLocomotionAnimInstance::bLookAtTarget' has a wrong offset!");

// Class SHProto.SHPlayerCameraManagerPlay
// 0x0030 (0x3450 - 0x3420)
class ASHPlayerCameraManagerPlay final : public ASHPlayerCameraManager
{
public:
	ECollisionChannel                             ProbeChannel;                                      // 0x3420(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3421[0x3];                                     // 0x3421(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProbeSize;                                         // 0x3424(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3428[0x28];                                    // 0x3428(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPlayerCameraManagerPlay">();
	}
	static class ASHPlayerCameraManagerPlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHPlayerCameraManagerPlay>();
	}
};
static_assert(alignof(ASHPlayerCameraManagerPlay) == 0x000010, "Wrong alignment on ASHPlayerCameraManagerPlay");
static_assert(sizeof(ASHPlayerCameraManagerPlay) == 0x003450, "Wrong size on ASHPlayerCameraManagerPlay");
static_assert(offsetof(ASHPlayerCameraManagerPlay, ProbeChannel) == 0x003420, "Member 'ASHPlayerCameraManagerPlay::ProbeChannel' has a wrong offset!");
static_assert(offsetof(ASHPlayerCameraManagerPlay, ProbeSize) == 0x003424, "Member 'ASHPlayerCameraManagerPlay::ProbeSize' has a wrong offset!");

// Class SHProto.SHPlayerHealingExcessEndingValueProcessor
// 0x0000 (0x0030 - 0x0030)
class USHPlayerHealingExcessEndingValueProcessor final : public USHEndingValueProcessor
{
public:
	void ProcessHealthValueChangedDetailed(class USHCharacterPlayHealthComponent* HealthComponent, float ChangeDelta, float OldValue, float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPlayerHealingExcessEndingValueProcessor">();
	}
	static class USHPlayerHealingExcessEndingValueProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPlayerHealingExcessEndingValueProcessor>();
	}
};
static_assert(alignof(USHPlayerHealingExcessEndingValueProcessor) == 0x000008, "Wrong alignment on USHPlayerHealingExcessEndingValueProcessor");
static_assert(sizeof(USHPlayerHealingExcessEndingValueProcessor) == 0x000030, "Wrong size on USHPlayerHealingExcessEndingValueProcessor");

// Class SHProto.SHPlayerHealthValueEndingValueProcessor
// 0x0000 (0x0030 - 0x0030)
class USHPlayerHealthValueEndingValueProcessor final : public USHEndingValueProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPlayerHealthValueEndingValueProcessor">();
	}
	static class USHPlayerHealthValueEndingValueProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPlayerHealthValueEndingValueProcessor>();
	}
};
static_assert(alignof(USHPlayerHealthValueEndingValueProcessor) == 0x000008, "Wrong alignment on USHPlayerHealthValueEndingValueProcessor");
static_assert(sizeof(USHPlayerHealthValueEndingValueProcessor) == 0x000030, "Wrong size on USHPlayerHealthValueEndingValueProcessor");

// Class SHProto.SHPlayerProfile
// 0x0050 (0x01B0 - 0x0160)
class USHPlayerProfile final : public UPlayerProfile
{
public:
	EReticleVisibility                            ReticleVisibility;                                 // 0x0160(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReticleThickness                             ReticleThickness;                                  // 0x0161(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_162[0x2];                                      // 0x0162(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReticleOpacity;                                    // 0x0164(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReticleColor                                 ReticleColor;                                      // 0x0168(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionIconVisibility                    InteractionIconVisibility;                         // 0x0169(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionIconSize                          InteractionIconSize;                               // 0x016A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionIconVisibility                    TraversalIconVisibility;                           // 0x016B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionIconSize                          TraversalIconSize;                                 // 0x016C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStruggleInputVisibility                      StruggleInputVisibility;                           // 0x016D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStruggleInputSize                            StruggleInputSize;                                 // 0x016E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowGameplayCenterDotReticle;                      // 0x016F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowRadioStateIndicator;                           // 0x0170(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAmmoWidgetVisibility                         AmmoWidgetVisibility;                              // 0x0171(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DirectionalVisualisation;                          // 0x0172(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextFont                                     TranscriptionTextFont;                             // 0x0173(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextSize                                     TranscriptionTextSize;                             // 0x0174(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TutorialsVisibility;                               // 0x0175(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextFont                                     TutorialsTextFont;                                 // 0x0176(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextSize                                     TutorialsTextSize;                                 // 0x0177(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowLoadingHints;                                  // 0x0178(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x3];                                      // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimSensitivityY;                                   // 0x017C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimSensitivityX;                                   // 0x0180(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AimInvertY;                                        // 0x0184(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AimMirrorX;                                        // 0x0185(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_186[0x2];                                      // 0x0186(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookSensitivityY;                                  // 0x0188(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookSensitivityX;                                  // 0x018C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LookInvertY;                                       // 0x0190(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LookMirrorX;                                       // 0x0191(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAimAssistMagnetismMode                       AimAssistMagnetismMode;                            // 0x0192(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdaptiveTriggersConstantMode;                     // 0x0193(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStruggleHoldMode;                                 // 0x0194(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLowHealthVignette;                                // 0x0195(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSplatterVignette;                           // 0x0196(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableItemsNotifications;                         // 0x0197(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHInputTriggerMode                           RangeAimTriggerMode;                               // 0x0198(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHInputTriggerMode                           MeleeAttackTriggerMode;                            // 0x0199(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHInputTriggerMode                           FireTriggerMode;                                   // 0x019A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHInputTriggerMode                           BoatLeftTriggerMode;                               // 0x019B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESHInputTriggerMode                           BoatRightTriggerMode;                              // 0x019C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableInventoryVisualEffects;                      // 0x019D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HighContrastMode;                                  // 0x019E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHighContrastColor                            HighContrastAlliesColor;                           // 0x019F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHighContrastColor                            HighContrastCollectibleItemsColor;                 // 0x01A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHighContrastColor                            HighContrastEnemiesColor;                          // 0x01A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHighContrastColor                            HighContrastEnvironmentColor;                      // 0x01A2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHighContrastColor                            HighContrastJamesColor;                            // 0x01A3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HighContrastGrayscaleBackground;                   // 0x01A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVisualMode                                   VisualMode;                                        // 0x01A5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerSkin                                   PlayerSkin;                                        // 0x01A6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SprintToggleable;                                  // 0x01A7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESettingsPresets                              Presets;                                           // 0x01A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECombatDifficulty                             CombatDifficulty;                                  // 0x01A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AA[0x6];                                      // 0x01AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPlayerProfile">();
	}
	static class USHPlayerProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPlayerProfile>();
	}
};
static_assert(alignof(USHPlayerProfile) == 0x000008, "Wrong alignment on USHPlayerProfile");
static_assert(sizeof(USHPlayerProfile) == 0x0001B0, "Wrong size on USHPlayerProfile");
static_assert(offsetof(USHPlayerProfile, ReticleVisibility) == 0x000160, "Member 'USHPlayerProfile::ReticleVisibility' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, ReticleThickness) == 0x000161, "Member 'USHPlayerProfile::ReticleThickness' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, ReticleOpacity) == 0x000164, "Member 'USHPlayerProfile::ReticleOpacity' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, ReticleColor) == 0x000168, "Member 'USHPlayerProfile::ReticleColor' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, InteractionIconVisibility) == 0x000169, "Member 'USHPlayerProfile::InteractionIconVisibility' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, InteractionIconSize) == 0x00016A, "Member 'USHPlayerProfile::InteractionIconSize' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, TraversalIconVisibility) == 0x00016B, "Member 'USHPlayerProfile::TraversalIconVisibility' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, TraversalIconSize) == 0x00016C, "Member 'USHPlayerProfile::TraversalIconSize' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, StruggleInputVisibility) == 0x00016D, "Member 'USHPlayerProfile::StruggleInputVisibility' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, StruggleInputSize) == 0x00016E, "Member 'USHPlayerProfile::StruggleInputSize' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, ShowGameplayCenterDotReticle) == 0x00016F, "Member 'USHPlayerProfile::ShowGameplayCenterDotReticle' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, ShowRadioStateIndicator) == 0x000170, "Member 'USHPlayerProfile::ShowRadioStateIndicator' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, AmmoWidgetVisibility) == 0x000171, "Member 'USHPlayerProfile::AmmoWidgetVisibility' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, DirectionalVisualisation) == 0x000172, "Member 'USHPlayerProfile::DirectionalVisualisation' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, TranscriptionTextFont) == 0x000173, "Member 'USHPlayerProfile::TranscriptionTextFont' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, TranscriptionTextSize) == 0x000174, "Member 'USHPlayerProfile::TranscriptionTextSize' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, TutorialsVisibility) == 0x000175, "Member 'USHPlayerProfile::TutorialsVisibility' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, TutorialsTextFont) == 0x000176, "Member 'USHPlayerProfile::TutorialsTextFont' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, TutorialsTextSize) == 0x000177, "Member 'USHPlayerProfile::TutorialsTextSize' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, ShowLoadingHints) == 0x000178, "Member 'USHPlayerProfile::ShowLoadingHints' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, AimSensitivityY) == 0x00017C, "Member 'USHPlayerProfile::AimSensitivityY' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, AimSensitivityX) == 0x000180, "Member 'USHPlayerProfile::AimSensitivityX' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, AimInvertY) == 0x000184, "Member 'USHPlayerProfile::AimInvertY' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, AimMirrorX) == 0x000185, "Member 'USHPlayerProfile::AimMirrorX' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, LookSensitivityY) == 0x000188, "Member 'USHPlayerProfile::LookSensitivityY' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, LookSensitivityX) == 0x00018C, "Member 'USHPlayerProfile::LookSensitivityX' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, LookInvertY) == 0x000190, "Member 'USHPlayerProfile::LookInvertY' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, LookMirrorX) == 0x000191, "Member 'USHPlayerProfile::LookMirrorX' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, AimAssistMagnetismMode) == 0x000192, "Member 'USHPlayerProfile::AimAssistMagnetismMode' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, bAdaptiveTriggersConstantMode) == 0x000193, "Member 'USHPlayerProfile::bAdaptiveTriggersConstantMode' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, bStruggleHoldMode) == 0x000194, "Member 'USHPlayerProfile::bStruggleHoldMode' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, bLowHealthVignette) == 0x000195, "Member 'USHPlayerProfile::bLowHealthVignette' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, bEnableSplatterVignette) == 0x000196, "Member 'USHPlayerProfile::bEnableSplatterVignette' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, bEnableItemsNotifications) == 0x000197, "Member 'USHPlayerProfile::bEnableItemsNotifications' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, RangeAimTriggerMode) == 0x000198, "Member 'USHPlayerProfile::RangeAimTriggerMode' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, MeleeAttackTriggerMode) == 0x000199, "Member 'USHPlayerProfile::MeleeAttackTriggerMode' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, FireTriggerMode) == 0x00019A, "Member 'USHPlayerProfile::FireTriggerMode' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, BoatLeftTriggerMode) == 0x00019B, "Member 'USHPlayerProfile::BoatLeftTriggerMode' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, BoatRightTriggerMode) == 0x00019C, "Member 'USHPlayerProfile::BoatRightTriggerMode' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, EnableInventoryVisualEffects) == 0x00019D, "Member 'USHPlayerProfile::EnableInventoryVisualEffects' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, HighContrastMode) == 0x00019E, "Member 'USHPlayerProfile::HighContrastMode' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, HighContrastAlliesColor) == 0x00019F, "Member 'USHPlayerProfile::HighContrastAlliesColor' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, HighContrastCollectibleItemsColor) == 0x0001A0, "Member 'USHPlayerProfile::HighContrastCollectibleItemsColor' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, HighContrastEnemiesColor) == 0x0001A1, "Member 'USHPlayerProfile::HighContrastEnemiesColor' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, HighContrastEnvironmentColor) == 0x0001A2, "Member 'USHPlayerProfile::HighContrastEnvironmentColor' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, HighContrastJamesColor) == 0x0001A3, "Member 'USHPlayerProfile::HighContrastJamesColor' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, HighContrastGrayscaleBackground) == 0x0001A4, "Member 'USHPlayerProfile::HighContrastGrayscaleBackground' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, VisualMode) == 0x0001A5, "Member 'USHPlayerProfile::VisualMode' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, PlayerSkin) == 0x0001A6, "Member 'USHPlayerProfile::PlayerSkin' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, SprintToggleable) == 0x0001A7, "Member 'USHPlayerProfile::SprintToggleable' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, Presets) == 0x0001A8, "Member 'USHPlayerProfile::Presets' has a wrong offset!");
static_assert(offsetof(USHPlayerProfile, CombatDifficulty) == 0x0001A9, "Member 'USHPlayerProfile::CombatDifficulty' has a wrong offset!");

// Class SHProto.SHPlaythroughHealingExcessEndingFactor
// 0x0000 (0x0088 - 0x0088)
class USHPlaythroughHealingExcessEndingFactor final : public USHIntEndingFactor
{
public:
	void SHDebug_Character_Endings_PlaythroughHealingExcessEndingFactor_SetDebugValue(int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPlaythroughHealingExcessEndingFactor">();
	}
	static class USHPlaythroughHealingExcessEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPlaythroughHealingExcessEndingFactor>();
	}
};
static_assert(alignof(USHPlaythroughHealingExcessEndingFactor) == 0x000008, "Wrong alignment on USHPlaythroughHealingExcessEndingFactor");
static_assert(sizeof(USHPlaythroughHealingExcessEndingFactor) == 0x000088, "Wrong size on USHPlaythroughHealingExcessEndingFactor");

// Class SHProto.RetroModeDataListAsset
// 0x0010 (0x0040 - 0x0030)
class URetroModeDataListAsset final : public UDataAsset
{
public:
	TArray<TSoftObjectPtr<class URetroModeDataAsset>> RetroModes;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RetroModeDataListAsset">();
	}
	static class URetroModeDataListAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URetroModeDataListAsset>();
	}
};
static_assert(alignof(URetroModeDataListAsset) == 0x000008, "Wrong alignment on URetroModeDataListAsset");
static_assert(sizeof(URetroModeDataListAsset) == 0x000040, "Wrong size on URetroModeDataListAsset");
static_assert(offsetof(URetroModeDataListAsset, RetroModes) == 0x000030, "Member 'URetroModeDataListAsset::RetroModes' has a wrong offset!");

// Class SHProto.SHPostprocessingCtrl
// 0x0100 (0x1780 - 0x1680)
class ASHPostprocessingCtrl : public APostprocessingCtrlActor
{
public:
	class URetroModeDataAsset*                    CurrentRetroMode;                                  // 0x1678(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentRetroModeIndex;                             // 0x1680(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1684[0x4];                                     // 0x1684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     HDRVis;                                            // 0x1688(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     HCMat;                                             // 0x1690(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                RTPC_LeavesIntensity;                              // 0x1698(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEffectHandle                          MoodNeutral;                                       // 0x16A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FEffectHandle                          MoodRoadToSilentHill;                              // 0x16A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FEffectHandle                          MoodCityFW;                                        // 0x16B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FEffectHandle                          MoodCityOW;                                        // 0x16B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FEffectHandle                          MoodInteriorFW;                                    // 0x16C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FEffectHandle                          MoodInteriorOW;                                    // 0x16C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FEffectHandle                          MoodHeavensNight;                                  // 0x16D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FEffectHandle                          MoodCityNight;                                     // 0x16D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E0[0x10];                                    // 0x16E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class URetroModeDataListAsset> RetroModesNew;                                     // 0x16F0(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      HDRVisMaterial;                                    // 0x1720(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      HighContrastModeMaterial;                          // 0x1750(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ApplyHDRPreview(float MinLuminance, float MidLuminance, float MaxLuminance, float Brightness, float UIBrightness, float UIContrast);
	void ShowHDRSettingsPP(bool State);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPostprocessingCtrl">();
	}
	static class ASHPostprocessingCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHPostprocessingCtrl>();
	}
};
static_assert(alignof(ASHPostprocessingCtrl) == 0x000010, "Wrong alignment on ASHPostprocessingCtrl");
static_assert(sizeof(ASHPostprocessingCtrl) == 0x001780, "Wrong size on ASHPostprocessingCtrl");
static_assert(offsetof(ASHPostprocessingCtrl, CurrentRetroMode) == 0x001678, "Member 'ASHPostprocessingCtrl::CurrentRetroMode' has a wrong offset!");
static_assert(offsetof(ASHPostprocessingCtrl, CurrentRetroModeIndex) == 0x001680, "Member 'ASHPostprocessingCtrl::CurrentRetroModeIndex' has a wrong offset!");
static_assert(offsetof(ASHPostprocessingCtrl, HDRVis) == 0x001688, "Member 'ASHPostprocessingCtrl::HDRVis' has a wrong offset!");
static_assert(offsetof(ASHPostprocessingCtrl, HCMat) == 0x001690, "Member 'ASHPostprocessingCtrl::HCMat' has a wrong offset!");
static_assert(offsetof(ASHPostprocessingCtrl, RTPC_LeavesIntensity) == 0x001698, "Member 'ASHPostprocessingCtrl::RTPC_LeavesIntensity' has a wrong offset!");
static_assert(offsetof(ASHPostprocessingCtrl, MoodNeutral) == 0x0016A0, "Member 'ASHPostprocessingCtrl::MoodNeutral' has a wrong offset!");
static_assert(offsetof(ASHPostprocessingCtrl, MoodRoadToSilentHill) == 0x0016A8, "Member 'ASHPostprocessingCtrl::MoodRoadToSilentHill' has a wrong offset!");
static_assert(offsetof(ASHPostprocessingCtrl, MoodCityFW) == 0x0016B0, "Member 'ASHPostprocessingCtrl::MoodCityFW' has a wrong offset!");
static_assert(offsetof(ASHPostprocessingCtrl, MoodCityOW) == 0x0016B8, "Member 'ASHPostprocessingCtrl::MoodCityOW' has a wrong offset!");
static_assert(offsetof(ASHPostprocessingCtrl, MoodInteriorFW) == 0x0016C0, "Member 'ASHPostprocessingCtrl::MoodInteriorFW' has a wrong offset!");
static_assert(offsetof(ASHPostprocessingCtrl, MoodInteriorOW) == 0x0016C8, "Member 'ASHPostprocessingCtrl::MoodInteriorOW' has a wrong offset!");
static_assert(offsetof(ASHPostprocessingCtrl, MoodHeavensNight) == 0x0016D0, "Member 'ASHPostprocessingCtrl::MoodHeavensNight' has a wrong offset!");
static_assert(offsetof(ASHPostprocessingCtrl, MoodCityNight) == 0x0016D8, "Member 'ASHPostprocessingCtrl::MoodCityNight' has a wrong offset!");
static_assert(offsetof(ASHPostprocessingCtrl, RetroModesNew) == 0x0016F0, "Member 'ASHPostprocessingCtrl::RetroModesNew' has a wrong offset!");
static_assert(offsetof(ASHPostprocessingCtrl, HDRVisMaterial) == 0x001720, "Member 'ASHPostprocessingCtrl::HDRVisMaterial' has a wrong offset!");
static_assert(offsetof(ASHPostprocessingCtrl, HighContrastModeMaterial) == 0x001750, "Member 'ASHPostprocessingCtrl::HighContrastModeMaterial' has a wrong offset!");

// Class SHProto.SHPostprocessVolume
// 0x0000 (0x1F30 - 0x1F30)
class ASHPostprocessVolume final : public AAtmosphereCtrlVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPostprocessVolume">();
	}
	static class ASHPostprocessVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHPostprocessVolume>();
	}
};
static_assert(alignof(ASHPostprocessVolume) == 0x000010, "Wrong alignment on ASHPostprocessVolume");
static_assert(sizeof(ASHPostprocessVolume) == 0x001F30, "Wrong size on ASHPostprocessVolume");

// Class SHProto.SHPrisonGallowPuzzleEndingFactor
// 0x0058 (0x0088 - 0x0030)
class USHPrisonGallowPuzzleEndingFactor final : public USHEndingFactor
{
public:
	TMap<ESHPrisonGallowPuzzleEndingFactorValue, struct FSHEndingScoreChanger> ValueToScoreChangeMap;                             // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	ESHPrisonGallowPuzzleEndingFactorValue        Value;                                             // 0x0080(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Character_Endings_Factors_PrisonGallowPuzzle_SetDebugValue(int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPrisonGallowPuzzleEndingFactor">();
	}
	static class USHPrisonGallowPuzzleEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPrisonGallowPuzzleEndingFactor>();
	}
};
static_assert(alignof(USHPrisonGallowPuzzleEndingFactor) == 0x000008, "Wrong alignment on USHPrisonGallowPuzzleEndingFactor");
static_assert(sizeof(USHPrisonGallowPuzzleEndingFactor) == 0x000088, "Wrong size on USHPrisonGallowPuzzleEndingFactor");
static_assert(offsetof(USHPrisonGallowPuzzleEndingFactor, ValueToScoreChangeMap) == 0x000030, "Member 'USHPrisonGallowPuzzleEndingFactor::ValueToScoreChangeMap' has a wrong offset!");
static_assert(offsetof(USHPrisonGallowPuzzleEndingFactor, Value) == 0x000080, "Member 'USHPrisonGallowPuzzleEndingFactor::Value' has a wrong offset!");

// Class SHProto.SHProtoCurveUtils
// 0x0000 (0x0028 - 0x0028)
class USHProtoCurveUtils final : public UBlueprintFunctionLibrary
{
public:
	static void AddCurveValue(class UCurveFloat* Curve, float Value, float Time);
	static void AddVectorCurveValue(class UCurveVector* Curve, const struct FVector& Value, float Time);
	static void ClearCurveValues(class UCurveBase* Curve);
	static float GetMaxTime(class UCurveFloat* Curve);
	static float GetMinTime(class UCurveFloat* Curve);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHProtoCurveUtils">();
	}
	static class USHProtoCurveUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHProtoCurveUtils>();
	}
};
static_assert(alignof(USHProtoCurveUtils) == 0x000008, "Wrong alignment on USHProtoCurveUtils");
static_assert(sizeof(USHProtoCurveUtils) == 0x000028, "Wrong size on USHProtoCurveUtils");

// Class SHProto.SHPukeProjectile
// 0x0050 (0x0358 - 0x0308)
class ASHPukeProjectile final : public ASHProjectile
{
public:
	class USHSystemFXData*                        PukePuddleFXData;                                  // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PukePuddleFXSpawnerClass;                          // 0x0310(0x0030)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DecalOrderId;                                      // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _PuddleSizeModifier;                               // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _PuddleMinSizeActivation;                          // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Damage;                                            // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0350(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPukeProjectile">();
	}
	static class ASHPukeProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHPukeProjectile>();
	}
};
static_assert(alignof(ASHPukeProjectile) == 0x000008, "Wrong alignment on ASHPukeProjectile");
static_assert(sizeof(ASHPukeProjectile) == 0x000358, "Wrong size on ASHPukeProjectile");
static_assert(offsetof(ASHPukeProjectile, PukePuddleFXData) == 0x000308, "Member 'ASHPukeProjectile::PukePuddleFXData' has a wrong offset!");
static_assert(offsetof(ASHPukeProjectile, PukePuddleFXSpawnerClass) == 0x000310, "Member 'ASHPukeProjectile::PukePuddleFXSpawnerClass' has a wrong offset!");
static_assert(offsetof(ASHPukeProjectile, DecalOrderId) == 0x000340, "Member 'ASHPukeProjectile::DecalOrderId' has a wrong offset!");
static_assert(offsetof(ASHPukeProjectile, _PuddleSizeModifier) == 0x000344, "Member 'ASHPukeProjectile::_PuddleSizeModifier' has a wrong offset!");
static_assert(offsetof(ASHPukeProjectile, _PuddleMinSizeActivation) == 0x000348, "Member 'ASHPukeProjectile::_PuddleMinSizeActivation' has a wrong offset!");
static_assert(offsetof(ASHPukeProjectile, Damage) == 0x00034C, "Member 'ASHPukeProjectile::Damage' has a wrong offset!");
static_assert(offsetof(ASHPukeProjectile, DamageType) == 0x000350, "Member 'ASHPukeProjectile::DamageType' has a wrong offset!");

// Class SHProto.SHPukePuddle
// 0x0010 (0x0438 - 0x0428)
class ASHPukePuddle final : public ASHPukePuddleBase
{
public:
	float                                         _SmokeDensity;                                     // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _CloseDistFactor;                                  // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _Damage;                                           // 0x0430(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_434[0x4];                                      // 0x0434(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleApplyDamage(class ACharacter* DamagedCharacter);

	bool IsPuddleDamageActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPukePuddle">();
	}
	static class ASHPukePuddle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHPukePuddle>();
	}
};
static_assert(alignof(ASHPukePuddle) == 0x000008, "Wrong alignment on ASHPukePuddle");
static_assert(sizeof(ASHPukePuddle) == 0x000438, "Wrong size on ASHPukePuddle");
static_assert(offsetof(ASHPukePuddle, _SmokeDensity) == 0x000428, "Member 'ASHPukePuddle::_SmokeDensity' has a wrong offset!");
static_assert(offsetof(ASHPukePuddle, _CloseDistFactor) == 0x00042C, "Member 'ASHPukePuddle::_CloseDistFactor' has a wrong offset!");
static_assert(offsetof(ASHPukePuddle, _Damage) == 0x000430, "Member 'ASHPukePuddle::_Damage' has a wrong offset!");

// Class SHProto.SHPushableAudioComponent
// 0x0020 (0x04D0 - 0x04B0)
class USHPushableAudioComponent final : public USHAkComponent
{
public:
	class UAkAudioEvent*                          GrabSoundEvent;                                    // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ReleaseSoundEvent;                                 // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          StartPushSoundEvent;                               // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          StopPushSoundEvent;                                // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPushableAudioComponent">();
	}
	static class USHPushableAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPushableAudioComponent>();
	}
};
static_assert(alignof(USHPushableAudioComponent) == 0x000010, "Wrong alignment on USHPushableAudioComponent");
static_assert(sizeof(USHPushableAudioComponent) == 0x0004D0, "Wrong size on USHPushableAudioComponent");
static_assert(offsetof(USHPushableAudioComponent, GrabSoundEvent) == 0x0004A8, "Member 'USHPushableAudioComponent::GrabSoundEvent' has a wrong offset!");
static_assert(offsetof(USHPushableAudioComponent, ReleaseSoundEvent) == 0x0004B0, "Member 'USHPushableAudioComponent::ReleaseSoundEvent' has a wrong offset!");
static_assert(offsetof(USHPushableAudioComponent, StartPushSoundEvent) == 0x0004B8, "Member 'USHPushableAudioComponent::StartPushSoundEvent' has a wrong offset!");
static_assert(offsetof(USHPushableAudioComponent, StopPushSoundEvent) == 0x0004C0, "Member 'USHPushableAudioComponent::StopPushSoundEvent' has a wrong offset!");

// Class SHProto.SHPushableComponent
// 0x0260 (0x0300 - 0x00A0)
class alignas(0x10) USHPushableComponent : public UActorComponent
{
public:
	bool                                          bBlockedOnBeginPlay;                               // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableForward;                                   // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableBackward;                                  // 0x00A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableRight;                                     // 0x00A3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableLeft;                                      // 0x00A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   AnimInstanceClass;                                 // 0x00A8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtRotationSnapDuration;                        // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtRotationSnapPitch;                           // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyViewRotationLimits;                          // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ViewRotationLimitPitch;                            // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasStaticYawRotation;                             // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ViewRotationLimitYaw;                              // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PossibleMovementsDebugSize;                        // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FloorDebugMiddleLocal;                             // 0x0118(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FloorDebugExtent;                                  // 0x0130(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bManageOwnerTick;                                  // 0x0148(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSHPushableHandleData>          Handles;                                           // 0x0150(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	struct FVector                                CustomBoundsScale;                                 // 0x0160(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MovementFloorValidationOriginOffset;               // 0x0178(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnPreStartBP;                                      // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnStartedBP;                                       // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnMovementBP;                                      // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnCollisionHitBP;                                  // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnFinishedBP;                                      // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnInteruptedBP;                                    // 0x01E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnComponentBlockedChangedBP;                       // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UMeshComponent*                         OwnerMesh;                                         // 0x0200(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       ProximitySphere;                                   // 0x0208(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       InteractingCharacter;                              // 0x0210(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHPushingObjectAnimInstance*           LinkedAnimGraphInstance;                           // 0x0218(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastFrameWorldLoc;                                 // 0x0220(0x0018)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0xC8];                                     // 0x0238(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize(class USphereComponent* InProximitySphere, class UMeshComponent* InMainMesh);
	void Interact(class ASHCharacterPlay* InInteractingCharacter);
	void ManualFinishRequest();
	void ProcessAnimInstFinishedInteraction(class USHPushingObjectAnimInstance* AnimInst);
	void ProcessAnimInstFiredFinishInteraction(class USHPushingObjectAnimInstance* AnimInst);
	void ProcessAnimInstStartedInteraction(class USHPushingObjectAnimInstance* AnimInst);
	void ProcessAnimInstStartedMovement(class USHPushingObjectAnimInstance* AnimInst);
	void ProcessAnimInstStoppedMovement(class USHPushingObjectAnimInstance* AnimInst);
	void ProcessInteractingCharacterCombatInputModeChanged(class USHCharacterPlayCombatComponent* CombatComp);
	void ProcessInteractingCharacterReceiveDamage(class USHCharacterPlayCombatComponent* CombatComp);
	void ProcessLookAtRotationAbsoluteEnd(bool WasCompleted);
	void ProcessMovementSnapEnd(bool WasCompleted);
	void ProcessProximityBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void ProcessProximityEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex);
	void ProcessSlideSnapEnd(bool WasCompleted);
	void SetComponentBlocked(const bool Blocked, const class UObject* Object);
	void SHPushableComponentEvent__DelegateSignature(class USHPushableComponent* Component);
	void TeleportAbsolute(const struct FVector& InWorldLoc);

	class ASHCharacterPlay* GetInteractingCharacter() const;
	class USHPushingObjectAnimInstance* GetLinkedAnimGraphInstance() const;
	class UMeshComponent* GetOwnerMesh() const;
	bool IsComponentBlocked() const;
	bool IsInInteraction() const;
	bool IsInteractingCharacterStandingOnOwnerMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPushableComponent">();
	}
	static class USHPushableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPushableComponent>();
	}
};
static_assert(alignof(USHPushableComponent) == 0x000010, "Wrong alignment on USHPushableComponent");
static_assert(sizeof(USHPushableComponent) == 0x000300, "Wrong size on USHPushableComponent");
static_assert(offsetof(USHPushableComponent, bBlockedOnBeginPlay) == 0x0000A0, "Member 'USHPushableComponent::bBlockedOnBeginPlay' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, bDisableForward) == 0x0000A1, "Member 'USHPushableComponent::bDisableForward' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, bDisableBackward) == 0x0000A2, "Member 'USHPushableComponent::bDisableBackward' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, bDisableRight) == 0x0000A3, "Member 'USHPushableComponent::bDisableRight' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, bDisableLeft) == 0x0000A4, "Member 'USHPushableComponent::bDisableLeft' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, AnimInstanceClass) == 0x0000A8, "Member 'USHPushableComponent::AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, LookAtRotationSnapDuration) == 0x0000D8, "Member 'USHPushableComponent::LookAtRotationSnapDuration' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, LookAtRotationSnapPitch) == 0x0000DC, "Member 'USHPushableComponent::LookAtRotationSnapPitch' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, bApplyViewRotationLimits) == 0x0000E0, "Member 'USHPushableComponent::bApplyViewRotationLimits' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, ViewRotationLimitPitch) == 0x0000E8, "Member 'USHPushableComponent::ViewRotationLimitPitch' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, bHasStaticYawRotation) == 0x0000F8, "Member 'USHPushableComponent::bHasStaticYawRotation' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, ViewRotationLimitYaw) == 0x000100, "Member 'USHPushableComponent::ViewRotationLimitYaw' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, PossibleMovementsDebugSize) == 0x000110, "Member 'USHPushableComponent::PossibleMovementsDebugSize' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, FloorDebugMiddleLocal) == 0x000118, "Member 'USHPushableComponent::FloorDebugMiddleLocal' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, FloorDebugExtent) == 0x000130, "Member 'USHPushableComponent::FloorDebugExtent' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, bManageOwnerTick) == 0x000148, "Member 'USHPushableComponent::bManageOwnerTick' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, Handles) == 0x000150, "Member 'USHPushableComponent::Handles' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, CustomBoundsScale) == 0x000160, "Member 'USHPushableComponent::CustomBoundsScale' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, MovementFloorValidationOriginOffset) == 0x000178, "Member 'USHPushableComponent::MovementFloorValidationOriginOffset' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, OnPreStartBP) == 0x000190, "Member 'USHPushableComponent::OnPreStartBP' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, OnStartedBP) == 0x0001A0, "Member 'USHPushableComponent::OnStartedBP' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, OnMovementBP) == 0x0001B0, "Member 'USHPushableComponent::OnMovementBP' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, OnCollisionHitBP) == 0x0001C0, "Member 'USHPushableComponent::OnCollisionHitBP' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, OnFinishedBP) == 0x0001D0, "Member 'USHPushableComponent::OnFinishedBP' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, OnInteruptedBP) == 0x0001E0, "Member 'USHPushableComponent::OnInteruptedBP' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, OnComponentBlockedChangedBP) == 0x0001F0, "Member 'USHPushableComponent::OnComponentBlockedChangedBP' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, OwnerMesh) == 0x000200, "Member 'USHPushableComponent::OwnerMesh' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, ProximitySphere) == 0x000208, "Member 'USHPushableComponent::ProximitySphere' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, InteractingCharacter) == 0x000210, "Member 'USHPushableComponent::InteractingCharacter' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, LinkedAnimGraphInstance) == 0x000218, "Member 'USHPushableComponent::LinkedAnimGraphInstance' has a wrong offset!");
static_assert(offsetof(USHPushableComponent, LastFrameWorldLoc) == 0x000220, "Member 'USHPushableComponent::LastFrameWorldLoc' has a wrong offset!");

// Class SHProto.SHPushableObjectDragComponent
// 0x0080 (0x0380 - 0x0300)
class USHPushableObjectDragComponent final : public USHPushableComponent
{
public:
	class FName                                   MeshAttachSocketName;                              // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnforceAttachedOwnerRelativeTransform;            // 0x0308(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             AttachedOwnerRelativeTransform;                    // 0x0310(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x10];                                     // 0x0370(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessMovementStartedEvent(class USHPushingObjectAnimInstance* AnimInst);
	void ProcessMovementStoppedEvent(class USHPushingObjectAnimInstance* AnimInst);
	void SHPushableObjectDragComponentEvent__DelegateSignature(class USHPushableObjectDragComponent* Component);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPushableObjectDragComponent">();
	}
	static class USHPushableObjectDragComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPushableObjectDragComponent>();
	}
};
static_assert(alignof(USHPushableObjectDragComponent) == 0x000010, "Wrong alignment on USHPushableObjectDragComponent");
static_assert(sizeof(USHPushableObjectDragComponent) == 0x000380, "Wrong size on USHPushableObjectDragComponent");
static_assert(offsetof(USHPushableObjectDragComponent, MeshAttachSocketName) == 0x000300, "Member 'USHPushableObjectDragComponent::MeshAttachSocketName' has a wrong offset!");
static_assert(offsetof(USHPushableObjectDragComponent, bEnforceAttachedOwnerRelativeTransform) == 0x000308, "Member 'USHPushableObjectDragComponent::bEnforceAttachedOwnerRelativeTransform' has a wrong offset!");
static_assert(offsetof(USHPushableObjectDragComponent, AttachedOwnerRelativeTransform) == 0x000310, "Member 'USHPushableObjectDragComponent::AttachedOwnerRelativeTransform' has a wrong offset!");

// Class SHProto.SHPushableRangeClampActor
// 0x0030 (0x02E0 - 0x02B0)
class ASHPushableRangeClampActor final : public AActor
{
public:
	class AActor*                                 ManagedActor;                                      // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              RangeClampLocal;                                   // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             ManagedActorLeftRange;                             // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RelayAppliedManagedActorState(bool bIsInDesiredSpotState, bool bInstantApply);
	void SHPushableRangeClampEvent__DelegateSignature(class ASHPushableRangeClampActor* ActorPtr);

	bool IsManagedActorOutOfRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPushableRangeClampActor">();
	}
	static class ASHPushableRangeClampActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHPushableRangeClampActor>();
	}
};
static_assert(alignof(ASHPushableRangeClampActor) == 0x000008, "Wrong alignment on ASHPushableRangeClampActor");
static_assert(sizeof(ASHPushableRangeClampActor) == 0x0002E0, "Wrong size on ASHPushableRangeClampActor");
static_assert(offsetof(ASHPushableRangeClampActor, ManagedActor) == 0x0002B0, "Member 'ASHPushableRangeClampActor::ManagedActor' has a wrong offset!");
static_assert(offsetof(ASHPushableRangeClampActor, RangeClampLocal) == 0x0002B8, "Member 'ASHPushableRangeClampActor::RangeClampLocal' has a wrong offset!");
static_assert(offsetof(ASHPushableRangeClampActor, ManagedActorLeftRange) == 0x0002C8, "Member 'ASHPushableRangeClampActor::ManagedActorLeftRange' has a wrong offset!");

// Class SHProto.SHPushingObjectAnimInstance
// 0x00D0 (0x0420 - 0x0350)
class USHPushingObjectAnimInstance final : public UAnimInstance
{
public:
	bool                                          bPlayInteraction;                                  // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFinishInteraction;                                // 0x0349(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMovementBlocked;                                // 0x034A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34B[0x5];                                      // 0x034B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurrentInputValue;                                 // 0x0350(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                AnimSpotRelativeToHandleLoc;                       // 0x0368(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        SupportedInputs;                                   // 0x0380(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        DebugImporantRelativeToHandleSpots;                // 0x0390(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         DebugHandleShapeRadius;                            // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A4[0x7C];                                     // 0x03A4(0x007C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyAnyMovementStarted();
	void ApplyInteractionFinished();
	void ApplyInteractionFinishFired();
	void ApplyInteractionStarted();
	void ApplyMovementStopped(const struct FVector& StoppedMovementInput);
	void OnAbortedBP();

	struct FVector GetBlockedInputValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPushingObjectAnimInstance">();
	}
	static class USHPushingObjectAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPushingObjectAnimInstance>();
	}
};
static_assert(alignof(USHPushingObjectAnimInstance) == 0x000010, "Wrong alignment on USHPushingObjectAnimInstance");
static_assert(sizeof(USHPushingObjectAnimInstance) == 0x000420, "Wrong size on USHPushingObjectAnimInstance");
static_assert(offsetof(USHPushingObjectAnimInstance, bPlayInteraction) == 0x000348, "Member 'USHPushingObjectAnimInstance::bPlayInteraction' has a wrong offset!");
static_assert(offsetof(USHPushingObjectAnimInstance, bFinishInteraction) == 0x000349, "Member 'USHPushingObjectAnimInstance::bFinishInteraction' has a wrong offset!");
static_assert(offsetof(USHPushingObjectAnimInstance, bIsMovementBlocked) == 0x00034A, "Member 'USHPushingObjectAnimInstance::bIsMovementBlocked' has a wrong offset!");
static_assert(offsetof(USHPushingObjectAnimInstance, CurrentInputValue) == 0x000350, "Member 'USHPushingObjectAnimInstance::CurrentInputValue' has a wrong offset!");
static_assert(offsetof(USHPushingObjectAnimInstance, AnimSpotRelativeToHandleLoc) == 0x000368, "Member 'USHPushingObjectAnimInstance::AnimSpotRelativeToHandleLoc' has a wrong offset!");
static_assert(offsetof(USHPushingObjectAnimInstance, SupportedInputs) == 0x000380, "Member 'USHPushingObjectAnimInstance::SupportedInputs' has a wrong offset!");
static_assert(offsetof(USHPushingObjectAnimInstance, DebugImporantRelativeToHandleSpots) == 0x000390, "Member 'USHPushingObjectAnimInstance::DebugImporantRelativeToHandleSpots' has a wrong offset!");
static_assert(offsetof(USHPushingObjectAnimInstance, DebugHandleShapeRadius) == 0x0003A0, "Member 'USHPushingObjectAnimInstance::DebugHandleShapeRadius' has a wrong offset!");

// Class SHProto.SHPuzzleDifficultyControllerActor
// 0x0008 (0x02C0 - 0x02B8)
class ASHPuzzleDifficultyControllerActor final : public ASHActorsManagementBaseControllerActor
{
public:
	bool                                          bManagedActorsActiveInEasyDifficulty;              // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bManagedActorsActiveInMediumDifficulty;            // 0x02B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bManagedActorsActiveInHardDifficulty;              // 0x02BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BB[0x5];                                      // 0x02BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPuzzleDifficultyControllerActor">();
	}
	static class ASHPuzzleDifficultyControllerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHPuzzleDifficultyControllerActor>();
	}
};
static_assert(alignof(ASHPuzzleDifficultyControllerActor) == 0x000008, "Wrong alignment on ASHPuzzleDifficultyControllerActor");
static_assert(sizeof(ASHPuzzleDifficultyControllerActor) == 0x0002C0, "Wrong size on ASHPuzzleDifficultyControllerActor");
static_assert(offsetof(ASHPuzzleDifficultyControllerActor, bManagedActorsActiveInEasyDifficulty) == 0x0002B8, "Member 'ASHPuzzleDifficultyControllerActor::bManagedActorsActiveInEasyDifficulty' has a wrong offset!");
static_assert(offsetof(ASHPuzzleDifficultyControllerActor, bManagedActorsActiveInMediumDifficulty) == 0x0002B9, "Member 'ASHPuzzleDifficultyControllerActor::bManagedActorsActiveInMediumDifficulty' has a wrong offset!");
static_assert(offsetof(ASHPuzzleDifficultyControllerActor, bManagedActorsActiveInHardDifficulty) == 0x0002BA, "Member 'ASHPuzzleDifficultyControllerActor::bManagedActorsActiveInHardDifficulty' has a wrong offset!");

// Class SHProto.SHPuzzleStatics
// 0x0000 (0x0028 - 0x0028)
class USHPuzzleStatics final : public UBlueprintFunctionLibrary
{
public:
	static void GetLadyJusticePuzzlePossibleVariations(const float StartValue, const TMap<float, class FString>& SolutionValueToName, const TArray<float>& Weights);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPuzzleStatics">();
	}
	static class USHPuzzleStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPuzzleStatics>();
	}
};
static_assert(alignof(USHPuzzleStatics) == 0x000008, "Wrong alignment on USHPuzzleStatics");
static_assert(sizeof(USHPuzzleStatics) == 0x000028, "Wrong size on USHPuzzleStatics");

// Class SHProto.SHPHAnimComponent
// 0x0000 (0x0490 - 0x0490)
class USHPHAnimComponent final : public USHEnemyAnimComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPHAnimComponent">();
	}
	static class USHPHAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPHAnimComponent>();
	}
};
static_assert(alignof(USHPHAnimComponent) == 0x000008, "Wrong alignment on USHPHAnimComponent");
static_assert(sizeof(USHPHAnimComponent) == 0x000490, "Wrong size on USHPHAnimComponent");

// Class SHProto.SH_AnimNotify_PHSetLocomotion
// 0x0008 (0x0040 - 0x0038)
class USH_AnimNotify_PHSetLocomotion final : public UAnimNotify
{
public:
	TSubclassOf<class USHPHLocomotionAnimInstance> NewLocomotion;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SH_AnimNotify_PHSetLocomotion">();
	}
	static class USH_AnimNotify_PHSetLocomotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<USH_AnimNotify_PHSetLocomotion>();
	}
};
static_assert(alignof(USH_AnimNotify_PHSetLocomotion) == 0x000008, "Wrong alignment on USH_AnimNotify_PHSetLocomotion");
static_assert(sizeof(USH_AnimNotify_PHSetLocomotion) == 0x000040, "Wrong size on USH_AnimNotify_PHSetLocomotion");
static_assert(offsetof(USH_AnimNotify_PHSetLocomotion, NewLocomotion) == 0x000038, "Member 'USH_AnimNotify_PHSetLocomotion::NewLocomotion' has a wrong offset!");

// Class SHProto.SHPyramidHeadBossFightOutcomeEndingFactor
// 0x0058 (0x0088 - 0x0030)
class USHPyramidHeadBossFightOutcomeEndingFactor final : public USHEndingFactor
{
public:
	TMap<ESHPyramidHeadBossFightOutcomeEndingFactorValue, struct FSHEndingScoreChanger> ValueToScoreChangeMap;                             // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	ESHPyramidHeadBossFightOutcomeEndingFactorValue Value;                                             // 0x0080(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Character_Endings_Factors_PyramidHeadBossFightOutcome_SetDebugValue(int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHPyramidHeadBossFightOutcomeEndingFactor">();
	}
	static class USHPyramidHeadBossFightOutcomeEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHPyramidHeadBossFightOutcomeEndingFactor>();
	}
};
static_assert(alignof(USHPyramidHeadBossFightOutcomeEndingFactor) == 0x000008, "Wrong alignment on USHPyramidHeadBossFightOutcomeEndingFactor");
static_assert(sizeof(USHPyramidHeadBossFightOutcomeEndingFactor) == 0x000088, "Wrong size on USHPyramidHeadBossFightOutcomeEndingFactor");
static_assert(offsetof(USHPyramidHeadBossFightOutcomeEndingFactor, ValueToScoreChangeMap) == 0x000030, "Member 'USHPyramidHeadBossFightOutcomeEndingFactor::ValueToScoreChangeMap' has a wrong offset!");
static_assert(offsetof(USHPyramidHeadBossFightOutcomeEndingFactor, Value) == 0x000080, "Member 'USHPyramidHeadBossFightOutcomeEndingFactor::Value' has a wrong offset!");

// Class SHProto.SHRadio
// 0x00C8 (0x0458 - 0x0390)
class ASHRadio final : public ASHItemEquipment
{
public:
	class USHAkComponent*                         SHAkComponent;                                     // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OuterSphereRadius;                                 // 0x0398(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InnerSphereRadius;                                 // 0x039C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StandardDistanceScoreInfluence;                    // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NavmeshDistanceScoreInfluence;                     // 0x03A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UNavigationQueryFilter>     NavMeshNavigationFilterClass;                      // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          StartEvent;                                        // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          StopEvent;                                         // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                RTPC_DangerLevel;                                  // 0x03C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RTPC_OuterSphereValue;                             // 0x03C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RTPC_InnerSphereValue;                             // 0x03CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EnableLightsSupport;                               // 0x03D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D1[0x3];                                      // 0x03D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LightsSensitivityMin;                              // 0x03D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LightsSensitivityFull;                             // 0x03D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 LightsColorBase;                                   // 0x03DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 LightsColorVariance;                               // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E4[0x74];                                     // 0x03E4(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnemyIgnored(class APawn* InEnemyPawn, const bool bInShouldBeIgnored);
	void SHDebug_Character_Items_Radio_DrawDebug();
	void SHDebug_Character_Items_Radio_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHRadio">();
	}
	static class ASHRadio* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHRadio>();
	}
};
static_assert(alignof(ASHRadio) == 0x000008, "Wrong alignment on ASHRadio");
static_assert(sizeof(ASHRadio) == 0x000458, "Wrong size on ASHRadio");
static_assert(offsetof(ASHRadio, SHAkComponent) == 0x000390, "Member 'ASHRadio::SHAkComponent' has a wrong offset!");
static_assert(offsetof(ASHRadio, OuterSphereRadius) == 0x000398, "Member 'ASHRadio::OuterSphereRadius' has a wrong offset!");
static_assert(offsetof(ASHRadio, InnerSphereRadius) == 0x00039C, "Member 'ASHRadio::InnerSphereRadius' has a wrong offset!");
static_assert(offsetof(ASHRadio, StandardDistanceScoreInfluence) == 0x0003A0, "Member 'ASHRadio::StandardDistanceScoreInfluence' has a wrong offset!");
static_assert(offsetof(ASHRadio, NavmeshDistanceScoreInfluence) == 0x0003A4, "Member 'ASHRadio::NavmeshDistanceScoreInfluence' has a wrong offset!");
static_assert(offsetof(ASHRadio, NavMeshNavigationFilterClass) == 0x0003A8, "Member 'ASHRadio::NavMeshNavigationFilterClass' has a wrong offset!");
static_assert(offsetof(ASHRadio, StartEvent) == 0x0003B0, "Member 'ASHRadio::StartEvent' has a wrong offset!");
static_assert(offsetof(ASHRadio, StopEvent) == 0x0003B8, "Member 'ASHRadio::StopEvent' has a wrong offset!");
static_assert(offsetof(ASHRadio, RTPC_DangerLevel) == 0x0003C0, "Member 'ASHRadio::RTPC_DangerLevel' has a wrong offset!");
static_assert(offsetof(ASHRadio, RTPC_OuterSphereValue) == 0x0003C8, "Member 'ASHRadio::RTPC_OuterSphereValue' has a wrong offset!");
static_assert(offsetof(ASHRadio, RTPC_InnerSphereValue) == 0x0003CC, "Member 'ASHRadio::RTPC_InnerSphereValue' has a wrong offset!");
static_assert(offsetof(ASHRadio, EnableLightsSupport) == 0x0003D0, "Member 'ASHRadio::EnableLightsSupport' has a wrong offset!");
static_assert(offsetof(ASHRadio, LightsSensitivityMin) == 0x0003D4, "Member 'ASHRadio::LightsSensitivityMin' has a wrong offset!");
static_assert(offsetof(ASHRadio, LightsSensitivityFull) == 0x0003D8, "Member 'ASHRadio::LightsSensitivityFull' has a wrong offset!");
static_assert(offsetof(ASHRadio, LightsColorBase) == 0x0003DC, "Member 'ASHRadio::LightsColorBase' has a wrong offset!");
static_assert(offsetof(ASHRadio, LightsColorVariance) == 0x0003E0, "Member 'ASHRadio::LightsColorVariance' has a wrong offset!");

// Class SHProto.SHRangedAutoAimCmbSubcompSettings
// 0x0050 (0x0080 - 0x0030)
class USHRangedAutoAimCmbSubcompSettings final : public UDataAsset
{
public:
	TMap<EAimAssistMagnetismMode, struct FSHRangedAutoAimConfigurationData> ModeToConfigurationMapping;                        // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHRangedAutoAimCmbSubcompSettings">();
	}
	static class USHRangedAutoAimCmbSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHRangedAutoAimCmbSubcompSettings>();
	}
};
static_assert(alignof(USHRangedAutoAimCmbSubcompSettings) == 0x000008, "Wrong alignment on USHRangedAutoAimCmbSubcompSettings");
static_assert(sizeof(USHRangedAutoAimCmbSubcompSettings) == 0x000080, "Wrong size on USHRangedAutoAimCmbSubcompSettings");
static_assert(offsetof(USHRangedAutoAimCmbSubcompSettings, ModeToConfigurationMapping) == 0x000030, "Member 'USHRangedAutoAimCmbSubcompSettings::ModeToConfigurationMapping' has a wrong offset!");

// Class SHProto.SHRangedAutoAimCmbSubcomp
// 0x0010 (0x0048 - 0x0038)
class USHRangedAutoAimCmbSubcomp final : public USHCombatSubcomponentBase
{
public:
	class USHRangedAutoAimCmbSubcompSettings*     Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Character_Combat_AutoAim_Magnet_DrawDebug();
	void SHDebug_Character_Combat_AutoAim_Magnet_ValuesDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHRangedAutoAimCmbSubcomp">();
	}
	static class USHRangedAutoAimCmbSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHRangedAutoAimCmbSubcomp>();
	}
};
static_assert(alignof(USHRangedAutoAimCmbSubcomp) == 0x000008, "Wrong alignment on USHRangedAutoAimCmbSubcomp");
static_assert(sizeof(USHRangedAutoAimCmbSubcomp) == 0x000048, "Wrong size on USHRangedAutoAimCmbSubcomp");
static_assert(offsetof(USHRangedAutoAimCmbSubcomp, Settings) == 0x000038, "Member 'USHRangedAutoAimCmbSubcomp::Settings' has a wrong offset!");

// Class SHProto.SHRangedCmbSubcomp
// 0x0210 (0x0248 - 0x0038)
class USHRangedCmbSubcomp final : public USHCombatSubcomponentBase
{
public:
	FMulticastInlineDelegateProperty_             OnRangedAimPointingActorChanged;                   // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRangedFireSuccess;                               // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRangedFireOutOfAmmo;                             // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRangedReload;                                    // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      WeaponsAmmoCounts;                                 // 0x0078(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, bool>                       SingleActionWeaponReadySaves;                      // 0x00C8(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_118[0x130];                                    // 0x0118(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRangedFireEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void OnRangedReloadEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void OnRangedSingleActionPrepareEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void ProcessEquippedWeaponModifiedEvent(class USHWeaponManageCmbSubcomp* WeaponManager);
	void ProcessIsInSprintChangeEvent(class USHCharacterPlayMovementComponent* ComponentRef);
	void ProcessSprintRequestedChangeEvent(class USHCharacterPlayMovementComponent* ComponentRef);
	void RequestManualFire(const class UObject* Object);
	void SHDebug_Character_Combat_ForceRangedAim();
	void SHRangedCombatEvent__DelegateSignature(class USHRangedCmbSubcomp* RangedCombatSubcomponent);
	void SHRangedCombatWeaponContextEvent__DelegateSignature(class USHRangedCmbSubcomp* RangedCombatSubcomponent, class ASHItemWeapon* ItemWeaponContext);

	class ASHItemWeaponRanged* GetEquippedRangedWeapon() const;
	bool IsInRangedAim() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHRangedCmbSubcomp">();
	}
	static class USHRangedCmbSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHRangedCmbSubcomp>();
	}
};
static_assert(alignof(USHRangedCmbSubcomp) == 0x000008, "Wrong alignment on USHRangedCmbSubcomp");
static_assert(sizeof(USHRangedCmbSubcomp) == 0x000248, "Wrong size on USHRangedCmbSubcomp");
static_assert(offsetof(USHRangedCmbSubcomp, OnRangedAimPointingActorChanged) == 0x000038, "Member 'USHRangedCmbSubcomp::OnRangedAimPointingActorChanged' has a wrong offset!");
static_assert(offsetof(USHRangedCmbSubcomp, OnRangedFireSuccess) == 0x000048, "Member 'USHRangedCmbSubcomp::OnRangedFireSuccess' has a wrong offset!");
static_assert(offsetof(USHRangedCmbSubcomp, OnRangedFireOutOfAmmo) == 0x000058, "Member 'USHRangedCmbSubcomp::OnRangedFireOutOfAmmo' has a wrong offset!");
static_assert(offsetof(USHRangedCmbSubcomp, OnRangedReload) == 0x000068, "Member 'USHRangedCmbSubcomp::OnRangedReload' has a wrong offset!");
static_assert(offsetof(USHRangedCmbSubcomp, WeaponsAmmoCounts) == 0x000078, "Member 'USHRangedCmbSubcomp::WeaponsAmmoCounts' has a wrong offset!");
static_assert(offsetof(USHRangedCmbSubcomp, SingleActionWeaponReadySaves) == 0x0000C8, "Member 'USHRangedCmbSubcomp::SingleActionWeaponReadySaves' has a wrong offset!");

// Class SHProto.SHRangedWeaponFXComponent
// 0x0000 (0x00A0 - 0x00A0)
class USHRangedWeaponFXComponent final : public USHWeaponFXComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHRangedWeaponFXComponent">();
	}
	static class USHRangedWeaponFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHRangedWeaponFXComponent>();
	}
};
static_assert(alignof(USHRangedWeaponFXComponent) == 0x000008, "Wrong alignment on USHRangedWeaponFXComponent");
static_assert(sizeof(USHRangedWeaponFXComponent) == 0x0000A0, "Wrong size on USHRangedWeaponFXComponent");

// Class SHProto.SHRaycastDetectableComponent
// 0x0000 (0x0780 - 0x0780)
class USHRaycastDetectableComponent final : public URaycastDetectableComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHRaycastDetectableComponent">();
	}
	static class USHRaycastDetectableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHRaycastDetectableComponent>();
	}
};
static_assert(alignof(USHRaycastDetectableComponent) == 0x000010, "Wrong alignment on USHRaycastDetectableComponent");
static_assert(sizeof(USHRaycastDetectableComponent) == 0x000780, "Wrong size on USHRaycastDetectableComponent");

// Class SHProto.SHRebindingViewWidget
// 0x00F8 (0x03B0 - 0x02B8)
class USHRebindingViewWidget final : public URebindingViewWidget
{
public:
	class UImage*                                 Controller_img;                                    // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              MicrosoftControllerImage;                          // 0x02C0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              PCMicrosoftControllerImage;                        // 0x02F0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              SonyControllerImage;                               // 0x0320(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              PCSonyControllerImage;                             // 0x0350(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              NintendoControllerImage;                           // 0x0380(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHRebindingViewWidget">();
	}
	static class USHRebindingViewWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHRebindingViewWidget>();
	}
};
static_assert(alignof(USHRebindingViewWidget) == 0x000008, "Wrong alignment on USHRebindingViewWidget");
static_assert(sizeof(USHRebindingViewWidget) == 0x0003B0, "Wrong size on USHRebindingViewWidget");
static_assert(offsetof(USHRebindingViewWidget, Controller_img) == 0x0002B8, "Member 'USHRebindingViewWidget::Controller_img' has a wrong offset!");
static_assert(offsetof(USHRebindingViewWidget, MicrosoftControllerImage) == 0x0002C0, "Member 'USHRebindingViewWidget::MicrosoftControllerImage' has a wrong offset!");
static_assert(offsetof(USHRebindingViewWidget, PCMicrosoftControllerImage) == 0x0002F0, "Member 'USHRebindingViewWidget::PCMicrosoftControllerImage' has a wrong offset!");
static_assert(offsetof(USHRebindingViewWidget, SonyControllerImage) == 0x000320, "Member 'USHRebindingViewWidget::SonyControllerImage' has a wrong offset!");
static_assert(offsetof(USHRebindingViewWidget, PCSonyControllerImage) == 0x000350, "Member 'USHRebindingViewWidget::PCSonyControllerImage' has a wrong offset!");
static_assert(offsetof(USHRebindingViewWidget, NintendoControllerImage) == 0x000380, "Member 'USHRebindingViewWidget::NintendoControllerImage' has a wrong offset!");

// Class SHProto.SHReviveAnimationsDA
// 0x0010 (0x0040 - 0x0030)
class USHReviveAnimationsDA final : public UDataAsset
{
public:
	TArray<struct FReviveAnimationData>           ReviveAnimations;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHReviveAnimationsDA">();
	}
	static class USHReviveAnimationsDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHReviveAnimationsDA>();
	}
};
static_assert(alignof(USHReviveAnimationsDA) == 0x000008, "Wrong alignment on USHReviveAnimationsDA");
static_assert(sizeof(USHReviveAnimationsDA) == 0x000040, "Wrong size on USHReviveAnimationsDA");
static_assert(offsetof(USHReviveAnimationsDA, ReviveAnimations) == 0x000030, "Member 'USHReviveAnimationsDA::ReviveAnimations' has a wrong offset!");

// Class SHProto.SHRollinWheelStaticMeshComponent
// 0x0020 (0x0620 - 0x0600)
class USHRollinWheelStaticMeshComponent final : public UStaticMeshComponent
{
public:
	float                                         RollingWheelRadius;                                // 0x05F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5FC[0x24];                                     // 0x05FC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDisabled(class USHPushableComponent* DummyComp);
	void SetEnabled(class USHPushableComponent* DummyComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHRollinWheelStaticMeshComponent">();
	}
	static class USHRollinWheelStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHRollinWheelStaticMeshComponent>();
	}
};
static_assert(alignof(USHRollinWheelStaticMeshComponent) == 0x000010, "Wrong alignment on USHRollinWheelStaticMeshComponent");
static_assert(sizeof(USHRollinWheelStaticMeshComponent) == 0x000620, "Wrong size on USHRollinWheelStaticMeshComponent");
static_assert(offsetof(USHRollinWheelStaticMeshComponent, RollingWheelRadius) == 0x0005F8, "Member 'USHRollinWheelStaticMeshComponent::RollingWheelRadius' has a wrong offset!");

// Class SHProto.SHRotateableComponent
// 0x0048 (0x00E8 - 0x00A0)
class USHRotateableComponent final : public UActorComponent
{
public:
	float                                         MomentumDecreaser;                                 // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MomentumLimit;                                     // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReceivedMoementumForceMod;                         // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitThrottle;                                       // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   RotateableMesh;                                    // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlaneSideDetectionComponent*           PlaneSideDetectionComponent;                       // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x20];                                      // 0x00C8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorHitApplyRotate(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void RegisterComponents(class UStaticMeshComponent* InRotateableMeshComponent, class UPlaneSideDetectionComponent* InSHPlaneSideDetectionComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHRotateableComponent">();
	}
	static class USHRotateableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHRotateableComponent>();
	}
};
static_assert(alignof(USHRotateableComponent) == 0x000008, "Wrong alignment on USHRotateableComponent");
static_assert(sizeof(USHRotateableComponent) == 0x0000E8, "Wrong size on USHRotateableComponent");
static_assert(offsetof(USHRotateableComponent, MomentumDecreaser) == 0x0000A0, "Member 'USHRotateableComponent::MomentumDecreaser' has a wrong offset!");
static_assert(offsetof(USHRotateableComponent, MomentumLimit) == 0x0000A4, "Member 'USHRotateableComponent::MomentumLimit' has a wrong offset!");
static_assert(offsetof(USHRotateableComponent, ReceivedMoementumForceMod) == 0x0000A8, "Member 'USHRotateableComponent::ReceivedMoementumForceMod' has a wrong offset!");
static_assert(offsetof(USHRotateableComponent, HitThrottle) == 0x0000AC, "Member 'USHRotateableComponent::HitThrottle' has a wrong offset!");
static_assert(offsetof(USHRotateableComponent, bDebug) == 0x0000B0, "Member 'USHRotateableComponent::bDebug' has a wrong offset!");
static_assert(offsetof(USHRotateableComponent, RotateableMesh) == 0x0000B8, "Member 'USHRotateableComponent::RotateableMesh' has a wrong offset!");
static_assert(offsetof(USHRotateableComponent, PlaneSideDetectionComponent) == 0x0000C0, "Member 'USHRotateableComponent::PlaneSideDetectionComponent' has a wrong offset!");

// Class SHProto.SHRotateInPlaceAnimInstance
// 0x0000 (0x0350 - 0x0350)
class USHRotateInPlaceAnimInstance final : public UAnimInstance
{
public:
	bool                                          UseControllerRotationYaw;                          // 0x0348(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInitializeValues();
	void OnRotateInPlaceStartNative();
	void OnRotateInPlaceStopNative();
	void SetUseControllerRotationYaw(bool Use);

	bool CanBeUsed() const;
	bool IsBlocked() const;
	bool IsCutscenePlaying() const;
	bool IsStopImmediatelyRequested() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHRotateInPlaceAnimInstance">();
	}
	static class USHRotateInPlaceAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHRotateInPlaceAnimInstance>();
	}
};
static_assert(alignof(USHRotateInPlaceAnimInstance) == 0x000010, "Wrong alignment on USHRotateInPlaceAnimInstance");
static_assert(sizeof(USHRotateInPlaceAnimInstance) == 0x000350, "Wrong size on USHRotateInPlaceAnimInstance");
static_assert(offsetof(USHRotateInPlaceAnimInstance, UseControllerRotationYaw) == 0x000348, "Member 'USHRotateInPlaceAnimInstance::UseControllerRotationYaw' has a wrong offset!");

// Class SHProto.SHSafeBeginPlayComponent
// 0x0038 (0x00D8 - 0x00A0)
class USHSafeBeginPlayComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             SafeBeginPlayEvent;                                // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSafeBeginPlayComponent">();
	}
	static class USHSafeBeginPlayComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSafeBeginPlayComponent>();
	}
};
static_assert(alignof(USHSafeBeginPlayComponent) == 0x000008, "Wrong alignment on USHSafeBeginPlayComponent");
static_assert(sizeof(USHSafeBeginPlayComponent) == 0x0000D8, "Wrong size on USHSafeBeginPlayComponent");
static_assert(offsetof(USHSafeBeginPlayComponent, SafeBeginPlayEvent) == 0x0000A0, "Member 'USHSafeBeginPlayComponent::SafeBeginPlayEvent' has a wrong offset!");

// Class SHProto.SHSaveGame
// 0x0130 (0x0250 - 0x0120)
class USHSaveGame final : public UBaseSaveGame
{
public:
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SaveVersion;                                       // 0x0128(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHSaveData                            Data;                                              // 0x0130(0x0120)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSaveGame">();
	}
	static class USHSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSaveGame>();
	}
};
static_assert(alignof(USHSaveGame) == 0x000010, "Wrong alignment on USHSaveGame");
static_assert(sizeof(USHSaveGame) == 0x000250, "Wrong size on USHSaveGame");
static_assert(offsetof(USHSaveGame, SaveVersion) == 0x000128, "Member 'USHSaveGame::SaveVersion' has a wrong offset!");
static_assert(offsetof(USHSaveGame, Data) == 0x000130, "Member 'USHSaveGame::Data' has a wrong offset!");

// Class SHProto.SHSavePoint
// 0x0158 (0x0408 - 0x02B0)
class ASHSavePoint final : public AActor
{
public:
	class USceneComponent*                        MeshOffsetPivot;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        MeshRotationPivot;                                 // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SheetMesh;                                         // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCineCameraComponent*                 Camera;                                            // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      AnimSpot;                                          // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        FlashlightLookAtPoint;                             // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionGenericComponent*         InteractionGeneric;                                // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractionProximitySphere;                        // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            InteractionIcon;                                   // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHRaycastDetectableComponent*          InteractionDetectable;                             // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractionDetectableShape;                        // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   GloomFXMesh;                                       // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpotLightComponent*                    InteractionSpotlight;                              // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpotLightComponent*                    GameplaySpotlight_Enviro;                          // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpotLightComponent*                    GameplaySpotlight_Player;                          // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URectLightComponent*                    GameplayRectlight_Enviro;                          // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionManagerComponent*         InteractionManager;                                // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayMapSavePointComponent*       GameplayMapObject;                                 // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    SavePointHandle;                                   // 0x0340(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimMontage>            AnimationMontage;                                  // 0x0350(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimMontage>            FaceAnimMontage;                                   // 0x0380(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             InteractionStartedEvent;                           // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             InteractionFinishedEvent;                          // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             InteractionAbortedEvent;                           // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class ASHCharacterPlay*                       InteractingCharacter;                              // 0x03E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x20];                                     // 0x03E8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExitInteractionRequest();
	void ManualInteractRequest(class ASHCharacterPlay* Character, bool SkipMoveToSpot);
	void OnInteractionEnded(bool WasAborted);
	void OnInteractionStarted();
	void OnSetupStarted();
	void ProcessCombatInputModeChangedEvent(class USHCharacterPlayCombatComponent* CombatComp);
	void ProcessInteractionManagerInitialized(class USHInteractionManagerComponent* Manager);
	void ProcessMovementSnapFinish(bool WasCompleted);
	void ProcessProximityBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void ProcessReceiveDamageEvent(class USHCharacterPlayCombatComponent* CombatComp);
	void SHSavePointActorEvent__DelegateSignature(class ASHSavePoint* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSavePoint">();
	}
	static class ASHSavePoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHSavePoint>();
	}
};
static_assert(alignof(ASHSavePoint) == 0x000008, "Wrong alignment on ASHSavePoint");
static_assert(sizeof(ASHSavePoint) == 0x000408, "Wrong size on ASHSavePoint");
static_assert(offsetof(ASHSavePoint, MeshOffsetPivot) == 0x0002B0, "Member 'ASHSavePoint::MeshOffsetPivot' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, MeshRotationPivot) == 0x0002B8, "Member 'ASHSavePoint::MeshRotationPivot' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, SheetMesh) == 0x0002C0, "Member 'ASHSavePoint::SheetMesh' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, Camera) == 0x0002C8, "Member 'ASHSavePoint::Camera' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, AnimSpot) == 0x0002D0, "Member 'ASHSavePoint::AnimSpot' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, FlashlightLookAtPoint) == 0x0002D8, "Member 'ASHSavePoint::FlashlightLookAtPoint' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, InteractionGeneric) == 0x0002E0, "Member 'ASHSavePoint::InteractionGeneric' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, InteractionProximitySphere) == 0x0002E8, "Member 'ASHSavePoint::InteractionProximitySphere' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, InteractionIcon) == 0x0002F0, "Member 'ASHSavePoint::InteractionIcon' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, InteractionDetectable) == 0x0002F8, "Member 'ASHSavePoint::InteractionDetectable' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, InteractionDetectableShape) == 0x000300, "Member 'ASHSavePoint::InteractionDetectableShape' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, GloomFXMesh) == 0x000308, "Member 'ASHSavePoint::GloomFXMesh' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, InteractionSpotlight) == 0x000310, "Member 'ASHSavePoint::InteractionSpotlight' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, GameplaySpotlight_Enviro) == 0x000318, "Member 'ASHSavePoint::GameplaySpotlight_Enviro' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, GameplaySpotlight_Player) == 0x000320, "Member 'ASHSavePoint::GameplaySpotlight_Player' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, GameplayRectlight_Enviro) == 0x000328, "Member 'ASHSavePoint::GameplayRectlight_Enviro' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, InteractionManager) == 0x000330, "Member 'ASHSavePoint::InteractionManager' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, GameplayMapObject) == 0x000338, "Member 'ASHSavePoint::GameplayMapObject' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, SavePointHandle) == 0x000340, "Member 'ASHSavePoint::SavePointHandle' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, AnimationMontage) == 0x000350, "Member 'ASHSavePoint::AnimationMontage' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, FaceAnimMontage) == 0x000380, "Member 'ASHSavePoint::FaceAnimMontage' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, InteractionStartedEvent) == 0x0003B0, "Member 'ASHSavePoint::InteractionStartedEvent' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, InteractionFinishedEvent) == 0x0003C0, "Member 'ASHSavePoint::InteractionFinishedEvent' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, InteractionAbortedEvent) == 0x0003D0, "Member 'ASHSavePoint::InteractionAbortedEvent' has a wrong offset!");
static_assert(offsetof(ASHSavePoint, InteractingCharacter) == 0x0003E0, "Member 'ASHSavePoint::InteractingCharacter' has a wrong offset!");

// Class SHProto.SHSaveSlotWidget
// 0x0078 (0x0308 - 0x0290)
class USHSaveSlotWidget final : public USaveSlotListEntryWidget
{
public:
	class UTextBlock*                             Location_lbl;                                      // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MinorLocation_lbl;                                 // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Type_lbl;                                          // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Date_lbl;                                          // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Time_lbl;                                          // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             GameTime_lbl;                                      // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Location_img;                                      // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CombatDifficulty_lbl;                              // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PuzzlesDifficulty_lbl;                             // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             SavePointInfos;                                    // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Expand_anim;                                       // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FText>                           CombatDifficultyTexts;                             // 0x02E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FText>                           PuzzlesDifficultyTexts;                            // 0x02F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	struct FGameSaveSlotInfo GetGameSlotInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSaveSlotWidget">();
	}
	static class USHSaveSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSaveSlotWidget>();
	}
};
static_assert(alignof(USHSaveSlotWidget) == 0x000008, "Wrong alignment on USHSaveSlotWidget");
static_assert(sizeof(USHSaveSlotWidget) == 0x000308, "Wrong size on USHSaveSlotWidget");
static_assert(offsetof(USHSaveSlotWidget, Location_lbl) == 0x000290, "Member 'USHSaveSlotWidget::Location_lbl' has a wrong offset!");
static_assert(offsetof(USHSaveSlotWidget, MinorLocation_lbl) == 0x000298, "Member 'USHSaveSlotWidget::MinorLocation_lbl' has a wrong offset!");
static_assert(offsetof(USHSaveSlotWidget, Type_lbl) == 0x0002A0, "Member 'USHSaveSlotWidget::Type_lbl' has a wrong offset!");
static_assert(offsetof(USHSaveSlotWidget, Date_lbl) == 0x0002A8, "Member 'USHSaveSlotWidget::Date_lbl' has a wrong offset!");
static_assert(offsetof(USHSaveSlotWidget, Time_lbl) == 0x0002B0, "Member 'USHSaveSlotWidget::Time_lbl' has a wrong offset!");
static_assert(offsetof(USHSaveSlotWidget, GameTime_lbl) == 0x0002B8, "Member 'USHSaveSlotWidget::GameTime_lbl' has a wrong offset!");
static_assert(offsetof(USHSaveSlotWidget, Location_img) == 0x0002C0, "Member 'USHSaveSlotWidget::Location_img' has a wrong offset!");
static_assert(offsetof(USHSaveSlotWidget, CombatDifficulty_lbl) == 0x0002C8, "Member 'USHSaveSlotWidget::CombatDifficulty_lbl' has a wrong offset!");
static_assert(offsetof(USHSaveSlotWidget, PuzzlesDifficulty_lbl) == 0x0002D0, "Member 'USHSaveSlotWidget::PuzzlesDifficulty_lbl' has a wrong offset!");
static_assert(offsetof(USHSaveSlotWidget, SavePointInfos) == 0x0002D8, "Member 'USHSaveSlotWidget::SavePointInfos' has a wrong offset!");
static_assert(offsetof(USHSaveSlotWidget, Expand_anim) == 0x0002E0, "Member 'USHSaveSlotWidget::Expand_anim' has a wrong offset!");
static_assert(offsetof(USHSaveSlotWidget, CombatDifficultyTexts) == 0x0002E8, "Member 'USHSaveSlotWidget::CombatDifficultyTexts' has a wrong offset!");
static_assert(offsetof(USHSaveSlotWidget, PuzzlesDifficultyTexts) == 0x0002F8, "Member 'USHSaveSlotWidget::PuzzlesDifficultyTexts' has a wrong offset!");

// Class SHProto.SHScreenDetectableComponent
// 0x0000 (0x05F0 - 0x05F0)
class USHScreenDetectableComponent final : public UScreenDetectableComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHScreenDetectableComponent">();
	}
	static class USHScreenDetectableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHScreenDetectableComponent>();
	}
};
static_assert(alignof(USHScreenDetectableComponent) == 0x000010, "Wrong alignment on USHScreenDetectableComponent");
static_assert(sizeof(USHScreenDetectableComponent) == 0x0005F0, "Wrong size on USHScreenDetectableComponent");

// Class SHProto.SHScribbleTutorialHandler
// 0x0008 (0x0040 - 0x0038)
class USHScribbleTutorialHandler final : public USHTutorialHandlerBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHScribbleTutorialHandler">();
	}
	static class USHScribbleTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHScribbleTutorialHandler>();
	}
};
static_assert(alignof(USHScribbleTutorialHandler) == 0x000008, "Wrong alignment on USHScribbleTutorialHandler");
static_assert(sizeof(USHScribbleTutorialHandler) == 0x000040, "Wrong size on USHScribbleTutorialHandler");

// Class SHProto.SHScriptedBreakWallTutorialHandler
// 0x0010 (0x0048 - 0x0038)
class USHScriptedBreakWallTutorialHandler final : public USHTutorialHandlerBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHScriptedBreakWallTutorialHandler">();
	}
	static class USHScriptedBreakWallTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHScriptedBreakWallTutorialHandler>();
	}
};
static_assert(alignof(USHScriptedBreakWallTutorialHandler) == 0x000008, "Wrong alignment on USHScriptedBreakWallTutorialHandler");
static_assert(sizeof(USHScriptedBreakWallTutorialHandler) == 0x000048, "Wrong size on USHScriptedBreakWallTutorialHandler");

// Class SHProto.SHScriptedPreTraversalTutorialHandler
// 0x0010 (0x0048 - 0x0038)
class USHScriptedPreTraversalTutorialHandler final : public USHTutorialHandlerBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHScriptedPreTraversalTutorialHandler">();
	}
	static class USHScriptedPreTraversalTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHScriptedPreTraversalTutorialHandler>();
	}
};
static_assert(alignof(USHScriptedPreTraversalTutorialHandler) == 0x000008, "Wrong alignment on USHScriptedPreTraversalTutorialHandler");
static_assert(sizeof(USHScriptedPreTraversalTutorialHandler) == 0x000048, "Wrong size on USHScriptedPreTraversalTutorialHandler");

// Class SHProto.SHSearchFocus
// 0x0100 (0x03B0 - 0x02B0)
class ASHSearchFocus final : public AActor
{
public:
	class USceneComponent*                        FocusExtraLightsContainer;                         // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHCineCameraComponent*                 FocusCamera;                                       // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionGenericComponent*         InteractionGeneric;                                // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractionProximitySphere;                        // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            InteractionIcon;                                   // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHRaycastDetectableComponent*          InteractionDetectable;                             // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractionDetectableShape;                        // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      InteractionAnimSpot;                               // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionManagerComponent*         InteractionManager;                                // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHFocusableComponent*                  FocusableComponent;                                // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayMapFocusableComponent*       GameplayMapMarkerComponent;                        // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNoCompleteFoundItem;                              // 0x0308(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    CompleteFoundItem;                                 // 0x0310(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         StageChangeAnimationTime;                          // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   AnimInstanceClass;                                 // 0x0328(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTrackInteractingCharacter;                        // 0x0358(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneToTrackInteractingCharacter;                   // 0x035C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseFocusCameraChangeTransformPerStage;            // 0x0364(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_365[0x3];                                      // 0x0365(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     FocusCameraRelativeTransforms;                     // 0x0368(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          StopAnimNotifiesAudioEvent;                        // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnCompleteFoundItemCollected;                      // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class ACharacter*                             InteractingCharacter;                              // 0x0390(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHSearchFocusAnimInstance*             LinkedAnimGraphInstance;                           // 0x0398(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x10];                                     // 0x03A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessAnimInstStageAdvanced(class USHSearchFocusAnimInstance* AnimInst);
	void ProcessAnimInstStartedInteraction(class USHSearchFocusAnimInstance* AnimInst);
	void ProcessFocusableInputActionEvent(ESHFocusableInputActionTypeEnum InputActionType, float KeyValue);
	void ProcessInteractingCharacterCombatInputModeChanged(class USHCharacterPlayCombatComponent* CombatComp);
	void ProcessInteractingCharacterReceiveDamage(class USHCharacterPlayCombatComponent* CombatComp);
	void ProcessInteractionGenericGrabbed(class USHInteractionGenericComponent* Generic, class ASHCharacterPlay* Character);
	void ProcessInteractionManagerInitialized(class USHInteractionManagerComponent* Manager);
	void ProcessMoveCharacterToSpotFinished(bool WasCompleted);
	void ProcessProximityBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void ProcessProximityEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex);
	void SHSearchFocusBlueprintEvent__DelegateSignature(class ASHSearchFocus* ActorPtr);

	int32 GetCurrentFocusStageIndex() const;
	bool IsInInteraction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSearchFocus">();
	}
	static class ASHSearchFocus* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHSearchFocus>();
	}
};
static_assert(alignof(ASHSearchFocus) == 0x000008, "Wrong alignment on ASHSearchFocus");
static_assert(sizeof(ASHSearchFocus) == 0x0003B0, "Wrong size on ASHSearchFocus");
static_assert(offsetof(ASHSearchFocus, FocusExtraLightsContainer) == 0x0002B0, "Member 'ASHSearchFocus::FocusExtraLightsContainer' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, FocusCamera) == 0x0002B8, "Member 'ASHSearchFocus::FocusCamera' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, InteractionGeneric) == 0x0002C0, "Member 'ASHSearchFocus::InteractionGeneric' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, InteractionProximitySphere) == 0x0002C8, "Member 'ASHSearchFocus::InteractionProximitySphere' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, InteractionIcon) == 0x0002D0, "Member 'ASHSearchFocus::InteractionIcon' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, InteractionDetectable) == 0x0002D8, "Member 'ASHSearchFocus::InteractionDetectable' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, InteractionDetectableShape) == 0x0002E0, "Member 'ASHSearchFocus::InteractionDetectableShape' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, InteractionAnimSpot) == 0x0002E8, "Member 'ASHSearchFocus::InteractionAnimSpot' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, InteractionManager) == 0x0002F0, "Member 'ASHSearchFocus::InteractionManager' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, FocusableComponent) == 0x0002F8, "Member 'ASHSearchFocus::FocusableComponent' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, GameplayMapMarkerComponent) == 0x000300, "Member 'ASHSearchFocus::GameplayMapMarkerComponent' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, bNoCompleteFoundItem) == 0x000308, "Member 'ASHSearchFocus::bNoCompleteFoundItem' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, CompleteFoundItem) == 0x000310, "Member 'ASHSearchFocus::CompleteFoundItem' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, StageChangeAnimationTime) == 0x000320, "Member 'ASHSearchFocus::StageChangeAnimationTime' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, AnimInstanceClass) == 0x000328, "Member 'ASHSearchFocus::AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, bTrackInteractingCharacter) == 0x000358, "Member 'ASHSearchFocus::bTrackInteractingCharacter' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, BoneToTrackInteractingCharacter) == 0x00035C, "Member 'ASHSearchFocus::BoneToTrackInteractingCharacter' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, bUseFocusCameraChangeTransformPerStage) == 0x000364, "Member 'ASHSearchFocus::bUseFocusCameraChangeTransformPerStage' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, FocusCameraRelativeTransforms) == 0x000368, "Member 'ASHSearchFocus::FocusCameraRelativeTransforms' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, StopAnimNotifiesAudioEvent) == 0x000378, "Member 'ASHSearchFocus::StopAnimNotifiesAudioEvent' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, OnCompleteFoundItemCollected) == 0x000380, "Member 'ASHSearchFocus::OnCompleteFoundItemCollected' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, InteractingCharacter) == 0x000390, "Member 'ASHSearchFocus::InteractingCharacter' has a wrong offset!");
static_assert(offsetof(ASHSearchFocus, LinkedAnimGraphInstance) == 0x000398, "Member 'ASHSearchFocus::LinkedAnimGraphInstance' has a wrong offset!");

// Class SHProto.SHSecondaryTargetComponent
// 0x0070 (0x0310 - 0x02A0)
class USHSecondaryTargetComponent final : public USceneComponent
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCompletedOnBegin;                                 // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TargetSize;                                        // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAllowedHeightDelta;                             // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAllowedDistanceToHitPoint2D;                    // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDirectionalOneSideOnly;                         // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRequiredDirectionsDotProduct;                   // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    SecondaryAttackDataRowHandle;                      // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	ESHSecondaryTargetType                        SecondaryTargetType;                               // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1[0x2F];                                     // 0x02E1(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignRuntimeSecondaryAttackRowName(const class FName& InRowName);
	void MarkAsCompleted();
	void SetDisabled(const bool InDisabled, const class UObject* Object);

	bool IsCompleted() const;
	bool IsDisabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSecondaryTargetComponent">();
	}
	static class USHSecondaryTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSecondaryTargetComponent>();
	}
};
static_assert(alignof(USHSecondaryTargetComponent) == 0x000010, "Wrong alignment on USHSecondaryTargetComponent");
static_assert(sizeof(USHSecondaryTargetComponent) == 0x000310, "Wrong size on USHSecondaryTargetComponent");
static_assert(offsetof(USHSecondaryTargetComponent, bCompletedOnBegin) == 0x0002A8, "Member 'USHSecondaryTargetComponent::bCompletedOnBegin' has a wrong offset!");
static_assert(offsetof(USHSecondaryTargetComponent, TargetSize) == 0x0002B0, "Member 'USHSecondaryTargetComponent::TargetSize' has a wrong offset!");
static_assert(offsetof(USHSecondaryTargetComponent, MaxAllowedHeightDelta) == 0x0002C0, "Member 'USHSecondaryTargetComponent::MaxAllowedHeightDelta' has a wrong offset!");
static_assert(offsetof(USHSecondaryTargetComponent, MaxAllowedDistanceToHitPoint2D) == 0x0002C4, "Member 'USHSecondaryTargetComponent::MaxAllowedDistanceToHitPoint2D' has a wrong offset!");
static_assert(offsetof(USHSecondaryTargetComponent, bIsDirectionalOneSideOnly) == 0x0002C8, "Member 'USHSecondaryTargetComponent::bIsDirectionalOneSideOnly' has a wrong offset!");
static_assert(offsetof(USHSecondaryTargetComponent, MinRequiredDirectionsDotProduct) == 0x0002CC, "Member 'USHSecondaryTargetComponent::MinRequiredDirectionsDotProduct' has a wrong offset!");
static_assert(offsetof(USHSecondaryTargetComponent, SecondaryAttackDataRowHandle) == 0x0002D0, "Member 'USHSecondaryTargetComponent::SecondaryAttackDataRowHandle' has a wrong offset!");
static_assert(offsetof(USHSecondaryTargetComponent, SecondaryTargetType) == 0x0002E0, "Member 'USHSecondaryTargetComponent::SecondaryTargetType' has a wrong offset!");

// Class SHProto.ItemsNotificationsVisualizationWidget
// 0x0000 (0x0278 - 0x0278)
class UItemsNotificationsVisualizationWidget final : public UUserWidget
{
public:
	void Update(bool bShow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemsNotificationsVisualizationWidget">();
	}
	static class UItemsNotificationsVisualizationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemsNotificationsVisualizationWidget>();
	}
};
static_assert(alignof(UItemsNotificationsVisualizationWidget) == 0x000008, "Wrong alignment on UItemsNotificationsVisualizationWidget");
static_assert(sizeof(UItemsNotificationsVisualizationWidget) == 0x000278, "Wrong size on UItemsNotificationsVisualizationWidget");

// Class SHProto.SHSettingOptionsPanel
// 0x0068 (0x0528 - 0x04C0)
class USHSettingOptionsPanel final : public USettingsPanelWidget
{
public:
	class UWidget*                                ShowAdvanced_but;                                  // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                GameplayChallenge_but;                             // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemsNotificationsVisualizationWidget* ItemsNotificationsVis_wdg;                         // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayPresetsConfig*                 PresetsConfig;                                     // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class URetroModeDataListAsset> RetroModes;                                        // 0x04E0(0x0030)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_510[0x10];                                     // 0x0510(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USHGameTextsConfig*                     GameTextsConfig;                                   // 0x0520(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GameplayChallengeApply();
	void OnShowInteractionIconVisualization(bool Show_0);
	void OnShowItemsNotificationsVisualization(bool Show_0);
	void OnShowReticleVisualization(bool Show_0);
	void OnShowStruggleIconVisualization(bool Show_0);
	void OnShowTranscriptionVisualization(bool Show_0);
	void OnShowTraversalIconVisualization(bool Show_0);
	void OnShowTutorialsVisualization(bool Show_0);
	void OnUpdateInteractionIconVisualization();
	void OnUpdateReticleVisualization();
	void OnUpdateStruggleIconVisualization();
	void OnUpdateTranscriptionVisualization();
	void OnUpdateTraversalIconVisualization();
	void OnUpdateTutorialsVisualization();
	void ShowItemsNotificationsVisualization(bool Show_0);

	struct FInteractionIconData GetInteractionIconData() const;
	bool GetItemsNotificationsData() const;
	struct FReticleData GetReticleData() const;
	struct FStruggleInputData GetStruggleIconData() const;
	struct FSlateFontInfo GetTranscriptionFontInfo() const;
	struct FTraversalIconData GetTraversalIconData() const;
	struct FTutorialsData GetTutorialsData() const;
	void OnUpdateItemsNotificationsVisualization() const;
	void UpdateItemsNotificationsVisualization() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSettingOptionsPanel">();
	}
	static class USHSettingOptionsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSettingOptionsPanel>();
	}
};
static_assert(alignof(USHSettingOptionsPanel) == 0x000008, "Wrong alignment on USHSettingOptionsPanel");
static_assert(sizeof(USHSettingOptionsPanel) == 0x000528, "Wrong size on USHSettingOptionsPanel");
static_assert(offsetof(USHSettingOptionsPanel, ShowAdvanced_but) == 0x0004C0, "Member 'USHSettingOptionsPanel::ShowAdvanced_but' has a wrong offset!");
static_assert(offsetof(USHSettingOptionsPanel, GameplayChallenge_but) == 0x0004C8, "Member 'USHSettingOptionsPanel::GameplayChallenge_but' has a wrong offset!");
static_assert(offsetof(USHSettingOptionsPanel, ItemsNotificationsVis_wdg) == 0x0004D0, "Member 'USHSettingOptionsPanel::ItemsNotificationsVis_wdg' has a wrong offset!");
static_assert(offsetof(USHSettingOptionsPanel, PresetsConfig) == 0x0004D8, "Member 'USHSettingOptionsPanel::PresetsConfig' has a wrong offset!");
static_assert(offsetof(USHSettingOptionsPanel, RetroModes) == 0x0004E0, "Member 'USHSettingOptionsPanel::RetroModes' has a wrong offset!");
static_assert(offsetof(USHSettingOptionsPanel, GameTextsConfig) == 0x000520, "Member 'USHSettingOptionsPanel::GameTextsConfig' has a wrong offset!");

// Class SHProto.SHSettingsWidget
// 0x0010 (0x0420 - 0x0410)
class USHSettingsWidget final : public USettingsWidget
{
public:
	uint8                                         Pad_410[0x10];                                     // 0x0410(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDlcDataUpdatedHandle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSettingsWidget">();
	}
	static class USHSettingsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSettingsWidget>();
	}
};
static_assert(alignof(USHSettingsWidget) == 0x000008, "Wrong alignment on USHSettingsWidget");
static_assert(sizeof(USHSettingsWidget) == 0x000420, "Wrong size on USHSettingsWidget");

// Class SHProto.SHSimulatedWaterActor
// 0x0060 (0x0310 - 0x02B0)
class ASHSimulatedWaterActor final : public AActor
{
public:
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   WaterPlaneMesh;                                    // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaterPlaneSize;                                    // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     WaterMaterialTemplate;                             // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EffectFixedSize;                                   // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               _DynamicMaterial;                                  // 0x02D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x30];                                     // 0x02E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddEffect(const ESimulatedWaterEffectType InType, const struct FVector& InPosition, const float InRadius, const struct FVector& InVeclocity);
	void SetWaterSimulationEnabled(bool IsEnable);

	class UMaterialInstanceDynamic* GetDynamicInstanceMaterial() const;
	float GetWaterDepthByCharacter(const class ACharacter* InCharacter) const;
	float GetWaterDepthByLocation(const struct FVector& InLocation) const;
	bool GetWaterSimulationEnabled() const;
	float GetWaterWorldAltitude() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSimulatedWaterActor">();
	}
	static class ASHSimulatedWaterActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHSimulatedWaterActor>();
	}
};
static_assert(alignof(ASHSimulatedWaterActor) == 0x000008, "Wrong alignment on ASHSimulatedWaterActor");
static_assert(sizeof(ASHSimulatedWaterActor) == 0x000310, "Wrong size on ASHSimulatedWaterActor");
static_assert(offsetof(ASHSimulatedWaterActor, NiagaraComponent) == 0x0002B0, "Member 'ASHSimulatedWaterActor::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(ASHSimulatedWaterActor, WaterPlaneMesh) == 0x0002B8, "Member 'ASHSimulatedWaterActor::WaterPlaneMesh' has a wrong offset!");
static_assert(offsetof(ASHSimulatedWaterActor, WaterPlaneSize) == 0x0002C0, "Member 'ASHSimulatedWaterActor::WaterPlaneSize' has a wrong offset!");
static_assert(offsetof(ASHSimulatedWaterActor, WaterMaterialTemplate) == 0x0002C8, "Member 'ASHSimulatedWaterActor::WaterMaterialTemplate' has a wrong offset!");
static_assert(offsetof(ASHSimulatedWaterActor, EffectFixedSize) == 0x0002D0, "Member 'ASHSimulatedWaterActor::EffectFixedSize' has a wrong offset!");
static_assert(offsetof(ASHSimulatedWaterActor, _DynamicMaterial) == 0x0002D8, "Member 'ASHSimulatedWaterActor::_DynamicMaterial' has a wrong offset!");

// Class SHProto.SHSlidingDoor
// 0x00B0 (0x0360 - 0x02B0)
class ASHSlidingDoor final : public AActor
{
public:
	class UStaticMeshComponent*                   FrameMesh;                                         // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DoorMesh;                                          // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlaneSideDetectionComponent*           DoorPlaneSideDetectionComponent;                   // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionGenericComponent*         InteractionGeneric;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractionProximitySphere;                        // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            InteractionIcon;                                   // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHRaycastDetectableComponent*          InteractionDetectable;                             // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractionDetectableShape;                        // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconSlotComponent*        InteractionIconSlotFront;                          // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconSlotComponent*        InteractionIconSlotBack;                           // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          PreHitDetector;                                    // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      LockAnimSpotAbove;                                 // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      LockAnimSpotBelow;                                 // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkSlidingDoorComponent*              SHAkSlidingDoorComponent;                          // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          SHAkPortalBounds;                                  // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHAkPortalDoorComponent*               SHAkPortalDoorComponent;                           // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionManagerComponent*         InteractionManager;                                // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHSlidingDoorLockComponent*            LockComponent;                                     // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHSlidingDoorAnimationsComponent*      DoorAnimationsComponent;                           // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHSlidingDoorMovementComponent*        DoorMovement;                                      // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayMapDoorComponent*            GameplayMapObject;                                 // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessDoorAlphaChanged(class USHDoorMovementBaseComponent* MovementComponent);
	void ProcessInteractionManagerInitialized(class USHInteractionManagerComponent* Manager);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSlidingDoor">();
	}
	static class ASHSlidingDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHSlidingDoor>();
	}
};
static_assert(alignof(ASHSlidingDoor) == 0x000008, "Wrong alignment on ASHSlidingDoor");
static_assert(sizeof(ASHSlidingDoor) == 0x000360, "Wrong size on ASHSlidingDoor");
static_assert(offsetof(ASHSlidingDoor, FrameMesh) == 0x0002B0, "Member 'ASHSlidingDoor::FrameMesh' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, DoorMesh) == 0x0002B8, "Member 'ASHSlidingDoor::DoorMesh' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, DoorPlaneSideDetectionComponent) == 0x0002C0, "Member 'ASHSlidingDoor::DoorPlaneSideDetectionComponent' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, InteractionGeneric) == 0x0002C8, "Member 'ASHSlidingDoor::InteractionGeneric' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, InteractionProximitySphere) == 0x0002D0, "Member 'ASHSlidingDoor::InteractionProximitySphere' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, InteractionIcon) == 0x0002D8, "Member 'ASHSlidingDoor::InteractionIcon' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, InteractionDetectable) == 0x0002E0, "Member 'ASHSlidingDoor::InteractionDetectable' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, InteractionDetectableShape) == 0x0002E8, "Member 'ASHSlidingDoor::InteractionDetectableShape' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, InteractionIconSlotFront) == 0x0002F0, "Member 'ASHSlidingDoor::InteractionIconSlotFront' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, InteractionIconSlotBack) == 0x0002F8, "Member 'ASHSlidingDoor::InteractionIconSlotBack' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, PreHitDetector) == 0x000300, "Member 'ASHSlidingDoor::PreHitDetector' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, LockAnimSpotAbove) == 0x000308, "Member 'ASHSlidingDoor::LockAnimSpotAbove' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, LockAnimSpotBelow) == 0x000310, "Member 'ASHSlidingDoor::LockAnimSpotBelow' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, SHAkSlidingDoorComponent) == 0x000318, "Member 'ASHSlidingDoor::SHAkSlidingDoorComponent' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, SHAkPortalBounds) == 0x000320, "Member 'ASHSlidingDoor::SHAkPortalBounds' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, SHAkPortalDoorComponent) == 0x000328, "Member 'ASHSlidingDoor::SHAkPortalDoorComponent' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, InteractionManager) == 0x000330, "Member 'ASHSlidingDoor::InteractionManager' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, LockComponent) == 0x000338, "Member 'ASHSlidingDoor::LockComponent' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, DoorAnimationsComponent) == 0x000340, "Member 'ASHSlidingDoor::DoorAnimationsComponent' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, DoorMovement) == 0x000348, "Member 'ASHSlidingDoor::DoorMovement' has a wrong offset!");
static_assert(offsetof(ASHSlidingDoor, GameplayMapObject) == 0x000350, "Member 'ASHSlidingDoor::GameplayMapObject' has a wrong offset!");

// Class SHProto.SHSlidingDoorAnimationsComponent
// 0x0050 (0x0118 - 0x00C8)
class USHSlidingDoorAnimationsComponent final : public USHDoorAnimationsBaseComponent
{
public:
	class USHSlidingDoorAnimationsSetData*        AnimationsSetData;                                 // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnLockedAnimPlayed;                                // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnOpenAnimPlayed;                                  // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x28];                                      // 0x00F0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MovementSnapFinished(bool WasCompleted);
	void OnLockedAnimEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void OnOpenAnimEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void PutCharacterOnSpotFinished(bool WasCompleted);
	void SHSlidingDoorAnimationEvent__DelegateSignature(class USHSlidingDoorAnimationsComponent* Component);
	void SHSlidingDoorAnimationEventBP__DelegateSignature(class USHSlidingDoorAnimationsComponent* Component);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSlidingDoorAnimationsComponent">();
	}
	static class USHSlidingDoorAnimationsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSlidingDoorAnimationsComponent>();
	}
};
static_assert(alignof(USHSlidingDoorAnimationsComponent) == 0x000008, "Wrong alignment on USHSlidingDoorAnimationsComponent");
static_assert(sizeof(USHSlidingDoorAnimationsComponent) == 0x000118, "Wrong size on USHSlidingDoorAnimationsComponent");
static_assert(offsetof(USHSlidingDoorAnimationsComponent, AnimationsSetData) == 0x0000C8, "Member 'USHSlidingDoorAnimationsComponent::AnimationsSetData' has a wrong offset!");
static_assert(offsetof(USHSlidingDoorAnimationsComponent, OnLockedAnimPlayed) == 0x0000D0, "Member 'USHSlidingDoorAnimationsComponent::OnLockedAnimPlayed' has a wrong offset!");
static_assert(offsetof(USHSlidingDoorAnimationsComponent, OnOpenAnimPlayed) == 0x0000E0, "Member 'USHSlidingDoorAnimationsComponent::OnOpenAnimPlayed' has a wrong offset!");

// Class SHProto.SHSlidingDoorLockComponent
// 0x0000 (0x00E8 - 0x00E8)
class USHSlidingDoorLockComponent final : public USHDoorLockBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSlidingDoorLockComponent">();
	}
	static class USHSlidingDoorLockComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSlidingDoorLockComponent>();
	}
};
static_assert(alignof(USHSlidingDoorLockComponent) == 0x000008, "Wrong alignment on USHSlidingDoorLockComponent");
static_assert(sizeof(USHSlidingDoorLockComponent) == 0x0000E8, "Wrong size on USHSlidingDoorLockComponent");

// Class SHProto.SHSlidingDoorMovementComponent
// 0x0060 (0x0188 - 0x0128)
class USHSlidingDoorMovementComponent final : public USHDoorMovementBaseComponent
{
public:
	float                                         BeginPlayDoorMovementAlpha;                        // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementRange;                                     // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MovementDirection;                                 // 0x0130(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DefaultOpenMovementCurve;                          // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DoorMovementAlphaSave;                             // 0x0150(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_154[0x34];                                     // 0x0154(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OverrideDoorAlpha(float InDoorAlpha);
	bool RequestPlayCurveMovement(class UCurveFloat* InCurve);
	bool RequestPlayDefaultOpenMovement();
	void SHSlidingDoorMovementEvent__DelegateSignature(class USHSlidingDoorMovementComponent* Component);
	void SHSlidingDoorMovementEventBP__DelegateSignature(class USHSlidingDoorMovementComponent* Component);
	void StopCurveMovement();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSlidingDoorMovementComponent">();
	}
	static class USHSlidingDoorMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSlidingDoorMovementComponent>();
	}
};
static_assert(alignof(USHSlidingDoorMovementComponent) == 0x000008, "Wrong alignment on USHSlidingDoorMovementComponent");
static_assert(sizeof(USHSlidingDoorMovementComponent) == 0x000188, "Wrong size on USHSlidingDoorMovementComponent");
static_assert(offsetof(USHSlidingDoorMovementComponent, BeginPlayDoorMovementAlpha) == 0x000128, "Member 'USHSlidingDoorMovementComponent::BeginPlayDoorMovementAlpha' has a wrong offset!");
static_assert(offsetof(USHSlidingDoorMovementComponent, MovementRange) == 0x00012C, "Member 'USHSlidingDoorMovementComponent::MovementRange' has a wrong offset!");
static_assert(offsetof(USHSlidingDoorMovementComponent, MovementDirection) == 0x000130, "Member 'USHSlidingDoorMovementComponent::MovementDirection' has a wrong offset!");
static_assert(offsetof(USHSlidingDoorMovementComponent, DefaultOpenMovementCurve) == 0x000148, "Member 'USHSlidingDoorMovementComponent::DefaultOpenMovementCurve' has a wrong offset!");
static_assert(offsetof(USHSlidingDoorMovementComponent, DoorMovementAlphaSave) == 0x000150, "Member 'USHSlidingDoorMovementComponent::DoorMovementAlphaSave' has a wrong offset!");

// Class SHProto.SHSpawnpointsItemsDatabase
// 0x0020 (0x0050 - 0x0030)
class USHSpawnpointsItemsDatabase final : public UDataAsset
{
public:
	TArray<struct FSHSpawnpointItemsDataSet>      CummulativeSpawnpoints;                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSHSpawnpointItemsDataSet>      OthersSpawnpoints;                                 // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSpawnpointsItemsDatabase">();
	}
	static class USHSpawnpointsItemsDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSpawnpointsItemsDatabase>();
	}
};
static_assert(alignof(USHSpawnpointsItemsDatabase) == 0x000008, "Wrong alignment on USHSpawnpointsItemsDatabase");
static_assert(sizeof(USHSpawnpointsItemsDatabase) == 0x000050, "Wrong size on USHSpawnpointsItemsDatabase");
static_assert(offsetof(USHSpawnpointsItemsDatabase, CummulativeSpawnpoints) == 0x000030, "Member 'USHSpawnpointsItemsDatabase::CummulativeSpawnpoints' has a wrong offset!");
static_assert(offsetof(USHSpawnpointsItemsDatabase, OthersSpawnpoints) == 0x000040, "Member 'USHSpawnpointsItemsDatabase::OthersSpawnpoints' has a wrong offset!");

// Class SHProto.SHSpawnpointsTutorialsDatabase
// 0x0020 (0x0050 - 0x0030)
class USHSpawnpointsTutorialsDatabase final : public UDataAsset
{
public:
	TArray<struct FSHSpawnpointTutorialsDataSet>  CummulativeSpawnpoints;                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSHSpawnpointTutorialsDataSet>  OthersSpawnpoints;                                 // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSpawnpointsTutorialsDatabase">();
	}
	static class USHSpawnpointsTutorialsDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSpawnpointsTutorialsDatabase>();
	}
};
static_assert(alignof(USHSpawnpointsTutorialsDatabase) == 0x000008, "Wrong alignment on USHSpawnpointsTutorialsDatabase");
static_assert(sizeof(USHSpawnpointsTutorialsDatabase) == 0x000050, "Wrong size on USHSpawnpointsTutorialsDatabase");
static_assert(offsetof(USHSpawnpointsTutorialsDatabase, CummulativeSpawnpoints) == 0x000030, "Member 'USHSpawnpointsTutorialsDatabase::CummulativeSpawnpoints' has a wrong offset!");
static_assert(offsetof(USHSpawnpointsTutorialsDatabase, OthersSpawnpoints) == 0x000040, "Member 'USHSpawnpointsTutorialsDatabase::OthersSpawnpoints' has a wrong offset!");

// Class SHProto.SHSpawnPointSettings
// 0x0060 (0x0098 - 0x0038)
class USHSpawnPointSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class USHSpawnpointsItemsDatabase> SpawnpointsItemsDatabase;                          // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USHSpawnpointsTutorialsDatabase> SpawnpointsTutorialsDatabase;                      // 0x0068(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSpawnPointSettings">();
	}
	static class USHSpawnPointSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSpawnPointSettings>();
	}
};
static_assert(alignof(USHSpawnPointSettings) == 0x000008, "Wrong alignment on USHSpawnPointSettings");
static_assert(sizeof(USHSpawnPointSettings) == 0x000098, "Wrong size on USHSpawnPointSettings");
static_assert(offsetof(USHSpawnPointSettings, SpawnpointsItemsDatabase) == 0x000038, "Member 'USHSpawnPointSettings::SpawnpointsItemsDatabase' has a wrong offset!");
static_assert(offsetof(USHSpawnPointSettings, SpawnpointsTutorialsDatabase) == 0x000068, "Member 'USHSpawnPointSettings::SpawnpointsTutorialsDatabase' has a wrong offset!");

// Class SHProto.SHStairsBase
// 0x0020 (0x02D0 - 0x02B0)
class ASHStairsBase final : public AActor
{
public:
	class UStaticMeshComponent*                   StairsGraphicalMesh;                               // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StairsProxyMesh;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USHStairsDetectionZoneComponent*> DetectionZoneComponents;                           // 0x02C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHStairsBase">();
	}
	static class ASHStairsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHStairsBase>();
	}
};
static_assert(alignof(ASHStairsBase) == 0x000008, "Wrong alignment on ASHStairsBase");
static_assert(sizeof(ASHStairsBase) == 0x0002D0, "Wrong size on ASHStairsBase");
static_assert(offsetof(ASHStairsBase, StairsGraphicalMesh) == 0x0002B0, "Member 'ASHStairsBase::StairsGraphicalMesh' has a wrong offset!");
static_assert(offsetof(ASHStairsBase, StairsProxyMesh) == 0x0002B8, "Member 'ASHStairsBase::StairsProxyMesh' has a wrong offset!");
static_assert(offsetof(ASHStairsBase, DetectionZoneComponents) == 0x0002C0, "Member 'ASHStairsBase::DetectionZoneComponents' has a wrong offset!");

// Class SHProto.SHStairsBaseWorldCache
// 0x0010 (0x0040 - 0x0030)
class USHStairsBaseWorldCache final : public UWorldSubsystem
{
public:
	TArray<class ASHStairsBase*>                  Cache;                                             // 0x0030(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHStairsBaseWorldCache">();
	}
	static class USHStairsBaseWorldCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHStairsBaseWorldCache>();
	}
};
static_assert(alignof(USHStairsBaseWorldCache) == 0x000008, "Wrong alignment on USHStairsBaseWorldCache");
static_assert(sizeof(USHStairsBaseWorldCache) == 0x000040, "Wrong size on USHStairsBaseWorldCache");
static_assert(offsetof(USHStairsBaseWorldCache, Cache) == 0x000030, "Member 'USHStairsBaseWorldCache::Cache' has a wrong offset!");

// Class SHProto.SHStairsDetectionZoneComponent
// 0x0020 (0x02C0 - 0x02A0)
class USHStairsDetectionZoneComponent final : public USceneComponent
{
public:
	struct FVector                                Extent;                                            // 0x02A0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHStairsDetectionZoneComponent">();
	}
	static class USHStairsDetectionZoneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHStairsDetectionZoneComponent>();
	}
};
static_assert(alignof(USHStairsDetectionZoneComponent) == 0x000010, "Wrong alignment on USHStairsDetectionZoneComponent");
static_assert(sizeof(USHStairsDetectionZoneComponent) == 0x0002C0, "Wrong size on USHStairsDetectionZoneComponent");
static_assert(offsetof(USHStairsDetectionZoneComponent, Extent) == 0x0002A0, "Member 'USHStairsDetectionZoneComponent::Extent' has a wrong offset!");
static_assert(offsetof(USHStairsDetectionZoneComponent, Enabled) == 0x0002B8, "Member 'USHStairsDetectionZoneComponent::Enabled' has a wrong offset!");

// Class SHProto.SHStealthModeCmbSubcomp
// 0x0090 (0x00C8 - 0x0038)
class USHStealthModeCmbSubcomp final : public USHCombatSubcomponentBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHMovementDataStruct                  StealthModeMovementData;                           // 0x0048(0x0028)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHBlendData                           StealthModeFOVBlend;                               // 0x0078(0x0020)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x30];                                      // 0x0098(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAllowStealthModeWhenBlocked(const bool Allow, const class UObject* Object);
	void SetStealthModeBlocked(const bool Blocked, const class UObject* Object);

	bool IsInStealthMode() const;
	bool IsStealthModeBlocked() const;
	bool IsStealthModeWhenBlockedAllowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHStealthModeCmbSubcomp">();
	}
	static class USHStealthModeCmbSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHStealthModeCmbSubcomp>();
	}
};
static_assert(alignof(USHStealthModeCmbSubcomp) == 0x000008, "Wrong alignment on USHStealthModeCmbSubcomp");
static_assert(sizeof(USHStealthModeCmbSubcomp) == 0x0000C8, "Wrong size on USHStealthModeCmbSubcomp");
static_assert(offsetof(USHStealthModeCmbSubcomp, StealthModeMovementData) == 0x000048, "Member 'USHStealthModeCmbSubcomp::StealthModeMovementData' has a wrong offset!");
static_assert(offsetof(USHStealthModeCmbSubcomp, StealthModeFOVBlend) == 0x000078, "Member 'USHStealthModeCmbSubcomp::StealthModeFOVBlend' has a wrong offset!");

// Class SHProto.SHStompedDeadEnemiesEndingValueProcessor
// 0x0030 (0x0060 - 0x0030)
class USHStompedDeadEnemiesEndingValueProcessor final : public USHEndingValueProcessor
{
public:
	struct FDataTableRowHandle                    StompAttackDataRowHandle;                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         RequiredMinBloodPuddleProgressAlpha;               // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEffectHandle                          LightEffect;                                       // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x14];                                      // 0x004C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessDeadEnemyDamaged(class ASHItemWeaponMelee* MeleeWeapon, class AActor* DamagedActorContext);
	void ProcessPrimaryAttackStarted(class USHMeleeCmbSubcomp* MeleeCombat, class ASHItemWeapon* ItemWeaponContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHStompedDeadEnemiesEndingValueProcessor">();
	}
	static class USHStompedDeadEnemiesEndingValueProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHStompedDeadEnemiesEndingValueProcessor>();
	}
};
static_assert(alignof(USHStompedDeadEnemiesEndingValueProcessor) == 0x000008, "Wrong alignment on USHStompedDeadEnemiesEndingValueProcessor");
static_assert(sizeof(USHStompedDeadEnemiesEndingValueProcessor) == 0x000060, "Wrong size on USHStompedDeadEnemiesEndingValueProcessor");
static_assert(offsetof(USHStompedDeadEnemiesEndingValueProcessor, StompAttackDataRowHandle) == 0x000030, "Member 'USHStompedDeadEnemiesEndingValueProcessor::StompAttackDataRowHandle' has a wrong offset!");
static_assert(offsetof(USHStompedDeadEnemiesEndingValueProcessor, RequiredMinBloodPuddleProgressAlpha) == 0x000040, "Member 'USHStompedDeadEnemiesEndingValueProcessor::RequiredMinBloodPuddleProgressAlpha' has a wrong offset!");
static_assert(offsetof(USHStompedDeadEnemiesEndingValueProcessor, LightEffect) == 0x000044, "Member 'USHStompedDeadEnemiesEndingValueProcessor::LightEffect' has a wrong offset!");

// Class SHProto.SHStressCmbSubcomp
// 0x0030 (0x0068 - 0x0038)
class USHStressCmbSubcomp final : public USHCombatSubcomponentBase
{
public:
	class USHStressCmbSubcompSettings*            Settings;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessRangedFireSuccess(class USHRangedCmbSubcomp* RangedCombatSubcomponent, class ASHItemWeapon* ItemWeaponContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHStressCmbSubcomp">();
	}
	static class USHStressCmbSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHStressCmbSubcomp>();
	}
};
static_assert(alignof(USHStressCmbSubcomp) == 0x000008, "Wrong alignment on USHStressCmbSubcomp");
static_assert(sizeof(USHStressCmbSubcomp) == 0x000068, "Wrong size on USHStressCmbSubcomp");
static_assert(offsetof(USHStressCmbSubcomp, Settings) == 0x000038, "Member 'USHStressCmbSubcomp::Settings' has a wrong offset!");

// Class SHProto.SHStruggleCmbSubcompSettings
// 0x0038 (0x0068 - 0x0030)
class USHStruggleCmbSubcompSettings final : public UDataAsset
{
public:
	struct FRotator                               LookAtOffsetRotation;                              // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LookAtDuration;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEffectHandle                          SpecialEffectStruggle;                             // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FEffectHandle                          SpecialEffectStruggleWin;                          // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FEffectHandle                          SpecialEffectStruggleLose;                         // 0x005C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHStruggleCmbSubcompSettings">();
	}
	static class USHStruggleCmbSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHStruggleCmbSubcompSettings>();
	}
};
static_assert(alignof(USHStruggleCmbSubcompSettings) == 0x000008, "Wrong alignment on USHStruggleCmbSubcompSettings");
static_assert(sizeof(USHStruggleCmbSubcompSettings) == 0x000068, "Wrong size on USHStruggleCmbSubcompSettings");
static_assert(offsetof(USHStruggleCmbSubcompSettings, LookAtOffsetRotation) == 0x000030, "Member 'USHStruggleCmbSubcompSettings::LookAtOffsetRotation' has a wrong offset!");
static_assert(offsetof(USHStruggleCmbSubcompSettings, LookAtDuration) == 0x000048, "Member 'USHStruggleCmbSubcompSettings::LookAtDuration' has a wrong offset!");
static_assert(offsetof(USHStruggleCmbSubcompSettings, SpecialEffectStruggle) == 0x00004C, "Member 'USHStruggleCmbSubcompSettings::SpecialEffectStruggle' has a wrong offset!");
static_assert(offsetof(USHStruggleCmbSubcompSettings, SpecialEffectStruggleWin) == 0x000054, "Member 'USHStruggleCmbSubcompSettings::SpecialEffectStruggleWin' has a wrong offset!");
static_assert(offsetof(USHStruggleCmbSubcompSettings, SpecialEffectStruggleLose) == 0x00005C, "Member 'USHStruggleCmbSubcompSettings::SpecialEffectStruggleLose' has a wrong offset!");

// Class SHProto.SHStruggleCmbSubcomp
// 0x00A0 (0x00D8 - 0x0038)
class USHStruggleCmbSubcomp final : public USHCombatSubcomponentBase
{
public:
	class USHStruggleCmbSubcompSettings*          ComponentSettings;                                 // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x98];                                      // 0x0040(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHStruggleCmbSubcomp">();
	}
	static class USHStruggleCmbSubcomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHStruggleCmbSubcomp>();
	}
};
static_assert(alignof(USHStruggleCmbSubcomp) == 0x000008, "Wrong alignment on USHStruggleCmbSubcomp");
static_assert(sizeof(USHStruggleCmbSubcomp) == 0x0000D8, "Wrong size on USHStruggleCmbSubcomp");
static_assert(offsetof(USHStruggleCmbSubcomp, ComponentSettings) == 0x000038, "Member 'USHStruggleCmbSubcomp::ComponentSettings' has a wrong offset!");

// Class SHProto.SHStruggleWithHoldInputTutorialHandler
// 0x0000 (0x0048 - 0x0048)
class USHStruggleWithHoldInputTutorialHandler final : public USHStruggleTutorialHandler
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHStruggleWithHoldInputTutorialHandler">();
	}
	static class USHStruggleWithHoldInputTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHStruggleWithHoldInputTutorialHandler>();
	}
};
static_assert(alignof(USHStruggleWithHoldInputTutorialHandler) == 0x000008, "Wrong alignment on USHStruggleWithHoldInputTutorialHandler");
static_assert(sizeof(USHStruggleWithHoldInputTutorialHandler) == 0x000048, "Wrong size on USHStruggleWithHoldInputTutorialHandler");

// Class SHProto.SHStruggleWithMashInputTutorialHandler
// 0x0000 (0x0048 - 0x0048)
class USHStruggleWithMashInputTutorialHandler final : public USHStruggleTutorialHandler
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHStruggleWithMashInputTutorialHandler">();
	}
	static class USHStruggleWithMashInputTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHStruggleWithMashInputTutorialHandler>();
	}
};
static_assert(alignof(USHStruggleWithMashInputTutorialHandler) == 0x000008, "Wrong alignment on USHStruggleWithMashInputTutorialHandler");
static_assert(sizeof(USHStruggleWithMashInputTutorialHandler) == 0x000048, "Wrong size on USHStruggleWithMashInputTutorialHandler");

// Class SHProto.SHSubcomponentSettingsProviderInterface
// 0x0000 (0x0028 - 0x0028)
class ISHSubcomponentSettingsProviderInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSubcomponentSettingsProviderInterface">();
	}
	static class ISHSubcomponentSettingsProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHSubcomponentSettingsProviderInterface>();
	}
};
static_assert(alignof(ISHSubcomponentSettingsProviderInterface) == 0x000008, "Wrong alignment on ISHSubcomponentSettingsProviderInterface");
static_assert(sizeof(ISHSubcomponentSettingsProviderInterface) == 0x000028, "Wrong size on ISHSubcomponentSettingsProviderInterface");

// Class SHProto.SHSwarmSpawnRegion
// 0x0000 (0x02D0 - 0x02D0)
class USHSwarmSpawnRegion final : public USHSwarmRegionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSwarmSpawnRegion">();
	}
	static class USHSwarmSpawnRegion* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSwarmSpawnRegion>();
	}
};
static_assert(alignof(USHSwarmSpawnRegion) == 0x000010, "Wrong alignment on USHSwarmSpawnRegion");
static_assert(sizeof(USHSwarmSpawnRegion) == 0x0002D0, "Wrong size on USHSwarmSpawnRegion");

// Class SHProto.SHSwarmDestroyRegion
// 0x0000 (0x02D0 - 0x02D0)
class USHSwarmDestroyRegion final : public USHSwarmRegionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSwarmDestroyRegion">();
	}
	static class USHSwarmDestroyRegion* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSwarmDestroyRegion>();
	}
};
static_assert(alignof(USHSwarmDestroyRegion) == 0x000010, "Wrong alignment on USHSwarmDestroyRegion");
static_assert(sizeof(USHSwarmDestroyRegion) == 0x0002D0, "Wrong size on USHSwarmDestroyRegion");

// Class SHProto.SHSwarmReflectRegion
// 0x0000 (0x02D0 - 0x02D0)
class USHSwarmReflectRegion final : public USHSwarmRegionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSwarmReflectRegion">();
	}
	static class USHSwarmReflectRegion* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSwarmReflectRegion>();
	}
};
static_assert(alignof(USHSwarmReflectRegion) == 0x000010, "Wrong alignment on USHSwarmReflectRegion");
static_assert(sizeof(USHSwarmReflectRegion) == 0x0002D0, "Wrong size on USHSwarmReflectRegion");

// Class SHProto.SHSwarmFollowRegion
// 0x0000 (0x02D0 - 0x02D0)
class USHSwarmFollowRegion final : public USHSwarmRegionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSwarmFollowRegion">();
	}
	static class USHSwarmFollowRegion* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSwarmFollowRegion>();
	}
};
static_assert(alignof(USHSwarmFollowRegion) == 0x000010, "Wrong alignment on USHSwarmFollowRegion");
static_assert(sizeof(USHSwarmFollowRegion) == 0x0002D0, "Wrong size on USHSwarmFollowRegion");

// Class SHProto.SHSwarmFollowPoint
// 0x0000 (0x02D0 - 0x02D0)
class USHSwarmFollowPoint final : public USHSwarmRegionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSwarmFollowPoint">();
	}
	static class USHSwarmFollowPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSwarmFollowPoint>();
	}
};
static_assert(alignof(USHSwarmFollowPoint) == 0x000010, "Wrong alignment on USHSwarmFollowPoint");
static_assert(sizeof(USHSwarmFollowPoint) == 0x0002D0, "Wrong size on USHSwarmFollowPoint");

// Class SHProto.SHSwarmVolume
// 0x0000 (0x02E8 - 0x02E8)
class ASHSwarmVolume final : public AVolume
{
public:
	void SetColorShape(const struct FColor& ShapeColor, float Opacity, bool DisplayShadedVolume);

	bool IsPointWithin(const struct FVector& Point) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSwarmVolume">();
	}
	static class ASHSwarmVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHSwarmVolume>();
	}
};
static_assert(alignof(ASHSwarmVolume) == 0x000008, "Wrong alignment on ASHSwarmVolume");
static_assert(sizeof(ASHSwarmVolume) == 0x0002E8, "Wrong size on ASHSwarmVolume");

// Class SHProto.SHSystemFXDataMappings
// 0x0050 (0x0080 - 0x0030)
class USHSystemFXDataMappings final : public UDataAsset
{
public:
	TMap<class UPhysicalMaterial*, class USHSystemFXData*> Mappings;                                          // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSystemFXDataMappings">();
	}
	static class USHSystemFXDataMappings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSystemFXDataMappings>();
	}
};
static_assert(alignof(USHSystemFXDataMappings) == 0x000008, "Wrong alignment on USHSystemFXDataMappings");
static_assert(sizeof(USHSystemFXDataMappings) == 0x000080, "Wrong size on USHSystemFXDataMappings");
static_assert(offsetof(USHSystemFXDataMappings, Mappings) == 0x000030, "Member 'USHSystemFXDataMappings::Mappings' has a wrong offset!");

// Class SHProto.SHSystemFXData
// 0x00D0 (0x0100 - 0x0030)
class USHSystemFXData final : public UDataAsset
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          ImpactFX;                                          // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactFXLifeTime;                                  // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCustomDecalData;                                // 0x0064(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomDecalSize;                                   // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 DecalAtlasFrames;                                  // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      ImpactDecal;                                       // 0x0080(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactDecalSize;                                   // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactDecalExtraRandomSize;                        // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAkSwitchValue>          ImpactSoundSwitch;                                 // 0x00D0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHSystemFXData">();
	}
	static class USHSystemFXData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHSystemFXData>();
	}
};
static_assert(alignof(USHSystemFXData) == 0x000008, "Wrong alignment on USHSystemFXData");
static_assert(sizeof(USHSystemFXData) == 0x000100, "Wrong size on USHSystemFXData");
static_assert(offsetof(USHSystemFXData, ImpactFX) == 0x000030, "Member 'USHSystemFXData::ImpactFX' has a wrong offset!");
static_assert(offsetof(USHSystemFXData, ImpactFXLifeTime) == 0x000060, "Member 'USHSystemFXData::ImpactFXLifeTime' has a wrong offset!");
static_assert(offsetof(USHSystemFXData, UseCustomDecalData) == 0x000064, "Member 'USHSystemFXData::UseCustomDecalData' has a wrong offset!");
static_assert(offsetof(USHSystemFXData, CustomDecalSize) == 0x000068, "Member 'USHSystemFXData::CustomDecalSize' has a wrong offset!");
static_assert(offsetof(USHSystemFXData, DecalAtlasFrames) == 0x000070, "Member 'USHSystemFXData::DecalAtlasFrames' has a wrong offset!");
static_assert(offsetof(USHSystemFXData, ImpactDecal) == 0x000080, "Member 'USHSystemFXData::ImpactDecal' has a wrong offset!");
static_assert(offsetof(USHSystemFXData, ImpactDecalSize) == 0x0000B0, "Member 'USHSystemFXData::ImpactDecalSize' has a wrong offset!");
static_assert(offsetof(USHSystemFXData, ImpactDecalExtraRandomSize) == 0x0000C8, "Member 'USHSystemFXData::ImpactDecalExtraRandomSize' has a wrong offset!");
static_assert(offsetof(USHSystemFXData, ImpactSoundSwitch) == 0x0000D0, "Member 'USHSystemFXData::ImpactSoundSwitch' has a wrong offset!");

// Class SHProto.SHTimeManagerComponent
// 0x0020 (0x00C0 - 0x00A0)
class USHTimeManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTimeManagerComponent">();
	}
	static class USHTimeManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTimeManagerComponent>();
	}
};
static_assert(alignof(USHTimeManagerComponent) == 0x000008, "Wrong alignment on USHTimeManagerComponent");
static_assert(sizeof(USHTimeManagerComponent) == 0x0000C0, "Wrong size on USHTimeManagerComponent");

// Class SHProto.SHTraceHelperStatics
// 0x0000 (0x0028 - 0x0028)
class USHTraceHelperStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool K2_ComplexCapsuleTraceByChannel(struct FHitResult* OutHitResult, struct FRotator* OutHitRotation, float* OutHitCapsuleHalfHeight, float* OutHitCapsuleHeightScalar, class UObject* InWorldContext, float InCapsuleRadius, float InCapsuleFromHalfHeight, float InCapsuleToHalfHeight, const struct FVector& InFromLocation, const struct FVector& InToLocation, const struct FRotator& InFromRotation, const struct FRotator& InDeltaRotation, float InRotationPrecisionAngle, float InTraceDensity, float InTopTraceHeightScalar, float InBottomTraceHeightScalar, float InCollisionPullbackTime, ETraceTypeQuery InTraceChannel, bool InTraceComplex, const TArray<class AActor*>& InActorsToIgnore, float InDrawDebugDuration);
	static bool K2_ComplexCapsuleTraceByComponent(struct FHitResult* OutHitResult, struct FRotator* OutHitRotation, float* OutHitCapsuleHalfHeight, float* OutHitCapsuleHeightScalar, class UCapsuleComponent* InCapsuleComponent, float InCapsuleRadiusIncrease, float InCapsuleHalfHeightIncrease, float InCapsuleToHalfHeight, const struct FVector& InToLocation, const struct FRotator& InToDeltaRotation, float InRotationPrecisionAngle, float InTraceDensity, float InTopTraceHeightScalar, float InBottomTraceHeightScalar, float InCollisionPullbackTime, bool InTraceComplex, const TArray<class AActor*>& InActorsToIgnore, float InDrawDebugDuration);
	static bool K2_ComplexCapsuleTraceByProfile(struct FHitResult* OutHitResult, struct FRotator* OutHitRotation, float* OutHitCapsuleHalfHeight, float* OutHitCapsuleHeightScalar, class UObject* InWorldContext, float InCapsuleRadius, float InCapsuleFromHalfHeight, float InCapsuleToHalfHeight, const struct FVector& InFromLocation, const struct FVector& InToLocation, const struct FRotator& InFromRotation, const struct FRotator& InDeltaRotation, float InRotationPrecisionAngle, float InTraceDensity, float InTopTraceHeightScalar, float InBottomTraceHeightScalar, float InCollisionPullbackTime, class FName InCollisionProfileName, bool InTraceComplex, const TArray<class AActor*>& InActorsToIgnore, float InDrawDebugDuration);
	static bool K2_RotateCapsuleOutOfCollisionByChannel(struct FHitResult* OutHitResult, struct FVector* OutLocation, struct FRotator* OutRotation, class UObject* InWorldContext, float InCapsuleRadius, float InCapsuleHalfHeight, float InRotationAnchorHeightScalar, const struct FVector& InLocation, const struct FRotator& InRotation, const struct FVector2D& InPullbackRotationMinimumAngles, const struct FVector2D& InPullbackRotationMaximumAngles, float InRotationPrecisionAngle, bool InSnapBackToCollision, float InTraceDensity, float InTopTraceHeightScalar, float InBottomTraceHeightScalar, ETraceTypeQuery InTraceChannel, bool InTraceComplex, const TArray<class AActor*>& InActorsToIgnore, float InDrawDebugDuration);
	static bool K2_RotateCapsuleOutOfCollisionByComponent(struct FHitResult* OutHitResult, struct FVector* OutLocation, struct FRotator* OutRotation, class UCapsuleComponent* InCapsuleComponent, float InCapsuleRadiusIncrease, float InCapsuleHalfHeightIncrease, float InRotationAnchorHeightScalar, const struct FVector2D& InPullbackRotationMinimumAngles, const struct FVector2D& InPullbackRotationMaximumAngles, float InRotationPrecisionAngle, bool InSnapBackToCollision, float InTraceDensity, float InTopTraceHeightScalar, float InBottomTraceHeightScalar, bool InTraceComplex, const TArray<class AActor*>& InActorsToIgnore, float InDrawDebugDuration);
	static bool K2_RotateCapsuleOutOfCollisionByProfile(struct FHitResult* OutHitResult, struct FVector* OutLocation, struct FRotator* OutRotation, class UObject* InWorldContext, float InCapsuleRadius, float InCapsuleHalfHeight, float InRotationAnchorHeightScalar, const struct FVector& InLocation, const struct FRotator& InRotation, const struct FVector2D& InPullbackRotationMinimumAngles, const struct FVector2D& InPullbackRotationMaximumAngles, float InRotationPrecisionAngle, bool InSnapBackToCollision, float InTraceDensity, float InTopTraceHeightScalar, float InBottomTraceHeightScalar, class FName InCollisionProfileName, bool InTraceComplex, const TArray<class AActor*>& InActorsToIgnore, float InDrawDebugDuration);
	static bool K2_TraceSphereAlongCapsuleByChannel(struct FHitResult* OutHitResult, float* OutSignedCollisionDistanceScalar, class UObject* InWorldContext, const struct FVector& InLocation, const struct FQuat& InRotation, float InCapsuleRadius, float InCapsuleHalfHeight, float InCapsuleAnchorHeightScalar, float InTopTraceHeightScalar, float InBottomTraceHeightScalar, ETraceTypeQuery InTraceChannel, bool InTraceComplex, const TArray<class AActor*>& InActorsToIgnore, float InDrawDebugDuration);
	static bool K2_TraceSphereAlongCapsuleByComponent(struct FHitResult* OutHitResult, float* OutSignedCollisionDistanceScalar, class UCapsuleComponent* InCapsuleComponent, float InCapsuleRadiusIncrease, float InCapsuleHalfHeightIncrease, float InCapsuleAnchorHeightScalar, float InTopTraceHeightScalar, float InBottomTraceHeightScalar, ETraceTypeQuery InTraceChannel, bool InTraceComplex, const TArray<class AActor*>& InActorsToIgnore, float InDrawDebugDuration);
	static bool K2_TraceSphereAlongCapsuleByProfile(struct FHitResult* OutHitResult, float* OutSignedCollisionDistanceScalar, class UObject* InWorldContext, const struct FVector& InLocation, const struct FQuat& InRotation, float InCapsuleRadius, float InCapsuleHalfHeight, float InCapsuleAnchorHeightScalar, float InTopTraceHeightScalar, float InBottomTraceHeightScalar, class FName InCollisionProfileName, bool InTraceComplex, const TArray<class AActor*>& InActorsToIgnore, float InDrawDebugDuration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraceHelperStatics">();
	}
	static class USHTraceHelperStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTraceHelperStatics>();
	}
};
static_assert(alignof(USHTraceHelperStatics) == 0x000008, "Wrong alignment on USHTraceHelperStatics");
static_assert(sizeof(USHTraceHelperStatics) == 0x000028, "Wrong size on USHTraceHelperStatics");

// Class SHProto.SHTraversalClimbAnimInstance
// 0x00E0 (0x0430 - 0x0350)
class USHTraversalClimbAnimInstance final : public UAnimInstance
{
public:
	bool                                          bPlayStartTraversal;                               // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_349[0x3];                                      // 0x0349(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EdgeDistance;                                      // 0x034C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeltaHeight;                                       // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace*                            AssignedClimbUpBlendSpace;                         // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace*                            AssignedJumpDownBlendSpace;                        // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTraversalDataSetup;                               // 0x0368(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_369[0xC7];                                     // 0x0369(0x00C7)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastEndOfTraversal();
	void SetupEventBP();

	bool IsOnLowerFloor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalClimbAnimInstance">();
	}
	static class USHTraversalClimbAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTraversalClimbAnimInstance>();
	}
};
static_assert(alignof(USHTraversalClimbAnimInstance) == 0x000010, "Wrong alignment on USHTraversalClimbAnimInstance");
static_assert(sizeof(USHTraversalClimbAnimInstance) == 0x000430, "Wrong size on USHTraversalClimbAnimInstance");
static_assert(offsetof(USHTraversalClimbAnimInstance, bPlayStartTraversal) == 0x000348, "Member 'USHTraversalClimbAnimInstance::bPlayStartTraversal' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbAnimInstance, EdgeDistance) == 0x00034C, "Member 'USHTraversalClimbAnimInstance::EdgeDistance' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbAnimInstance, DeltaHeight) == 0x000350, "Member 'USHTraversalClimbAnimInstance::DeltaHeight' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbAnimInstance, AssignedClimbUpBlendSpace) == 0x000358, "Member 'USHTraversalClimbAnimInstance::AssignedClimbUpBlendSpace' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbAnimInstance, AssignedJumpDownBlendSpace) == 0x000360, "Member 'USHTraversalClimbAnimInstance::AssignedJumpDownBlendSpace' has a wrong offset!");
static_assert(offsetof(USHTraversalClimbAnimInstance, bTraversalDataSetup) == 0x000368, "Member 'USHTraversalClimbAnimInstance::bTraversalDataSetup' has a wrong offset!");

// Class SHProto.SHTraversalIconBaseManager
// 0x0038 (0x00D8 - 0x00A0)
class USHTraversalIconBaseManager : public UActorComponent
{
public:
	float                                         IconUnavailableOpacityMultiplier;                  // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USHTraversalBaseComponent*              AssignedTraversalComponent;                        // 0x00A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            AssignedIconComponent;                             // 0x00B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessObstacleProximityFoundCharacterEvent(class USHTraversalBaseComponent* InTraversalComponent);
	void ProcessObstacleProximityLostCharacterEvent(class USHTraversalBaseComponent* InTraversalComponent);
	void ProcessObstacleTraversalUnavailableChangedEvent(class USHTraversalBaseComponent* InTraversalComponent);
	void RegisterRequisites(class USHTraversalBaseComponent* InTraversalComponent, class USHInteractionIconComponent* InIconComponent);
	void ResetForcedIconState();
	void SetForcedIconState(ESHInteractionIconState InForcedState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalIconBaseManager">();
	}
	static class USHTraversalIconBaseManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTraversalIconBaseManager>();
	}
};
static_assert(alignof(USHTraversalIconBaseManager) == 0x000008, "Wrong alignment on USHTraversalIconBaseManager");
static_assert(sizeof(USHTraversalIconBaseManager) == 0x0000D8, "Wrong size on USHTraversalIconBaseManager");
static_assert(offsetof(USHTraversalIconBaseManager, IconUnavailableOpacityMultiplier) == 0x0000A0, "Member 'USHTraversalIconBaseManager::IconUnavailableOpacityMultiplier' has a wrong offset!");
static_assert(offsetof(USHTraversalIconBaseManager, AssignedTraversalComponent) == 0x0000A8, "Member 'USHTraversalIconBaseManager::AssignedTraversalComponent' has a wrong offset!");
static_assert(offsetof(USHTraversalIconBaseManager, AssignedIconComponent) == 0x0000B0, "Member 'USHTraversalIconBaseManager::AssignedIconComponent' has a wrong offset!");

// Class SHProto.SHTraversalClimbIconManager
// 0x0000 (0x00D8 - 0x00D8)
class USHTraversalClimbIconManager final : public USHTraversalIconBaseManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalClimbIconManager">();
	}
	static class USHTraversalClimbIconManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTraversalClimbIconManager>();
	}
};
static_assert(alignof(USHTraversalClimbIconManager) == 0x000008, "Wrong alignment on USHTraversalClimbIconManager");
static_assert(sizeof(USHTraversalClimbIconManager) == 0x0000D8, "Wrong size on USHTraversalClimbIconManager");

// Class SHProto.SHTraversalClimbTutorialHandler
// 0x0000 (0x0048 - 0x0048)
class USHTraversalClimbTutorialHandler final : public USHTraversalTutorialHandler
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalClimbTutorialHandler">();
	}
	static class USHTraversalClimbTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTraversalClimbTutorialHandler>();
	}
};
static_assert(alignof(USHTraversalClimbTutorialHandler) == 0x000008, "Wrong alignment on USHTraversalClimbTutorialHandler");
static_assert(sizeof(USHTraversalClimbTutorialHandler) == 0x000048, "Wrong size on USHTraversalClimbTutorialHandler");

// Class SHProto.SHTraversalCrawlTutorialHandler
// 0x0000 (0x0048 - 0x0048)
class USHTraversalCrawlTutorialHandler final : public USHTraversalTutorialHandler
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalCrawlTutorialHandler">();
	}
	static class USHTraversalCrawlTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTraversalCrawlTutorialHandler>();
	}
};
static_assert(alignof(USHTraversalCrawlTutorialHandler) == 0x000008, "Wrong alignment on USHTraversalCrawlTutorialHandler");
static_assert(sizeof(USHTraversalCrawlTutorialHandler) == 0x000048, "Wrong size on USHTraversalCrawlTutorialHandler");

// Class SHProto.SHTraversalCustomObstacle
// 0x0048 (0x0300 - 0x02B8)
class ASHTraversalCustomObstacle final : public ASHTraversalBase
{
public:
	class UStaticMeshComponent*                   ObstacleMesh;                                      // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlaneSideDetectionComponent*           PlaneSideDetectionComponent;                       // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            TraversalIcon;                                     // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHTraversalObstacleComponent*          TraversalObstacleComponent;                        // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHTraversalObstacleIconManager*        TraversalIconManager;                              // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayMapObstacleComponent*        GameplayMapObject;                                 // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x18];                                     // 0x02E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize(const TArray<class USplineComponent*>& InEdgeSplines);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalCustomObstacle">();
	}
	static class ASHTraversalCustomObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHTraversalCustomObstacle>();
	}
};
static_assert(alignof(ASHTraversalCustomObstacle) == 0x000008, "Wrong alignment on ASHTraversalCustomObstacle");
static_assert(sizeof(ASHTraversalCustomObstacle) == 0x000300, "Wrong size on ASHTraversalCustomObstacle");
static_assert(offsetof(ASHTraversalCustomObstacle, ObstacleMesh) == 0x0002B8, "Member 'ASHTraversalCustomObstacle::ObstacleMesh' has a wrong offset!");
static_assert(offsetof(ASHTraversalCustomObstacle, PlaneSideDetectionComponent) == 0x0002C0, "Member 'ASHTraversalCustomObstacle::PlaneSideDetectionComponent' has a wrong offset!");
static_assert(offsetof(ASHTraversalCustomObstacle, TraversalIcon) == 0x0002C8, "Member 'ASHTraversalCustomObstacle::TraversalIcon' has a wrong offset!");
static_assert(offsetof(ASHTraversalCustomObstacle, TraversalObstacleComponent) == 0x0002D0, "Member 'ASHTraversalCustomObstacle::TraversalObstacleComponent' has a wrong offset!");
static_assert(offsetof(ASHTraversalCustomObstacle, TraversalIconManager) == 0x0002D8, "Member 'ASHTraversalCustomObstacle::TraversalIconManager' has a wrong offset!");
static_assert(offsetof(ASHTraversalCustomObstacle, GameplayMapObject) == 0x0002E0, "Member 'ASHTraversalCustomObstacle::GameplayMapObject' has a wrong offset!");

// Class SHProto.SHTraversalJumpDownTutorialHandler
// 0x0000 (0x0048 - 0x0048)
class USHTraversalJumpDownTutorialHandler final : public USHTraversalTutorialHandler
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalJumpDownTutorialHandler">();
	}
	static class USHTraversalJumpDownTutorialHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTraversalJumpDownTutorialHandler>();
	}
};
static_assert(alignof(USHTraversalJumpDownTutorialHandler) == 0x000008, "Wrong alignment on USHTraversalJumpDownTutorialHandler");
static_assert(sizeof(USHTraversalJumpDownTutorialHandler) == 0x000048, "Wrong size on USHTraversalJumpDownTutorialHandler");

// Class SHProto.SHTraversalObstacle
// 0x0030 (0x02E8 - 0x02B8)
class ASHTraversalObstacle final : public ASHTraversalBase
{
public:
	class UStaticMeshComponent*                   ObstacleMesh;                                      // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlaneSideDetectionComponent*           PlaneSideDetectionComponent;                       // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            TraversalIcon;                                     // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHTraversalObstacleComponent*          TraversalObstacleComponent;                        // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHTraversalObstacleIconManager*        TraversalIconManager;                              // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHGameplayMapObstacleComponent*        GameplayMapObject;                                 // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalObstacle">();
	}
	static class ASHTraversalObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHTraversalObstacle>();
	}
};
static_assert(alignof(ASHTraversalObstacle) == 0x000008, "Wrong alignment on ASHTraversalObstacle");
static_assert(sizeof(ASHTraversalObstacle) == 0x0002E8, "Wrong size on ASHTraversalObstacle");
static_assert(offsetof(ASHTraversalObstacle, ObstacleMesh) == 0x0002B8, "Member 'ASHTraversalObstacle::ObstacleMesh' has a wrong offset!");
static_assert(offsetof(ASHTraversalObstacle, PlaneSideDetectionComponent) == 0x0002C0, "Member 'ASHTraversalObstacle::PlaneSideDetectionComponent' has a wrong offset!");
static_assert(offsetof(ASHTraversalObstacle, TraversalIcon) == 0x0002C8, "Member 'ASHTraversalObstacle::TraversalIcon' has a wrong offset!");
static_assert(offsetof(ASHTraversalObstacle, TraversalObstacleComponent) == 0x0002D0, "Member 'ASHTraversalObstacle::TraversalObstacleComponent' has a wrong offset!");
static_assert(offsetof(ASHTraversalObstacle, TraversalIconManager) == 0x0002D8, "Member 'ASHTraversalObstacle::TraversalIconManager' has a wrong offset!");
static_assert(offsetof(ASHTraversalObstacle, GameplayMapObject) == 0x0002E0, "Member 'ASHTraversalObstacle::GameplayMapObject' has a wrong offset!");

// Class SHProto.SHTraversalObstacleComponent
// 0x0858 (0x09E0 - 0x0188)
class alignas(0x10) USHTraversalObstacleComponent final : public USHTraversalBaseComponent
{
public:
	struct FVector                                TraversalAnimPositionDiffAbove;                    // 0x0188(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TraversalAnimPositionDiffBelow;                    // 0x01A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldUnequipWeapon;                              // 0x01B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableFlashlightPlainSocketMode;                  // 0x01B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BA[0x6];                                      // 0x01BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RequiredDistance;                                  // 0x01C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RequiredViewDotProduct;                            // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSecureView;                                       // 0x01DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DD[0x3];                                      // 0x01DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SecuredViewOffset;                                 // 0x01E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSecureViewDurationAsAnimLengthMul;                // 0x01F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F9[0x3];                                      // 0x01F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecuredViewDuration;                               // 0x01FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseFocusTracking;                                 // 0x0200(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseStaticCameraAnimAnchor;                        // 0x0201(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_202[0x6];                                      // 0x0202(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHCameraAnimationData                 CameraAnimationAbove;                              // 0x0208(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSHCameraAnimationData                 CameraAnimationBelow;                              // 0x0288(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSHObstacleAnimationSet                DefaultAnimationSet;                               // 0x0308(0x0200)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSHObstacleAnimationSet                InDangerAnimationSet;                              // 0x0508(0x0200)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVector                                TraversalSecureArea;                               // 0x0708(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DebugBoxOffset;                                    // 0x0720(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DebugBoxAnchor;                                    // 0x0738(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             PreTraversalStarted;                               // 0x0750(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTraversalStarted;                                // 0x0760(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTraversalFinished;                               // 0x0770(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnCameraAnimExeCreated;                            // 0x0780(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class USHAnimMontagePlayer*                   AnimMontagePlayer;                                 // 0x0790(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         FriendActors;                                      // 0x0798(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A8[0x238];                                    // 0x07A8(0x0238)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddFriendActor(class AActor* InActor);
	void ProcessTraversalAnimBlendingOut(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void ProcessTraversalAnimEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void RegisterAboveFlashlightLookAtComponent(class USceneComponent* InLookAtComponent);
	void RegisterBelowFlashlightLookAtComponent(class USceneComponent* InLookAtComponent);
	void RemoveFriendActor(class AActor* InActor);
	void SHObstacleComponentEvent__DelegateSignature(ESHDetectionSide DetectionSide);
	void SHObstacleEvent__DelegateSignature(class USHTraversalObstacleComponent* ComponentPtr);
	void SHObstacleWithCameraAnimExeEvent__DelegateSignature(class USHTraversalObstacleComponent* ComponentPtr, class ASHCameraAnimationExecutive* CameraAnimExe);
	void SHObstacleWithSideEvent__DelegateSignature(class USHTraversalObstacleComponent* ComponentPtr, ESHDetectionSide DetectionSide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalObstacleComponent">();
	}
	static class USHTraversalObstacleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTraversalObstacleComponent>();
	}
};
static_assert(alignof(USHTraversalObstacleComponent) == 0x000010, "Wrong alignment on USHTraversalObstacleComponent");
static_assert(sizeof(USHTraversalObstacleComponent) == 0x0009E0, "Wrong size on USHTraversalObstacleComponent");
static_assert(offsetof(USHTraversalObstacleComponent, TraversalAnimPositionDiffAbove) == 0x000188, "Member 'USHTraversalObstacleComponent::TraversalAnimPositionDiffAbove' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, TraversalAnimPositionDiffBelow) == 0x0001A0, "Member 'USHTraversalObstacleComponent::TraversalAnimPositionDiffBelow' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, bShouldUnequipWeapon) == 0x0001B8, "Member 'USHTraversalObstacleComponent::bShouldUnequipWeapon' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, bEnableFlashlightPlainSocketMode) == 0x0001B9, "Member 'USHTraversalObstacleComponent::bEnableFlashlightPlainSocketMode' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, RequiredDistance) == 0x0001C0, "Member 'USHTraversalObstacleComponent::RequiredDistance' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, RequiredViewDotProduct) == 0x0001D8, "Member 'USHTraversalObstacleComponent::RequiredViewDotProduct' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, bSecureView) == 0x0001DC, "Member 'USHTraversalObstacleComponent::bSecureView' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, SecuredViewOffset) == 0x0001E0, "Member 'USHTraversalObstacleComponent::SecuredViewOffset' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, bSecureViewDurationAsAnimLengthMul) == 0x0001F8, "Member 'USHTraversalObstacleComponent::bSecureViewDurationAsAnimLengthMul' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, SecuredViewDuration) == 0x0001FC, "Member 'USHTraversalObstacleComponent::SecuredViewDuration' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, bUseFocusTracking) == 0x000200, "Member 'USHTraversalObstacleComponent::bUseFocusTracking' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, bUseStaticCameraAnimAnchor) == 0x000201, "Member 'USHTraversalObstacleComponent::bUseStaticCameraAnimAnchor' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, CameraAnimationAbove) == 0x000208, "Member 'USHTraversalObstacleComponent::CameraAnimationAbove' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, CameraAnimationBelow) == 0x000288, "Member 'USHTraversalObstacleComponent::CameraAnimationBelow' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, DefaultAnimationSet) == 0x000308, "Member 'USHTraversalObstacleComponent::DefaultAnimationSet' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, InDangerAnimationSet) == 0x000508, "Member 'USHTraversalObstacleComponent::InDangerAnimationSet' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, TraversalSecureArea) == 0x000708, "Member 'USHTraversalObstacleComponent::TraversalSecureArea' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, DebugBoxOffset) == 0x000720, "Member 'USHTraversalObstacleComponent::DebugBoxOffset' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, DebugBoxAnchor) == 0x000738, "Member 'USHTraversalObstacleComponent::DebugBoxAnchor' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, PreTraversalStarted) == 0x000750, "Member 'USHTraversalObstacleComponent::PreTraversalStarted' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, OnTraversalStarted) == 0x000760, "Member 'USHTraversalObstacleComponent::OnTraversalStarted' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, OnTraversalFinished) == 0x000770, "Member 'USHTraversalObstacleComponent::OnTraversalFinished' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, OnCameraAnimExeCreated) == 0x000780, "Member 'USHTraversalObstacleComponent::OnCameraAnimExeCreated' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, AnimMontagePlayer) == 0x000790, "Member 'USHTraversalObstacleComponent::AnimMontagePlayer' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleComponent, FriendActors) == 0x000798, "Member 'USHTraversalObstacleComponent::FriendActors' has a wrong offset!");

// Class SHProto.SHTraversalObstacleExtended
// 0x0038 (0x02F0 - 0x02B8)
class ASHTraversalObstacleExtended final : public ASHTraversalBase
{
public:
	class UStaticMeshComponent*                   ObstacleMesh;                                      // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlaneSideDetectionComponent*           PlaneSideDetectionComponent;                       // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      TeleportToComponent;                               // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHInteractionIconComponent*            TraversalIcon;                                     // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHTraversalObstacleExtendedComponent*  TraversalObstacleExtendedComponent;                // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHTraversalObstacleExtendedIconManager* TraversalIconManager;                              // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTeleportOnPlayingEnd;                             // 0x02E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalObstacleExtended">();
	}
	static class ASHTraversalObstacleExtended* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHTraversalObstacleExtended>();
	}
};
static_assert(alignof(ASHTraversalObstacleExtended) == 0x000008, "Wrong alignment on ASHTraversalObstacleExtended");
static_assert(sizeof(ASHTraversalObstacleExtended) == 0x0002F0, "Wrong size on ASHTraversalObstacleExtended");
static_assert(offsetof(ASHTraversalObstacleExtended, ObstacleMesh) == 0x0002B8, "Member 'ASHTraversalObstacleExtended::ObstacleMesh' has a wrong offset!");
static_assert(offsetof(ASHTraversalObstacleExtended, PlaneSideDetectionComponent) == 0x0002C0, "Member 'ASHTraversalObstacleExtended::PlaneSideDetectionComponent' has a wrong offset!");
static_assert(offsetof(ASHTraversalObstacleExtended, TeleportToComponent) == 0x0002C8, "Member 'ASHTraversalObstacleExtended::TeleportToComponent' has a wrong offset!");
static_assert(offsetof(ASHTraversalObstacleExtended, TraversalIcon) == 0x0002D0, "Member 'ASHTraversalObstacleExtended::TraversalIcon' has a wrong offset!");
static_assert(offsetof(ASHTraversalObstacleExtended, TraversalObstacleExtendedComponent) == 0x0002D8, "Member 'ASHTraversalObstacleExtended::TraversalObstacleExtendedComponent' has a wrong offset!");
static_assert(offsetof(ASHTraversalObstacleExtended, TraversalIconManager) == 0x0002E0, "Member 'ASHTraversalObstacleExtended::TraversalIconManager' has a wrong offset!");
static_assert(offsetof(ASHTraversalObstacleExtended, bTeleportOnPlayingEnd) == 0x0002E8, "Member 'ASHTraversalObstacleExtended::bTeleportOnPlayingEnd' has a wrong offset!");

// Class SHProto.SHTraversalObstacleExtendedComponent
// 0x0508 (0x0690 - 0x0188)
class alignas(0x10) USHTraversalObstacleExtendedComponent final : public USHTraversalBaseComponent
{
public:
	struct FVector                                TraversalAnimPosition;                             // 0x0188(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RequiredDistance;                                  // 0x01A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RequiredViewDotProduct;                            // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSecureView;                                       // 0x01BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BD[0x3];                                      // 0x01BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SecuredViewOffset;                                 // 0x01C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSecureViewDurationAsAnimLengthMul;                // 0x01D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D9[0x3];                                      // 0x01D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecuredViewDuration;                               // 0x01DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseFocusTracking;                                 // 0x01E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E1[0x7];                                      // 0x01E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHCameraAnimationData                 CameraAnimationStart;                              // 0x01E8(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSHCameraAnimationData                 CameraAnimationEnd;                                // 0x0268(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSHTraversalObstacleExtendedAnimationSet AnimationSet;                                      // 0x02E8(0x02C0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVector                                TraversalSecureArea;                               // 0x05A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             PreTraversalStarted;                               // 0x05C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTraversalStarted;                                // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTraversalStageChanged;                           // 0x05E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTraversalFinished;                               // 0x05F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class USHAnimMontagePlayer*                   AnimMontagePlayer;                                 // 0x0600(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      TeleportToOnPlayingEndComponent;                   // 0x0608(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ASHCameraAnimationExecutive> PlayingCameraAnimExe;                              // 0x0610(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_618[0x78];                                     // 0x0618(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessMovementSnapFinish(bool bWasCompleted);
	void ProcessTraversalAnimBlendingOut(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void ProcesTraversalAnimEnd(class UAnimMontage* Montage, ESHAnimEndType AnimEndType);
	void SHObstacleExtendedEvent__DelegateSignature(class USHTraversalObstacleExtendedComponent* ComponentPtr);

	ESHTraversalObstacleExtendedStage GetCurrentStage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalObstacleExtendedComponent">();
	}
	static class USHTraversalObstacleExtendedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTraversalObstacleExtendedComponent>();
	}
};
static_assert(alignof(USHTraversalObstacleExtendedComponent) == 0x000010, "Wrong alignment on USHTraversalObstacleExtendedComponent");
static_assert(sizeof(USHTraversalObstacleExtendedComponent) == 0x000690, "Wrong size on USHTraversalObstacleExtendedComponent");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, TraversalAnimPosition) == 0x000188, "Member 'USHTraversalObstacleExtendedComponent::TraversalAnimPosition' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, RequiredDistance) == 0x0001A0, "Member 'USHTraversalObstacleExtendedComponent::RequiredDistance' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, RequiredViewDotProduct) == 0x0001B8, "Member 'USHTraversalObstacleExtendedComponent::RequiredViewDotProduct' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, bSecureView) == 0x0001BC, "Member 'USHTraversalObstacleExtendedComponent::bSecureView' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, SecuredViewOffset) == 0x0001C0, "Member 'USHTraversalObstacleExtendedComponent::SecuredViewOffset' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, bSecureViewDurationAsAnimLengthMul) == 0x0001D8, "Member 'USHTraversalObstacleExtendedComponent::bSecureViewDurationAsAnimLengthMul' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, SecuredViewDuration) == 0x0001DC, "Member 'USHTraversalObstacleExtendedComponent::SecuredViewDuration' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, bUseFocusTracking) == 0x0001E0, "Member 'USHTraversalObstacleExtendedComponent::bUseFocusTracking' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, CameraAnimationStart) == 0x0001E8, "Member 'USHTraversalObstacleExtendedComponent::CameraAnimationStart' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, CameraAnimationEnd) == 0x000268, "Member 'USHTraversalObstacleExtendedComponent::CameraAnimationEnd' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, AnimationSet) == 0x0002E8, "Member 'USHTraversalObstacleExtendedComponent::AnimationSet' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, TraversalSecureArea) == 0x0005A8, "Member 'USHTraversalObstacleExtendedComponent::TraversalSecureArea' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, PreTraversalStarted) == 0x0005C0, "Member 'USHTraversalObstacleExtendedComponent::PreTraversalStarted' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, OnTraversalStarted) == 0x0005D0, "Member 'USHTraversalObstacleExtendedComponent::OnTraversalStarted' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, OnTraversalStageChanged) == 0x0005E0, "Member 'USHTraversalObstacleExtendedComponent::OnTraversalStageChanged' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, OnTraversalFinished) == 0x0005F0, "Member 'USHTraversalObstacleExtendedComponent::OnTraversalFinished' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, AnimMontagePlayer) == 0x000600, "Member 'USHTraversalObstacleExtendedComponent::AnimMontagePlayer' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, TeleportToOnPlayingEndComponent) == 0x000608, "Member 'USHTraversalObstacleExtendedComponent::TeleportToOnPlayingEndComponent' has a wrong offset!");
static_assert(offsetof(USHTraversalObstacleExtendedComponent, PlayingCameraAnimExe) == 0x000610, "Member 'USHTraversalObstacleExtendedComponent::PlayingCameraAnimExe' has a wrong offset!");

// Class SHProto.SHTraversalObstacleExtendedIconManager
// 0x0000 (0x00D8 - 0x00D8)
class USHTraversalObstacleExtendedIconManager final : public USHTraversalIconBaseManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalObstacleExtendedIconManager">();
	}
	static class USHTraversalObstacleExtendedIconManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTraversalObstacleExtendedIconManager>();
	}
};
static_assert(alignof(USHTraversalObstacleExtendedIconManager) == 0x000008, "Wrong alignment on USHTraversalObstacleExtendedIconManager");
static_assert(sizeof(USHTraversalObstacleExtendedIconManager) == 0x0000D8, "Wrong size on USHTraversalObstacleExtendedIconManager");

// Class SHProto.SHTraversalObstacleIconManager
// 0x0000 (0x00D8 - 0x00D8)
class USHTraversalObstacleIconManager final : public USHTraversalIconBaseManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHTraversalObstacleIconManager">();
	}
	static class USHTraversalObstacleIconManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHTraversalObstacleIconManager>();
	}
};
static_assert(alignof(USHTraversalObstacleIconManager) == 0x000008, "Wrong alignment on USHTraversalObstacleIconManager");
static_assert(sizeof(USHTraversalObstacleIconManager) == 0x0000D8, "Wrong size on USHTraversalObstacleIconManager");

// Class SHProto.SHUfoEndingFactor
// 0x0068 (0x0098 - 0x0030)
class USHUfoEndingFactor final : public USHEndingFactor
{
public:
	TMap<ESHUfoEndingInteraction, bool>           InteractionToValueMap;                             // 0x0030(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x18];                                      // 0x0080(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Character_Endings_Factors_UFOEnding_DrawDebug();
	void SHDebug_Character_Endings_Factors_UFOEnding_SetDebugValue(int32 InInteractionIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHUfoEndingFactor">();
	}
	static class USHUfoEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHUfoEndingFactor>();
	}
};
static_assert(alignof(USHUfoEndingFactor) == 0x000008, "Wrong alignment on USHUfoEndingFactor");
static_assert(sizeof(USHUfoEndingFactor) == 0x000098, "Wrong size on USHUfoEndingFactor");
static_assert(offsetof(USHUfoEndingFactor, InteractionToValueMap) == 0x000030, "Member 'USHUfoEndingFactor::InteractionToValueMap' has a wrong offset!");

// Class SHProto.SHUfoEndingInteractionArea
// 0x0020 (0x02D0 - 0x02B0)
class ASHUfoEndingInteractionArea final : public AActor
{
public:
	ESHUfoEndingInteraction                       InteractionContext;                                // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x1F];                                     // 0x02B1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsCompleted();
	void SetEnabled(const class UObject* Enabler, bool InEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHUfoEndingInteractionArea">();
	}
	static class ASHUfoEndingInteractionArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHUfoEndingInteractionArea>();
	}
};
static_assert(alignof(ASHUfoEndingInteractionArea) == 0x000008, "Wrong alignment on ASHUfoEndingInteractionArea");
static_assert(sizeof(ASHUfoEndingInteractionArea) == 0x0002D0, "Wrong size on ASHUfoEndingInteractionArea");
static_assert(offsetof(ASHUfoEndingInteractionArea, InteractionContext) == 0x0002B0, "Member 'ASHUfoEndingInteractionArea::InteractionContext' has a wrong offset!");

// Class SHProto.SHUserButton
// 0x00E0 (0x0358 - 0x0278)
class USHUserButton final : public UUserWidget
{
public:
	uint8                                         Blocked : 1;                                       // 0x0278(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBButton*                               Root_but;                                          // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextLayoutWidget*                      Label_wdg;                                         // 0x0288(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   DisplayName;                                       // 0x0290(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   Description;                                       // 0x02A8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   InactiveDescription;                               // 0x02C0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnClicked;                                         // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x10];                                     // 0x02E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHovered;                                         // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x10];                                     // 0x0308(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnUnhovered;                                       // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x10];                                     // 0x0328(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnShowDescription;                                 // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnHideDescription;                                 // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void BP_OnLockedChanged(bool bIsLocked);
	void SetDisplayName(const class FText& Text);
	void SetLocked(bool bInIsLocked);

	bool IsLocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHUserButton">();
	}
	static class USHUserButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHUserButton>();
	}
};
static_assert(alignof(USHUserButton) == 0x000008, "Wrong alignment on USHUserButton");
static_assert(sizeof(USHUserButton) == 0x000358, "Wrong size on USHUserButton");
static_assert(offsetof(USHUserButton, Root_but) == 0x000280, "Member 'USHUserButton::Root_but' has a wrong offset!");
static_assert(offsetof(USHUserButton, Label_wdg) == 0x000288, "Member 'USHUserButton::Label_wdg' has a wrong offset!");
static_assert(offsetof(USHUserButton, DisplayName) == 0x000290, "Member 'USHUserButton::DisplayName' has a wrong offset!");
static_assert(offsetof(USHUserButton, Description) == 0x0002A8, "Member 'USHUserButton::Description' has a wrong offset!");
static_assert(offsetof(USHUserButton, InactiveDescription) == 0x0002C0, "Member 'USHUserButton::InactiveDescription' has a wrong offset!");
static_assert(offsetof(USHUserButton, OnClicked) == 0x0002D8, "Member 'USHUserButton::OnClicked' has a wrong offset!");
static_assert(offsetof(USHUserButton, OnHovered) == 0x0002F8, "Member 'USHUserButton::OnHovered' has a wrong offset!");
static_assert(offsetof(USHUserButton, OnUnhovered) == 0x000318, "Member 'USHUserButton::OnUnhovered' has a wrong offset!");
static_assert(offsetof(USHUserButton, OnShowDescription) == 0x000338, "Member 'USHUserButton::OnShowDescription' has a wrong offset!");
static_assert(offsetof(USHUserButton, OnHideDescription) == 0x000348, "Member 'USHUserButton::OnHideDescription' has a wrong offset!");

// Class SHProto.SHValveAnimInstance
// 0x0040 (0x0390 - 0x0350)
class USHValveAnimInstance final : public UAnimInstance
{
public:
	bool                                          bPlayInteraction;                                  // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bProcessInteraction;                               // 0x0349(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFinishInteraction;                                // 0x034A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34B[0x45];                                     // 0x034B(0x0045)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyInteractionFinishBegin();
	void ApplyInteractionFinished();
	void ApplyInteractionFirstPhaseEnded();
	void ApplyInteractionFirstPhaseStarted();
	void ApplyInteractionSecondPhaseEnded();
	void ApplyInteractionSecondPhaseStarted();
	void ApplyInteractionStarted();
	void SHValveAnimInstanceEvent__DelegateSignature(class USHValveAnimInstance* AnimInst);
	void SHValveAnimInstanceProgressPhaseChangeEvent__DelegateSignature(class USHValveAnimInstance* AnimInst, int32 PhaseNumber, bool bHasStarted);

	bool CanReceiveInput() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHValveAnimInstance">();
	}
	static class USHValveAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHValveAnimInstance>();
	}
};
static_assert(alignof(USHValveAnimInstance) == 0x000010, "Wrong alignment on USHValveAnimInstance");
static_assert(sizeof(USHValveAnimInstance) == 0x000390, "Wrong size on USHValveAnimInstance");
static_assert(offsetof(USHValveAnimInstance, bPlayInteraction) == 0x000348, "Member 'USHValveAnimInstance::bPlayInteraction' has a wrong offset!");
static_assert(offsetof(USHValveAnimInstance, bProcessInteraction) == 0x000349, "Member 'USHValveAnimInstance::bProcessInteraction' has a wrong offset!");
static_assert(offsetof(USHValveAnimInstance, bFinishInteraction) == 0x00034A, "Member 'USHValveAnimInstance::bFinishInteraction' has a wrong offset!");

// Class SHProto.SHValveWithRequiredItem
// 0x00F8 (0x0490 - 0x0398)
class ASHValveWithRequiredItem final : public ASHValve
{
public:
	struct FDataTableRowHandle                    RequiredItem;                                      // 0x0398(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             AddingItemCameraRelTransform;                      // 0x03B0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             RotatingValveCameraRelTransform;                   // 0x0410(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCorrectItemSelectedAudio;                      // 0x0470(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_471[0x7];                                      // 0x0471(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             RequiredItemAddedEvent;                            // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bHasAddedRequiredItem;                             // 0x0488(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_489[0x7];                                      // 0x0489(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessFocusableItemSelectedEvent(class FName InItemName);
	void ProcessRequiredItemAdded();
	void ValveRequiredItemEvent__DelegateSignature(class ASHValveWithRequiredItem* ValveWithRequiredItem);

	bool HasAddedRequiredItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHValveWithRequiredItem">();
	}
	static class ASHValveWithRequiredItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHValveWithRequiredItem>();
	}
};
static_assert(alignof(ASHValveWithRequiredItem) == 0x000010, "Wrong alignment on ASHValveWithRequiredItem");
static_assert(sizeof(ASHValveWithRequiredItem) == 0x000490, "Wrong size on ASHValveWithRequiredItem");
static_assert(offsetof(ASHValveWithRequiredItem, RequiredItem) == 0x000398, "Member 'ASHValveWithRequiredItem::RequiredItem' has a wrong offset!");
static_assert(offsetof(ASHValveWithRequiredItem, AddingItemCameraRelTransform) == 0x0003B0, "Member 'ASHValveWithRequiredItem::AddingItemCameraRelTransform' has a wrong offset!");
static_assert(offsetof(ASHValveWithRequiredItem, RotatingValveCameraRelTransform) == 0x000410, "Member 'ASHValveWithRequiredItem::RotatingValveCameraRelTransform' has a wrong offset!");
static_assert(offsetof(ASHValveWithRequiredItem, bUseCorrectItemSelectedAudio) == 0x000470, "Member 'ASHValveWithRequiredItem::bUseCorrectItemSelectedAudio' has a wrong offset!");
static_assert(offsetof(ASHValveWithRequiredItem, RequiredItemAddedEvent) == 0x000478, "Member 'ASHValveWithRequiredItem::RequiredItemAddedEvent' has a wrong offset!");
static_assert(offsetof(ASHValveWithRequiredItem, bHasAddedRequiredItem) == 0x000488, "Member 'ASHValveWithRequiredItem::bHasAddedRequiredItem' has a wrong offset!");

// Class SHProto.SHVehicleAnimInstance
// 0x0020 (0x0370 - 0x0350)
class USHVehicleAnimInstance final : public UAnimInstance
{
public:
	bool                                          bPlayInteraction;                                  // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInstantGetIn;                                     // 0x0349(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFinishInteraction;                                // 0x034A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMovementBlocked;                                // 0x034B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurrentInputValue;                                 // 0x0350(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHVehicleAnimInstance">();
	}
	static class USHVehicleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHVehicleAnimInstance>();
	}
};
static_assert(alignof(USHVehicleAnimInstance) == 0x000010, "Wrong alignment on USHVehicleAnimInstance");
static_assert(sizeof(USHVehicleAnimInstance) == 0x000370, "Wrong size on USHVehicleAnimInstance");
static_assert(offsetof(USHVehicleAnimInstance, bPlayInteraction) == 0x000348, "Member 'USHVehicleAnimInstance::bPlayInteraction' has a wrong offset!");
static_assert(offsetof(USHVehicleAnimInstance, bInstantGetIn) == 0x000349, "Member 'USHVehicleAnimInstance::bInstantGetIn' has a wrong offset!");
static_assert(offsetof(USHVehicleAnimInstance, bFinishInteraction) == 0x00034A, "Member 'USHVehicleAnimInstance::bFinishInteraction' has a wrong offset!");
static_assert(offsetof(USHVehicleAnimInstance, bIsMovementBlocked) == 0x00034B, "Member 'USHVehicleAnimInstance::bIsMovementBlocked' has a wrong offset!");
static_assert(offsetof(USHVehicleAnimInstance, CurrentInputValue) == 0x000350, "Member 'USHVehicleAnimInstance::CurrentInputValue' has a wrong offset!");

// Class SHProto.SHVehicleComponent
// 0x0068 (0x0108 - 0x00A0)
class USHVehicleComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnPassagerSpotRegister;                            // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPassagerSpotUnregister;                          // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MovementProcessorClass;                            // 0x00C0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHVehicleMovementProcessor*            MovementProcessor;                                 // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USHVehicleSpotComponent*>        VehiclePassengerSpots;                             // 0x00F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void ClearAccumulatedMovement();
	void GetInInstant(class ACharacter* InteractingCharacter, class USHVehicleSpotComponent* PassengerSpot);
	void GetOutInstant(class ACharacter* InteractingCharacter);
	void Initialize();
	void SHVehicleEvent__DelegateSignature(class USHVehicleComponent* VehiclePtr);
	void SHVehicleSpotEvent__DelegateSignature(class USHVehicleComponent* VehiclePtr, class USHVehicleSpotComponent* VehicleSpotPtr);
	void TeleportVehicle(const struct FVector& InWorldLoc, const struct FRotator& InWorldRot);

	class USHVehicleMovementProcessor* GetMovementProcessor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHVehicleComponent">();
	}
	static class USHVehicleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHVehicleComponent>();
	}
};
static_assert(alignof(USHVehicleComponent) == 0x000008, "Wrong alignment on USHVehicleComponent");
static_assert(sizeof(USHVehicleComponent) == 0x000108, "Wrong size on USHVehicleComponent");
static_assert(offsetof(USHVehicleComponent, OnPassagerSpotRegister) == 0x0000A0, "Member 'USHVehicleComponent::OnPassagerSpotRegister' has a wrong offset!");
static_assert(offsetof(USHVehicleComponent, OnPassagerSpotUnregister) == 0x0000B0, "Member 'USHVehicleComponent::OnPassagerSpotUnregister' has a wrong offset!");
static_assert(offsetof(USHVehicleComponent, MovementProcessorClass) == 0x0000C0, "Member 'USHVehicleComponent::MovementProcessorClass' has a wrong offset!");
static_assert(offsetof(USHVehicleComponent, MovementProcessor) == 0x0000F0, "Member 'USHVehicleComponent::MovementProcessor' has a wrong offset!");
static_assert(offsetof(USHVehicleComponent, VehiclePassengerSpots) == 0x0000F8, "Member 'USHVehicleComponent::VehiclePassengerSpots' has a wrong offset!");

// Class SHProto.SHVehicleSpotCameraDataSet
// 0x00B0 (0x00E0 - 0x0030)
class USHVehicleSpotCameraDataSet final : public UDataAsset
{
public:
	bool                                          bUseCustomViewComponentRelLoc;                     // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CustomViewComponentRelLoc;                         // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLimitPitch;                                    // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              PitchLimitToSet;                                   // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLimitYaw;                                      // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              YawLimitToSet;                                     // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomCameraData;                              // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSHCameraDataStruct                    CustomCameraData;                                  // 0x0088(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHVehicleSpotCameraDataSet">();
	}
	static class USHVehicleSpotCameraDataSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHVehicleSpotCameraDataSet>();
	}
};
static_assert(alignof(USHVehicleSpotCameraDataSet) == 0x000008, "Wrong alignment on USHVehicleSpotCameraDataSet");
static_assert(sizeof(USHVehicleSpotCameraDataSet) == 0x0000E0, "Wrong size on USHVehicleSpotCameraDataSet");
static_assert(offsetof(USHVehicleSpotCameraDataSet, bUseCustomViewComponentRelLoc) == 0x000030, "Member 'USHVehicleSpotCameraDataSet::bUseCustomViewComponentRelLoc' has a wrong offset!");
static_assert(offsetof(USHVehicleSpotCameraDataSet, CustomViewComponentRelLoc) == 0x000038, "Member 'USHVehicleSpotCameraDataSet::CustomViewComponentRelLoc' has a wrong offset!");
static_assert(offsetof(USHVehicleSpotCameraDataSet, bUseLimitPitch) == 0x000050, "Member 'USHVehicleSpotCameraDataSet::bUseLimitPitch' has a wrong offset!");
static_assert(offsetof(USHVehicleSpotCameraDataSet, PitchLimitToSet) == 0x000058, "Member 'USHVehicleSpotCameraDataSet::PitchLimitToSet' has a wrong offset!");
static_assert(offsetof(USHVehicleSpotCameraDataSet, bUseLimitYaw) == 0x000068, "Member 'USHVehicleSpotCameraDataSet::bUseLimitYaw' has a wrong offset!");
static_assert(offsetof(USHVehicleSpotCameraDataSet, YawLimitToSet) == 0x000070, "Member 'USHVehicleSpotCameraDataSet::YawLimitToSet' has a wrong offset!");
static_assert(offsetof(USHVehicleSpotCameraDataSet, bUseCustomCameraData) == 0x000080, "Member 'USHVehicleSpotCameraDataSet::bUseCustomCameraData' has a wrong offset!");
static_assert(offsetof(USHVehicleSpotCameraDataSet, CustomCameraData) == 0x000088, "Member 'USHVehicleSpotCameraDataSet::CustomCameraData' has a wrong offset!");

// Class SHProto.SHVehicleSpotComponent
// 0x0090 (0x0330 - 0x02A0)
class USHVehicleSpotComponent final : public USceneComponent
{
public:
	TSoftClassPtr<class UClass>                   AnimInstanceClass;                                 // 0x02A0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanReceiveInput;                                  // 0x02D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   InputReceiverClass;                                // 0x02D8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHVehicleSpotCameraDataSet*            CameraDataSet;                                     // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHVehicleComponent*                    VehicleComponent;                                  // 0x0310(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USHVehicleInputReceiver*                InputReceiver;                                     // 0x0318(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             InteractingCharacter;                              // 0x0320(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ACharacter* GetInteractingCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHVehicleSpotComponent">();
	}
	static class USHVehicleSpotComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHVehicleSpotComponent>();
	}
};
static_assert(alignof(USHVehicleSpotComponent) == 0x000010, "Wrong alignment on USHVehicleSpotComponent");
static_assert(sizeof(USHVehicleSpotComponent) == 0x000330, "Wrong size on USHVehicleSpotComponent");
static_assert(offsetof(USHVehicleSpotComponent, AnimInstanceClass) == 0x0002A0, "Member 'USHVehicleSpotComponent::AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(USHVehicleSpotComponent, bCanReceiveInput) == 0x0002D0, "Member 'USHVehicleSpotComponent::bCanReceiveInput' has a wrong offset!");
static_assert(offsetof(USHVehicleSpotComponent, InputReceiverClass) == 0x0002D8, "Member 'USHVehicleSpotComponent::InputReceiverClass' has a wrong offset!");
static_assert(offsetof(USHVehicleSpotComponent, CameraDataSet) == 0x000308, "Member 'USHVehicleSpotComponent::CameraDataSet' has a wrong offset!");
static_assert(offsetof(USHVehicleSpotComponent, VehicleComponent) == 0x000310, "Member 'USHVehicleSpotComponent::VehicleComponent' has a wrong offset!");
static_assert(offsetof(USHVehicleSpotComponent, InputReceiver) == 0x000318, "Member 'USHVehicleSpotComponent::InputReceiver' has a wrong offset!");
static_assert(offsetof(USHVehicleSpotComponent, InteractingCharacter) == 0x000320, "Member 'USHVehicleSpotComponent::InteractingCharacter' has a wrong offset!");

// Class SHProto.SHWaterInteractionComponent
// 0x0060 (0x0100 - 0x00A0)
class USHWaterInteractionComponent final : public UActorComponent
{
public:
	bool                                          IsWaterInteractionEnabled;                         // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TrackOwnerEnabled;                                 // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x2];                                       // 0x00A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OwnerRadius;                                       // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESimulatedWaterEffectType                     OwnerEffectType;                                   // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x57];                                      // 0x00A9(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AddSimpleWaterInteraction(const class UObject* Requester, const struct FSHXWaterIntersection& InWaterIntersection);

	void AddWaterInteraction(const struct FSHXWaterIntersection& InWaterIntersection);
	void SetWaterInteractionBlocked(const bool IsBlock, const class UObject* Object);

	const TArray<struct FSHXWaterIntersection> GetCurrentIntersections() const;
	bool IsWaterInteractionBlocked() const;
	bool IsWaterInteractionBlockedBy(const class UObject* Object) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHWaterInteractionComponent">();
	}
	static class USHWaterInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHWaterInteractionComponent>();
	}
};
static_assert(alignof(USHWaterInteractionComponent) == 0x000008, "Wrong alignment on USHWaterInteractionComponent");
static_assert(sizeof(USHWaterInteractionComponent) == 0x000100, "Wrong size on USHWaterInteractionComponent");
static_assert(offsetof(USHWaterInteractionComponent, IsWaterInteractionEnabled) == 0x0000A0, "Member 'USHWaterInteractionComponent::IsWaterInteractionEnabled' has a wrong offset!");
static_assert(offsetof(USHWaterInteractionComponent, TrackOwnerEnabled) == 0x0000A1, "Member 'USHWaterInteractionComponent::TrackOwnerEnabled' has a wrong offset!");
static_assert(offsetof(USHWaterInteractionComponent, OwnerRadius) == 0x0000A4, "Member 'USHWaterInteractionComponent::OwnerRadius' has a wrong offset!");
static_assert(offsetof(USHWaterInteractionComponent, OwnerEffectType) == 0x0000A8, "Member 'USHWaterInteractionComponent::OwnerEffectType' has a wrong offset!");

// Class SHProto.SHWaterManagerComponent
// 0x0028 (0x00C8 - 0x00A0)
class USHWaterManagerComponent final : public UActorComponent
{
public:
	TArray<class ASHWaterVolume*>                 RegisteredWaterVolumes;                            // 0x00A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 TrackedActor;                                      // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_WaterInteraction_DrawDebug();

	class ASHWaterVolume* GetSimulatingWaterVolume() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHWaterManagerComponent">();
	}
	static class USHWaterManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHWaterManagerComponent>();
	}
};
static_assert(alignof(USHWaterManagerComponent) == 0x000008, "Wrong alignment on USHWaterManagerComponent");
static_assert(sizeof(USHWaterManagerComponent) == 0x0000C8, "Wrong size on USHWaterManagerComponent");
static_assert(offsetof(USHWaterManagerComponent, RegisteredWaterVolumes) == 0x0000A0, "Member 'USHWaterManagerComponent::RegisteredWaterVolumes' has a wrong offset!");
static_assert(offsetof(USHWaterManagerComponent, TrackedActor) == 0x0000B0, "Member 'USHWaterManagerComponent::TrackedActor' has a wrong offset!");

// Class SHProto.SHWaterVolume
// 0x0020 (0x0308 - 0x02E8)
class ASHWaterVolume final : public AVolume
{
public:
	uint8                                         Pad_2E8[0x20];                                     // 0x02E8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableRuntimeSimulation(const bool IsDisable, const class UObject* Object);

	bool IsPointWithin(const struct FVector& Point) const;
	bool IsRuntimeSimulationDisabled() const;
	bool IsRuntimeSimulationDisabledBy(const class UObject* Object) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHWaterVolume">();
	}
	static class ASHWaterVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASHWaterVolume>();
	}
};
static_assert(alignof(ASHWaterVolume) == 0x000008, "Wrong alignment on ASHWaterVolume");
static_assert(sizeof(ASHWaterVolume) == 0x000308, "Wrong size on ASHWaterVolume");

// Class SHProto.SHWeaponAnimInstance
// 0x0000 (0x0350 - 0x0350)
class USHWeaponAnimInstance final : public UAnimInstance
{
public:
	bool IsAiming() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHWeaponAnimInstance">();
	}
	static class USHWeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHWeaponAnimInstance>();
	}
};
static_assert(alignof(USHWeaponAnimInstance) == 0x000010, "Wrong alignment on USHWeaponAnimInstance");
static_assert(sizeof(USHWeaponAnimInstance) == 0x000350, "Wrong size on USHWeaponAnimInstance");

// Class SHProto.SHWeaponManageCmbSubcompSettings
// 0x0020 (0x0050 - 0x0030)
class USHWeaponManageCmbSubcompSettings final : public UDataAsset
{
public:
	TArray<struct FDataTableRowHandle>            MeleeWeaponsOrder;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDataTableRowHandle>            RangedWeaponsOrder;                                // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHWeaponManageCmbSubcompSettings">();
	}
	static class USHWeaponManageCmbSubcompSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHWeaponManageCmbSubcompSettings>();
	}
};
static_assert(alignof(USHWeaponManageCmbSubcompSettings) == 0x000008, "Wrong alignment on USHWeaponManageCmbSubcompSettings");
static_assert(sizeof(USHWeaponManageCmbSubcompSettings) == 0x000050, "Wrong size on USHWeaponManageCmbSubcompSettings");
static_assert(offsetof(USHWeaponManageCmbSubcompSettings, MeleeWeaponsOrder) == 0x000030, "Member 'USHWeaponManageCmbSubcompSettings::MeleeWeaponsOrder' has a wrong offset!");
static_assert(offsetof(USHWeaponManageCmbSubcompSettings, RangedWeaponsOrder) == 0x000040, "Member 'USHWeaponManageCmbSubcompSettings::RangedWeaponsOrder' has a wrong offset!");

// Class SHProto.SHRangedWeaponAnimInterface
// 0x0000 (0x0028 - 0x0028)
class ISHRangedWeaponAnimInterface final : public IInterface
{
public:
	void SetOutOfAmmo(bool InNewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHRangedWeaponAnimInterface">();
	}
	static class ISHRangedWeaponAnimInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISHRangedWeaponAnimInterface>();
	}
};
static_assert(alignof(ISHRangedWeaponAnimInterface) == 0x000008, "Wrong alignment on ISHRangedWeaponAnimInterface");
static_assert(sizeof(ISHRangedWeaponAnimInterface) == 0x000028, "Wrong size on ISHRangedWeaponAnimInterface");

// Class SHProto.SHWestCityFWInteractedAllAtHeavensNightEndingFactor
// 0x0000 (0x0088 - 0x0088)
class USHWestCityFWInteractedAllAtHeavensNightEndingFactor final : public USHBoolEndingFactor
{
public:
	void SHDebug_Character_Endings_WestCityFWInteractedAllAtHeavensNightEndingFactor_SetDebugValue(bool InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHWestCityFWInteractedAllAtHeavensNightEndingFactor">();
	}
	static class USHWestCityFWInteractedAllAtHeavensNightEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHWestCityFWInteractedAllAtHeavensNightEndingFactor>();
	}
};
static_assert(alignof(USHWestCityFWInteractedAllAtHeavensNightEndingFactor) == 0x000008, "Wrong alignment on USHWestCityFWInteractedAllAtHeavensNightEndingFactor");
static_assert(sizeof(USHWestCityFWInteractedAllAtHeavensNightEndingFactor) == 0x000088, "Wrong size on USHWestCityFWInteractedAllAtHeavensNightEndingFactor");

// Class SHProto.SHWestCityFWMariaInteractionsEndingFactor
// 0x0000 (0x0088 - 0x0088)
class USHWestCityFWMariaInteractionsEndingFactor final : public USHBoolEndingFactor
{
public:
	void SHDebug_Character_Endings_WestCityFWMariaInteractionsEndingFactor_SetDebugValue(bool InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHWestCityFWMariaInteractionsEndingFactor">();
	}
	static class USHWestCityFWMariaInteractionsEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHWestCityFWMariaInteractionsEndingFactor>();
	}
};
static_assert(alignof(USHWestCityFWMariaInteractionsEndingFactor) == 0x000008, "Wrong alignment on USHWestCityFWMariaInteractionsEndingFactor");
static_assert(sizeof(USHWestCityFWMariaInteractionsEndingFactor) == 0x000088, "Wrong size on USHWestCityFWMariaInteractionsEndingFactor");

// Class SHProto.SHWoodsideCoinPuzzleEndingFactor
// 0x0058 (0x0088 - 0x0030)
class USHWoodsideCoinPuzzleEndingFactor final : public USHEndingFactor
{
public:
	TMap<ESHWoodsideCoinPuzzleEndingFactorValue, struct FSHEndingScoreChanger> ValueToScoreChangeMap;                             // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	ESHWoodsideCoinPuzzleEndingFactorValue        Value;                                             // 0x0080(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SHDebug_Character_Endings_Factors_WoodsideCoinPuzzle_SetDebugValue(int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHWoodsideCoinPuzzleEndingFactor">();
	}
	static class USHWoodsideCoinPuzzleEndingFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHWoodsideCoinPuzzleEndingFactor>();
	}
};
static_assert(alignof(USHWoodsideCoinPuzzleEndingFactor) == 0x000008, "Wrong alignment on USHWoodsideCoinPuzzleEndingFactor");
static_assert(sizeof(USHWoodsideCoinPuzzleEndingFactor) == 0x000088, "Wrong size on USHWoodsideCoinPuzzleEndingFactor");
static_assert(offsetof(USHWoodsideCoinPuzzleEndingFactor, ValueToScoreChangeMap) == 0x000030, "Member 'USHWoodsideCoinPuzzleEndingFactor::ValueToScoreChangeMap' has a wrong offset!");
static_assert(offsetof(USHWoodsideCoinPuzzleEndingFactor, Value) == 0x000080, "Member 'USHWoodsideCoinPuzzleEndingFactor::Value' has a wrong offset!");

// Class SHProto.SkeletonRagdollProfileBonesDynamic
// 0x0010 (0x00B8 - 0x00A8)
class USkeletonRagdollProfileBonesDynamic final : public USkeletonRagdollProfile
{
public:
	TArray<struct FBoneRagdoll>                   Bones;                                             // 0x00A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletonRagdollProfileBonesDynamic">();
	}
	static class USkeletonRagdollProfileBonesDynamic* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkeletonRagdollProfileBonesDynamic>();
	}
};
static_assert(alignof(USkeletonRagdollProfileBonesDynamic) == 0x000008, "Wrong alignment on USkeletonRagdollProfileBonesDynamic");
static_assert(sizeof(USkeletonRagdollProfileBonesDynamic) == 0x0000B8, "Wrong size on USkeletonRagdollProfileBonesDynamic");
static_assert(offsetof(USkeletonRagdollProfileBonesDynamic, Bones) == 0x0000A8, "Member 'USkeletonRagdollProfileBonesDynamic::Bones' has a wrong offset!");

// Class SHProto.SkeletonRagdollProfilesDA
// 0x0010 (0x0040 - 0x0030)
class USkeletonRagdollProfilesDA final : public UDataAsset
{
public:
	TArray<struct FSkeletonRagdollProfileData>    Profiles;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletonRagdollProfilesDA">();
	}
	static class USkeletonRagdollProfilesDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkeletonRagdollProfilesDA>();
	}
};
static_assert(alignof(USkeletonRagdollProfilesDA) == 0x000008, "Wrong alignment on USkeletonRagdollProfilesDA");
static_assert(sizeof(USkeletonRagdollProfilesDA) == 0x000040, "Wrong size on USkeletonRagdollProfilesDA");
static_assert(offsetof(USkeletonRagdollProfilesDA, Profiles) == 0x000030, "Member 'USkeletonRagdollProfilesDA::Profiles' has a wrong offset!");

// Class SHProto.SpotLightWithShadowDistance
// 0x0000 (0x02C8 - 0x02C8)
class ASpotLightWithShadowDistance final : public ASpotLight
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpotLightWithShadowDistance">();
	}
	static class ASpotLightWithShadowDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpotLightWithShadowDistance>();
	}
};
static_assert(alignof(ASpotLightWithShadowDistance) == 0x000008, "Wrong alignment on ASpotLightWithShadowDistance");
static_assert(sizeof(ASpotLightWithShadowDistance) == 0x0002C8, "Wrong size on ASpotLightWithShadowDistance");

// Class SHProto.SHAnimNotify_PlayWorldCameraShake
// 0x0020 (0x0058 - 0x0038)
class USHAnimNotify_PlayWorldCameraShake final : public UAnimNotify
{
public:
	TSubclassOf<class UCameraShakeBase>           Shake;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EpicenterSocket;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InnerRadius;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterRadius;                                       // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOrientShakeTowardsEpicenter;                      // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotify_PlayWorldCameraShake">();
	}
	static class USHAnimNotify_PlayWorldCameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotify_PlayWorldCameraShake>();
	}
};
static_assert(alignof(USHAnimNotify_PlayWorldCameraShake) == 0x000008, "Wrong alignment on USHAnimNotify_PlayWorldCameraShake");
static_assert(sizeof(USHAnimNotify_PlayWorldCameraShake) == 0x000058, "Wrong size on USHAnimNotify_PlayWorldCameraShake");
static_assert(offsetof(USHAnimNotify_PlayWorldCameraShake, Shake) == 0x000038, "Member 'USHAnimNotify_PlayWorldCameraShake::Shake' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_PlayWorldCameraShake, EpicenterSocket) == 0x000040, "Member 'USHAnimNotify_PlayWorldCameraShake::EpicenterSocket' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_PlayWorldCameraShake, InnerRadius) == 0x000048, "Member 'USHAnimNotify_PlayWorldCameraShake::InnerRadius' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_PlayWorldCameraShake, OuterRadius) == 0x00004C, "Member 'USHAnimNotify_PlayWorldCameraShake::OuterRadius' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_PlayWorldCameraShake, Falloff) == 0x000050, "Member 'USHAnimNotify_PlayWorldCameraShake::Falloff' has a wrong offset!");
static_assert(offsetof(USHAnimNotify_PlayWorldCameraShake, bOrientShakeTowardsEpicenter) == 0x000054, "Member 'USHAnimNotify_PlayWorldCameraShake::bOrientShakeTowardsEpicenter' has a wrong offset!");

// Class SHProto.SHLockYourEnemyDodges
// 0x0000 (0x0030 - 0x0030)
class USHLockYourEnemyDodges final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHLockYourEnemyDodges">();
	}
	static class USHLockYourEnemyDodges* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHLockYourEnemyDodges>();
	}
};
static_assert(alignof(USHLockYourEnemyDodges) == 0x000008, "Wrong alignment on USHLockYourEnemyDodges");
static_assert(sizeof(USHLockYourEnemyDodges) == 0x000030, "Wrong size on USHLockYourEnemyDodges");

// Class SHProto.SHAnimNotifyState
// 0x0008 (0x0038 - 0x0030)
class USHAnimNotifyState final : public UAnimNotifyState
{
public:
	float                                         StateDuration;                                     // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StateCurrentTime;                                  // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SHAnimNotifyState">();
	}
	static class USHAnimNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<USHAnimNotifyState>();
	}
};
static_assert(alignof(USHAnimNotifyState) == 0x000008, "Wrong alignment on USHAnimNotifyState");
static_assert(sizeof(USHAnimNotifyState) == 0x000038, "Wrong size on USHAnimNotifyState");
static_assert(offsetof(USHAnimNotifyState, StateDuration) == 0x000030, "Member 'USHAnimNotifyState::StateDuration' has a wrong offset!");
static_assert(offsetof(USHAnimNotifyState, StateCurrentTime) == 0x000034, "Member 'USHAnimNotifyState::StateCurrentTime' has a wrong offset!");

}

