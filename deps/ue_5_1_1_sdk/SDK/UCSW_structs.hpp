#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UCSW

#include "Basic.hpp"

#include "GameBase_structs.hpp"
#include "SlateCore_structs.hpp"
#include "Engine_structs.hpp"
#include "InputRebinding_structs.hpp"
#include "Commons_structs.hpp"
#include "InputCore_structs.hpp"


namespace SDK
{

// Enum UCSW.ESettingsPropertyType
// NumValues: 0x0008
enum class ESettingsPropertyType : uint8
{
	Custom                                   = 0,
	Bool                                     = 1,
	Int                                      = 2,
	Float                                    = 3,
	Enum                                     = 4,
	Volume                                   = 5,
	KeyBind                                  = 6,
	ESettingsPropertyType_MAX                = 7,
};

// Enum UCSW.ESettingsWidgetType
// NumValues: 0x0006
enum class ESettingsWidgetType : uint8
{
	Spiner                                   = 0,
	CheckBox                                 = 1,
	Slider                                   = 2,
	Custom                                   = 3,
	VolumeControl                            = 4,
	ESettingsWidgetType_MAX                  = 5,
};

// Enum UCSW.ESettingOptionFlags
// NumValues: 0x0017
enum class ESettingOptionFlags : uint8
{
	BaseSetting                              = 0,
	GfxOption                                = 1,
	GSAOption                                = 2,
	ChildProperty                            = 3,
	ArtificialOption                         = 4,
	PcOnly                                   = 5,
	ConsoleOnly                              = 6,
	XSXOnly                                  = 7,
	NoXBox                                   = 8,
	MainMenuOnly                             = 9,
	InGameOnly                               = 10,
	CustomType                               = 11,
	CustomVisibility                         = 12,
	UpdateViewOnChange                       = 13,
	CustomActionOnHover                      = 14,
	CustomActionOnUpdate                     = 15,
	Mapped                                   = 16,
	MappedToGSA                              = 17,
	NeedPreApplyTest                         = 18,
	AdvancedGSAOption                        = 19,
	HasQualityValues                         = 20,
	PresetOption                             = 21,
	ESettingOptionFlags_MAX                  = 22,
};

// Enum UCSW.ESettingOptionConditionAction
// NumValues: 0x000A
enum class ESettingOptionConditionAction : uint8
{
	Enable                                   = 0,
	Disable                                  = 1,
	Visible                                  = 2,
	Hidden                                   = 3,
	Active                                   = 4,
	Inactive                                 = 5,
	Custom                                   = 6,
	Preset                                   = 7,
	QualityValue                             = 8,
	ESettingOptionConditionAction_MAX        = 9,
};

// ScriptStruct UCSW.HDRData
// 0x001C (0x001C - 0x0000)
struct FHDRData final
{
public:
	bool                                          HDR;                                               // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HDRMinLuminance;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HDRMidLuminance;                                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HDRMaxLuminance;                                   // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HDRBrightness;                                     // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HDRUIBrightness;                                   // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HDRUIContrast;                                     // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHDRData) == 0x000004, "Wrong alignment on FHDRData");
static_assert(sizeof(FHDRData) == 0x00001C, "Wrong size on FHDRData");
static_assert(offsetof(FHDRData, HDR) == 0x000000, "Member 'FHDRData::HDR' has a wrong offset!");
static_assert(offsetof(FHDRData, HDRMinLuminance) == 0x000004, "Member 'FHDRData::HDRMinLuminance' has a wrong offset!");
static_assert(offsetof(FHDRData, HDRMidLuminance) == 0x000008, "Member 'FHDRData::HDRMidLuminance' has a wrong offset!");
static_assert(offsetof(FHDRData, HDRMaxLuminance) == 0x00000C, "Member 'FHDRData::HDRMaxLuminance' has a wrong offset!");
static_assert(offsetof(FHDRData, HDRBrightness) == 0x000010, "Member 'FHDRData::HDRBrightness' has a wrong offset!");
static_assert(offsetof(FHDRData, HDRUIBrightness) == 0x000014, "Member 'FHDRData::HDRUIBrightness' has a wrong offset!");
static_assert(offsetof(FHDRData, HDRUIContrast) == 0x000018, "Member 'FHDRData::HDRUIContrast' has a wrong offset!");

// ScriptStruct UCSW.SettingOptionVisualizationData
// 0x0060 (0x0060 - 0x0000)
struct FSettingOptionVisualizationData final
{
public:
	class FText                                   Description;                                       // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ValueDescription;                                  // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSettingOptionVisualizationData) == 0x000008, "Wrong alignment on FSettingOptionVisualizationData");
static_assert(sizeof(FSettingOptionVisualizationData) == 0x000060, "Wrong size on FSettingOptionVisualizationData");
static_assert(offsetof(FSettingOptionVisualizationData, Description) == 0x000000, "Member 'FSettingOptionVisualizationData::Description' has a wrong offset!");
static_assert(offsetof(FSettingOptionVisualizationData, ValueDescription) == 0x000018, "Member 'FSettingOptionVisualizationData::ValueDescription' has a wrong offset!");
static_assert(offsetof(FSettingOptionVisualizationData, Image) == 0x000030, "Member 'FSettingOptionVisualizationData::Image' has a wrong offset!");

// ScriptStruct UCSW.CommandText
// 0x0020 (0x0020 - 0x0000)
struct FCommandText final
{
public:
	class FString                                 Text;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Command;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCommandText) == 0x000008, "Wrong alignment on FCommandText");
static_assert(sizeof(FCommandText) == 0x000020, "Wrong size on FCommandText");
static_assert(offsetof(FCommandText, Text) == 0x000000, "Member 'FCommandText::Text' has a wrong offset!");
static_assert(offsetof(FCommandText, Command) == 0x000010, "Member 'FCommandText::Command' has a wrong offset!");

// ScriptStruct UCSW.ColorVisionDeficiencyData
// 0x0008 (0x0008 - 0x0000)
struct FColorVisionDeficiencyData final
{
public:
	EColorVisionDeficiency                        ColorVisionDeficiency;                             // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Severity;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FColorVisionDeficiencyData) == 0x000004, "Wrong alignment on FColorVisionDeficiencyData");
static_assert(sizeof(FColorVisionDeficiencyData) == 0x000008, "Wrong size on FColorVisionDeficiencyData");
static_assert(offsetof(FColorVisionDeficiencyData, ColorVisionDeficiency) == 0x000000, "Member 'FColorVisionDeficiencyData::ColorVisionDeficiency' has a wrong offset!");
static_assert(offsetof(FColorVisionDeficiencyData, Severity) == 0x000004, "Member 'FColorVisionDeficiencyData::Severity' has a wrong offset!");

// ScriptStruct UCSW.ControlTipsData
// 0x0004 (0x0004 - 0x0000)
struct FControlTipsData final
{
public:
	bool                                          Show;                                              // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETooltipsVisibilityEffects                    Visibility;                                        // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextSize                                     Size;                                              // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextFont                                     Font;                                              // 0x0003(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlTipsData) == 0x000001, "Wrong alignment on FControlTipsData");
static_assert(sizeof(FControlTipsData) == 0x000004, "Wrong size on FControlTipsData");
static_assert(offsetof(FControlTipsData, Show) == 0x000000, "Member 'FControlTipsData::Show' has a wrong offset!");
static_assert(offsetof(FControlTipsData, Visibility) == 0x000001, "Member 'FControlTipsData::Visibility' has a wrong offset!");
static_assert(offsetof(FControlTipsData, Size) == 0x000002, "Member 'FControlTipsData::Size' has a wrong offset!");
static_assert(offsetof(FControlTipsData, Font) == 0x000003, "Member 'FControlTipsData::Font' has a wrong offset!");

// ScriptStruct UCSW.ColorVisionVisualizationImages
// 0x0060 (0x0060 - 0x0000)
struct FColorVisionVisualizationImages final
{
public:
	TSoftObjectPtr<class UTexture2D>              ImageMin;                                          // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ImageMax;                                          // 0x0030(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FColorVisionVisualizationImages) == 0x000008, "Wrong alignment on FColorVisionVisualizationImages");
static_assert(sizeof(FColorVisionVisualizationImages) == 0x000060, "Wrong size on FColorVisionVisualizationImages");
static_assert(offsetof(FColorVisionVisualizationImages, ImageMin) == 0x000000, "Member 'FColorVisionVisualizationImages::ImageMin' has a wrong offset!");
static_assert(offsetof(FColorVisionVisualizationImages, ImageMax) == 0x000030, "Member 'FColorVisionVisualizationImages::ImageMax' has a wrong offset!");

// ScriptStruct UCSW.SubtitleData
// 0x0007 (0x0007 - 0x0000)
struct FSubtitleData final
{
public:
	bool                                          ShowSubtitles;                                     // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowNonVerbalCaptions;                             // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SubtitleNames;                                     // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextSize                                     Size;                                              // 0x0003(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextFont                                     Font;                                              // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESubtitleColor                                Color;                                             // 0x0005(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESubtitleBackground                           SubtitleBackground;                                // 0x0006(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubtitleData) == 0x000001, "Wrong alignment on FSubtitleData");
static_assert(sizeof(FSubtitleData) == 0x000007, "Wrong size on FSubtitleData");
static_assert(offsetof(FSubtitleData, ShowSubtitles) == 0x000000, "Member 'FSubtitleData::ShowSubtitles' has a wrong offset!");
static_assert(offsetof(FSubtitleData, ShowNonVerbalCaptions) == 0x000001, "Member 'FSubtitleData::ShowNonVerbalCaptions' has a wrong offset!");
static_assert(offsetof(FSubtitleData, SubtitleNames) == 0x000002, "Member 'FSubtitleData::SubtitleNames' has a wrong offset!");
static_assert(offsetof(FSubtitleData, Size) == 0x000003, "Member 'FSubtitleData::Size' has a wrong offset!");
static_assert(offsetof(FSubtitleData, Font) == 0x000004, "Member 'FSubtitleData::Font' has a wrong offset!");
static_assert(offsetof(FSubtitleData, Color) == 0x000005, "Member 'FSubtitleData::Color' has a wrong offset!");
static_assert(offsetof(FSubtitleData, SubtitleBackground) == 0x000006, "Member 'FSubtitleData::SubtitleBackground' has a wrong offset!");

// ScriptStruct UCSW.ControlTipData
// 0x0068 (0x0070 - 0x0008)
struct FControlTipData final : public FTableRowBase
{
public:
	class FText                                   Text;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FUE4InputHandle>                Inputs;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           Keys;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   TooltipKeys;                                       // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TooltipButtons;                                    // 0x0058(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlTipData) == 0x000008, "Wrong alignment on FControlTipData");
static_assert(sizeof(FControlTipData) == 0x000070, "Wrong size on FControlTipData");
static_assert(offsetof(FControlTipData, Text) == 0x000008, "Member 'FControlTipData::Text' has a wrong offset!");
static_assert(offsetof(FControlTipData, Inputs) == 0x000020, "Member 'FControlTipData::Inputs' has a wrong offset!");
static_assert(offsetof(FControlTipData, Keys) == 0x000030, "Member 'FControlTipData::Keys' has a wrong offset!");
static_assert(offsetof(FControlTipData, TooltipKeys) == 0x000040, "Member 'FControlTipData::TooltipKeys' has a wrong offset!");
static_assert(offsetof(FControlTipData, TooltipButtons) == 0x000058, "Member 'FControlTipData::TooltipButtons' has a wrong offset!");

// ScriptStruct UCSW.GameTextData
// 0x0170 (0x0170 - 0x0000)
struct FGameTextData final
{
public:
	struct FSlateFontInfo                         FontDefault;                                       // 0x0000(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DefaultTextStyle;                                  // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         FontBold;                                          // 0x0060(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             BoldTextStyle;                                     // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         FontDyslexic;                                      // 0x00C0(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DyslexicTextStyle;                                 // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ETextSize, int32>                        Sizes;                                             // 0x0120(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameTextData) == 0x000008, "Wrong alignment on FGameTextData");
static_assert(sizeof(FGameTextData) == 0x000170, "Wrong size on FGameTextData");
static_assert(offsetof(FGameTextData, FontDefault) == 0x000000, "Member 'FGameTextData::FontDefault' has a wrong offset!");
static_assert(offsetof(FGameTextData, DefaultTextStyle) == 0x000058, "Member 'FGameTextData::DefaultTextStyle' has a wrong offset!");
static_assert(offsetof(FGameTextData, FontBold) == 0x000060, "Member 'FGameTextData::FontBold' has a wrong offset!");
static_assert(offsetof(FGameTextData, BoldTextStyle) == 0x0000B8, "Member 'FGameTextData::BoldTextStyle' has a wrong offset!");
static_assert(offsetof(FGameTextData, FontDyslexic) == 0x0000C0, "Member 'FGameTextData::FontDyslexic' has a wrong offset!");
static_assert(offsetof(FGameTextData, DyslexicTextStyle) == 0x000118, "Member 'FGameTextData::DyslexicTextStyle' has a wrong offset!");
static_assert(offsetof(FGameTextData, Sizes) == 0x000120, "Member 'FGameTextData::Sizes' has a wrong offset!");

// ScriptStruct UCSW.SettingOptionValue
// 0x0030 (0x0030 - 0x0000)
struct FSettingOptionValue final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSettingOptionValue) == 0x000008, "Wrong alignment on FSettingOptionValue");
static_assert(sizeof(FSettingOptionValue) == 0x000030, "Wrong size on FSettingOptionValue");
static_assert(offsetof(FSettingOptionValue, DisplayName) == 0x000000, "Member 'FSettingOptionValue::DisplayName' has a wrong offset!");
static_assert(offsetof(FSettingOptionValue, Description) == 0x000018, "Member 'FSettingOptionValue::Description' has a wrong offset!");

// ScriptStruct UCSW.SettingOptionCondition
// 0x0010 (0x0010 - 0x0000)
struct FSettingOptionCondition final
{
public:
	struct FNamedHandle                           Property;                                          // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESettingOptionConditionAction                 Action;                                            // 0x000C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSettingOptionCondition) == 0x000004, "Wrong alignment on FSettingOptionCondition");
static_assert(sizeof(FSettingOptionCondition) == 0x000010, "Wrong size on FSettingOptionCondition");
static_assert(offsetof(FSettingOptionCondition, Property) == 0x000000, "Member 'FSettingOptionCondition::Property' has a wrong offset!");
static_assert(offsetof(FSettingOptionCondition, Value) == 0x000008, "Member 'FSettingOptionCondition::Value' has a wrong offset!");
static_assert(offsetof(FSettingOptionCondition, Action) == 0x00000C, "Member 'FSettingOptionCondition::Action' has a wrong offset!");

// ScriptStruct UCSW.SliderParams
// 0x000C (0x000C - 0x0000)
struct FSliderParams final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Step;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSliderParams) == 0x000004, "Wrong alignment on FSliderParams");
static_assert(sizeof(FSliderParams) == 0x00000C, "Wrong size on FSliderParams");
static_assert(offsetof(FSliderParams, Min) == 0x000000, "Member 'FSliderParams::Min' has a wrong offset!");
static_assert(offsetof(FSliderParams, Max) == 0x000004, "Member 'FSliderParams::Max' has a wrong offset!");
static_assert(offsetof(FSliderParams, Step) == 0x000008, "Member 'FSliderParams::Step' has a wrong offset!");

// ScriptStruct UCSW.DefaultOptionValue
// 0x0008 (0x0008 - 0x0000)
struct FDefaultOptionValue final
{
public:
	int32                                         BaseValue;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDefaultOptionValue) == 0x000004, "Wrong alignment on FDefaultOptionValue");
static_assert(sizeof(FDefaultOptionValue) == 0x000008, "Wrong size on FDefaultOptionValue");
static_assert(offsetof(FDefaultOptionValue, BaseValue) == 0x000000, "Member 'FDefaultOptionValue::BaseValue' has a wrong offset!");
static_assert(offsetof(FDefaultOptionValue, Value) == 0x000004, "Member 'FDefaultOptionValue::Value' has a wrong offset!");

// ScriptStruct UCSW.SettingOption
// 0x0098 (0x0098 - 0x0000)
struct FSettingOption final
{
public:
	uint32                                        Flags;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESettingsPropertyType                         PropertyType;                                      // 0x0004(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDefaultOptionValue                    DefaultValue;                                      // 0x0008(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0018(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FText                                   InactiveDescription;                               // 0x0048(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	ESettingsWidgetType                           CtrlType;                                          // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSettingOptionValue>            Values;                                            // 0x0068(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSettingOptionCondition                Condition;                                         // 0x0078(0x0010)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   HoverAction;                                       // 0x0088(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpdateAction;                                      // 0x0090(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSettingOption) == 0x000008, "Wrong alignment on FSettingOption");
static_assert(sizeof(FSettingOption) == 0x000098, "Wrong size on FSettingOption");
static_assert(offsetof(FSettingOption, Flags) == 0x000000, "Member 'FSettingOption::Flags' has a wrong offset!");
static_assert(offsetof(FSettingOption, PropertyType) == 0x000004, "Member 'FSettingOption::PropertyType' has a wrong offset!");
static_assert(offsetof(FSettingOption, DefaultValue) == 0x000008, "Member 'FSettingOption::DefaultValue' has a wrong offset!");
static_assert(offsetof(FSettingOption, Name) == 0x000010, "Member 'FSettingOption::Name' has a wrong offset!");
static_assert(offsetof(FSettingOption, DisplayName) == 0x000018, "Member 'FSettingOption::DisplayName' has a wrong offset!");
static_assert(offsetof(FSettingOption, Description) == 0x000030, "Member 'FSettingOption::Description' has a wrong offset!");
static_assert(offsetof(FSettingOption, InactiveDescription) == 0x000048, "Member 'FSettingOption::InactiveDescription' has a wrong offset!");
static_assert(offsetof(FSettingOption, CtrlType) == 0x000060, "Member 'FSettingOption::CtrlType' has a wrong offset!");
static_assert(offsetof(FSettingOption, Values) == 0x000068, "Member 'FSettingOption::Values' has a wrong offset!");
static_assert(offsetof(FSettingOption, Condition) == 0x000078, "Member 'FSettingOption::Condition' has a wrong offset!");
static_assert(offsetof(FSettingOption, HoverAction) == 0x000088, "Member 'FSettingOption::HoverAction' has a wrong offset!");
static_assert(offsetof(FSettingOption, UpdateAction) == 0x000090, "Member 'FSettingOption::UpdateAction' has a wrong offset!");

// ScriptStruct UCSW.SettingOptionVisualization
// 0x0048 (0x0048 - 0x0000)
struct FSettingOptionVisualization final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTexture2D>>      ValueImages;                                       // 0x0038(0x0010)(Edit, EditFixedSize, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSettingOptionVisualization) == 0x000008, "Wrong alignment on FSettingOptionVisualization");
static_assert(sizeof(FSettingOptionVisualization) == 0x000048, "Wrong size on FSettingOptionVisualization");
static_assert(offsetof(FSettingOptionVisualization, Name) == 0x000000, "Member 'FSettingOptionVisualization::Name' has a wrong offset!");
static_assert(offsetof(FSettingOptionVisualization, Image) == 0x000008, "Member 'FSettingOptionVisualization::Image' has a wrong offset!");
static_assert(offsetof(FSettingOptionVisualization, ValueImages) == 0x000038, "Member 'FSettingOptionVisualization::ValueImages' has a wrong offset!");

// ScriptStruct UCSW.SettingOptionHandle
// 0x0000 (0x0008 - 0x0008)
struct FSettingOptionHandle : public FNamedHandle
{
};
static_assert(alignof(FSettingOptionHandle) == 0x000004, "Wrong alignment on FSettingOptionHandle");
static_assert(sizeof(FSettingOptionHandle) == 0x000008, "Wrong size on FSettingOptionHandle");

// ScriptStruct UCSW.GfxOptionHandle
// 0x0000 (0x0008 - 0x0008)
struct FGfxOptionHandle final : public FSettingOptionHandle
{
};
static_assert(alignof(FGfxOptionHandle) == 0x000004, "Wrong alignment on FGfxOptionHandle");
static_assert(sizeof(FGfxOptionHandle) == 0x000008, "Wrong size on FGfxOptionHandle");

}

