#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Mai

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "Mai_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "Dai_structs.hpp"
#include "Dai_classes.hpp"
#include "Being_structs.hpp"
#include "Being_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "NinjaCharacter_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "NavigationSystem_classes.hpp"


namespace SDK
{

// Class Mai.MaiDespawnInterface
// 0x0000 (0x0028 - 0x0028)
class IMaiDespawnInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiDespawnInterface">();
	}
	static class IMaiDespawnInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMaiDespawnInterface>();
	}
};
static_assert(alignof(IMaiDespawnInterface) == 0x000008, "Wrong alignment on IMaiDespawnInterface");
static_assert(sizeof(IMaiDespawnInterface) == 0x000028, "Wrong size on IMaiDespawnInterface");

// Class Mai.MaiAction
// 0x0020 (0x00C0 - 0x00A0)
class UMaiAction : public UBeingAction
{
public:
	class FName                                   _ActionName;                                       // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _SetBehaviorName;                                  // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnActionFinished;                                  // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void SetActionName(class FName Name_0);

	class FName GetActionName() const;
	bool IsActionFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiAction">();
	}
	static class UMaiAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiAction>();
	}
};
static_assert(alignof(UMaiAction) == 0x000008, "Wrong alignment on UMaiAction");
static_assert(sizeof(UMaiAction) == 0x0000C0, "Wrong size on UMaiAction");
static_assert(offsetof(UMaiAction, _ActionName) == 0x0000A0, "Member 'UMaiAction::_ActionName' has a wrong offset!");
static_assert(offsetof(UMaiAction, _SetBehaviorName) == 0x0000A8, "Member 'UMaiAction::_SetBehaviorName' has a wrong offset!");
static_assert(offsetof(UMaiAction, OnActionFinished) == 0x0000B0, "Member 'UMaiAction::OnActionFinished' has a wrong offset!");

// Class Mai.MaiBTService_KeepDistanceBySpeed
// 0x0038 (0x00D0 - 0x0098)
class UMaiBTService_KeepDistanceBySpeed final : public UBTService_BlackboardBase
{
public:
	struct FBlackboardKeySelector                 _IdealLocation;                                    // 0x0098(0x0028)(Edit, NativeAccessSpecifierPrivate)
	float                                         _LocationOffset;                                   // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _SpeedInterpolation;                               // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _MinSpeed;                                         // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _Debug;                                            // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTService_KeepDistanceBySpeed">();
	}
	static class UMaiBTService_KeepDistanceBySpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTService_KeepDistanceBySpeed>();
	}
};
static_assert(alignof(UMaiBTService_KeepDistanceBySpeed) == 0x000008, "Wrong alignment on UMaiBTService_KeepDistanceBySpeed");
static_assert(sizeof(UMaiBTService_KeepDistanceBySpeed) == 0x0000D0, "Wrong size on UMaiBTService_KeepDistanceBySpeed");
static_assert(offsetof(UMaiBTService_KeepDistanceBySpeed, _IdealLocation) == 0x000098, "Member 'UMaiBTService_KeepDistanceBySpeed::_IdealLocation' has a wrong offset!");
static_assert(offsetof(UMaiBTService_KeepDistanceBySpeed, _LocationOffset) == 0x0000C0, "Member 'UMaiBTService_KeepDistanceBySpeed::_LocationOffset' has a wrong offset!");
static_assert(offsetof(UMaiBTService_KeepDistanceBySpeed, _SpeedInterpolation) == 0x0000C4, "Member 'UMaiBTService_KeepDistanceBySpeed::_SpeedInterpolation' has a wrong offset!");
static_assert(offsetof(UMaiBTService_KeepDistanceBySpeed, _MinSpeed) == 0x0000C8, "Member 'UMaiBTService_KeepDistanceBySpeed::_MinSpeed' has a wrong offset!");
static_assert(offsetof(UMaiBTService_KeepDistanceBySpeed, _Debug) == 0x0000CC, "Member 'UMaiBTService_KeepDistanceBySpeed::_Debug' has a wrong offset!");

// Class Mai.MaiAction_Sequence
// 0x0018 (0x00D8 - 0x00C0)
class UMaiAction_Sequence final : public UMaiAction
{
public:
	TArray<class UBeingAction*>                   _ActionSequence;                                   // 0x00C0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EBeingActionFailHandling                      _ChildFailureHandlingMode;                         // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _Loop;                                             // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiAction_Sequence">();
	}
	static class UMaiAction_Sequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiAction_Sequence>();
	}
};
static_assert(alignof(UMaiAction_Sequence) == 0x000008, "Wrong alignment on UMaiAction_Sequence");
static_assert(sizeof(UMaiAction_Sequence) == 0x0000D8, "Wrong size on UMaiAction_Sequence");
static_assert(offsetof(UMaiAction_Sequence, _ActionSequence) == 0x0000C0, "Member 'UMaiAction_Sequence::_ActionSequence' has a wrong offset!");
static_assert(offsetof(UMaiAction_Sequence, _ChildFailureHandlingMode) == 0x0000D0, "Member 'UMaiAction_Sequence::_ChildFailureHandlingMode' has a wrong offset!");
static_assert(offsetof(UMaiAction_Sequence, _Loop) == 0x0000D4, "Member 'UMaiAction_Sequence::_Loop' has a wrong offset!");

// Class Mai.MaiCrowdAgent
// 0x0000 (0x0308 - 0x0308)
class UMaiCrowdAgent final : public UCrowdFollowingComponent
{
public:
	void InitializeCrowd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiCrowdAgent">();
	}
	static class UMaiCrowdAgent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiCrowdAgent>();
	}
};
static_assert(alignof(UMaiCrowdAgent) == 0x000008, "Wrong alignment on UMaiCrowdAgent");
static_assert(sizeof(UMaiCrowdAgent) == 0x000308, "Wrong size on UMaiCrowdAgent");

// Class Mai.MaiActionGraph
// 0x0020 (0x02D0 - 0x02B0)
class AMaiActionGraph final : public AActor
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaiPointGraphComponent*                _PointGraph;                                       // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class APawn*>                          _GraphWalkers;                                     // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	class AMaiActionPoint* FindNearestPoint(const struct FVector& Location) const;
	int32 GetActionPointCount() const;
	void GetActionPoints(TArray<class AMaiActionPoint*>* ActionPoints) const;
	void GetActionPointsWithQuery(TArray<class AMaiActionPoint*>* ActionPoints, const struct FMaiActionPointQuery& Query) const;
	class AMaiActionPoint* GetNextActionPoint(class AMaiActionPoint* Ap, class FName SequenceTag) const;
	void GetSequenceActionPoints(TArray<class AMaiActionPoint*>* ActionPoints, class FName SequenceTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiActionGraph">();
	}
	static class AMaiActionGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiActionGraph>();
	}
};
static_assert(alignof(AMaiActionGraph) == 0x000008, "Wrong alignment on AMaiActionGraph");
static_assert(sizeof(AMaiActionGraph) == 0x0002D0, "Wrong size on AMaiActionGraph");
static_assert(offsetof(AMaiActionGraph, _PointGraph) == 0x0002B8, "Member 'AMaiActionGraph::_PointGraph' has a wrong offset!");
static_assert(offsetof(AMaiActionGraph, _GraphWalkers) == 0x0002C0, "Member 'AMaiActionGraph::_GraphWalkers' has a wrong offset!");

// Class Mai.MaiPointGraphComponent
// 0x0020 (0x02C0 - 0x02A0)
class UMaiPointGraphComponent final : public USceneComponent
{
public:
	TArray<class AMaiActionPoint*>                _ActionPoints;                                     // 0x02A0(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          _SequenceConverted;                                // 0x02B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Indoor;                                           // 0x02B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2[0xE];                                      // 0x02B2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AMaiActionPoint* FindNearestPoint(const struct FVector& Location) const;
	int32 GetActionPointCount() const;
	void GetActionPoints(TArray<class AMaiActionPoint*>* ActionPoints, class FName WithTag) const;
	void GetActionPointsWithQuery(TArray<class AMaiActionPoint*>* ActionPoints, const struct FMaiActionPointQuery& Query) const;
	class AMaiActionPoint* GetRandomActionPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiPointGraphComponent">();
	}
	static class UMaiPointGraphComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiPointGraphComponent>();
	}
};
static_assert(alignof(UMaiPointGraphComponent) == 0x000010, "Wrong alignment on UMaiPointGraphComponent");
static_assert(sizeof(UMaiPointGraphComponent) == 0x0002C0, "Wrong size on UMaiPointGraphComponent");
static_assert(offsetof(UMaiPointGraphComponent, _ActionPoints) == 0x0002A0, "Member 'UMaiPointGraphComponent::_ActionPoints' has a wrong offset!");
static_assert(offsetof(UMaiPointGraphComponent, _SequenceConverted) == 0x0002B0, "Member 'UMaiPointGraphComponent::_SequenceConverted' has a wrong offset!");
static_assert(offsetof(UMaiPointGraphComponent, _Indoor) == 0x0002B1, "Member 'UMaiPointGraphComponent::_Indoor' has a wrong offset!");

// Class Mai.MaiBTDecorator_WithInterval
// 0x0010 (0x0078 - 0x0068)
class UMaiBTDecorator_WithInterval : public UBTDecorator
{
public:
	float                                         Interval;                                          // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomDeviation;                                   // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTDecorator_WithInterval">();
	}
	static class UMaiBTDecorator_WithInterval* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTDecorator_WithInterval>();
	}
};
static_assert(alignof(UMaiBTDecorator_WithInterval) == 0x000008, "Wrong alignment on UMaiBTDecorator_WithInterval");
static_assert(sizeof(UMaiBTDecorator_WithInterval) == 0x000078, "Wrong size on UMaiBTDecorator_WithInterval");
static_assert(offsetof(UMaiBTDecorator_WithInterval, Interval) == 0x000068, "Member 'UMaiBTDecorator_WithInterval::Interval' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_WithInterval, RandomDeviation) == 0x00006C, "Member 'UMaiBTDecorator_WithInterval::RandomDeviation' has a wrong offset!");

// Class Mai.MaiBTDecorator_Condition
// 0x0008 (0x0080 - 0x0078)
class UMaiBTDecorator_Condition final : public UMaiBTDecorator_WithInterval
{
public:
	class UDaiCondition*                          _Condition;                                        // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTDecorator_Condition">();
	}
	static class UMaiBTDecorator_Condition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTDecorator_Condition>();
	}
};
static_assert(alignof(UMaiBTDecorator_Condition) == 0x000008, "Wrong alignment on UMaiBTDecorator_Condition");
static_assert(sizeof(UMaiBTDecorator_Condition) == 0x000080, "Wrong size on UMaiBTDecorator_Condition");
static_assert(offsetof(UMaiBTDecorator_Condition, _Condition) == 0x000078, "Member 'UMaiBTDecorator_Condition::_Condition' has a wrong offset!");

// Class Mai.AIDataProvider_IncParams
// 0x0008 (0x0048 - 0x0040)
class UAIDataProvider_IncParams final : public UAIDataProvider_QueryParams
{
public:
	float                                         Mod;                                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDataProvider_IncParams">();
	}
	static class UAIDataProvider_IncParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDataProvider_IncParams>();
	}
};
static_assert(alignof(UAIDataProvider_IncParams) == 0x000008, "Wrong alignment on UAIDataProvider_IncParams");
static_assert(sizeof(UAIDataProvider_IncParams) == 0x000048, "Wrong size on UAIDataProvider_IncParams");
static_assert(offsetof(UAIDataProvider_IncParams, Mod) == 0x000040, "Member 'UAIDataProvider_IncParams::Mod' has a wrong offset!");

// Class Mai.MaiActionSequenceComponent
// 0x0040 (0x05C0 - 0x0580)
class UMaiActionSequenceComponent final : public ULineBatchComponent
{
public:
	TArray<class AMaiActionPoint*>                _SequencePoints;                                   // 0x0580(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FColor                                 _SequenceColor;                                    // 0x0590(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _AutoAddRange;                                     // 0x0594(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Looped;                                           // 0x0598(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_599[0x7];                                      // 0x0599(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _PreviewIndex;                                     // 0x05A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A4[0x4];                                      // 0x05A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMaiActionPoint*                        _MovingPoint;                                      // 0x05A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B0[0x10];                                     // 0x05B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AMaiActionPoint* GetNextActionPoint(class AMaiActionPoint* Point, class APawn* ConditionCaller) const;
	void GetSequenceActionPoints(TArray<class AMaiActionPoint*>* Points) const;
	class AMaiActionPoint* GetTargetActionPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiActionSequenceComponent">();
	}
	static class UMaiActionSequenceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiActionSequenceComponent>();
	}
};
static_assert(alignof(UMaiActionSequenceComponent) == 0x000010, "Wrong alignment on UMaiActionSequenceComponent");
static_assert(sizeof(UMaiActionSequenceComponent) == 0x0005C0, "Wrong size on UMaiActionSequenceComponent");
static_assert(offsetof(UMaiActionSequenceComponent, _SequencePoints) == 0x000580, "Member 'UMaiActionSequenceComponent::_SequencePoints' has a wrong offset!");
static_assert(offsetof(UMaiActionSequenceComponent, _SequenceColor) == 0x000590, "Member 'UMaiActionSequenceComponent::_SequenceColor' has a wrong offset!");
static_assert(offsetof(UMaiActionSequenceComponent, _AutoAddRange) == 0x000594, "Member 'UMaiActionSequenceComponent::_AutoAddRange' has a wrong offset!");
static_assert(offsetof(UMaiActionSequenceComponent, _Looped) == 0x000598, "Member 'UMaiActionSequenceComponent::_Looped' has a wrong offset!");
static_assert(offsetof(UMaiActionSequenceComponent, _PreviewIndex) == 0x0005A0, "Member 'UMaiActionSequenceComponent::_PreviewIndex' has a wrong offset!");
static_assert(offsetof(UMaiActionSequenceComponent, _MovingPoint) == 0x0005A8, "Member 'UMaiActionSequenceComponent::_MovingPoint' has a wrong offset!");

// Class Mai.MaiActionPoint
// 0x01A0 (0x0450 - 0x02B0)
class AMaiActionPoint : public AActor
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   _MarkerMesh;                                       // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaiAreaComponent*                      _WorkArea;                                         // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        _Arrow;                                            // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextRenderComponent*                   _Text;                                             // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _Color;                                            // 0x02D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AMaiController*>                 _Users;                                            // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          _HasTravelConditions;                              // 0x02F8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _IsGraphPoint;                                     // 0x02F9(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FA[0x6];                                      // 0x02FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDaiCondition>              _OldConditionClass;                                // 0x0300(0x0008)(Edit, ZeroConstructor, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDaiCondition>              _NewConditionClass;                                // 0x0308(0x0008)(Edit, ZeroConstructor, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Radius;                                           // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBeingWalkingStance                           _WalkingStanceEnum;                                // 0x0314(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _MaxUsers;                                         // 0x0315(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_316[0x2];                                      // 0x0316(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        _UseCounter;                                       // 0x0318(0x0004)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _UseOnce : 1;                                      // 0x031C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31D[0x3];                                      // 0x031D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         _Weight;                                           // 0x0320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_321[0x3];                                      // 0x0321(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         _Enabled : 1;                                      // 0x0324(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _Skipable : 1;                                     // 0x0324(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _PlacedInWorld : 1;                                // 0x0324(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _WaypointOnly : 1;                                 // 0x0324(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _MoveExaclyToAP : 1;                               // 0x0324(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _StopsToAction : 1;                                // 0x0324(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _RotateToAction : 1;                               // 0x0324(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_325[0x3];                                      // 0x0325(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _RotateToActionPrecision;                          // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaiWork>                       _WorkList;                                         // 0x0330(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDaiConditions                         _UseConditions;                                    // 0x0340(0x0030)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDaiNotifies                           _TravelNotifies;                                   // 0x0370(0x0018)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDaiNotifies                           _AbandonNotifies;                                  // 0x0388(0x0018)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDaiConditions                         _TravelConditions;                                 // 0x03A0(0x0030)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FMaiWork>                       _WaitWorkList;                                     // 0x03D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class AMaiActionPoint*, uint8>           _Destinations;                                     // 0x03E0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                _ShowComponents;                                   // 0x0430(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActionStarted;                                   // 0x0440(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnActionPointAbandoned(class AMaiController* User);
	void OnActionPointReached(class AMaiController* User);
	void OnActionPointSelected(class AMaiController* User);
	void OnPlaceInWorld();
	void PrepareActionSet(class AMaiController* User);
	void PrepareToWork(class AMaiController* User);
	void ResetUseCounter();
	void Used();

	bool CanBeUsedBy(class AMaiController* User) const;
	struct FRotator GetActionRotation() const;
	class UMaiActionSequenceComponent* GetSequence(class FName SequenceTag) const;
	uint8 GetWeight() const;
	bool HasAnyWork() const;
	bool InDetectionArea(const struct FVector& Location, float AreaExtent) const;
	bool IsUsable() const;
	bool IsUsableBy(class AMaiController* User) const;
	bool IsVisibleFrom(const struct FVector& Location, float DefaultVisibilityRange, float PerceptionMod) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiActionPoint">();
	}
	static class AMaiActionPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiActionPoint>();
	}
};
static_assert(alignof(AMaiActionPoint) == 0x000008, "Wrong alignment on AMaiActionPoint");
static_assert(sizeof(AMaiActionPoint) == 0x000450, "Wrong size on AMaiActionPoint");
static_assert(offsetof(AMaiActionPoint, _MarkerMesh) == 0x0002B8, "Member 'AMaiActionPoint::_MarkerMesh' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _WorkArea) == 0x0002C0, "Member 'AMaiActionPoint::_WorkArea' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _Arrow) == 0x0002C8, "Member 'AMaiActionPoint::_Arrow' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _Text) == 0x0002D0, "Member 'AMaiActionPoint::_Text' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _Color) == 0x0002D8, "Member 'AMaiActionPoint::_Color' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _Users) == 0x0002E8, "Member 'AMaiActionPoint::_Users' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _HasTravelConditions) == 0x0002F8, "Member 'AMaiActionPoint::_HasTravelConditions' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _IsGraphPoint) == 0x0002F9, "Member 'AMaiActionPoint::_IsGraphPoint' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _OldConditionClass) == 0x000300, "Member 'AMaiActionPoint::_OldConditionClass' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _NewConditionClass) == 0x000308, "Member 'AMaiActionPoint::_NewConditionClass' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _Radius) == 0x000310, "Member 'AMaiActionPoint::_Radius' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _WalkingStanceEnum) == 0x000314, "Member 'AMaiActionPoint::_WalkingStanceEnum' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _MaxUsers) == 0x000315, "Member 'AMaiActionPoint::_MaxUsers' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _UseCounter) == 0x000318, "Member 'AMaiActionPoint::_UseCounter' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _Weight) == 0x000320, "Member 'AMaiActionPoint::_Weight' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _RotateToActionPrecision) == 0x000328, "Member 'AMaiActionPoint::_RotateToActionPrecision' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _WorkList) == 0x000330, "Member 'AMaiActionPoint::_WorkList' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _UseConditions) == 0x000340, "Member 'AMaiActionPoint::_UseConditions' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _TravelNotifies) == 0x000370, "Member 'AMaiActionPoint::_TravelNotifies' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _AbandonNotifies) == 0x000388, "Member 'AMaiActionPoint::_AbandonNotifies' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _TravelConditions) == 0x0003A0, "Member 'AMaiActionPoint::_TravelConditions' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _WaitWorkList) == 0x0003D0, "Member 'AMaiActionPoint::_WaitWorkList' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _Destinations) == 0x0003E0, "Member 'AMaiActionPoint::_Destinations' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, _ShowComponents) == 0x000430, "Member 'AMaiActionPoint::_ShowComponents' has a wrong offset!");
static_assert(offsetof(AMaiActionPoint, OnActionStarted) == 0x000440, "Member 'AMaiActionPoint::OnActionStarted' has a wrong offset!");

// Class Mai.MaiNavBox
// 0x0010 (0x0590 - 0x0580)
class UMaiNavBox : public UBoxComponent
{
public:
	uint8                                         Pad_580[0x10];                                     // 0x0580(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableArea();
	void EnableArea();
	void SetAreaClass(TSubclassOf<class UNavArea> NewAreaClass);

	bool IsInArea(const struct FVector& Location, float Extent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNavBox">();
	}
	static class UMaiNavBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiNavBox>();
	}
};
static_assert(alignof(UMaiNavBox) == 0x000010, "Wrong alignment on UMaiNavBox");
static_assert(sizeof(UMaiNavBox) == 0x000590, "Wrong size on UMaiNavBox");

// Class Mai.MaiNarrowTriggerBox
// 0x0000 (0x0590 - 0x0590)
class UMaiNarrowTriggerBox final : public UMaiNavBox
{
public:
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNarrowTriggerBox">();
	}
	static class UMaiNarrowTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiNarrowTriggerBox>();
	}
};
static_assert(alignof(UMaiNarrowTriggerBox) == 0x000010, "Wrong alignment on UMaiNarrowTriggerBox");
static_assert(sizeof(UMaiNarrowTriggerBox) == 0x000590, "Wrong size on UMaiNarrowTriggerBox");

// Class Mai.MaiAction_AnimationBase
// 0x0010 (0x00D0 - 0x00C0)
class UMaiAction_AnimationBase : public UMaiAction
{
public:
	class UAnimMontage*                           _OwnerMontage;                                     // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             _OwnerCH;                                          // 0x00C8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnOwnerMontageEnds(class UAnimMontage* Montage, bool Interrupted);
	void SetOwnerCH(class ACharacter* OwnerCH);
	void SetOwnerMontage(class UAnimMontage* Montage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiAction_AnimationBase">();
	}
	static class UMaiAction_AnimationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiAction_AnimationBase>();
	}
};
static_assert(alignof(UMaiAction_AnimationBase) == 0x000008, "Wrong alignment on UMaiAction_AnimationBase");
static_assert(sizeof(UMaiAction_AnimationBase) == 0x0000D0, "Wrong size on UMaiAction_AnimationBase");
static_assert(offsetof(UMaiAction_AnimationBase, _OwnerMontage) == 0x0000C0, "Member 'UMaiAction_AnimationBase::_OwnerMontage' has a wrong offset!");
static_assert(offsetof(UMaiAction_AnimationBase, _OwnerCH) == 0x0000C8, "Member 'UMaiAction_AnimationBase::_OwnerCH' has a wrong offset!");

// Class Mai.MaiAction_SynchronizationBase
// 0x0018 (0x00E8 - 0x00D0)
class UMaiAction_SynchronizationBase : public UMaiAction_AnimationBase
{
public:
	class UAnimMontage*                           _OtherMontage;                                     // 0x00D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             _OtherCH;                                          // 0x00D8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOtherMontageEnds(class UAnimMontage* Montage, bool Interrupted);
	void PossessOther();
	void ReleaseOther();
	void SetOtherCH(class ACharacter* OtherCH);
	void SetOtherMontage(class UAnimMontage* Montage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiAction_SynchronizationBase">();
	}
	static class UMaiAction_SynchronizationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiAction_SynchronizationBase>();
	}
};
static_assert(alignof(UMaiAction_SynchronizationBase) == 0x000008, "Wrong alignment on UMaiAction_SynchronizationBase");
static_assert(sizeof(UMaiAction_SynchronizationBase) == 0x0000E8, "Wrong size on UMaiAction_SynchronizationBase");
static_assert(offsetof(UMaiAction_SynchronizationBase, _OtherMontage) == 0x0000D0, "Member 'UMaiAction_SynchronizationBase::_OtherMontage' has a wrong offset!");
static_assert(offsetof(UMaiAction_SynchronizationBase, _OtherCH) == 0x0000D8, "Member 'UMaiAction_SynchronizationBase::_OtherCH' has a wrong offset!");

// Class Mai.MaiIsLineToEnemyClearStat
// 0x0038 (0x0128 - 0x00F0)
class UMaiIsLineToEnemyClearStat : public UBeingRelativeStat
{
public:
	EDrawDebugTrace                               _DrawDebugType;                                    // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _TraceColor;                                       // 0x00F4(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _TraceHitColor;                                    // 0x0104(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _DrawTime;                                         // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _Profile;                                          // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _Radius;                                           // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiIsLineToEnemyClearStat">();
	}
	static class UMaiIsLineToEnemyClearStat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiIsLineToEnemyClearStat>();
	}
};
static_assert(alignof(UMaiIsLineToEnemyClearStat) == 0x000008, "Wrong alignment on UMaiIsLineToEnemyClearStat");
static_assert(sizeof(UMaiIsLineToEnemyClearStat) == 0x000128, "Wrong size on UMaiIsLineToEnemyClearStat");
static_assert(offsetof(UMaiIsLineToEnemyClearStat, _DrawDebugType) == 0x0000F0, "Member 'UMaiIsLineToEnemyClearStat::_DrawDebugType' has a wrong offset!");
static_assert(offsetof(UMaiIsLineToEnemyClearStat, _TraceColor) == 0x0000F4, "Member 'UMaiIsLineToEnemyClearStat::_TraceColor' has a wrong offset!");
static_assert(offsetof(UMaiIsLineToEnemyClearStat, _TraceHitColor) == 0x000104, "Member 'UMaiIsLineToEnemyClearStat::_TraceHitColor' has a wrong offset!");
static_assert(offsetof(UMaiIsLineToEnemyClearStat, _DrawTime) == 0x000114, "Member 'UMaiIsLineToEnemyClearStat::_DrawTime' has a wrong offset!");
static_assert(offsetof(UMaiIsLineToEnemyClearStat, _Profile) == 0x000118, "Member 'UMaiIsLineToEnemyClearStat::_Profile' has a wrong offset!");
static_assert(offsetof(UMaiIsLineToEnemyClearStat, _Radius) == 0x000120, "Member 'UMaiIsLineToEnemyClearStat::_Radius' has a wrong offset!");

// Class Mai.MaiAction_Snap2Base
// 0x02F8 (0x03E0 - 0x00E8)
#pragma pack(push, 0x1)
class alignas(0x10) UMaiAction_Snap2Base : public UMaiAction_SynchronizationBase
{
public:
	class UBeingRootMotionBank*                   _OwnerATB;                                         // 0x00E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBeingRootMotionBank*                   _OtherATB;                                         // 0x00F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimationRootMotion                   _OwnerMontageRM;                                   // 0x00F8(0x0048)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FAnimationRootMotion                   _OtherMontageRM;                                   // 0x0140(0x0048)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSectionRootMotion                     _OwnerARM;                                         // 0x0188(0x0058)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSectionRootMotion                     _OtherARM;                                         // 0x01E0(0x0058)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSectionRootMotion                     _OwnerWorldARM;                                    // 0x0238(0x0058)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSectionRootMotion                     _OtherWorldARM;                                    // 0x0290(0x0058)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             _OwnerIdealTransform;                              // 0x02F0(0x0060)(Edit, BlueprintVisible, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             _OtherIdealTransform;                              // 0x0350(0x0060)(Edit, BlueprintVisible, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _SectionName;                                      // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Disconnect;                                       // 0x03B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _SyncSnap;                                         // 0x03B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _BlockSnap;                                        // 0x03BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Snap3D;                                           // 0x03BB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SnapMoveMulMin;                                   // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SnapMoveMulMax;                                   // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SnapMoveMulInterp;                                // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _RotationInterpSpeed;                              // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _TranslationInterpSpeed;                           // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D0[0x8];                                      // 0x03D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSectionEnd(class FName Section);
	void OnSectionStart(class FName Section);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiAction_Snap2Base">();
	}
	static class UMaiAction_Snap2Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiAction_Snap2Base>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMaiAction_Snap2Base) == 0x000010, "Wrong alignment on UMaiAction_Snap2Base");
static_assert(sizeof(UMaiAction_Snap2Base) == 0x0003E0, "Wrong size on UMaiAction_Snap2Base");
static_assert(offsetof(UMaiAction_Snap2Base, _OwnerATB) == 0x0000E8, "Member 'UMaiAction_Snap2Base::_OwnerATB' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _OtherATB) == 0x0000F0, "Member 'UMaiAction_Snap2Base::_OtherATB' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _OwnerMontageRM) == 0x0000F8, "Member 'UMaiAction_Snap2Base::_OwnerMontageRM' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _OtherMontageRM) == 0x000140, "Member 'UMaiAction_Snap2Base::_OtherMontageRM' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _OwnerARM) == 0x000188, "Member 'UMaiAction_Snap2Base::_OwnerARM' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _OtherARM) == 0x0001E0, "Member 'UMaiAction_Snap2Base::_OtherARM' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _OwnerWorldARM) == 0x000238, "Member 'UMaiAction_Snap2Base::_OwnerWorldARM' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _OtherWorldARM) == 0x000290, "Member 'UMaiAction_Snap2Base::_OtherWorldARM' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _OwnerIdealTransform) == 0x0002F0, "Member 'UMaiAction_Snap2Base::_OwnerIdealTransform' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _OtherIdealTransform) == 0x000350, "Member 'UMaiAction_Snap2Base::_OtherIdealTransform' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _SectionName) == 0x0003B0, "Member 'UMaiAction_Snap2Base::_SectionName' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _Disconnect) == 0x0003B8, "Member 'UMaiAction_Snap2Base::_Disconnect' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _SyncSnap) == 0x0003B9, "Member 'UMaiAction_Snap2Base::_SyncSnap' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _BlockSnap) == 0x0003BA, "Member 'UMaiAction_Snap2Base::_BlockSnap' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _Snap3D) == 0x0003BB, "Member 'UMaiAction_Snap2Base::_Snap3D' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _SnapMoveMulMin) == 0x0003BC, "Member 'UMaiAction_Snap2Base::_SnapMoveMulMin' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _SnapMoveMulMax) == 0x0003C0, "Member 'UMaiAction_Snap2Base::_SnapMoveMulMax' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _SnapMoveMulInterp) == 0x0003C4, "Member 'UMaiAction_Snap2Base::_SnapMoveMulInterp' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _RotationInterpSpeed) == 0x0003C8, "Member 'UMaiAction_Snap2Base::_RotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap2Base, _TranslationInterpSpeed) == 0x0003CC, "Member 'UMaiAction_Snap2Base::_TranslationInterpSpeed' has a wrong offset!");

// Class Mai.MaiAction_Snap1Base
// 0x0190 (0x0260 - 0x00D0)
#pragma pack(push, 0x1)
class alignas(0x10) UMaiAction_Snap1Base : public UMaiAction_AnimationBase
{
public:
	class UBeingRootMotionBank*                   _OwnerATB;                                         // 0x00D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimationRootMotion                   _OwnerMontageRM;                                   // 0x00D8(0x0048)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSectionRootMotion                     _OwnerARM;                                         // 0x0120(0x0058)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSectionRootMotion                     _OwnerWorldARM;                                    // 0x0178(0x0058)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTransform                             _OwnerIdealTransform;                              // 0x01D0(0x0060)(Edit, BlueprintVisible, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _RotationInterpSpeed;                              // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _TranslationInterpSpeed;                           // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _SectionName;                                      // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _MoveOnRail;                                       // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Disconnect;                                       // 0x0241(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _SyncSnap;                                         // 0x0242(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _BlockSnap;                                        // 0x0243(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Snap3D;                                           // 0x0244(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _SnapUpVector;                                     // 0x0245(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _IdealTransformAsTarget;                           // 0x0246(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ErrorCorrection;                                  // 0x0247(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SnapMoveMulMin;                                   // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SnapMoveMulMax;                                   // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SnapMoveMulInterp;                                // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalculateIdealTransforms();
	void OnSectionEnd(class FName Section);
	void OnSectionStart(class FName Section);
	class UAnimMontage* PlayOwnerMontage();

	struct FVector GetSectionOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiAction_Snap1Base">();
	}
	static class UMaiAction_Snap1Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiAction_Snap1Base>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMaiAction_Snap1Base) == 0x000010, "Wrong alignment on UMaiAction_Snap1Base");
static_assert(sizeof(UMaiAction_Snap1Base) == 0x000260, "Wrong size on UMaiAction_Snap1Base");
static_assert(offsetof(UMaiAction_Snap1Base, _OwnerATB) == 0x0000D0, "Member 'UMaiAction_Snap1Base::_OwnerATB' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap1Base, _OwnerMontageRM) == 0x0000D8, "Member 'UMaiAction_Snap1Base::_OwnerMontageRM' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap1Base, _OwnerARM) == 0x000120, "Member 'UMaiAction_Snap1Base::_OwnerARM' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap1Base, _OwnerWorldARM) == 0x000178, "Member 'UMaiAction_Snap1Base::_OwnerWorldARM' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap1Base, _OwnerIdealTransform) == 0x0001D0, "Member 'UMaiAction_Snap1Base::_OwnerIdealTransform' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap1Base, _RotationInterpSpeed) == 0x000230, "Member 'UMaiAction_Snap1Base::_RotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap1Base, _TranslationInterpSpeed) == 0x000234, "Member 'UMaiAction_Snap1Base::_TranslationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap1Base, _SectionName) == 0x000238, "Member 'UMaiAction_Snap1Base::_SectionName' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap1Base, _MoveOnRail) == 0x000240, "Member 'UMaiAction_Snap1Base::_MoveOnRail' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap1Base, _Disconnect) == 0x000241, "Member 'UMaiAction_Snap1Base::_Disconnect' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap1Base, _SyncSnap) == 0x000242, "Member 'UMaiAction_Snap1Base::_SyncSnap' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap1Base, _BlockSnap) == 0x000243, "Member 'UMaiAction_Snap1Base::_BlockSnap' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap1Base, _Snap3D) == 0x000244, "Member 'UMaiAction_Snap1Base::_Snap3D' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap1Base, _SnapUpVector) == 0x000245, "Member 'UMaiAction_Snap1Base::_SnapUpVector' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap1Base, _IdealTransformAsTarget) == 0x000246, "Member 'UMaiAction_Snap1Base::_IdealTransformAsTarget' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap1Base, _ErrorCorrection) == 0x000247, "Member 'UMaiAction_Snap1Base::_ErrorCorrection' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap1Base, _SnapMoveMulMin) == 0x000248, "Member 'UMaiAction_Snap1Base::_SnapMoveMulMin' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap1Base, _SnapMoveMulMax) == 0x00024C, "Member 'UMaiAction_Snap1Base::_SnapMoveMulMax' has a wrong offset!");
static_assert(offsetof(UMaiAction_Snap1Base, _SnapMoveMulInterp) == 0x000250, "Member 'UMaiAction_Snap1Base::_SnapMoveMulInterp' has a wrong offset!");

// Class Mai.MaiSenseConfig_The6thSense
// 0x0018 (0x0060 - 0x0048)
class UMaiSenseConfig_The6thSense final : public UAISenseConfig
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DistanceCurve;                                     // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SensingRange;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSenseConfig_The6thSense">();
	}
	static class UMaiSenseConfig_The6thSense* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSenseConfig_The6thSense>();
	}
};
static_assert(alignof(UMaiSenseConfig_The6thSense) == 0x000008, "Wrong alignment on UMaiSenseConfig_The6thSense");
static_assert(sizeof(UMaiSenseConfig_The6thSense) == 0x000060, "Wrong size on UMaiSenseConfig_The6thSense");
static_assert(offsetof(UMaiSenseConfig_The6thSense, DistanceCurve) == 0x000050, "Member 'UMaiSenseConfig_The6thSense::DistanceCurve' has a wrong offset!");
static_assert(offsetof(UMaiSenseConfig_The6thSense, SensingRange) == 0x000058, "Member 'UMaiSenseConfig_The6thSense::SensingRange' has a wrong offset!");

// Class Mai.MaiAction_MoveOnSpline
// 0x0008 (0x00C8 - 0x00C0)
class UMaiAction_MoveOnSpline final : public UMaiAction
{
public:
	class AMaiSplineActor*                        _Spline;                                           // 0x00C0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UMaiAction_MoveOnSpline* CreateActionMoveOnSpline(class UObject* WorldContextObject, class AMaiSplineActor* Spline);
	static class UMaiAction_MoveOnSpline* CreateActionMoveOnSplineToAP(class UObject* WorldContextObject, class APawn* Pawn, class AMaiActionPoint* Point);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiAction_MoveOnSpline">();
	}
	static class UMaiAction_MoveOnSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiAction_MoveOnSpline>();
	}
};
static_assert(alignof(UMaiAction_MoveOnSpline) == 0x000008, "Wrong alignment on UMaiAction_MoveOnSpline");
static_assert(sizeof(UMaiAction_MoveOnSpline) == 0x0000C8, "Wrong size on UMaiAction_MoveOnSpline");
static_assert(offsetof(UMaiAction_MoveOnSpline, _Spline) == 0x0000C0, "Member 'UMaiAction_MoveOnSpline::_Spline' has a wrong offset!");

// Class Mai.MaiBTDecorator_ContainsBehavior
// 0x0000 (0x0068 - 0x0068)
class UMaiBTDecorator_ContainsBehavior final : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTDecorator_ContainsBehavior">();
	}
	static class UMaiBTDecorator_ContainsBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTDecorator_ContainsBehavior>();
	}
};
static_assert(alignof(UMaiBTDecorator_ContainsBehavior) == 0x000008, "Wrong alignment on UMaiBTDecorator_ContainsBehavior");
static_assert(sizeof(UMaiBTDecorator_ContainsBehavior) == 0x000068, "Wrong size on UMaiBTDecorator_ContainsBehavior");

// Class Mai.MaiAction_PlayAnimation
// 0x00F0 (0x0350 - 0x0260)
class UMaiAction_PlayAnimation : public UMaiAction_Snap1Base
{
public:
	struct FGameplayTagContainer                  _AnimTags;                                         // 0x0258(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  _AbortAnimTags;                                    // 0x0278(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   _AbortSection;                                     // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _NonBlocking : 1;                                  // 0x02A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _InfinitLoop : 1;                                  // 0x02A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _AbortBlendOutTime;                                // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Duration;                                         // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _PlayRate;                                         // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _LoopCount;                                        // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _BlockBT;                                          // 0x02B4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDaiAnimPlayParams                     _OwnerAnimParams;                                  // 0x02C0(0x0078)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_338[0x18];                                     // 0x0338(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMaiAction_PlayAnimation* CreateActionPlayAnimWithParams(class UObject* WorldContextObject, const struct FDaiAnimPlayParams& AnimParams, class FName blockBT, int32 LoopCount);
	static class UMaiAction_PlayAnimation* CreateActionPlayFromTags(class UObject* WorldContextObject, const struct FGameplayTagContainer& AnimTags, class FName blockBT, int32 LoopCount);
	static class UMaiAction_PlayAnimation* CreateActionPlayLoopedAnim(class UObject* WorldContextObject, const struct FGameplayTagContainer& AnimTags, class FName blockBT, int32 LoopCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiAction_PlayAnimation">();
	}
	static class UMaiAction_PlayAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiAction_PlayAnimation>();
	}
};
static_assert(alignof(UMaiAction_PlayAnimation) == 0x000010, "Wrong alignment on UMaiAction_PlayAnimation");
static_assert(sizeof(UMaiAction_PlayAnimation) == 0x000350, "Wrong size on UMaiAction_PlayAnimation");
static_assert(offsetof(UMaiAction_PlayAnimation, _AnimTags) == 0x000258, "Member 'UMaiAction_PlayAnimation::_AnimTags' has a wrong offset!");
static_assert(offsetof(UMaiAction_PlayAnimation, _AbortAnimTags) == 0x000278, "Member 'UMaiAction_PlayAnimation::_AbortAnimTags' has a wrong offset!");
static_assert(offsetof(UMaiAction_PlayAnimation, _AbortSection) == 0x000298, "Member 'UMaiAction_PlayAnimation::_AbortSection' has a wrong offset!");
static_assert(offsetof(UMaiAction_PlayAnimation, _AbortBlendOutTime) == 0x0002A4, "Member 'UMaiAction_PlayAnimation::_AbortBlendOutTime' has a wrong offset!");
static_assert(offsetof(UMaiAction_PlayAnimation, _Duration) == 0x0002A8, "Member 'UMaiAction_PlayAnimation::_Duration' has a wrong offset!");
static_assert(offsetof(UMaiAction_PlayAnimation, _PlayRate) == 0x0002AC, "Member 'UMaiAction_PlayAnimation::_PlayRate' has a wrong offset!");
static_assert(offsetof(UMaiAction_PlayAnimation, _LoopCount) == 0x0002B0, "Member 'UMaiAction_PlayAnimation::_LoopCount' has a wrong offset!");
static_assert(offsetof(UMaiAction_PlayAnimation, _BlockBT) == 0x0002B4, "Member 'UMaiAction_PlayAnimation::_BlockBT' has a wrong offset!");
static_assert(offsetof(UMaiAction_PlayAnimation, _OwnerAnimParams) == 0x0002C0, "Member 'UMaiAction_PlayAnimation::_OwnerAnimParams' has a wrong offset!");

// Class Mai.MaiAction_ExtMovementAnimation
// 0x0030 (0x0380 - 0x0350)
class UMaiAction_ExtMovementAnimation final : public UMaiAction_PlayAnimation
{
public:
	class AMaiNavLink*                            _NavLink;                                          // 0x0350(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _StartInA;                                         // 0x0358(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _LeftMargin;                                       // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _RightMargin;                                      // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaiAttack*                             _Attack;                                           // 0x0368(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _Enemy;                                            // 0x0370(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMaiAction_ExtMovementAnimation* CreateActionExtMovementAnimation(class UObject* WorldContextObject, const struct FGameplayTagContainer& AnimTags, class AMaiNavLink* NavLink, bool StartSide, TSubclassOf<class UMaiAction_ExtMovementAnimation> ActionClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiAction_ExtMovementAnimation">();
	}
	static class UMaiAction_ExtMovementAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiAction_ExtMovementAnimation>();
	}
};
static_assert(alignof(UMaiAction_ExtMovementAnimation) == 0x000010, "Wrong alignment on UMaiAction_ExtMovementAnimation");
static_assert(sizeof(UMaiAction_ExtMovementAnimation) == 0x000380, "Wrong size on UMaiAction_ExtMovementAnimation");
static_assert(offsetof(UMaiAction_ExtMovementAnimation, _NavLink) == 0x000350, "Member 'UMaiAction_ExtMovementAnimation::_NavLink' has a wrong offset!");
static_assert(offsetof(UMaiAction_ExtMovementAnimation, _StartInA) == 0x000358, "Member 'UMaiAction_ExtMovementAnimation::_StartInA' has a wrong offset!");
static_assert(offsetof(UMaiAction_ExtMovementAnimation, _LeftMargin) == 0x00035C, "Member 'UMaiAction_ExtMovementAnimation::_LeftMargin' has a wrong offset!");
static_assert(offsetof(UMaiAction_ExtMovementAnimation, _RightMargin) == 0x000360, "Member 'UMaiAction_ExtMovementAnimation::_RightMargin' has a wrong offset!");
static_assert(offsetof(UMaiAction_ExtMovementAnimation, _Attack) == 0x000368, "Member 'UMaiAction_ExtMovementAnimation::_Attack' has a wrong offset!");
static_assert(offsetof(UMaiAction_ExtMovementAnimation, _Enemy) == 0x000370, "Member 'UMaiAction_ExtMovementAnimation::_Enemy' has a wrong offset!");

// Class Mai.MaiAction_ChangeSurface
// 0x0060 (0x03B0 - 0x0350)
class UMaiAction_ChangeSurface final : public UMaiAction_PlayAnimation
{
public:
	struct FTransform                             _TargetTransform;                                  // 0x0350(0x0060)(Edit, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UMaiAction_ChangeSurface* CreateActionChangeSurface(class UObject* WorldContextObject, const struct FGameplayTagContainer& AnimTags, const struct FTransform& TargetTransform, TSubclassOf<class UMaiAction_ChangeSurface> ActionClass, float PlayRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiAction_ChangeSurface">();
	}
	static class UMaiAction_ChangeSurface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiAction_ChangeSurface>();
	}
};
static_assert(alignof(UMaiAction_ChangeSurface) == 0x000010, "Wrong alignment on UMaiAction_ChangeSurface");
static_assert(sizeof(UMaiAction_ChangeSurface) == 0x0003B0, "Wrong size on UMaiAction_ChangeSurface");
static_assert(offsetof(UMaiAction_ChangeSurface, _TargetTransform) == 0x000350, "Member 'UMaiAction_ChangeSurface::_TargetTransform' has a wrong offset!");

// Class Mai.MaiAction_SyncAnimations
// 0x0130 (0x0510 - 0x03E0)
class UMaiAction_SyncAnimations : public UMaiAction_Snap2Base
{
public:
	struct FGameplayTagContainer                  _OwnerAnimTags;                                    // 0x03D8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _OtherAnimTags;                                    // 0x03F8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _PlayRate;                                         // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMaiSyncRotationMode                          _RotationMode;                                     // 0x041C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         _SnapOtherToOwner : 1;                             // 0x041D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         _UseOtherRotation : 1;                             // 0x041D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         _IgnoreOffset : 1;                                 // 0x041D(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_41E[0x2];                                      // 0x041E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDaiAnimPlayParams                     _OwnerAnimParams;                                  // 0x0420(0x0078)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDaiAnimPlayParams                     _OtherAnimParams;                                  // 0x0498(0x0078)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UMaiAction_SyncAnimations* CreateActionSyncAnims(class UObject* WorldContextObject, const struct FGameplayTagContainer& OwnerAnimTags, const struct FGameplayTagContainer& OtherAnimTags, class AActor* Other, TSubclassOf<class UMaiAction_SyncAnimations> ActionClass, class FName behaviorName, float PlayRate);
	static class UMaiAction_SyncAnimations* CreateActionSyncAnimsSingle(class UObject* WorldContextObject, const struct FGameplayTag& OwnerAnimTag, const struct FGameplayTag& OtherAnimTag, class AActor* Other, TSubclassOf<class UMaiAction_SyncAnimations> ActionClass, class FName behaviorName, float PlayRate);
	static class UMaiAction_SyncAnimations* CreateActionSyncFromConfig(class UObject* WorldContext, class AActor* Other, const struct FMaiSyncActionConfig& Config, class FName behaviorName);
	static class UMaiAction_SyncAnimations* CreateActionSyncFromRow(class UObject* WorldContext, class AActor* Other, const struct FDataTableRowHandle& Row);

	void CalculateIdealTransforms();
	class UAnimMontage* PlayOtherMontage();
	class UAnimMontage* PlayOwnerMontage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiAction_SyncAnimations">();
	}
	static class UMaiAction_SyncAnimations* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiAction_SyncAnimations>();
	}
};
static_assert(alignof(UMaiAction_SyncAnimations) == 0x000010, "Wrong alignment on UMaiAction_SyncAnimations");
static_assert(sizeof(UMaiAction_SyncAnimations) == 0x000510, "Wrong size on UMaiAction_SyncAnimations");
static_assert(offsetof(UMaiAction_SyncAnimations, _OwnerAnimTags) == 0x0003D8, "Member 'UMaiAction_SyncAnimations::_OwnerAnimTags' has a wrong offset!");
static_assert(offsetof(UMaiAction_SyncAnimations, _OtherAnimTags) == 0x0003F8, "Member 'UMaiAction_SyncAnimations::_OtherAnimTags' has a wrong offset!");
static_assert(offsetof(UMaiAction_SyncAnimations, _PlayRate) == 0x000418, "Member 'UMaiAction_SyncAnimations::_PlayRate' has a wrong offset!");
static_assert(offsetof(UMaiAction_SyncAnimations, _RotationMode) == 0x00041C, "Member 'UMaiAction_SyncAnimations::_RotationMode' has a wrong offset!");
static_assert(offsetof(UMaiAction_SyncAnimations, _OwnerAnimParams) == 0x000420, "Member 'UMaiAction_SyncAnimations::_OwnerAnimParams' has a wrong offset!");
static_assert(offsetof(UMaiAction_SyncAnimations, _OtherAnimParams) == 0x000498, "Member 'UMaiAction_SyncAnimations::_OtherAnimParams' has a wrong offset!");

// Class Mai.MaiAction_RotateTo
// 0x0028 (0x00E8 - 0x00C0)
class UMaiAction_RotateTo final : public UMaiAction
{
public:
	class AActor*                                 _LookAtActor;                                      // 0x00C0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _LookAtLocation;                                   // 0x00C8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Precision;                                        // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMaiAction_RotateTo* CreateActionRotateToActor(class UObject* WorldContextObject, class AActor* Actor, float Precision);
	static class UMaiAction_RotateTo* CreateActionRotateToLocation(class UObject* WorldContextObject, const struct FVector& Location, float Precision);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiAction_RotateTo">();
	}
	static class UMaiAction_RotateTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiAction_RotateTo>();
	}
};
static_assert(alignof(UMaiAction_RotateTo) == 0x000008, "Wrong alignment on UMaiAction_RotateTo");
static_assert(sizeof(UMaiAction_RotateTo) == 0x0000E8, "Wrong size on UMaiAction_RotateTo");
static_assert(offsetof(UMaiAction_RotateTo, _LookAtActor) == 0x0000C0, "Member 'UMaiAction_RotateTo::_LookAtActor' has a wrong offset!");
static_assert(offsetof(UMaiAction_RotateTo, _LookAtLocation) == 0x0000C8, "Member 'UMaiAction_RotateTo::_LookAtLocation' has a wrong offset!");
static_assert(offsetof(UMaiAction_RotateTo, _Precision) == 0x0000E0, "Member 'UMaiAction_RotateTo::_Precision' has a wrong offset!");

// Class Mai.MaiBTDecorator_ForceFail
// 0x0000 (0x0068 - 0x0068)
class UMaiBTDecorator_ForceFail final : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTDecorator_ForceFail">();
	}
	static class UMaiBTDecorator_ForceFail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTDecorator_ForceFail>();
	}
};
static_assert(alignof(UMaiBTDecorator_ForceFail) == 0x000008, "Wrong alignment on UMaiBTDecorator_ForceFail");
static_assert(sizeof(UMaiBTDecorator_ForceFail) == 0x000068, "Wrong size on UMaiBTDecorator_ForceFail");

// Class Mai.MaiAction_WaitUntilStops
// 0x0000 (0x00C0 - 0x00C0)
class UMaiAction_WaitUntilStops final : public UMaiAction
{
public:
	static class UMaiAction_WaitUntilStops* CreateActionWaitUntilStops(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiAction_WaitUntilStops">();
	}
	static class UMaiAction_WaitUntilStops* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiAction_WaitUntilStops>();
	}
};
static_assert(alignof(UMaiAction_WaitUntilStops) == 0x000008, "Wrong alignment on UMaiAction_WaitUntilStops");
static_assert(sizeof(UMaiAction_WaitUntilStops) == 0x0000C0, "Wrong size on UMaiAction_WaitUntilStops");

// Class Mai.MaiAggroMeter
// 0x02E8 (0x0388 - 0x00A0)
class UMaiAggroMeter final : public UActorComponent
{
public:
	struct FDaiBlockade                           _BlockDecay;                                       // 0x00A0(0x0018)(Edit, SaveGame, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDaiBlockade                           _BlockGain;                                        // 0x00B8(0x0018)(Edit, SaveGame, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDaiBlockade                           _BlockGain_Weak;                                   // 0x00D0(0x0018)(Edit, SaveGame, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _WeakSenses[0x7];                                  // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EF[0x1];                                       // 0x00EF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMaiAggroConfig                        _Configs[0x3];                                     // 0x00F0(0x002C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      _ExtraStances;                                     // 0x0178(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMaiAggroDifficulty                    _DifficultyConfig[0xA];                            // 0x01C8(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         _Aggro;                                            // 0x0218(0x0004)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _TimeSinceLastAccumulate;                          // 0x021C(0x0004)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class AActor*, float>                    _HateList;                                         // 0x0220(0x0050)(Edit, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         _IgnoreList;                                       // 0x0270(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	EMaiAggroStance                               _BehaviorStance;                                   // 0x0280(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AAIController*                          _Controller;                                       // 0x0288(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDaiFloatModifiers                     _AggroDecayCooldownMod;                            // 0x0290(0x0018)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDaiFloatModifiers                     _AggroDecayMod;                                    // 0x02A8(0x0018)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDaiFloatModifiers2                    _AggroGainMods[0x7];                               // 0x02C0(0x0018)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AggroStanceChanged;                                // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             BehaviorStanceChanged;                             // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UMaiAggroMeter* GetAggroMeter(class AActor* Actor);
	static EMaiSenseType GetSenseTypeForStimulus(class UObject* WorldContextObject, const struct FAIStimulus& Stimulus);

	void AddAggro(float Aggro, bool Force);
	void AddGainMod(class UDaiFloatModifier* Mod, EMaiSenseType Sense, class FName Name_0);
	void ClearWeakDisableGain();
	void DisableDecay(bool Disable, class FName Reason);
	void DisableGain(bool Disable, class FName Reason);
	void OnTargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus);
	void RemoveGainMod(class UDaiFloatModifier* Mod, EMaiSenseType Sense, class FName Name_0);
	void SetAggro(float NewAggro, bool Force);
	void SetBehaviorStance(EMaiAggroStance Stance);
	void WeakDisableGain(bool Disable, class FName Reason);

	float GetAggro() const;
	EMaiAggroStance GetBehaviorStance() const;
	struct FColor GetDebugColor() const;
	class FString GetDebugText() const;
	class AActor* GetMostHated() const;
	EMaiAggroStance GetStance() const;
	float GetStanceMaxAggro(EMaiAggroStance Stance) const;
	float GetStanceMinAggro(EMaiAggroStance Stance) const;
	bool IsAggressive() const;
	bool IsAggroGainDisabled() const;
	bool IsCautious() const;
	bool IsNeutral() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiAggroMeter">();
	}
	static class UMaiAggroMeter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiAggroMeter>();
	}
};
static_assert(alignof(UMaiAggroMeter) == 0x000008, "Wrong alignment on UMaiAggroMeter");
static_assert(sizeof(UMaiAggroMeter) == 0x000388, "Wrong size on UMaiAggroMeter");
static_assert(offsetof(UMaiAggroMeter, _BlockDecay) == 0x0000A0, "Member 'UMaiAggroMeter::_BlockDecay' has a wrong offset!");
static_assert(offsetof(UMaiAggroMeter, _BlockGain) == 0x0000B8, "Member 'UMaiAggroMeter::_BlockGain' has a wrong offset!");
static_assert(offsetof(UMaiAggroMeter, _BlockGain_Weak) == 0x0000D0, "Member 'UMaiAggroMeter::_BlockGain_Weak' has a wrong offset!");
static_assert(offsetof(UMaiAggroMeter, _WeakSenses) == 0x0000E8, "Member 'UMaiAggroMeter::_WeakSenses' has a wrong offset!");
static_assert(offsetof(UMaiAggroMeter, _Configs) == 0x0000F0, "Member 'UMaiAggroMeter::_Configs' has a wrong offset!");
static_assert(offsetof(UMaiAggroMeter, _ExtraStances) == 0x000178, "Member 'UMaiAggroMeter::_ExtraStances' has a wrong offset!");
static_assert(offsetof(UMaiAggroMeter, _DifficultyConfig) == 0x0001C8, "Member 'UMaiAggroMeter::_DifficultyConfig' has a wrong offset!");
static_assert(offsetof(UMaiAggroMeter, _Aggro) == 0x000218, "Member 'UMaiAggroMeter::_Aggro' has a wrong offset!");
static_assert(offsetof(UMaiAggroMeter, _TimeSinceLastAccumulate) == 0x00021C, "Member 'UMaiAggroMeter::_TimeSinceLastAccumulate' has a wrong offset!");
static_assert(offsetof(UMaiAggroMeter, _HateList) == 0x000220, "Member 'UMaiAggroMeter::_HateList' has a wrong offset!");
static_assert(offsetof(UMaiAggroMeter, _IgnoreList) == 0x000270, "Member 'UMaiAggroMeter::_IgnoreList' has a wrong offset!");
static_assert(offsetof(UMaiAggroMeter, _BehaviorStance) == 0x000280, "Member 'UMaiAggroMeter::_BehaviorStance' has a wrong offset!");
static_assert(offsetof(UMaiAggroMeter, _Controller) == 0x000288, "Member 'UMaiAggroMeter::_Controller' has a wrong offset!");
static_assert(offsetof(UMaiAggroMeter, _AggroDecayCooldownMod) == 0x000290, "Member 'UMaiAggroMeter::_AggroDecayCooldownMod' has a wrong offset!");
static_assert(offsetof(UMaiAggroMeter, _AggroDecayMod) == 0x0002A8, "Member 'UMaiAggroMeter::_AggroDecayMod' has a wrong offset!");
static_assert(offsetof(UMaiAggroMeter, _AggroGainMods) == 0x0002C0, "Member 'UMaiAggroMeter::_AggroGainMods' has a wrong offset!");
static_assert(offsetof(UMaiAggroMeter, AggroStanceChanged) == 0x000368, "Member 'UMaiAggroMeter::AggroStanceChanged' has a wrong offset!");
static_assert(offsetof(UMaiAggroMeter, BehaviorStanceChanged) == 0x000378, "Member 'UMaiAggroMeter::BehaviorStanceChanged' has a wrong offset!");

// Class Mai.MaiSense_SightDecorator
// 0x0000 (0x00A0 - 0x00A0)
class UMaiSense_SightDecorator : public UActorComponent
{
public:
	bool IsInSight(class AActor* Actor, class UMaiSenseDebugger* Debugger) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSense_SightDecorator">();
	}
	static class UMaiSense_SightDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSense_SightDecorator>();
	}
};
static_assert(alignof(UMaiSense_SightDecorator) == 0x000008, "Wrong alignment on UMaiSense_SightDecorator");
static_assert(sizeof(UMaiSense_SightDecorator) == 0x0000A0, "Wrong size on UMaiSense_SightDecorator");

// Class Mai.MaiSense_PillarSight
// 0x0010 (0x00B0 - 0x00A0)
class UMaiSense_PillarSight final : public UMaiSense_SightDecorator
{
public:
	float                                         _HalfWidth;                                        // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Yaw;                                              // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Local;                                            // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSense_PillarSight">();
	}
	static class UMaiSense_PillarSight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSense_PillarSight>();
	}
};
static_assert(alignof(UMaiSense_PillarSight) == 0x000008, "Wrong alignment on UMaiSense_PillarSight");
static_assert(sizeof(UMaiSense_PillarSight) == 0x0000B0, "Wrong size on UMaiSense_PillarSight");
static_assert(offsetof(UMaiSense_PillarSight, _HalfWidth) == 0x0000A0, "Member 'UMaiSense_PillarSight::_HalfWidth' has a wrong offset!");
static_assert(offsetof(UMaiSense_PillarSight, _Yaw) == 0x0000A4, "Member 'UMaiSense_PillarSight::_Yaw' has a wrong offset!");
static_assert(offsetof(UMaiSense_PillarSight, _Local) == 0x0000A8, "Member 'UMaiSense_PillarSight::_Local' has a wrong offset!");

// Class Mai.MaiFloatAggroModifier
// 0x0058 (0x00E8 - 0x0090)
class UMaiFloatAggroModifier : public UDaiFloatModifier2
{
public:
	struct FAIStimulus                            _Stimulus;                                         // 0x0090(0x0058)(Edit, Transient, EditConst, NoDestructor, NativeAccessSpecifierPrivate)

public:
	const struct FAIStimulus GetStimulus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiFloatAggroModifier">();
	}
	static class UMaiFloatAggroModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiFloatAggroModifier>();
	}
};
static_assert(alignof(UMaiFloatAggroModifier) == 0x000008, "Wrong alignment on UMaiFloatAggroModifier");
static_assert(sizeof(UMaiFloatAggroModifier) == 0x0000E8, "Wrong size on UMaiFloatAggroModifier");
static_assert(offsetof(UMaiFloatAggroModifier, _Stimulus) == 0x000090, "Member 'UMaiFloatAggroModifier::_Stimulus' has a wrong offset!");

// Class Mai.MaiOutAreaGainMod
// 0x0008 (0x00F0 - 0x00E8)
class UMaiOutAreaGainMod final : public UMaiFloatAggroModifier
{
public:
	float                                         _OutAreaMul;                                       // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiOutAreaGainMod">();
	}
	static class UMaiOutAreaGainMod* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiOutAreaGainMod>();
	}
};
static_assert(alignof(UMaiOutAreaGainMod) == 0x000008, "Wrong alignment on UMaiOutAreaGainMod");
static_assert(sizeof(UMaiOutAreaGainMod) == 0x0000F0, "Wrong size on UMaiOutAreaGainMod");
static_assert(offsetof(UMaiOutAreaGainMod, _OutAreaMul) == 0x0000E8, "Member 'UMaiOutAreaGainMod::_OutAreaMul' has a wrong offset!");

// Class Mai.MaiBTService_NativeNotify
// 0x0008 (0x0078 - 0x0070)
class UMaiBTService_NativeNotify : public UBTService
{
public:
	bool                                          _OnActivate;                                       // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _OnDeactivate;                                     // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _OnTick;                                           // 0x0072(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_73[0x5];                                       // 0x0073(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTService_NativeNotify">();
	}
	static class UMaiBTService_NativeNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTService_NativeNotify>();
	}
};
static_assert(alignof(UMaiBTService_NativeNotify) == 0x000008, "Wrong alignment on UMaiBTService_NativeNotify");
static_assert(sizeof(UMaiBTService_NativeNotify) == 0x000078, "Wrong size on UMaiBTService_NativeNotify");
static_assert(offsetof(UMaiBTService_NativeNotify, _OnActivate) == 0x000070, "Member 'UMaiBTService_NativeNotify::_OnActivate' has a wrong offset!");
static_assert(offsetof(UMaiBTService_NativeNotify, _OnDeactivate) == 0x000071, "Member 'UMaiBTService_NativeNotify::_OnDeactivate' has a wrong offset!");
static_assert(offsetof(UMaiBTService_NativeNotify, _OnTick) == 0x000072, "Member 'UMaiBTService_NativeNotify::_OnTick' has a wrong offset!");

// Class Mai.MaiBTService_ClearBoardNotify
// 0x0028 (0x00A0 - 0x0078)
class UMaiBTService_ClearBoardNotify final : public UMaiBTService_NativeNotify
{
public:
	struct FBlackboardKeySelector                 Key;                                               // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTService_ClearBoardNotify">();
	}
	static class UMaiBTService_ClearBoardNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTService_ClearBoardNotify>();
	}
};
static_assert(alignof(UMaiBTService_ClearBoardNotify) == 0x000008, "Wrong alignment on UMaiBTService_ClearBoardNotify");
static_assert(sizeof(UMaiBTService_ClearBoardNotify) == 0x0000A0, "Wrong size on UMaiBTService_ClearBoardNotify");
static_assert(offsetof(UMaiBTService_ClearBoardNotify, Key) == 0x000078, "Member 'UMaiBTService_ClearBoardNotify::Key' has a wrong offset!");

// Class Mai.MaiEqsTest_Trace2
// 0x00F8 (0x02F0 - 0x01F8)
class UMaiEqsTest_Trace2 final : public UEnvQueryTest
{
public:
	struct FEnvTraceData                          TraceData;                                         // 0x01F8(0x0040)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          OverrideChannel;                                   // 0x0238(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceCollisionChannel;                             // 0x0239(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23A[0x6];                                      // 0x023A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderBoolValue               TraceFromContext;                                  // 0x0240(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              ItemHeightOffset;                                  // 0x0278(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              ContextHeightOffset;                               // 0x02B0(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiEqsTest_Trace2">();
	}
	static class UMaiEqsTest_Trace2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiEqsTest_Trace2>();
	}
};
static_assert(alignof(UMaiEqsTest_Trace2) == 0x000008, "Wrong alignment on UMaiEqsTest_Trace2");
static_assert(sizeof(UMaiEqsTest_Trace2) == 0x0002F0, "Wrong size on UMaiEqsTest_Trace2");
static_assert(offsetof(UMaiEqsTest_Trace2, TraceData) == 0x0001F8, "Member 'UMaiEqsTest_Trace2::TraceData' has a wrong offset!");
static_assert(offsetof(UMaiEqsTest_Trace2, OverrideChannel) == 0x000238, "Member 'UMaiEqsTest_Trace2::OverrideChannel' has a wrong offset!");
static_assert(offsetof(UMaiEqsTest_Trace2, TraceCollisionChannel) == 0x000239, "Member 'UMaiEqsTest_Trace2::TraceCollisionChannel' has a wrong offset!");
static_assert(offsetof(UMaiEqsTest_Trace2, TraceFromContext) == 0x000240, "Member 'UMaiEqsTest_Trace2::TraceFromContext' has a wrong offset!");
static_assert(offsetof(UMaiEqsTest_Trace2, ItemHeightOffset) == 0x000278, "Member 'UMaiEqsTest_Trace2::ItemHeightOffset' has a wrong offset!");
static_assert(offsetof(UMaiEqsTest_Trace2, ContextHeightOffset) == 0x0002B0, "Member 'UMaiEqsTest_Trace2::ContextHeightOffset' has a wrong offset!");
static_assert(offsetof(UMaiEqsTest_Trace2, Context) == 0x0002E8, "Member 'UMaiEqsTest_Trace2::Context' has a wrong offset!");

// Class Mai.MaiOutAreaDecayMod
// 0x0010 (0x0098 - 0x0088)
class UMaiOutAreaDecayMod final : public UDaiFloatModifier
{
public:
	float                                         _OutAreaMul;                                       // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0xC];                                       // 0x008C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiOutAreaDecayMod">();
	}
	static class UMaiOutAreaDecayMod* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiOutAreaDecayMod>();
	}
};
static_assert(alignof(UMaiOutAreaDecayMod) == 0x000008, "Wrong alignment on UMaiOutAreaDecayMod");
static_assert(sizeof(UMaiOutAreaDecayMod) == 0x000098, "Wrong size on UMaiOutAreaDecayMod");
static_assert(offsetof(UMaiOutAreaDecayMod, _OutAreaMul) == 0x000088, "Member 'UMaiOutAreaDecayMod::_OutAreaMul' has a wrong offset!");

// Class Mai.AnimNotify_DisableSync
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_DisableSync final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DisableSync">();
	}
	static class UAnimNotify_DisableSync* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DisableSync>();
	}
};
static_assert(alignof(UAnimNotify_DisableSync) == 0x000008, "Wrong alignment on UAnimNotify_DisableSync");
static_assert(sizeof(UAnimNotify_DisableSync) == 0x000038, "Wrong size on UAnimNotify_DisableSync");

// Class Mai.MaiEqsContext_BlackboardActor
// 0x0000 (0x0028 - 0x0028)
class UMaiEqsContext_BlackboardActor final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiEqsContext_BlackboardActor">();
	}
	static class UMaiEqsContext_BlackboardActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiEqsContext_BlackboardActor>();
	}
};
static_assert(alignof(UMaiEqsContext_BlackboardActor) == 0x000008, "Wrong alignment on UMaiEqsContext_BlackboardActor");
static_assert(sizeof(UMaiEqsContext_BlackboardActor) == 0x000028, "Wrong size on UMaiEqsContext_BlackboardActor");

// Class Mai.AnimNotify_FinishSync
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_FinishSync final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_FinishSync">();
	}
	static class UAnimNotify_FinishSync* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_FinishSync>();
	}
};
static_assert(alignof(UAnimNotify_FinishSync) == 0x000008, "Wrong alignment on UAnimNotify_FinishSync");
static_assert(sizeof(UAnimNotify_FinishSync) == 0x000038, "Wrong size on UAnimNotify_FinishSync");

// Class Mai.AnimNotifyState_SnapInSync
// 0x0000 (0x0030 - 0x0030)
class UAnimNotifyState_SnapInSync final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SnapInSync">();
	}
	static class UAnimNotifyState_SnapInSync* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SnapInSync>();
	}
};
static_assert(alignof(UAnimNotifyState_SnapInSync) == 0x000008, "Wrong alignment on UAnimNotifyState_SnapInSync");
static_assert(sizeof(UAnimNotifyState_SnapInSync) == 0x000030, "Wrong size on UAnimNotifyState_SnapInSync");

// Class Mai.MaiEqsGenerator_SearchActionPoints
// 0x0058 (0x00A8 - 0x0050)
class UMaiEqsGenerator_SearchActionPoints final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderFloatValue              _SearchRadius;                                     // 0x0050(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           _SearchCenter;                                     // 0x0088(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AMaiActionPoint>            _PointClass;                                       // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _PointTag;                                         // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _CheckWeight;                                      // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _CheckConditions;                                  // 0x00A1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiEqsGenerator_SearchActionPoints">();
	}
	static class UMaiEqsGenerator_SearchActionPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiEqsGenerator_SearchActionPoints>();
	}
};
static_assert(alignof(UMaiEqsGenerator_SearchActionPoints) == 0x000008, "Wrong alignment on UMaiEqsGenerator_SearchActionPoints");
static_assert(sizeof(UMaiEqsGenerator_SearchActionPoints) == 0x0000A8, "Wrong size on UMaiEqsGenerator_SearchActionPoints");
static_assert(offsetof(UMaiEqsGenerator_SearchActionPoints, _SearchRadius) == 0x000050, "Member 'UMaiEqsGenerator_SearchActionPoints::_SearchRadius' has a wrong offset!");
static_assert(offsetof(UMaiEqsGenerator_SearchActionPoints, _SearchCenter) == 0x000088, "Member 'UMaiEqsGenerator_SearchActionPoints::_SearchCenter' has a wrong offset!");
static_assert(offsetof(UMaiEqsGenerator_SearchActionPoints, _PointClass) == 0x000090, "Member 'UMaiEqsGenerator_SearchActionPoints::_PointClass' has a wrong offset!");
static_assert(offsetof(UMaiEqsGenerator_SearchActionPoints, _PointTag) == 0x000098, "Member 'UMaiEqsGenerator_SearchActionPoints::_PointTag' has a wrong offset!");
static_assert(offsetof(UMaiEqsGenerator_SearchActionPoints, _CheckWeight) == 0x0000A0, "Member 'UMaiEqsGenerator_SearchActionPoints::_CheckWeight' has a wrong offset!");
static_assert(offsetof(UMaiEqsGenerator_SearchActionPoints, _CheckConditions) == 0x0000A1, "Member 'UMaiEqsGenerator_SearchActionPoints::_CheckConditions' has a wrong offset!");

// Class Mai.AnimNotifyState_FocusOnEnemy
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_FocusOnEnemy final : public UAnimNotifyState
{
public:
	bool                                          _ActOnSnapping;                                    // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_FocusOnEnemy">();
	}
	static class UAnimNotifyState_FocusOnEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_FocusOnEnemy>();
	}
};
static_assert(alignof(UAnimNotifyState_FocusOnEnemy) == 0x000008, "Wrong alignment on UAnimNotifyState_FocusOnEnemy");
static_assert(sizeof(UAnimNotifyState_FocusOnEnemy) == 0x000038, "Wrong size on UAnimNotifyState_FocusOnEnemy");
static_assert(offsetof(UAnimNotifyState_FocusOnEnemy, _ActOnSnapping) == 0x000030, "Member 'UAnimNotifyState_FocusOnEnemy::_ActOnSnapping' has a wrong offset!");

// Class Mai.AnimNotifyState_AllowDodgeReaction
// 0x0000 (0x0030 - 0x0030)
class UAnimNotifyState_AllowDodgeReaction final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_AllowDodgeReaction">();
	}
	static class UAnimNotifyState_AllowDodgeReaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_AllowDodgeReaction>();
	}
};
static_assert(alignof(UAnimNotifyState_AllowDodgeReaction) == 0x000008, "Wrong alignment on UAnimNotifyState_AllowDodgeReaction");
static_assert(sizeof(UAnimNotifyState_AllowDodgeReaction) == 0x000030, "Wrong size on UAnimNotifyState_AllowDodgeReaction");

// Class Mai.MsgMadeDodgeReceiverInterface
// 0x0000 (0x0028 - 0x0028)
class IMsgMadeDodgeReceiverInterface final : public IInterface
{
public:
	void ReceiveMadeDodgeMsg(class UMaiMessage* Message, class AActor* Sender);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgMadeDodgeReceiverInterface">();
	}
	static class IMsgMadeDodgeReceiverInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMsgMadeDodgeReceiverInterface>();
	}
};
static_assert(alignof(IMsgMadeDodgeReceiverInterface) == 0x000008, "Wrong alignment on IMsgMadeDodgeReceiverInterface");
static_assert(sizeof(IMsgMadeDodgeReceiverInterface) == 0x000028, "Wrong size on IMsgMadeDodgeReceiverInterface");

// Class Mai.AnimNotify_EnableBehaviorTree
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_EnableBehaviorTree final : public UAnimNotify
{
public:
	class FName                                   _Reason;                                           // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EnableBehaviorTree">();
	}
	static class UAnimNotify_EnableBehaviorTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EnableBehaviorTree>();
	}
};
static_assert(alignof(UAnimNotify_EnableBehaviorTree) == 0x000008, "Wrong alignment on UAnimNotify_EnableBehaviorTree");
static_assert(sizeof(UAnimNotify_EnableBehaviorTree) == 0x000040, "Wrong size on UAnimNotify_EnableBehaviorTree");
static_assert(offsetof(UAnimNotify_EnableBehaviorTree, _Reason) == 0x000038, "Member 'UAnimNotify_EnableBehaviorTree::_Reason' has a wrong offset!");

// Class Mai.AnimNotify_ExtMovementMarker
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_ExtMovementMarker final : public UAnimNotify
{
public:
	int32                                         _Number;                                           // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ExtMovementMarker">();
	}
	static class UAnimNotify_ExtMovementMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ExtMovementMarker>();
	}
};
static_assert(alignof(UAnimNotify_ExtMovementMarker) == 0x000008, "Wrong alignment on UAnimNotify_ExtMovementMarker");
static_assert(sizeof(UAnimNotify_ExtMovementMarker) == 0x000040, "Wrong size on UAnimNotify_ExtMovementMarker");
static_assert(offsetof(UAnimNotify_ExtMovementMarker, _Number) == 0x000038, "Member 'UAnimNotify_ExtMovementMarker::_Number' has a wrong offset!");

// Class Mai.MaiBTService_RegisterCombos
// 0x0000 (0x0070 - 0x0070)
class UMaiBTService_RegisterCombos final : public UBTService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTService_RegisterCombos">();
	}
	static class UMaiBTService_RegisterCombos* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTService_RegisterCombos>();
	}
};
static_assert(alignof(UMaiBTService_RegisterCombos) == 0x000008, "Wrong alignment on UMaiBTService_RegisterCombos");
static_assert(sizeof(UMaiBTService_RegisterCombos) == 0x000070, "Wrong size on UMaiBTService_RegisterCombos");

// Class Mai.AnimNotify_ExtMovementCheckAtack
// 0x00B0 (0x00E8 - 0x0038)
class UAnimNotify_ExtMovementCheckAtack final : public UAnimNotify
{
public:
	struct FMaiExtMovementAttack                  _DifficultyConfig[0xA];                            // 0x0038(0x0010)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    _AttackRow;                                        // 0x00D8(0x0010)(BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ExtMovementCheckAtack">();
	}
	static class UAnimNotify_ExtMovementCheckAtack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ExtMovementCheckAtack>();
	}
};
static_assert(alignof(UAnimNotify_ExtMovementCheckAtack) == 0x000008, "Wrong alignment on UAnimNotify_ExtMovementCheckAtack");
static_assert(sizeof(UAnimNotify_ExtMovementCheckAtack) == 0x0000E8, "Wrong size on UAnimNotify_ExtMovementCheckAtack");
static_assert(offsetof(UAnimNotify_ExtMovementCheckAtack, _DifficultyConfig) == 0x000038, "Member 'UAnimNotify_ExtMovementCheckAtack::_DifficultyConfig' has a wrong offset!");
static_assert(offsetof(UAnimNotify_ExtMovementCheckAtack, _AttackRow) == 0x0000D8, "Member 'UAnimNotify_ExtMovementCheckAtack::_AttackRow' has a wrong offset!");

// Class Mai.MaiShapeDrawer
// 0x0000 (0x0580 - 0x0580)
class UMaiShapeDrawer : public ULineBatchComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiShapeDrawer">();
	}
	static class UMaiShapeDrawer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiShapeDrawer>();
	}
};
static_assert(alignof(UMaiShapeDrawer) == 0x000010, "Wrong alignment on UMaiShapeDrawer");
static_assert(sizeof(UMaiShapeDrawer) == 0x000580, "Wrong size on UMaiShapeDrawer");

// Class Mai.MaiAreaComponent
// 0x0030 (0x05B0 - 0x0580)
#pragma pack(push, 0x1)
class alignas(0x10) UMaiAreaComponent : public UMaiShapeDrawer
{
public:
	struct FColor                                 _Color;                                            // 0x0580(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_584[0x4];                                      // 0x0584(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMaiShape                              _Shape;                                            // 0x0588(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	EMaiShapeType GetAreaShape(struct FVector* Extents);

	struct FVector GetRandomPoint(float Extent) const;
	bool IsInArea(const struct FVector& Location, float Extent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiAreaComponent">();
	}
	static class UMaiAreaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiAreaComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMaiAreaComponent) == 0x000010, "Wrong alignment on UMaiAreaComponent");
static_assert(sizeof(UMaiAreaComponent) == 0x0005B0, "Wrong size on UMaiAreaComponent");
static_assert(offsetof(UMaiAreaComponent, _Color) == 0x000580, "Member 'UMaiAreaComponent::_Color' has a wrong offset!");
static_assert(offsetof(UMaiAreaComponent, _Shape) == 0x000588, "Member 'UMaiAreaComponent::_Shape' has a wrong offset!");

// Class Mai.MaiDetectionAreaComponent
// 0x0000 (0x05B0 - 0x05B0)
class UMaiDetectionAreaComponent final : public UMaiAreaComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiDetectionAreaComponent">();
	}
	static class UMaiDetectionAreaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiDetectionAreaComponent>();
	}
};
static_assert(alignof(UMaiDetectionAreaComponent) == 0x000010, "Wrong alignment on UMaiDetectionAreaComponent");
static_assert(sizeof(UMaiDetectionAreaComponent) == 0x0005B0, "Wrong size on UMaiDetectionAreaComponent");

// Class Mai.MaiFlyingPoint
// 0x0050 (0x0300 - 0x02B0)
class AMaiFlyingPoint final : public AActor
{
public:
	class UMaiFlyingPointComponent*               _Transformer;                                      // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   _MarkerMesh;                                       // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextRenderComponent*                   _Text;                                             // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _Color;                                            // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _ID;                                               // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMaiFlyingGraph*                        _Owner;                                            // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _Weight;                                           // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x3];                                      // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _Radius;                                           // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMaiFlyingConnection>           _Connections;                                      // 0x02F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	bool IsReachableFrom(const struct FVector& Location, class AMaiController* User) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiFlyingPoint">();
	}
	static class AMaiFlyingPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiFlyingPoint>();
	}
};
static_assert(alignof(AMaiFlyingPoint) == 0x000008, "Wrong alignment on AMaiFlyingPoint");
static_assert(sizeof(AMaiFlyingPoint) == 0x000300, "Wrong size on AMaiFlyingPoint");
static_assert(offsetof(AMaiFlyingPoint, _Transformer) == 0x0002B0, "Member 'AMaiFlyingPoint::_Transformer' has a wrong offset!");
static_assert(offsetof(AMaiFlyingPoint, _MarkerMesh) == 0x0002B8, "Member 'AMaiFlyingPoint::_MarkerMesh' has a wrong offset!");
static_assert(offsetof(AMaiFlyingPoint, _Text) == 0x0002C0, "Member 'AMaiFlyingPoint::_Text' has a wrong offset!");
static_assert(offsetof(AMaiFlyingPoint, _Color) == 0x0002C8, "Member 'AMaiFlyingPoint::_Color' has a wrong offset!");
static_assert(offsetof(AMaiFlyingPoint, _ID) == 0x0002D8, "Member 'AMaiFlyingPoint::_ID' has a wrong offset!");
static_assert(offsetof(AMaiFlyingPoint, _Owner) == 0x0002E0, "Member 'AMaiFlyingPoint::_Owner' has a wrong offset!");
static_assert(offsetof(AMaiFlyingPoint, _Weight) == 0x0002E8, "Member 'AMaiFlyingPoint::_Weight' has a wrong offset!");
static_assert(offsetof(AMaiFlyingPoint, _Radius) == 0x0002EC, "Member 'AMaiFlyingPoint::_Radius' has a wrong offset!");
static_assert(offsetof(AMaiFlyingPoint, _Connections) == 0x0002F0, "Member 'AMaiFlyingPoint::_Connections' has a wrong offset!");

// Class Mai.MaiChaseAreaComponent
// 0x0000 (0x05B0 - 0x05B0)
class UMaiChaseAreaComponent final : public UMaiAreaComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiChaseAreaComponent">();
	}
	static class UMaiChaseAreaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiChaseAreaComponent>();
	}
};
static_assert(alignof(UMaiChaseAreaComponent) == 0x000010, "Wrong alignment on UMaiChaseAreaComponent");
static_assert(sizeof(UMaiChaseAreaComponent) == 0x0005B0, "Wrong size on UMaiChaseAreaComponent");

// Class Mai.MaiSpawnAreaComponent
// 0x0000 (0x05B0 - 0x05B0)
class UMaiSpawnAreaComponent final : public UMaiAreaComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSpawnAreaComponent">();
	}
	static class UMaiSpawnAreaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSpawnAreaComponent>();
	}
};
static_assert(alignof(UMaiSpawnAreaComponent) == 0x000010, "Wrong alignment on UMaiSpawnAreaComponent");
static_assert(sizeof(UMaiSpawnAreaComponent) == 0x0005B0, "Wrong size on UMaiSpawnAreaComponent");

// Class Mai.NavArea_Jump
// 0x0000 (0x0048 - 0x0048)
class UNavArea_Jump final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Jump">();
	}
	static class UNavArea_Jump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Jump>();
	}
};
static_assert(alignof(UNavArea_Jump) == 0x000008, "Wrong alignment on UNavArea_Jump");
static_assert(sizeof(UNavArea_Jump) == 0x000048, "Wrong size on UNavArea_Jump");

// Class Mai.MaiRadiusComponent
// 0x0010 (0x0590 - 0x0580)
class UMaiRadiusComponent final : public ULineBatchComponent
{
public:
	struct FColor                                 _Color;                                            // 0x0580(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Radius;                                           // 0x0584(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_588[0x8];                                      // 0x0588(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiRadiusComponent">();
	}
	static class UMaiRadiusComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiRadiusComponent>();
	}
};
static_assert(alignof(UMaiRadiusComponent) == 0x000010, "Wrong alignment on UMaiRadiusComponent");
static_assert(sizeof(UMaiRadiusComponent) == 0x000590, "Wrong size on UMaiRadiusComponent");
static_assert(offsetof(UMaiRadiusComponent, _Color) == 0x000580, "Member 'UMaiRadiusComponent::_Color' has a wrong offset!");
static_assert(offsetof(UMaiRadiusComponent, _Radius) == 0x000584, "Member 'UMaiRadiusComponent::_Radius' has a wrong offset!");

// Class Mai.MaiAttack
// 0x00E0 (0x0108 - 0x0028)
class UMaiAttack : public UObject
{
public:
	bool                                          _CheckAttackCone;                                  // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            _AttackRange;                                      // 0x002C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _AttackDir;                                        // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _AttackAngle;                                      // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaiToken                                     _TokenType;                                        // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaiAttackInitialStance                       _InitialStance;                                    // 0x0045(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          _Behavior;                                         // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  _AnimTags;                                         // 0x0050(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         _PureAttackRange;                                  // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _FocusCharging;                                    // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            _FocusRate;                                        // 0x0078(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   _FocusFunc;                                        // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaiAttackFocus                               _FocusMode;                                        // 0x0089(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaiAttackSnap                                _SnapMode;                                         // 0x008A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaiAttackDodgeReaction                       _DodgeReaction;                                    // 0x008B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _TimeToDodgeBeforeHit;                             // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _AllowDodgeReaction;                               // 0x0090(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _CheckImpactCone;                                  // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x2];                                       // 0x0092(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _ImpactDir;                                        // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _ImpactAngle;                                      // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _ImpactRange;                                      // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMaiImpactConfig>               _AltImpacts;                                       // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                _DamageType;                                       // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            _Damage;                                           // 0x00B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _CheckCooldown;                                    // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            _Cooldown;                                         // 0x00CC(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _CooldownValue;                                    // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            _DelayAfterAttack;                                 // 0x00E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _EndWithMontage;                                   // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _RangedAttack;                                     // 0x00F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x2];                                       // 0x00F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_F4_0 : 1;                                   // 0x00F4(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         _EnabledFocus : 1;                                 // 0x00F4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_F4_2 : 1;                                   // 0x00F4(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         _EnabledSnap : 1;                                  // 0x00F4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         _DuringBlow : 1;                                   // 0x00F4(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         _AttackCommited : 1;                               // 0x00F4(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _AttackTime;                                       // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _LastHitTime;                                      // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _NextHitTime;                                      // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMaiAttackStatus                              _AttackStatus;                                     // 0x0104(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableFocus();
	void DisableSnap();
	void EnableFocus();
	void EnableSnap();
	void EndAttack(bool Abort);
	void EventAllowDodge(class AActor* Owner);
	void EventAttackHit(class AActor* Owner);
	void EventAttackMiss(class AActor* Owner);
	void EventBeginAttack(class AActor* Owner);
	void EventEndBlow(class AActor* Owner);
	void EventInitAttack(class AActor* Owner);
	void EventStartBlow(class AActor* Owner, int32 ImpactID);
	void EventStopAttack(class AActor* Owner, bool Aborted);
	void EventTickAttack(class AActor* Owner, float DeltaSeconds);
	void LoadRowHandle(const struct FDataTableRowHandle& AttackRow);
	void SetAllowDodgeReaction(bool Allow);
	void SetAttackCommited();
	void SetAttackCone(float Angle, float Dir);
	void SetAttackRange(float Min, float Max);
	void SetBehavior(class UBehaviorTree* Behavior, const TArray<struct FGameplayTag>& AnimTags);
	void SetCooldown(float Min, float Max);
	void SetDamage(TSubclassOf<class UDamageType> DamageType, int32 Min, int32 Max);
	void SetFocus(EMaiAttackFocus Mode, float Charging);
	void SetLogicalImpact(bool Enable, float Range, float Angle, float Dir);
	void SetSnapMode(EMaiAttackSnap Mode);

	bool GetAllowDodgeReaction() const;
	class UMaiAttackerComponent* GetAttackerComponent() const;
	void GetAttackRange(float* Min, float* Max) const;
	class AActor* GetAttackTarget() const;
	float GetDamage(int32 ImpactID) const;
	TSubclassOf<class UDamageType> GetDamageType(int32 ImpactID) const;
	float GetImpactAngle(int32 ImpactID) const;
	float GetImpactDir(int32 ImpactID) const;
	float GetImpactRange(int32 ImpactID) const;
	class AActor* GetOwnerActor() const;
	class AAIController* GetOwnerAI() const;
	class ACharacter* GetOwnerCH() const;
	bool IsFocusing() const;
	bool IsSnapping() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiAttack">();
	}
	static class UMaiAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiAttack>();
	}
};
static_assert(alignof(UMaiAttack) == 0x000008, "Wrong alignment on UMaiAttack");
static_assert(sizeof(UMaiAttack) == 0x000108, "Wrong size on UMaiAttack");
static_assert(offsetof(UMaiAttack, _CheckAttackCone) == 0x000028, "Member 'UMaiAttack::_CheckAttackCone' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _AttackRange) == 0x00002C, "Member 'UMaiAttack::_AttackRange' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _AttackDir) == 0x00003C, "Member 'UMaiAttack::_AttackDir' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _AttackAngle) == 0x000040, "Member 'UMaiAttack::_AttackAngle' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _TokenType) == 0x000044, "Member 'UMaiAttack::_TokenType' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _InitialStance) == 0x000045, "Member 'UMaiAttack::_InitialStance' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _Behavior) == 0x000048, "Member 'UMaiAttack::_Behavior' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _AnimTags) == 0x000050, "Member 'UMaiAttack::_AnimTags' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _PureAttackRange) == 0x000070, "Member 'UMaiAttack::_PureAttackRange' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _FocusCharging) == 0x000074, "Member 'UMaiAttack::_FocusCharging' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _FocusRate) == 0x000078, "Member 'UMaiAttack::_FocusRate' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _FocusFunc) == 0x000088, "Member 'UMaiAttack::_FocusFunc' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _FocusMode) == 0x000089, "Member 'UMaiAttack::_FocusMode' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _SnapMode) == 0x00008A, "Member 'UMaiAttack::_SnapMode' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _DodgeReaction) == 0x00008B, "Member 'UMaiAttack::_DodgeReaction' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _TimeToDodgeBeforeHit) == 0x00008C, "Member 'UMaiAttack::_TimeToDodgeBeforeHit' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _AllowDodgeReaction) == 0x000090, "Member 'UMaiAttack::_AllowDodgeReaction' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _CheckImpactCone) == 0x000091, "Member 'UMaiAttack::_CheckImpactCone' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _ImpactDir) == 0x000094, "Member 'UMaiAttack::_ImpactDir' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _ImpactAngle) == 0x000098, "Member 'UMaiAttack::_ImpactAngle' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _ImpactRange) == 0x00009C, "Member 'UMaiAttack::_ImpactRange' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _AltImpacts) == 0x0000A0, "Member 'UMaiAttack::_AltImpacts' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _DamageType) == 0x0000B0, "Member 'UMaiAttack::_DamageType' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _Damage) == 0x0000B8, "Member 'UMaiAttack::_Damage' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _CheckCooldown) == 0x0000C8, "Member 'UMaiAttack::_CheckCooldown' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _Cooldown) == 0x0000CC, "Member 'UMaiAttack::_Cooldown' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _CooldownValue) == 0x0000DC, "Member 'UMaiAttack::_CooldownValue' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _DelayAfterAttack) == 0x0000E0, "Member 'UMaiAttack::_DelayAfterAttack' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _EndWithMontage) == 0x0000F0, "Member 'UMaiAttack::_EndWithMontage' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _RangedAttack) == 0x0000F1, "Member 'UMaiAttack::_RangedAttack' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _AttackTime) == 0x0000F8, "Member 'UMaiAttack::_AttackTime' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _LastHitTime) == 0x0000FC, "Member 'UMaiAttack::_LastHitTime' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _NextHitTime) == 0x000100, "Member 'UMaiAttack::_NextHitTime' has a wrong offset!");
static_assert(offsetof(UMaiAttack, _AttackStatus) == 0x000104, "Member 'UMaiAttack::_AttackStatus' has a wrong offset!");

// Class Mai.MaiLightObserver
// 0x0030 (0x02D0 - 0x02A0)
class UMaiLightObserver final : public USceneComponent
{
public:
	float                                         _Radius;                                           // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _HalfHeight;                                       // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Enabled;                                          // 0x02A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _IsLit;                                            // 0x02A9(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA[0x6];                                      // 0x02AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             LightObserverChange;                               // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LightingState;                                     // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void TurnOff();
	void TurnOn();

	bool GetIsLit() const;
	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiLightObserver">();
	}
	static class UMaiLightObserver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiLightObserver>();
	}
};
static_assert(alignof(UMaiLightObserver) == 0x000010, "Wrong alignment on UMaiLightObserver");
static_assert(sizeof(UMaiLightObserver) == 0x0002D0, "Wrong size on UMaiLightObserver");
static_assert(offsetof(UMaiLightObserver, _Radius) == 0x0002A0, "Member 'UMaiLightObserver::_Radius' has a wrong offset!");
static_assert(offsetof(UMaiLightObserver, _HalfHeight) == 0x0002A4, "Member 'UMaiLightObserver::_HalfHeight' has a wrong offset!");
static_assert(offsetof(UMaiLightObserver, _Enabled) == 0x0002A8, "Member 'UMaiLightObserver::_Enabled' has a wrong offset!");
static_assert(offsetof(UMaiLightObserver, _IsLit) == 0x0002A9, "Member 'UMaiLightObserver::_IsLit' has a wrong offset!");
static_assert(offsetof(UMaiLightObserver, LightObserverChange) == 0x0002B0, "Member 'UMaiLightObserver::LightObserverChange' has a wrong offset!");
static_assert(offsetof(UMaiLightObserver, LightingState) == 0x0002C0, "Member 'UMaiLightObserver::LightingState' has a wrong offset!");

// Class Mai.MaiScriptAttack
// 0x01E8 (0x02F0 - 0x0108)
class alignas(0x10) UMaiScriptAttack final : public UMaiAttack
{
public:
	struct FDaiAnimPlayParams                     _OwnerAnimParams;                                  // 0x0108(0x0078)(BlueprintVisible, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           _OwnerMontage;                                     // 0x0180(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _SnapTargetLocation;                               // 0x0188(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _StartSectionDuration;                             // 0x01A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A4[0x8];                                      // 0x01A4(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _AttackAnimTime;                                   // 0x01AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _SnapStartTime;                                    // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 _HitTimes;                                         // 0x01B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, AdvancedDisplay, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0x50];                                     // 0x01C8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _SnapOnlyInStartSection;                           // 0x0218(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _SnapOnlyToLastHit;                                // 0x0219(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21A[0x2];                                      // 0x021A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _MaxAttackSpeed;                                   // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _MaxSlideSpeed;                                    // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _AbortBlendOut;                                    // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _RotationInterpolationRate;                        // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _MovementDist;                                     // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _MovementCurve;                                    // 0x0230(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMaiDebugPrintParams                   _PrintParams;                                      // 0x0238(0x0030)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x88];                                     // 0x0268(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerMontageEnds(class UAnimMontage* Montage, bool Interrupted);
	class UAnimMontage* PlayOwnerMontage();
	void SelectBestAnim(const struct FVector& Forward);
	void SetOwnerMontage(class UAnimMontage* Montage);
	void SetSliding(float Distance, class UCurveFloat* Curve);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiScriptAttack">();
	}
	static class UMaiScriptAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiScriptAttack>();
	}
};
static_assert(alignof(UMaiScriptAttack) == 0x000010, "Wrong alignment on UMaiScriptAttack");
static_assert(sizeof(UMaiScriptAttack) == 0x0002F0, "Wrong size on UMaiScriptAttack");
static_assert(offsetof(UMaiScriptAttack, _OwnerAnimParams) == 0x000108, "Member 'UMaiScriptAttack::_OwnerAnimParams' has a wrong offset!");
static_assert(offsetof(UMaiScriptAttack, _OwnerMontage) == 0x000180, "Member 'UMaiScriptAttack::_OwnerMontage' has a wrong offset!");
static_assert(offsetof(UMaiScriptAttack, _SnapTargetLocation) == 0x000188, "Member 'UMaiScriptAttack::_SnapTargetLocation' has a wrong offset!");
static_assert(offsetof(UMaiScriptAttack, _StartSectionDuration) == 0x0001A0, "Member 'UMaiScriptAttack::_StartSectionDuration' has a wrong offset!");
static_assert(offsetof(UMaiScriptAttack, _AttackAnimTime) == 0x0001AC, "Member 'UMaiScriptAttack::_AttackAnimTime' has a wrong offset!");
static_assert(offsetof(UMaiScriptAttack, _SnapStartTime) == 0x0001B0, "Member 'UMaiScriptAttack::_SnapStartTime' has a wrong offset!");
static_assert(offsetof(UMaiScriptAttack, _HitTimes) == 0x0001B8, "Member 'UMaiScriptAttack::_HitTimes' has a wrong offset!");
static_assert(offsetof(UMaiScriptAttack, _SnapOnlyInStartSection) == 0x000218, "Member 'UMaiScriptAttack::_SnapOnlyInStartSection' has a wrong offset!");
static_assert(offsetof(UMaiScriptAttack, _SnapOnlyToLastHit) == 0x000219, "Member 'UMaiScriptAttack::_SnapOnlyToLastHit' has a wrong offset!");
static_assert(offsetof(UMaiScriptAttack, _MaxAttackSpeed) == 0x00021C, "Member 'UMaiScriptAttack::_MaxAttackSpeed' has a wrong offset!");
static_assert(offsetof(UMaiScriptAttack, _MaxSlideSpeed) == 0x000220, "Member 'UMaiScriptAttack::_MaxSlideSpeed' has a wrong offset!");
static_assert(offsetof(UMaiScriptAttack, _AbortBlendOut) == 0x000224, "Member 'UMaiScriptAttack::_AbortBlendOut' has a wrong offset!");
static_assert(offsetof(UMaiScriptAttack, _RotationInterpolationRate) == 0x000228, "Member 'UMaiScriptAttack::_RotationInterpolationRate' has a wrong offset!");
static_assert(offsetof(UMaiScriptAttack, _MovementDist) == 0x00022C, "Member 'UMaiScriptAttack::_MovementDist' has a wrong offset!");
static_assert(offsetof(UMaiScriptAttack, _MovementCurve) == 0x000230, "Member 'UMaiScriptAttack::_MovementCurve' has a wrong offset!");
static_assert(offsetof(UMaiScriptAttack, _PrintParams) == 0x000238, "Member 'UMaiScriptAttack::_PrintParams' has a wrong offset!");

// Class Mai.MaiBTDecorator_SelectEnemy
// 0x0038 (0x00B0 - 0x0078)
class UMaiBTDecorator_SelectEnemy final : public UMaiBTDecorator_WithInterval
{
public:
	struct FBlackboardKeySelector                 _Target;                                           // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTDecorator_SelectEnemy">();
	}
	static class UMaiBTDecorator_SelectEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTDecorator_SelectEnemy>();
	}
};
static_assert(alignof(UMaiBTDecorator_SelectEnemy) == 0x000008, "Wrong alignment on UMaiBTDecorator_SelectEnemy");
static_assert(sizeof(UMaiBTDecorator_SelectEnemy) == 0x0000B0, "Wrong size on UMaiBTDecorator_SelectEnemy");
static_assert(offsetof(UMaiBTDecorator_SelectEnemy, _Target) == 0x000078, "Member 'UMaiBTDecorator_SelectEnemy::_Target' has a wrong offset!");

// Class Mai.MaiAttackerComponent
// 0x0328 (0x03C8 - 0x00A0)
class UMaiAttackerComponent final : public UActorComponent
{
public:
	class UMaiIsLineToEnemyClearStat*             _CanMove;                                          // 0x00A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaiIsLineToEnemyClearStat*             _CanShoot;                                         // 0x00A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _AutoCombatRange;                                  // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _CombatRange;                                      // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           _IgnoreLocks;                                      // 0x00B8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             _TableOfAttacks;                                   // 0x00C8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          _AttacksTree;                                      // 0x00D0(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMaiAttackerConfig                     _DifficultyConfig[0xA];                            // 0x00D8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0x4];                                      // 0x0268(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _AttacksTreeInjectTag;                             // 0x026C(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _BehaviorInjectTag;                                // 0x0274(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _CountersTreeInjectTag;                            // 0x027C(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _BBDelayAfterAttack;                               // 0x0284(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FMaiAttackConfig>    _Attacks;                                          // 0x0290(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UMaiAttack*>          _SingleAttacks;                                    // 0x02E0(0x0050)(Edit, ExportObject, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMaiAttackBTNode>               _BTAttacks;                                        // 0x0330(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	class UBTCompositeNode*                       _BTAttacksRoot;                                    // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _BlowImpactID;                                     // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         _ChaseMode : 1;                                    // 0x034C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_34D[0x3];                                      // 0x034D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaiAttack*                             _CurrentAttack;                                    // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _AttackTarget;                                     // 0x0358(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         _HittedActors;                                     // 0x0360(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	float                                         _Cooldown;                                         // 0x0370(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ForceMiss;                                        // 0x0374(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_375[0x3];                                      // 0x0375(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _NextAttackName;                                   // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, SaveGame, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaiAttack*                             _NextAttack;                                       // 0x0380(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             DamageEnemy;                                       // 0x0388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAttackBegin;                                     // 0x0398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAttackEnd;                                       // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAttackCleared;                                   // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UMaiAttackerComponent* GetAttacker(class AActor* Actor);

	bool ApplyDamage(class AActor* Enemy, const struct FHitResult& Hit, TSubclassOf<class UDamageType> DamageType, float Damage, bool SingleDamage);
	void BeginAttack();
	void ChangeAttacksBT(class UBehaviorTree* AttacksTree);
	void CleanUpAttack(class FName AttackName);
	void DebugAttack(class AActor* Enemy);
	void EnableChaseMode(bool Enable);
	void EnableFocusOnEnemy(bool Enable);
	void EndBlow(int32 ImpactID);
	void FillAttacks();
	void ForceMiss(bool Miss);
	void ForceNextAttack(class FName AttackName);
	void InjectBT(bool Inject);
	void RunPureAttack(class AActor* Enemy, class FName AttackName);
	void SelectAttack(class AActor* Enemy, class FName AttackName);
	void StartBlow(int32 ImpactID);
	void StopAttack(bool Aborted, class FName AttackName);
	bool TryApplyLogicalDamage(class AActor* Enemy, float Damage, int32 ImpactID);
	bool TryApplyPhysicalDamage(class AActor* Enemy, const struct FHitResult& Hit);

	class UMaiAttack* FindBestAttack() const;
	EMaiAttackRange GetAttackRangeType(class AActor* Enemy, class FName AttackName) const;
	class AActor* GetCurrentAttackTarget() const;
	float GetCurrentAttackTime() const;
	bool HasAnyValidAttack(class AActor* Enemy, EMaiAttackRange Range, bool CheckCone, bool CheckToken) const;
	bool HasHit() const;
	bool IsInAttackRange(class AActor* Enemy, float VelocityScale) const;
	bool IsMissed(class AActor* Enemy) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiAttackerComponent">();
	}
	static class UMaiAttackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiAttackerComponent>();
	}
};
static_assert(alignof(UMaiAttackerComponent) == 0x000008, "Wrong alignment on UMaiAttackerComponent");
static_assert(sizeof(UMaiAttackerComponent) == 0x0003C8, "Wrong size on UMaiAttackerComponent");
static_assert(offsetof(UMaiAttackerComponent, _CanMove) == 0x0000A0, "Member 'UMaiAttackerComponent::_CanMove' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _CanShoot) == 0x0000A8, "Member 'UMaiAttackerComponent::_CanShoot' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _AutoCombatRange) == 0x0000B0, "Member 'UMaiAttackerComponent::_AutoCombatRange' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _CombatRange) == 0x0000B4, "Member 'UMaiAttackerComponent::_CombatRange' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _IgnoreLocks) == 0x0000B8, "Member 'UMaiAttackerComponent::_IgnoreLocks' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _TableOfAttacks) == 0x0000C8, "Member 'UMaiAttackerComponent::_TableOfAttacks' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _AttacksTree) == 0x0000D0, "Member 'UMaiAttackerComponent::_AttacksTree' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _DifficultyConfig) == 0x0000D8, "Member 'UMaiAttackerComponent::_DifficultyConfig' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _AttacksTreeInjectTag) == 0x00026C, "Member 'UMaiAttackerComponent::_AttacksTreeInjectTag' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _BehaviorInjectTag) == 0x000274, "Member 'UMaiAttackerComponent::_BehaviorInjectTag' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _CountersTreeInjectTag) == 0x00027C, "Member 'UMaiAttackerComponent::_CountersTreeInjectTag' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _BBDelayAfterAttack) == 0x000284, "Member 'UMaiAttackerComponent::_BBDelayAfterAttack' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _Attacks) == 0x000290, "Member 'UMaiAttackerComponent::_Attacks' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _SingleAttacks) == 0x0002E0, "Member 'UMaiAttackerComponent::_SingleAttacks' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _BTAttacks) == 0x000330, "Member 'UMaiAttackerComponent::_BTAttacks' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _BTAttacksRoot) == 0x000340, "Member 'UMaiAttackerComponent::_BTAttacksRoot' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _BlowImpactID) == 0x000348, "Member 'UMaiAttackerComponent::_BlowImpactID' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _CurrentAttack) == 0x000350, "Member 'UMaiAttackerComponent::_CurrentAttack' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _AttackTarget) == 0x000358, "Member 'UMaiAttackerComponent::_AttackTarget' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _HittedActors) == 0x000360, "Member 'UMaiAttackerComponent::_HittedActors' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _Cooldown) == 0x000370, "Member 'UMaiAttackerComponent::_Cooldown' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _ForceMiss) == 0x000374, "Member 'UMaiAttackerComponent::_ForceMiss' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _NextAttackName) == 0x000378, "Member 'UMaiAttackerComponent::_NextAttackName' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, _NextAttack) == 0x000380, "Member 'UMaiAttackerComponent::_NextAttack' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, DamageEnemy) == 0x000388, "Member 'UMaiAttackerComponent::DamageEnemy' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, OnAttackBegin) == 0x000398, "Member 'UMaiAttackerComponent::OnAttackBegin' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, OnAttackEnd) == 0x0003A8, "Member 'UMaiAttackerComponent::OnAttackEnd' has a wrong offset!");
static_assert(offsetof(UMaiAttackerComponent, OnAttackCleared) == 0x0003B8, "Member 'UMaiAttackerComponent::OnAttackCleared' has a wrong offset!");

// Class Mai.MaiBTService_BlueprintBase
// 0x0000 (0x0098 - 0x0098)
class UMaiBTService_BlueprintBase : public UBTService_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTService_BlueprintBase">();
	}
	static class UMaiBTService_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTService_BlueprintBase>();
	}
};
static_assert(alignof(UMaiBTService_BlueprintBase) == 0x000008, "Wrong alignment on UMaiBTService_BlueprintBase");
static_assert(sizeof(UMaiBTService_BlueprintBase) == 0x000098, "Wrong size on UMaiBTService_BlueprintBase");

// Class Mai.MaiBTService_Notify
// 0x0008 (0x00A0 - 0x0098)
class UMaiBTService_Notify final : public UMaiBTService_BlueprintBase
{
public:
	bool                                          _OnActivate;                                       // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _OnDeactivate;                                     // 0x0099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _OnTick;                                           // 0x009A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9B[0x5];                                       // 0x009B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceiveNotify(class AAIController* OwnerController, class APawn* ControlledPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTService_Notify">();
	}
	static class UMaiBTService_Notify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTService_Notify>();
	}
};
static_assert(alignof(UMaiBTService_Notify) == 0x000008, "Wrong alignment on UMaiBTService_Notify");
static_assert(sizeof(UMaiBTService_Notify) == 0x0000A0, "Wrong size on UMaiBTService_Notify");
static_assert(offsetof(UMaiBTService_Notify, _OnActivate) == 0x000098, "Member 'UMaiBTService_Notify::_OnActivate' has a wrong offset!");
static_assert(offsetof(UMaiBTService_Notify, _OnDeactivate) == 0x000099, "Member 'UMaiBTService_Notify::_OnDeactivate' has a wrong offset!");
static_assert(offsetof(UMaiBTService_Notify, _OnTick) == 0x00009A, "Member 'UMaiBTService_Notify::_OnTick' has a wrong offset!");

// Class Mai.MaiHostileAttackers
// 0x1350 (0x13F0 - 0x00A0)
class UMaiHostileAttackers : public UActorComponent
{
public:
	uint8                                         _MaxActiveAttackers;                               // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _ActiveAttackers;                                  // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         _PassiveAttackers;                                 // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x50];                                      // 0x00C8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDaiBlockade                           _LockTokensDistribution;                           // 0x0118(0x0018)(Edit, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDaiBlockade                           _HardLockTokens;                                   // 0x0130(0x0018)(Edit, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         _TokenLockOwners;                                  // 0x0148(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FMaiHostileConfig                      _DifficultyConfig[0xA];                            // 0x0158(0x0188)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         _TokenCoinsPaid;                                   // 0x10A8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _Token2Used[0x20];                                 // 0x10AC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112C[0x4];                                     // 0x112C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaiTokenCooldown>              _Token2Cooldown;                                   // 0x1130(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TMap<class AActor*, uint8>                    _Token2Holders;                                    // 0x1140(0x0050)(Edit, DisableEditOnTemplate, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TMap<class AActor*, struct FVector>           _Token2Waiting;                                    // 0x1190(0x0050)(Edit, DisableEditOnTemplate, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         _Token2StealAngle;                                 // 0x11E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Token2StealDist;                                  // 0x11E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _Pool;                                             // 0x11E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMaiTokenConfig                        _Token2Config[0x20];                               // 0x11EC(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         _Token2Pools[0x20];                                // 0x136C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13EC[0x4];                                     // 0x13EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMaiHostileAttackers* GetHostileAttackers(class AActor* Actor);

	bool AddAttacker(class AActor* Enemy);
	void CaptureTokenLock(class AActor* Enemy, bool Lock);
	void ChangeMaxActiveAttackers(uint8 Count);
	void DebugAttacker();
	void HardLockTokens(class FName Reason, class AActor* Enemy);
	void IgnoreLockFor(class FName Reason, class AActor* Enemy, bool OnlyIfLocked);
	void LockTokens(class FName Reason, bool Lock);
	void LockTokensDistribution(class FName Reason, bool Lock);
	void OfferSlotToOthers(class AActor* Enemy);
	void ReleaseAttackPosition(class AActor* Enemy);
	void RemoveAllAttackers();
	void RemoveAttacker(class AActor* Enemy);
	void ReturnToken(class AActor* Enemy, bool AddCooldown);
	void TakeAttackPosition(class AActor* Enemy, const struct FVector& Location);
	bool TakeToken(class AActor* Enemy, EMaiToken Token, const TArray<class FName>& IgnoreLocks, bool Force);
	void UpdateActiveAttackers();

	bool CanCaptureToken(class AActor* Enemy) const;
	bool CanGetSlot(class AActor* Enemy) const;
	bool CanHaveSlot(class AActor* Enemy) const;
	bool DisallowSlotGive(class AActor* Enemy) const;
	uint8 GetAttackerCount() const;
	uint8 GetSlotHoldersCount(TSubclassOf<class AActor> Klass) const;
	class AActor* GetTokenHolder() const;
	class AActor* GetTokenLockOwner() const;
	bool HasAnyAttacker() const;
	bool HasHardLock() const;
	bool HasOtherAttacker(class AActor* Enemy) const;
	bool HasToken(class AActor* Enemy) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiHostileAttackers">();
	}
	static class UMaiHostileAttackers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiHostileAttackers>();
	}
};
static_assert(alignof(UMaiHostileAttackers) == 0x000008, "Wrong alignment on UMaiHostileAttackers");
static_assert(sizeof(UMaiHostileAttackers) == 0x0013F0, "Wrong size on UMaiHostileAttackers");
static_assert(offsetof(UMaiHostileAttackers, _MaxActiveAttackers) == 0x0000A0, "Member 'UMaiHostileAttackers::_MaxActiveAttackers' has a wrong offset!");
static_assert(offsetof(UMaiHostileAttackers, _ActiveAttackers) == 0x0000A8, "Member 'UMaiHostileAttackers::_ActiveAttackers' has a wrong offset!");
static_assert(offsetof(UMaiHostileAttackers, _PassiveAttackers) == 0x0000B8, "Member 'UMaiHostileAttackers::_PassiveAttackers' has a wrong offset!");
static_assert(offsetof(UMaiHostileAttackers, _LockTokensDistribution) == 0x000118, "Member 'UMaiHostileAttackers::_LockTokensDistribution' has a wrong offset!");
static_assert(offsetof(UMaiHostileAttackers, _HardLockTokens) == 0x000130, "Member 'UMaiHostileAttackers::_HardLockTokens' has a wrong offset!");
static_assert(offsetof(UMaiHostileAttackers, _TokenLockOwners) == 0x000148, "Member 'UMaiHostileAttackers::_TokenLockOwners' has a wrong offset!");
static_assert(offsetof(UMaiHostileAttackers, _DifficultyConfig) == 0x000158, "Member 'UMaiHostileAttackers::_DifficultyConfig' has a wrong offset!");
static_assert(offsetof(UMaiHostileAttackers, _TokenCoinsPaid) == 0x0010A8, "Member 'UMaiHostileAttackers::_TokenCoinsPaid' has a wrong offset!");
static_assert(offsetof(UMaiHostileAttackers, _Token2Used) == 0x0010AC, "Member 'UMaiHostileAttackers::_Token2Used' has a wrong offset!");
static_assert(offsetof(UMaiHostileAttackers, _Token2Cooldown) == 0x001130, "Member 'UMaiHostileAttackers::_Token2Cooldown' has a wrong offset!");
static_assert(offsetof(UMaiHostileAttackers, _Token2Holders) == 0x001140, "Member 'UMaiHostileAttackers::_Token2Holders' has a wrong offset!");
static_assert(offsetof(UMaiHostileAttackers, _Token2Waiting) == 0x001190, "Member 'UMaiHostileAttackers::_Token2Waiting' has a wrong offset!");
static_assert(offsetof(UMaiHostileAttackers, _Token2StealAngle) == 0x0011E0, "Member 'UMaiHostileAttackers::_Token2StealAngle' has a wrong offset!");
static_assert(offsetof(UMaiHostileAttackers, _Token2StealDist) == 0x0011E4, "Member 'UMaiHostileAttackers::_Token2StealDist' has a wrong offset!");
static_assert(offsetof(UMaiHostileAttackers, _Pool) == 0x0011E8, "Member 'UMaiHostileAttackers::_Pool' has a wrong offset!");
static_assert(offsetof(UMaiHostileAttackers, _Token2Config) == 0x0011EC, "Member 'UMaiHostileAttackers::_Token2Config' has a wrong offset!");
static_assert(offsetof(UMaiHostileAttackers, _Token2Pools) == 0x00136C, "Member 'UMaiHostileAttackers::_Token2Pools' has a wrong offset!");

// Class Mai.MaiBTDecorator_DoesNodePathExist
// 0x0060 (0x00C8 - 0x0068)
class UMaiBTDecorator_DoesNodePathExist final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 BlackboardKeyA;                                    // 0x0068(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 BlackboardKeyB;                                    // 0x0090(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	EMaiNodePathExistanceQueryType                PathQueryType;                                     // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x00C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTDecorator_DoesNodePathExist">();
	}
	static class UMaiBTDecorator_DoesNodePathExist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTDecorator_DoesNodePathExist>();
	}
};
static_assert(alignof(UMaiBTDecorator_DoesNodePathExist) == 0x000008, "Wrong alignment on UMaiBTDecorator_DoesNodePathExist");
static_assert(sizeof(UMaiBTDecorator_DoesNodePathExist) == 0x0000C8, "Wrong size on UMaiBTDecorator_DoesNodePathExist");
static_assert(offsetof(UMaiBTDecorator_DoesNodePathExist, BlackboardKeyA) == 0x000068, "Member 'UMaiBTDecorator_DoesNodePathExist::BlackboardKeyA' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_DoesNodePathExist, BlackboardKeyB) == 0x000090, "Member 'UMaiBTDecorator_DoesNodePathExist::BlackboardKeyB' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_DoesNodePathExist, PathQueryType) == 0x0000B8, "Member 'UMaiBTDecorator_DoesNodePathExist::PathQueryType' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_DoesNodePathExist, FilterClass) == 0x0000C0, "Member 'UMaiBTDecorator_DoesNodePathExist::FilterClass' has a wrong offset!");

// Class Mai.MaiSenseDebugger
// 0x0030 (0x05B0 - 0x0580)
class UMaiSenseDebugger final : public UMaiShapeDrawer
{
public:
	float                                         _DefaultThickness;                                 // 0x0580(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_584[0x2C];                                     // 0x0584(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSenseDebugger">();
	}
	static class UMaiSenseDebugger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSenseDebugger>();
	}
};
static_assert(alignof(UMaiSenseDebugger) == 0x000010, "Wrong alignment on UMaiSenseDebugger");
static_assert(sizeof(UMaiSenseDebugger) == 0x0005B0, "Wrong size on UMaiSenseDebugger");
static_assert(offsetof(UMaiSenseDebugger, _DefaultThickness) == 0x000580, "Member 'UMaiSenseDebugger::_DefaultThickness' has a wrong offset!");

// Class Mai.MaiBehaviorTreeComponent
// 0x0000 (0x0288 - 0x0288)
class UMaiBehaviorTreeComponent final : public UBehaviorTreeComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBehaviorTreeComponent">();
	}
	static class UMaiBehaviorTreeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBehaviorTreeComponent>();
	}
};
static_assert(alignof(UMaiBehaviorTreeComponent) == 0x000008, "Wrong alignment on UMaiBehaviorTreeComponent");
static_assert(sizeof(UMaiBehaviorTreeComponent) == 0x000288, "Wrong size on UMaiBehaviorTreeComponent");

// Class Mai.ProvideBlackboardObject
// 0x0028 (0x0098 - 0x0070)
class UProvideBlackboardObject final : public UDaiContextGetter
{
public:
	struct FBlackboardKeySelector                 _Entry;                                            // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProvideBlackboardObject">();
	}
	static class UProvideBlackboardObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProvideBlackboardObject>();
	}
};
static_assert(alignof(UProvideBlackboardObject) == 0x000008, "Wrong alignment on UProvideBlackboardObject");
static_assert(sizeof(UProvideBlackboardObject) == 0x000098, "Wrong size on UProvideBlackboardObject");
static_assert(offsetof(UProvideBlackboardObject, _Entry) == 0x000070, "Member 'UProvideBlackboardObject::_Entry' has a wrong offset!");

// Class Mai.MaiBTService_WalkingStanceScope
// 0x0008 (0x0078 - 0x0070)
class UMaiBTService_WalkingStanceScope final : public UBTService
{
public:
	EBeingWalkingStance                           WalkingStance;                                     // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Priority;                                          // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTService_WalkingStanceScope">();
	}
	static class UMaiBTService_WalkingStanceScope* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTService_WalkingStanceScope>();
	}
};
static_assert(alignof(UMaiBTService_WalkingStanceScope) == 0x000008, "Wrong alignment on UMaiBTService_WalkingStanceScope");
static_assert(sizeof(UMaiBTService_WalkingStanceScope) == 0x000078, "Wrong size on UMaiBTService_WalkingStanceScope");
static_assert(offsetof(UMaiBTService_WalkingStanceScope, WalkingStance) == 0x000070, "Member 'UMaiBTService_WalkingStanceScope::WalkingStance' has a wrong offset!");
static_assert(offsetof(UMaiBTService_WalkingStanceScope, Priority) == 0x000071, "Member 'UMaiBTService_WalkingStanceScope::Priority' has a wrong offset!");

// Class Mai.MaiBTComposite_Random
// 0x0008 (0x0098 - 0x0090)
class UMaiBTComposite_Random final : public UBTCompositeNode
{
public:
	int32                                         _FillTo;                                           // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTComposite_Random">();
	}
	static class UMaiBTComposite_Random* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTComposite_Random>();
	}
};
static_assert(alignof(UMaiBTComposite_Random) == 0x000008, "Wrong alignment on UMaiBTComposite_Random");
static_assert(sizeof(UMaiBTComposite_Random) == 0x000098, "Wrong size on UMaiBTComposite_Random");
static_assert(offsetof(UMaiBTComposite_Random, _FillTo) == 0x000090, "Member 'UMaiBTComposite_Random::_FillTo' has a wrong offset!");

// Class Mai.MaiBTDecorator_DoesWallPathExist
// 0x0060 (0x00C8 - 0x0068)
class UMaiBTDecorator_DoesWallPathExist final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 BlackboardKeyA;                                    // 0x0068(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 BlackboardKeyB;                                    // 0x0090(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	EMaiWallPathExistanceQueryType                PathQueryType;                                     // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x00C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTDecorator_DoesWallPathExist">();
	}
	static class UMaiBTDecorator_DoesWallPathExist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTDecorator_DoesWallPathExist>();
	}
};
static_assert(alignof(UMaiBTDecorator_DoesWallPathExist) == 0x000008, "Wrong alignment on UMaiBTDecorator_DoesWallPathExist");
static_assert(sizeof(UMaiBTDecorator_DoesWallPathExist) == 0x0000C8, "Wrong size on UMaiBTDecorator_DoesWallPathExist");
static_assert(offsetof(UMaiBTDecorator_DoesWallPathExist, BlackboardKeyA) == 0x000068, "Member 'UMaiBTDecorator_DoesWallPathExist::BlackboardKeyA' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_DoesWallPathExist, BlackboardKeyB) == 0x000090, "Member 'UMaiBTDecorator_DoesWallPathExist::BlackboardKeyB' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_DoesWallPathExist, PathQueryType) == 0x0000B8, "Member 'UMaiBTDecorator_DoesWallPathExist::PathQueryType' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_DoesWallPathExist, FilterClass) == 0x0000C0, "Member 'UMaiBTDecorator_DoesWallPathExist::FilterClass' has a wrong offset!");

// Class Mai.MaiEqsGenerator_ActionPoints
// 0x0070 (0x00C0 - 0x0050)
class UMaiEqsGenerator_ActionPoints final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderClassValue              _PointClass;                                       // 0x0050(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderNameValue               _PointTag;                                         // 0x0088(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiEqsGenerator_ActionPoints">();
	}
	static class UMaiEqsGenerator_ActionPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiEqsGenerator_ActionPoints>();
	}
};
static_assert(alignof(UMaiEqsGenerator_ActionPoints) == 0x000008, "Wrong alignment on UMaiEqsGenerator_ActionPoints");
static_assert(sizeof(UMaiEqsGenerator_ActionPoints) == 0x0000C0, "Wrong size on UMaiEqsGenerator_ActionPoints");
static_assert(offsetof(UMaiEqsGenerator_ActionPoints, _PointClass) == 0x000050, "Member 'UMaiEqsGenerator_ActionPoints::_PointClass' has a wrong offset!");
static_assert(offsetof(UMaiEqsGenerator_ActionPoints, _PointTag) == 0x000088, "Member 'UMaiEqsGenerator_ActionPoints::_PointTag' has a wrong offset!");

// Class Mai.MaiBTDecorator_AreInSameLocation
// 0x0090 (0x0108 - 0x0078)
class UMaiBTDecorator_AreInSameLocation final : public UMaiBTDecorator_WithInterval
{
public:
	struct FMaiBlackboardFloat                    AcceptableRadius;                                  // 0x0078(0x0030)(Edit, NativeAccessSpecifierPublic)
	EDaiDistanceType                              GeometricDistanceType;                             // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BlackboardKeyA;                                    // 0x00B0(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BlackboardKeyB;                                    // 0x00D8(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          _IncludeOverlapA;                                  // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _IncludeOverlapB;                                  // 0x0101(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x6];                                      // 0x0102(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTDecorator_AreInSameLocation">();
	}
	static class UMaiBTDecorator_AreInSameLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTDecorator_AreInSameLocation>();
	}
};
static_assert(alignof(UMaiBTDecorator_AreInSameLocation) == 0x000008, "Wrong alignment on UMaiBTDecorator_AreInSameLocation");
static_assert(sizeof(UMaiBTDecorator_AreInSameLocation) == 0x000108, "Wrong size on UMaiBTDecorator_AreInSameLocation");
static_assert(offsetof(UMaiBTDecorator_AreInSameLocation, AcceptableRadius) == 0x000078, "Member 'UMaiBTDecorator_AreInSameLocation::AcceptableRadius' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_AreInSameLocation, GeometricDistanceType) == 0x0000A8, "Member 'UMaiBTDecorator_AreInSameLocation::GeometricDistanceType' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_AreInSameLocation, BlackboardKeyA) == 0x0000B0, "Member 'UMaiBTDecorator_AreInSameLocation::BlackboardKeyA' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_AreInSameLocation, BlackboardKeyB) == 0x0000D8, "Member 'UMaiBTDecorator_AreInSameLocation::BlackboardKeyB' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_AreInSameLocation, _IncludeOverlapA) == 0x000100, "Member 'UMaiBTDecorator_AreInSameLocation::_IncludeOverlapA' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_AreInSameLocation, _IncludeOverlapB) == 0x000101, "Member 'UMaiBTDecorator_AreInSameLocation::_IncludeOverlapB' has a wrong offset!");

// Class Mai.MaiBTDecorator_CheckActorGameplayTags
// 0x0060 (0x00D8 - 0x0078)
class UMaiBTDecorator_CheckActorGameplayTags final : public UMaiBTDecorator_WithInterval
{
public:
	struct FBlackboardKeySelector                 ActorToCheck;                                      // 0x0078(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	EGameplayContainerMatchType                   TagsToMatch;                                       // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x00A8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	class FString                                 CachedDescription;                                 // 0x00C8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTDecorator_CheckActorGameplayTags">();
	}
	static class UMaiBTDecorator_CheckActorGameplayTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTDecorator_CheckActorGameplayTags>();
	}
};
static_assert(alignof(UMaiBTDecorator_CheckActorGameplayTags) == 0x000008, "Wrong alignment on UMaiBTDecorator_CheckActorGameplayTags");
static_assert(sizeof(UMaiBTDecorator_CheckActorGameplayTags) == 0x0000D8, "Wrong size on UMaiBTDecorator_CheckActorGameplayTags");
static_assert(offsetof(UMaiBTDecorator_CheckActorGameplayTags, ActorToCheck) == 0x000078, "Member 'UMaiBTDecorator_CheckActorGameplayTags::ActorToCheck' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_CheckActorGameplayTags, TagsToMatch) == 0x0000A0, "Member 'UMaiBTDecorator_CheckActorGameplayTags::TagsToMatch' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_CheckActorGameplayTags, GameplayTags) == 0x0000A8, "Member 'UMaiBTDecorator_CheckActorGameplayTags::GameplayTags' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_CheckActorGameplayTags, CachedDescription) == 0x0000C8, "Member 'UMaiBTDecorator_CheckActorGameplayTags::CachedDescription' has a wrong offset!");

// Class Mai.MsgEndBlowReceiverInterface
// 0x0000 (0x0028 - 0x0028)
class IMsgEndBlowReceiverInterface final : public IInterface
{
public:
	void ReceiveEndBlowMsg(class UMaiMessage* Message, class AActor* Attacker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgEndBlowReceiverInterface">();
	}
	static class IMsgEndBlowReceiverInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMsgEndBlowReceiverInterface>();
	}
};
static_assert(alignof(IMsgEndBlowReceiverInterface) == 0x000008, "Wrong alignment on IMsgEndBlowReceiverInterface");
static_assert(sizeof(IMsgEndBlowReceiverInterface) == 0x000028, "Wrong size on IMsgEndBlowReceiverInterface");

// Class Mai.MaiBTDecorator_CheckAttack
// 0x0068 (0x00D0 - 0x0068)
class UMaiBTDecorator_CheckAttack : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 _Target;                                           // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    _AttackRow;                                        // 0x0090(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 _AttackKey;                                        // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          _AttackFromKey;                                    // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _CheckRange;                                       // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _CheckCone;                                        // 0x00CA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _CheckVisibility;                                  // 0x00CB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _StealToken;                                       // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTDecorator_CheckAttack">();
	}
	static class UMaiBTDecorator_CheckAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTDecorator_CheckAttack>();
	}
};
static_assert(alignof(UMaiBTDecorator_CheckAttack) == 0x000008, "Wrong alignment on UMaiBTDecorator_CheckAttack");
static_assert(sizeof(UMaiBTDecorator_CheckAttack) == 0x0000D0, "Wrong size on UMaiBTDecorator_CheckAttack");
static_assert(offsetof(UMaiBTDecorator_CheckAttack, _Target) == 0x000068, "Member 'UMaiBTDecorator_CheckAttack::_Target' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_CheckAttack, _AttackRow) == 0x000090, "Member 'UMaiBTDecorator_CheckAttack::_AttackRow' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_CheckAttack, _AttackKey) == 0x0000A0, "Member 'UMaiBTDecorator_CheckAttack::_AttackKey' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_CheckAttack, _AttackFromKey) == 0x0000C8, "Member 'UMaiBTDecorator_CheckAttack::_AttackFromKey' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_CheckAttack, _CheckRange) == 0x0000C9, "Member 'UMaiBTDecorator_CheckAttack::_CheckRange' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_CheckAttack, _CheckCone) == 0x0000CA, "Member 'UMaiBTDecorator_CheckAttack::_CheckCone' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_CheckAttack, _CheckVisibility) == 0x0000CB, "Member 'UMaiBTDecorator_CheckAttack::_CheckVisibility' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_CheckAttack, _StealToken) == 0x0000CC, "Member 'UMaiBTDecorator_CheckAttack::_StealToken' has a wrong offset!");

// Class Mai.MaiBTService_CallNotify
// 0x0008 (0x0080 - 0x0078)
class UMaiBTService_CallNotify final : public UMaiBTService_NativeNotify
{
public:
	class UDaiNotify*                             _Notify;                                           // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTService_CallNotify">();
	}
	static class UMaiBTService_CallNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTService_CallNotify>();
	}
};
static_assert(alignof(UMaiBTService_CallNotify) == 0x000008, "Wrong alignment on UMaiBTService_CallNotify");
static_assert(sizeof(UMaiBTService_CallNotify) == 0x000080, "Wrong size on UMaiBTService_CallNotify");
static_assert(offsetof(UMaiBTService_CallNotify, _Notify) == 0x000078, "Member 'UMaiBTService_CallNotify::_Notify' has a wrong offset!");

// Class Mai.MaiBTDecorator_SelectAttack
// 0x0000 (0x00D0 - 0x00D0)
class UMaiBTDecorator_SelectAttack final : public UMaiBTDecorator_CheckAttack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTDecorator_SelectAttack">();
	}
	static class UMaiBTDecorator_SelectAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTDecorator_SelectAttack>();
	}
};
static_assert(alignof(UMaiBTDecorator_SelectAttack) == 0x000008, "Wrong alignment on UMaiBTDecorator_SelectAttack");
static_assert(sizeof(UMaiBTDecorator_SelectAttack) == 0x0000D0, "Wrong size on UMaiBTDecorator_SelectAttack");

// Class Mai.MaiBTDecorator_HasValidAnyAttack
// 0x0038 (0x00B0 - 0x0078)
class UMaiBTDecorator_HasValidAnyAttack final : public UMaiBTDecorator_WithInterval
{
public:
	struct FBlackboardKeySelector                 _Enemy;                                            // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          _CheckCone;                                        // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _StealToken;                                       // 0x00A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x2];                                       // 0x00A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _MinCheckPeriod;                                   // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _MaxCheckPeriod;                                   // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTDecorator_HasValidAnyAttack">();
	}
	static class UMaiBTDecorator_HasValidAnyAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTDecorator_HasValidAnyAttack>();
	}
};
static_assert(alignof(UMaiBTDecorator_HasValidAnyAttack) == 0x000008, "Wrong alignment on UMaiBTDecorator_HasValidAnyAttack");
static_assert(sizeof(UMaiBTDecorator_HasValidAnyAttack) == 0x0000B0, "Wrong size on UMaiBTDecorator_HasValidAnyAttack");
static_assert(offsetof(UMaiBTDecorator_HasValidAnyAttack, _Enemy) == 0x000078, "Member 'UMaiBTDecorator_HasValidAnyAttack::_Enemy' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_HasValidAnyAttack, _CheckCone) == 0x0000A0, "Member 'UMaiBTDecorator_HasValidAnyAttack::_CheckCone' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_HasValidAnyAttack, _StealToken) == 0x0000A1, "Member 'UMaiBTDecorator_HasValidAnyAttack::_StealToken' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_HasValidAnyAttack, _MinCheckPeriod) == 0x0000A4, "Member 'UMaiBTDecorator_HasValidAnyAttack::_MinCheckPeriod' has a wrong offset!");
static_assert(offsetof(UMaiBTDecorator_HasValidAnyAttack, _MaxCheckPeriod) == 0x0000A8, "Member 'UMaiBTDecorator_HasValidAnyAttack::_MaxCheckPeriod' has a wrong offset!");

// Class Mai.MaiBTDecorator_CanStealAnyToken
// 0x0028 (0x00A0 - 0x0078)
class UMaiBTDecorator_CanStealAnyToken final : public UMaiBTDecorator_WithInterval
{
public:
	struct FBlackboardKeySelector                 _Enemy;                                            // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTDecorator_CanStealAnyToken">();
	}
	static class UMaiBTDecorator_CanStealAnyToken* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTDecorator_CanStealAnyToken>();
	}
};
static_assert(alignof(UMaiBTDecorator_CanStealAnyToken) == 0x000008, "Wrong alignment on UMaiBTDecorator_CanStealAnyToken");
static_assert(sizeof(UMaiBTDecorator_CanStealAnyToken) == 0x0000A0, "Wrong size on UMaiBTDecorator_CanStealAnyToken");
static_assert(offsetof(UMaiBTDecorator_CanStealAnyToken, _Enemy) == 0x000078, "Member 'UMaiBTDecorator_CanStealAnyToken::_Enemy' has a wrong offset!");

// Class Mai.MaiBTDecorator_Priority
// 0x0030 (0x0098 - 0x0068)
class UMaiBTDecorator_Priority final : public UBTDecorator
{
public:
	struct FMaiBlackboardInt                      _Chance;                                           // 0x0068(0x0030)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTDecorator_Priority">();
	}
	static class UMaiBTDecorator_Priority* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTDecorator_Priority>();
	}
};
static_assert(alignof(UMaiBTDecorator_Priority) == 0x000008, "Wrong alignment on UMaiBTDecorator_Priority");
static_assert(sizeof(UMaiBTDecorator_Priority) == 0x000098, "Wrong size on UMaiBTDecorator_Priority");
static_assert(offsetof(UMaiBTDecorator_Priority, _Chance) == 0x000068, "Member 'UMaiBTDecorator_Priority::_Chance' has a wrong offset!");

// Class Mai.MaiBTDecorator_BlueprintBase
// 0x0000 (0x00A0 - 0x00A0)
class UMaiBTDecorator_BlueprintBase final : public UBTDecorator_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTDecorator_BlueprintBase">();
	}
	static class UMaiBTDecorator_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTDecorator_BlueprintBase>();
	}
};
static_assert(alignof(UMaiBTDecorator_BlueprintBase) == 0x000008, "Wrong alignment on UMaiBTDecorator_BlueprintBase");
static_assert(sizeof(UMaiBTDecorator_BlueprintBase) == 0x0000A0, "Wrong size on UMaiBTDecorator_BlueprintBase");

// Class Mai.MaiBTTask_BlueprintBase
// 0x0000 (0x00A8 - 0x00A8)
class UMaiBTTask_BlueprintBase : public UBTTask_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTTask_BlueprintBase">();
	}
	static class UMaiBTTask_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTTask_BlueprintBase>();
	}
};
static_assert(alignof(UMaiBTTask_BlueprintBase) == 0x000008, "Wrong alignment on UMaiBTTask_BlueprintBase");
static_assert(sizeof(UMaiBTTask_BlueprintBase) == 0x0000A8, "Wrong size on UMaiBTTask_BlueprintBase");

// Class Mai.MaiBTService_KeepDistance
// 0x0010 (0x00A8 - 0x0098)
class UMaiBTService_KeepDistance final : public UBTService_BlackboardBase
{
public:
	TArray<struct FStanceRange>                   _Ranges;                                           // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTService_KeepDistance">();
	}
	static class UMaiBTService_KeepDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTService_KeepDistance>();
	}
};
static_assert(alignof(UMaiBTService_KeepDistance) == 0x000008, "Wrong alignment on UMaiBTService_KeepDistance");
static_assert(sizeof(UMaiBTService_KeepDistance) == 0x0000A8, "Wrong size on UMaiBTService_KeepDistance");
static_assert(offsetof(UMaiBTService_KeepDistance, _Ranges) == 0x000098, "Member 'UMaiBTService_KeepDistance::_Ranges' has a wrong offset!");

// Class Mai.MaiBTService_LockAttackPosition
// 0x0028 (0x0098 - 0x0070)
class UMaiBTService_LockAttackPosition final : public UBTService
{
public:
	struct FBlackboardKeySelector                 AttackLocation;                                    // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTService_LockAttackPosition">();
	}
	static class UMaiBTService_LockAttackPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTService_LockAttackPosition>();
	}
};
static_assert(alignof(UMaiBTService_LockAttackPosition) == 0x000008, "Wrong alignment on UMaiBTService_LockAttackPosition");
static_assert(sizeof(UMaiBTService_LockAttackPosition) == 0x000098, "Wrong size on UMaiBTService_LockAttackPosition");
static_assert(offsetof(UMaiBTService_LockAttackPosition, AttackLocation) == 0x000070, "Member 'UMaiBTService_LockAttackPosition::AttackLocation' has a wrong offset!");

// Class Mai.MaiBTService_LookAt
// 0x0008 (0x00A0 - 0x0098)
class UMaiBTService_LookAt final : public UBTService_BlackboardBase
{
public:
	uint8                                         _Priority;                                         // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMaiFocusType                                 _FocusType;                                        // 0x0099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _CheckConeRange;                                   // 0x009A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B[0x1];                                       // 0x009B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _ConeRange;                                        // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTService_LookAt">();
	}
	static class UMaiBTService_LookAt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTService_LookAt>();
	}
};
static_assert(alignof(UMaiBTService_LookAt) == 0x000008, "Wrong alignment on UMaiBTService_LookAt");
static_assert(sizeof(UMaiBTService_LookAt) == 0x0000A0, "Wrong size on UMaiBTService_LookAt");
static_assert(offsetof(UMaiBTService_LookAt, _Priority) == 0x000098, "Member 'UMaiBTService_LookAt::_Priority' has a wrong offset!");
static_assert(offsetof(UMaiBTService_LookAt, _FocusType) == 0x000099, "Member 'UMaiBTService_LookAt::_FocusType' has a wrong offset!");
static_assert(offsetof(UMaiBTService_LookAt, _CheckConeRange) == 0x00009A, "Member 'UMaiBTService_LookAt::_CheckConeRange' has a wrong offset!");
static_assert(offsetof(UMaiBTService_LookAt, _ConeRange) == 0x00009C, "Member 'UMaiBTService_LookAt::_ConeRange' has a wrong offset!");

// Class Mai.MaiBTService_PlaySlotAnim
// 0x0088 (0x00F8 - 0x0070)
class UMaiBTService_PlaySlotAnim final : public UBTService
{
public:
	bool                                          _SelectAnimByTag;                                  // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      _AnimationToPlay;                                  // 0x0078(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _AnimTags;                                         // 0x0080(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         _PlayRate;                                         // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _TimeToStartAt;                                    // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _Slot;                                             // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _BlendInTime;                                      // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _BlendOutTime;                                     // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _LoopCount;                                        // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 _PlayTimeOutput;                                   // 0x00C0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 CachedSkelMesh;                                    // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           _PlayedMontage;                                    // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTService_PlaySlotAnim">();
	}
	static class UMaiBTService_PlaySlotAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTService_PlaySlotAnim>();
	}
};
static_assert(alignof(UMaiBTService_PlaySlotAnim) == 0x000008, "Wrong alignment on UMaiBTService_PlaySlotAnim");
static_assert(sizeof(UMaiBTService_PlaySlotAnim) == 0x0000F8, "Wrong size on UMaiBTService_PlaySlotAnim");
static_assert(offsetof(UMaiBTService_PlaySlotAnim, _SelectAnimByTag) == 0x000070, "Member 'UMaiBTService_PlaySlotAnim::_SelectAnimByTag' has a wrong offset!");
static_assert(offsetof(UMaiBTService_PlaySlotAnim, _AnimationToPlay) == 0x000078, "Member 'UMaiBTService_PlaySlotAnim::_AnimationToPlay' has a wrong offset!");
static_assert(offsetof(UMaiBTService_PlaySlotAnim, _AnimTags) == 0x000080, "Member 'UMaiBTService_PlaySlotAnim::_AnimTags' has a wrong offset!");
static_assert(offsetof(UMaiBTService_PlaySlotAnim, _PlayRate) == 0x0000A0, "Member 'UMaiBTService_PlaySlotAnim::_PlayRate' has a wrong offset!");
static_assert(offsetof(UMaiBTService_PlaySlotAnim, _TimeToStartAt) == 0x0000A4, "Member 'UMaiBTService_PlaySlotAnim::_TimeToStartAt' has a wrong offset!");
static_assert(offsetof(UMaiBTService_PlaySlotAnim, _Slot) == 0x0000A8, "Member 'UMaiBTService_PlaySlotAnim::_Slot' has a wrong offset!");
static_assert(offsetof(UMaiBTService_PlaySlotAnim, _BlendInTime) == 0x0000B0, "Member 'UMaiBTService_PlaySlotAnim::_BlendInTime' has a wrong offset!");
static_assert(offsetof(UMaiBTService_PlaySlotAnim, _BlendOutTime) == 0x0000B4, "Member 'UMaiBTService_PlaySlotAnim::_BlendOutTime' has a wrong offset!");
static_assert(offsetof(UMaiBTService_PlaySlotAnim, _LoopCount) == 0x0000B8, "Member 'UMaiBTService_PlaySlotAnim::_LoopCount' has a wrong offset!");
static_assert(offsetof(UMaiBTService_PlaySlotAnim, _PlayTimeOutput) == 0x0000C0, "Member 'UMaiBTService_PlaySlotAnim::_PlayTimeOutput' has a wrong offset!");
static_assert(offsetof(UMaiBTService_PlaySlotAnim, CachedSkelMesh) == 0x0000E8, "Member 'UMaiBTService_PlaySlotAnim::CachedSkelMesh' has a wrong offset!");
static_assert(offsetof(UMaiBTService_PlaySlotAnim, _PlayedMontage) == 0x0000F0, "Member 'UMaiBTService_PlaySlotAnim::_PlayedMontage' has a wrong offset!");

// Class Mai.MaiBTService_InitAttack
// 0x0068 (0x00D8 - 0x0070)
class UMaiBTService_InitAttack final : public UBTService
{
public:
	struct FBlackboardKeySelector                 _Target;                                           // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    _AttackRow;                                        // 0x0098(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 _AttackKey;                                        // 0x00A8(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          _AttackFromKey;                                    // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTService_InitAttack">();
	}
	static class UMaiBTService_InitAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTService_InitAttack>();
	}
};
static_assert(alignof(UMaiBTService_InitAttack) == 0x000008, "Wrong alignment on UMaiBTService_InitAttack");
static_assert(sizeof(UMaiBTService_InitAttack) == 0x0000D8, "Wrong size on UMaiBTService_InitAttack");
static_assert(offsetof(UMaiBTService_InitAttack, _Target) == 0x000070, "Member 'UMaiBTService_InitAttack::_Target' has a wrong offset!");
static_assert(offsetof(UMaiBTService_InitAttack, _AttackRow) == 0x000098, "Member 'UMaiBTService_InitAttack::_AttackRow' has a wrong offset!");
static_assert(offsetof(UMaiBTService_InitAttack, _AttackKey) == 0x0000A8, "Member 'UMaiBTService_InitAttack::_AttackKey' has a wrong offset!");
static_assert(offsetof(UMaiBTService_InitAttack, _AttackFromKey) == 0x0000D0, "Member 'UMaiBTService_InitAttack::_AttackFromKey' has a wrong offset!");

// Class Mai.MaiBTService_SelectNextAP
// 0x0080 (0x00F0 - 0x0070)
class UMaiBTService_SelectNextAP final : public UBTService
{
public:
	struct FBlackboardKeySelector                 _ActionPoint;                                      // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 _WorkLocation;                                     // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	EPointSelection                               _SelectionMethod;                                  // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 _SelectionOrigin;                                  // 0x00C8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTService_SelectNextAP">();
	}
	static class UMaiBTService_SelectNextAP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTService_SelectNextAP>();
	}
};
static_assert(alignof(UMaiBTService_SelectNextAP) == 0x000008, "Wrong alignment on UMaiBTService_SelectNextAP");
static_assert(sizeof(UMaiBTService_SelectNextAP) == 0x0000F0, "Wrong size on UMaiBTService_SelectNextAP");
static_assert(offsetof(UMaiBTService_SelectNextAP, _ActionPoint) == 0x000070, "Member 'UMaiBTService_SelectNextAP::_ActionPoint' has a wrong offset!");
static_assert(offsetof(UMaiBTService_SelectNextAP, _WorkLocation) == 0x000098, "Member 'UMaiBTService_SelectNextAP::_WorkLocation' has a wrong offset!");
static_assert(offsetof(UMaiBTService_SelectNextAP, _SelectionMethod) == 0x0000C0, "Member 'UMaiBTService_SelectNextAP::_SelectionMethod' has a wrong offset!");
static_assert(offsetof(UMaiBTService_SelectNextAP, _SelectionOrigin) == 0x0000C8, "Member 'UMaiBTService_SelectNextAP::_SelectionOrigin' has a wrong offset!");

// Class Mai.MaiBTService_AbandonAP
// 0x0028 (0x00C0 - 0x0098)
class UMaiBTService_AbandonAP final : public UMaiBTService_BlueprintBase
{
public:
	struct FBlackboardKeySelector                 _ActionPoint;                                      // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTService_AbandonAP">();
	}
	static class UMaiBTService_AbandonAP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTService_AbandonAP>();
	}
};
static_assert(alignof(UMaiBTService_AbandonAP) == 0x000008, "Wrong alignment on UMaiBTService_AbandonAP");
static_assert(sizeof(UMaiBTService_AbandonAP) == 0x0000C0, "Wrong size on UMaiBTService_AbandonAP");
static_assert(offsetof(UMaiBTService_AbandonAP, _ActionPoint) == 0x000098, "Member 'UMaiBTService_AbandonAP::_ActionPoint' has a wrong offset!");

// Class Mai.MaiBTService_SetBoolNotify
// 0x0030 (0x00A8 - 0x0078)
class UMaiBTService_SetBoolNotify final : public UMaiBTService_NativeNotify
{
public:
	struct FBlackboardKeySelector                 FlagToSet;                                         // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bValue;                                            // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTService_SetBoolNotify">();
	}
	static class UMaiBTService_SetBoolNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTService_SetBoolNotify>();
	}
};
static_assert(alignof(UMaiBTService_SetBoolNotify) == 0x000008, "Wrong alignment on UMaiBTService_SetBoolNotify");
static_assert(sizeof(UMaiBTService_SetBoolNotify) == 0x0000A8, "Wrong size on UMaiBTService_SetBoolNotify");
static_assert(offsetof(UMaiBTService_SetBoolNotify, FlagToSet) == 0x000078, "Member 'UMaiBTService_SetBoolNotify::FlagToSet' has a wrong offset!");
static_assert(offsetof(UMaiBTService_SetBoolNotify, bValue) == 0x0000A0, "Member 'UMaiBTService_SetBoolNotify::bValue' has a wrong offset!");

// Class Mai.MaiBTService_StackBehavior
// 0x0008 (0x0078 - 0x0070)
class UMaiBTService_StackBehavior final : public UBTService
{
public:
	class FName                                   behaviorName;                                      // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTService_StackBehavior">();
	}
	static class UMaiBTService_StackBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTService_StackBehavior>();
	}
};
static_assert(alignof(UMaiBTService_StackBehavior) == 0x000008, "Wrong alignment on UMaiBTService_StackBehavior");
static_assert(sizeof(UMaiBTService_StackBehavior) == 0x000078, "Wrong size on UMaiBTService_StackBehavior");
static_assert(offsetof(UMaiBTService_StackBehavior, behaviorName) == 0x000070, "Member 'UMaiBTService_StackBehavior::behaviorName' has a wrong offset!");

// Class Mai.BTTask_BeingActionBase
// 0x0000 (0x0070 - 0x0070)
class UBTTask_BeingActionBase : public UBTTaskNode
{
public:
	void OnActionEvent(class UBeingAction* Action, EBeingActionEventType EventType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_BeingActionBase">();
	}
	static class UBTTask_BeingActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_BeingActionBase>();
	}
};
static_assert(alignof(UBTTask_BeingActionBase) == 0x000008, "Wrong alignment on UBTTask_BeingActionBase");
static_assert(sizeof(UBTTask_BeingActionBase) == 0x000070, "Wrong size on UBTTask_BeingActionBase");

// Class Mai.BTTask_PushBeingAction
// 0x0008 (0x0078 - 0x0070)
class UBTTask_PushBeingAction final : public UBTTask_BeingActionBase
{
public:
	class UBeingAction*                           Action;                                            // 0x0070(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_PushBeingAction">();
	}
	static class UBTTask_PushBeingAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_PushBeingAction>();
	}
};
static_assert(alignof(UBTTask_PushBeingAction) == 0x000008, "Wrong alignment on UBTTask_PushBeingAction");
static_assert(sizeof(UBTTask_PushBeingAction) == 0x000078, "Wrong size on UBTTask_PushBeingAction");
static_assert(offsetof(UBTTask_PushBeingAction, Action) == 0x000070, "Member 'UBTTask_PushBeingAction::Action' has a wrong offset!");

// Class Mai.MaiBTTask_LookAtBBEntry
// 0x0010 (0x00A8 - 0x0098)
class UMaiBTTask_LookAtBBEntry final : public UBTTask_BlackboardBase
{
public:
	float                                         Precision;                                         // 0x0098(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMaiFocusType                                 _FocusType;                                        // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9D[0xB];                                       // 0x009D(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTTask_LookAtBBEntry">();
	}
	static class UMaiBTTask_LookAtBBEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTTask_LookAtBBEntry>();
	}
};
static_assert(alignof(UMaiBTTask_LookAtBBEntry) == 0x000008, "Wrong alignment on UMaiBTTask_LookAtBBEntry");
static_assert(sizeof(UMaiBTTask_LookAtBBEntry) == 0x0000A8, "Wrong size on UMaiBTTask_LookAtBBEntry");
static_assert(offsetof(UMaiBTTask_LookAtBBEntry, Precision) == 0x000098, "Member 'UMaiBTTask_LookAtBBEntry::Precision' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_LookAtBBEntry, _FocusType) == 0x00009C, "Member 'UMaiBTTask_LookAtBBEntry::_FocusType' has a wrong offset!");

// Class Mai.MaiBTTask_MoveToExt
// 0x0010 (0x00C0 - 0x00B0)
class UMaiBTTask_MoveToExt : public UBTTask_MoveTo
{
public:
	bool                                          _RepathOnGoalMoved;                                // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _RepathTestPeriod;                                 // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _RepathTestDistance;                               // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTTask_MoveToExt">();
	}
	static class UMaiBTTask_MoveToExt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTTask_MoveToExt>();
	}
};
static_assert(alignof(UMaiBTTask_MoveToExt) == 0x000008, "Wrong alignment on UMaiBTTask_MoveToExt");
static_assert(sizeof(UMaiBTTask_MoveToExt) == 0x0000C0, "Wrong size on UMaiBTTask_MoveToExt");
static_assert(offsetof(UMaiBTTask_MoveToExt, _RepathOnGoalMoved) == 0x0000B0, "Member 'UMaiBTTask_MoveToExt::_RepathOnGoalMoved' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_MoveToExt, _RepathTestPeriod) == 0x0000B4, "Member 'UMaiBTTask_MoveToExt::_RepathTestPeriod' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_MoveToExt, _RepathTestDistance) == 0x0000B8, "Member 'UMaiBTTask_MoveToExt::_RepathTestDistance' has a wrong offset!");

// Class Mai.MaiBTTask_MoveToAP
// 0x0010 (0x00D0 - 0x00C0)
class UMaiBTTask_MoveToAP final : public UMaiBTTask_MoveToExt
{
public:
	struct FGameplayTag                           _ActionInjectionTag;                               // 0x00C0(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _RunActionsOnReach;                                // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _StanceFromActionPoint;                            // 0x00C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTTask_MoveToAP">();
	}
	static class UMaiBTTask_MoveToAP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTTask_MoveToAP>();
	}
};
static_assert(alignof(UMaiBTTask_MoveToAP) == 0x000008, "Wrong alignment on UMaiBTTask_MoveToAP");
static_assert(sizeof(UMaiBTTask_MoveToAP) == 0x0000D0, "Wrong size on UMaiBTTask_MoveToAP");
static_assert(offsetof(UMaiBTTask_MoveToAP, _ActionInjectionTag) == 0x0000C0, "Member 'UMaiBTTask_MoveToAP::_ActionInjectionTag' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_MoveToAP, _RunActionsOnReach) == 0x0000C8, "Member 'UMaiBTTask_MoveToAP::_RunActionsOnReach' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_MoveToAP, _StanceFromActionPoint) == 0x0000C9, "Member 'UMaiBTTask_MoveToAP::_StanceFromActionPoint' has a wrong offset!");

// Class Mai.MaiBTTask_MoveToOnNodes
// 0x0030 (0x00C8 - 0x0098)
class UMaiBTTask_MoveToOnNodes final : public UBTTask_BlackboardBase
{
public:
	float                                         _AcceptableRadius;                                 // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _ObservedBlackboardValueTolerance;                 // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ObserveBlackboardValue;                           // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaiOnPathFail                                _OnPathFail;                                       // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _TargetLocation;                                   // 0x00A8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaiNodeFollowing*                      _Following;                                        // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTTask_MoveToOnNodes">();
	}
	static class UMaiBTTask_MoveToOnNodes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTTask_MoveToOnNodes>();
	}
};
static_assert(alignof(UMaiBTTask_MoveToOnNodes) == 0x000008, "Wrong alignment on UMaiBTTask_MoveToOnNodes");
static_assert(sizeof(UMaiBTTask_MoveToOnNodes) == 0x0000C8, "Wrong size on UMaiBTTask_MoveToOnNodes");
static_assert(offsetof(UMaiBTTask_MoveToOnNodes, _AcceptableRadius) == 0x000098, "Member 'UMaiBTTask_MoveToOnNodes::_AcceptableRadius' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_MoveToOnNodes, _ObservedBlackboardValueTolerance) == 0x00009C, "Member 'UMaiBTTask_MoveToOnNodes::_ObservedBlackboardValueTolerance' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_MoveToOnNodes, _ObserveBlackboardValue) == 0x0000A0, "Member 'UMaiBTTask_MoveToOnNodes::_ObserveBlackboardValue' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_MoveToOnNodes, _OnPathFail) == 0x0000A1, "Member 'UMaiBTTask_MoveToOnNodes::_OnPathFail' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_MoveToOnNodes, _TargetLocation) == 0x0000A8, "Member 'UMaiBTTask_MoveToOnNodes::_TargetLocation' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_MoveToOnNodes, _Following) == 0x0000C0, "Member 'UMaiBTTask_MoveToOnNodes::_Following' has a wrong offset!");

// Class Mai.MaiBTTask_MoveToOnWalls
// 0x00A8 (0x0140 - 0x0098)
class UMaiBTTask_MoveToOnWalls final : public UBTTask_BlackboardBase
{
public:
	float                                         _AcceptableRadius;                                 // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _OverlapAgent : 1;                                 // 0x009C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _OverlapGoal : 1;                                  // 0x009C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _TrackMovingGoal : 1;                              // 0x009C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _ProjectGoalLocation : 1;                          // 0x009C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _AllowStrafe : 1;                                  // 0x009C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _ObservedBlackboardValueTolerance;                 // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ObserveBlackboardValue;                           // 0x00A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _MoveToAP;                                         // 0x00A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _ActionInjectionTag;                               // 0x00A8(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _RunActionsOnReach;                                // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _StanceFromActionPoint;                            // 0x00B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 _AvoidActor;                                       // 0x00B8(0x0028)(Edit, NativeAccessSpecifierPublic)
	int32                                         _AvoidCountLimit;                                  // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaiWallFollowing*                      _Following;                                        // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x50];                                      // 0x00F0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTTask_MoveToOnWalls">();
	}
	static class UMaiBTTask_MoveToOnWalls* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTTask_MoveToOnWalls>();
	}
};
static_assert(alignof(UMaiBTTask_MoveToOnWalls) == 0x000008, "Wrong alignment on UMaiBTTask_MoveToOnWalls");
static_assert(sizeof(UMaiBTTask_MoveToOnWalls) == 0x000140, "Wrong size on UMaiBTTask_MoveToOnWalls");
static_assert(offsetof(UMaiBTTask_MoveToOnWalls, _AcceptableRadius) == 0x000098, "Member 'UMaiBTTask_MoveToOnWalls::_AcceptableRadius' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_MoveToOnWalls, _ObservedBlackboardValueTolerance) == 0x0000A0, "Member 'UMaiBTTask_MoveToOnWalls::_ObservedBlackboardValueTolerance' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_MoveToOnWalls, _ObserveBlackboardValue) == 0x0000A4, "Member 'UMaiBTTask_MoveToOnWalls::_ObserveBlackboardValue' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_MoveToOnWalls, _MoveToAP) == 0x0000A5, "Member 'UMaiBTTask_MoveToOnWalls::_MoveToAP' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_MoveToOnWalls, _ActionInjectionTag) == 0x0000A8, "Member 'UMaiBTTask_MoveToOnWalls::_ActionInjectionTag' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_MoveToOnWalls, _RunActionsOnReach) == 0x0000B0, "Member 'UMaiBTTask_MoveToOnWalls::_RunActionsOnReach' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_MoveToOnWalls, _StanceFromActionPoint) == 0x0000B1, "Member 'UMaiBTTask_MoveToOnWalls::_StanceFromActionPoint' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_MoveToOnWalls, _AvoidActor) == 0x0000B8, "Member 'UMaiBTTask_MoveToOnWalls::_AvoidActor' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_MoveToOnWalls, _AvoidCountLimit) == 0x0000E0, "Member 'UMaiBTTask_MoveToOnWalls::_AvoidCountLimit' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_MoveToOnWalls, _Following) == 0x0000E8, "Member 'UMaiBTTask_MoveToOnWalls::_Following' has a wrong offset!");

// Class Mai.MaiBTTask_PlayAnimMontage
// 0x00D0 (0x0178 - 0x00A8)
class UMaiBTTask_PlayAnimMontage final : public UBTTask_BlueprintBase
{
public:
	bool                                          _SelectAnimByTag;                                  // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      _AnimationToPlay;                                  // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  _AnimTags;                                         // 0x00B8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         _SelectAnimByAngle : 1;                            // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _SelectAnimOnNav : 1;                              // 0x00D8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _NonBlocking : 1;                                  // 0x00D8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _NonBlockingAbort : 1;                             // 0x00D8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _InfinitLoop : 1;                                  // 0x00D8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 _SelectAnimDir;                                    // 0x00E0(0x0028)(Edit, NativeAccessSpecifierPublic)
	class FName                                   _Slot;                                             // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _PlayRate;                                         // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _TimeToStartAt;                                    // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _AbortBlendOutTime;                                // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Duration;                                         // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _LoopCount;                                        // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _AbortAnimTags;                                    // 0x0128(0x0020)(Edit, NativeAccessSpecifierPublic)
	class FName                                   _AbortSection;                                     // 0x0148(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBehaviorTreeComponent*                 MyOwnerComp;                                       // 0x0150(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           _AbortMontage;                                     // 0x0158(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_160[0x18];                                     // 0x0160(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTTask_PlayAnimMontage">();
	}
	static class UMaiBTTask_PlayAnimMontage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTTask_PlayAnimMontage>();
	}
};
static_assert(alignof(UMaiBTTask_PlayAnimMontage) == 0x000008, "Wrong alignment on UMaiBTTask_PlayAnimMontage");
static_assert(sizeof(UMaiBTTask_PlayAnimMontage) == 0x000178, "Wrong size on UMaiBTTask_PlayAnimMontage");
static_assert(offsetof(UMaiBTTask_PlayAnimMontage, _SelectAnimByTag) == 0x0000A8, "Member 'UMaiBTTask_PlayAnimMontage::_SelectAnimByTag' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_PlayAnimMontage, _AnimationToPlay) == 0x0000B0, "Member 'UMaiBTTask_PlayAnimMontage::_AnimationToPlay' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_PlayAnimMontage, _AnimTags) == 0x0000B8, "Member 'UMaiBTTask_PlayAnimMontage::_AnimTags' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_PlayAnimMontage, _SelectAnimDir) == 0x0000E0, "Member 'UMaiBTTask_PlayAnimMontage::_SelectAnimDir' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_PlayAnimMontage, _Slot) == 0x000108, "Member 'UMaiBTTask_PlayAnimMontage::_Slot' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_PlayAnimMontage, _PlayRate) == 0x000110, "Member 'UMaiBTTask_PlayAnimMontage::_PlayRate' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_PlayAnimMontage, _TimeToStartAt) == 0x000114, "Member 'UMaiBTTask_PlayAnimMontage::_TimeToStartAt' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_PlayAnimMontage, _AbortBlendOutTime) == 0x000118, "Member 'UMaiBTTask_PlayAnimMontage::_AbortBlendOutTime' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_PlayAnimMontage, _Duration) == 0x00011C, "Member 'UMaiBTTask_PlayAnimMontage::_Duration' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_PlayAnimMontage, _LoopCount) == 0x000120, "Member 'UMaiBTTask_PlayAnimMontage::_LoopCount' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_PlayAnimMontage, _AbortAnimTags) == 0x000128, "Member 'UMaiBTTask_PlayAnimMontage::_AbortAnimTags' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_PlayAnimMontage, _AbortSection) == 0x000148, "Member 'UMaiBTTask_PlayAnimMontage::_AbortSection' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_PlayAnimMontage, MyOwnerComp) == 0x000150, "Member 'UMaiBTTask_PlayAnimMontage::MyOwnerComp' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_PlayAnimMontage, _AbortMontage) == 0x000158, "Member 'UMaiBTTask_PlayAnimMontage::_AbortMontage' has a wrong offset!");

// Class Mai.MaiBTTask_State
// 0x0010 (0x00B8 - 0x00A8)
class UMaiBTTask_State final : public UMaiBTTask_BlueprintBase
{
public:
	class UBeingState*                            _State;                                            // 0x00A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, AdvancedDisplay, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Decorated;                                        // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStateStatusChanged(EStateStatus Status);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBTTask_State">();
	}
	static class UMaiBTTask_State* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBTTask_State>();
	}
};
static_assert(alignof(UMaiBTTask_State) == 0x000008, "Wrong alignment on UMaiBTTask_State");
static_assert(sizeof(UMaiBTTask_State) == 0x0000B8, "Wrong size on UMaiBTTask_State");
static_assert(offsetof(UMaiBTTask_State, _State) == 0x0000A8, "Member 'UMaiBTTask_State::_State' has a wrong offset!");
static_assert(offsetof(UMaiBTTask_State, _Decorated) == 0x0000B0, "Member 'UMaiBTTask_State::_Decorated' has a wrong offset!");

// Class Mai.MaiCharacter
// 0x0240 (0x08F0 - 0x06B0)
class AMaiCharacter : public ANinjaCharacter
{
public:
	uint8                                         Pad_6B0[0x8];                                      // 0x06B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _MeshPivot;                                        // 0x06B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBeingStatesComponent*                  _MyStates;                                         // 0x06C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _EyesViewPoint;                                    // 0x06C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UShapeComponent*>                _AttackColliders;                                  // 0x06D0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TMap<class UShapeComponent*, struct FMaiLocations> _AttackCollidersDebug;                             // 0x06E0(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _TagContainer;                                     // 0x0730(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, SaveGame, Protected, NativeAccessSpecifierProtected)
	bool                                          _EyesInLookAt;                                     // 0x0750(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _DetectLongFall;                                   // 0x0751(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_752[0x2];                                      // 0x0752(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _DetectLongFallDuration;                           // 0x0754(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _DetectLongFallTimer;                              // 0x0758(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_75C[0x4];                                      // 0x075C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDaiBlockade                           _DeactivationReasons;                              // 0x0760(0x0018)(Edit, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FMaiLevelLocation>              _LevelPath;                                        // 0x0778(0x0010)(Edit, ZeroConstructor, EditConst, SaveGame, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_788[0x8];                                      // 0x0788(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             _SpawnTransform;                                   // 0x0790(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, SaveGame, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             _MoveBlockedBy;                                    // 0x07F0(0x00E8)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFullyDisabledValueChanged;                       // 0x08D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E8[0x8];                                      // 0x08E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FVector GetFixedCapsuleLocation(class APawn* Pawn, const struct FVector& Location);
	static struct FVector GetFixedGroundLocation(class APawn* Pawn, const struct FVector& Location);

	void AbortAttack(class FName AttackName);
	void Activate(class FName Reason);
	void AIDebuggerTick(class AMaiDebugger* Debugger, float DeltaSeconds);
	void AppendGameplayTags(const struct FGameplayTagContainer& GameplayTags);
	void ClearGameplayTags();
	void Deactivate(class FName Reason);
	void DisableActor();
	void DisableAttackColliders(const TArray<class FName>& CollidersTags);
	void EnableActor();
	void EnableAttackColliders(const TArray<class FName>& CollidersTags);
	void LongFallDetected();
	bool ReceiveShouldDespawn(EMaiDespawnReason Reason);
	void RemoveGameplayTags(const struct FGameplayTagContainer& GameplayTags);
	void SetGameplayTags(const struct FGameplayTagContainer& GameplayTags);
	float TakePointDamage(float Damage, TSubclassOf<class UDamageType> DamageClass, class AController* EventInstigator, class AActor* DamageCauser);
	void WantDespawn(bool Despawn);

	class UMaiCharacterMovementComponent* GetMaiCharacterMovement() const;
	class AMaiController* GetMaiController() const;
	class AMaiSpawner* GetMaiSpawner() const;
	struct FVector GetPrevLevelLocation(float MinDist) const;
	bool IsActive() const;
	bool IsDead() const;
	bool IsNotMoving() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiCharacter">();
	}
	static class AMaiCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiCharacter>();
	}
};
static_assert(alignof(AMaiCharacter) == 0x000010, "Wrong alignment on AMaiCharacter");
static_assert(sizeof(AMaiCharacter) == 0x0008F0, "Wrong size on AMaiCharacter");
static_assert(offsetof(AMaiCharacter, _MeshPivot) == 0x0006B8, "Member 'AMaiCharacter::_MeshPivot' has a wrong offset!");
static_assert(offsetof(AMaiCharacter, _MyStates) == 0x0006C0, "Member 'AMaiCharacter::_MyStates' has a wrong offset!");
static_assert(offsetof(AMaiCharacter, _EyesViewPoint) == 0x0006C8, "Member 'AMaiCharacter::_EyesViewPoint' has a wrong offset!");
static_assert(offsetof(AMaiCharacter, _AttackColliders) == 0x0006D0, "Member 'AMaiCharacter::_AttackColliders' has a wrong offset!");
static_assert(offsetof(AMaiCharacter, _AttackCollidersDebug) == 0x0006E0, "Member 'AMaiCharacter::_AttackCollidersDebug' has a wrong offset!");
static_assert(offsetof(AMaiCharacter, _TagContainer) == 0x000730, "Member 'AMaiCharacter::_TagContainer' has a wrong offset!");
static_assert(offsetof(AMaiCharacter, _EyesInLookAt) == 0x000750, "Member 'AMaiCharacter::_EyesInLookAt' has a wrong offset!");
static_assert(offsetof(AMaiCharacter, _DetectLongFall) == 0x000751, "Member 'AMaiCharacter::_DetectLongFall' has a wrong offset!");
static_assert(offsetof(AMaiCharacter, _DetectLongFallDuration) == 0x000754, "Member 'AMaiCharacter::_DetectLongFallDuration' has a wrong offset!");
static_assert(offsetof(AMaiCharacter, _DetectLongFallTimer) == 0x000758, "Member 'AMaiCharacter::_DetectLongFallTimer' has a wrong offset!");
static_assert(offsetof(AMaiCharacter, _DeactivationReasons) == 0x000760, "Member 'AMaiCharacter::_DeactivationReasons' has a wrong offset!");
static_assert(offsetof(AMaiCharacter, _LevelPath) == 0x000778, "Member 'AMaiCharacter::_LevelPath' has a wrong offset!");
static_assert(offsetof(AMaiCharacter, _SpawnTransform) == 0x000790, "Member 'AMaiCharacter::_SpawnTransform' has a wrong offset!");
static_assert(offsetof(AMaiCharacter, _MoveBlockedBy) == 0x0007F0, "Member 'AMaiCharacter::_MoveBlockedBy' has a wrong offset!");
static_assert(offsetof(AMaiCharacter, OnFullyDisabledValueChanged) == 0x0008D8, "Member 'AMaiCharacter::OnFullyDisabledValueChanged' has a wrong offset!");

// Class Mai.MaiCharacterMovementComponent
// 0x01E0 (0x11E0 - 0x1000)
class UMaiCharacterMovementComponent : public UNinjaCharacterMovementComponent
{
public:
	float                                         _CurrentWalkSpeed;                                 // 0x1000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1004[0x4];                                     // 0x1004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBeingMaxSpeedStat*                     _MaxSpeedStat;                                     // 0x1008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBeingSpeedModStat*                     _SpeedMod;                                         // 0x1010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBeingSteering*                         _Steering;                                         // 0x1018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EMaiTribool>                           _AllowPhysicsRotationDuringAnimRootMotion;         // 0x1020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         _Acceleration;                                     // 0x1030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _CustomWalkSpeed;                                  // 0x1034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _UseCustomWalkSpeed;                               // 0x1038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ResetPitchAndRoll;                                // 0x1039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _CanStrafe;                                        // 0x103A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _UseRMAvoidance;                                   // 0x103B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _HasRMLocomotion;                                  // 0x103C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_103D[0x3];                                     // 0x103D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             _MoveBlockedBy;                                    // 0x1040(0x00E8)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          _SideMovement;                                     // 0x1128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _AllowSideMovement;                                // 0x1129(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112A[0x2];                                     // 0x112A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _SideMin;                                          // 0x112C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SideMax;                                          // 0x1130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SideDuration;                                     // 0x1134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SideDurationMin;                                  // 0x1138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SideDurationMax;                                  // 0x113C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SideMinSpeed;                                     // 0x1140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardMovementLimit;                              // 0x1144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardsMovementLimit;                            // 0x1148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SidewaysMovementLimit;                             // 0x114C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1150[0x90];                                    // 0x1150(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MoveToward(const struct FVector& Move);
	void SetCustomWalkSpeed(float NewSpeed);
	void SetLimitedBackwardsMovement(float MaximumBackwardsMovement);
	void SetLimitedForwardMovement(float MaximumForwardMovement);
	void SetLimitedMovement(float MaximumForwardMovement, float MaximumBackwardMovement, float MaximumSidewaysMovement);
	void SetLimitedSidewaysMovement(float MaximumSidewaysMovement);
	void SetSideMovement(bool Side);

	float GetLimitedBackwardsMovement() const;
	float GetLimitedForwardMovement() const;
	float GetLimitedSidewaysMovement() const;
	float GetMaxWalkSpeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiCharacterMovementComponent">();
	}
	static class UMaiCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiCharacterMovementComponent>();
	}
};
static_assert(alignof(UMaiCharacterMovementComponent) == 0x000010, "Wrong alignment on UMaiCharacterMovementComponent");
static_assert(sizeof(UMaiCharacterMovementComponent) == 0x0011E0, "Wrong size on UMaiCharacterMovementComponent");
static_assert(offsetof(UMaiCharacterMovementComponent, _CurrentWalkSpeed) == 0x001000, "Member 'UMaiCharacterMovementComponent::_CurrentWalkSpeed' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _MaxSpeedStat) == 0x001008, "Member 'UMaiCharacterMovementComponent::_MaxSpeedStat' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _SpeedMod) == 0x001010, "Member 'UMaiCharacterMovementComponent::_SpeedMod' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _Steering) == 0x001018, "Member 'UMaiCharacterMovementComponent::_Steering' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _AllowPhysicsRotationDuringAnimRootMotion) == 0x001020, "Member 'UMaiCharacterMovementComponent::_AllowPhysicsRotationDuringAnimRootMotion' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _Acceleration) == 0x001030, "Member 'UMaiCharacterMovementComponent::_Acceleration' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _CustomWalkSpeed) == 0x001034, "Member 'UMaiCharacterMovementComponent::_CustomWalkSpeed' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _UseCustomWalkSpeed) == 0x001038, "Member 'UMaiCharacterMovementComponent::_UseCustomWalkSpeed' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _ResetPitchAndRoll) == 0x001039, "Member 'UMaiCharacterMovementComponent::_ResetPitchAndRoll' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _CanStrafe) == 0x00103A, "Member 'UMaiCharacterMovementComponent::_CanStrafe' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _UseRMAvoidance) == 0x00103B, "Member 'UMaiCharacterMovementComponent::_UseRMAvoidance' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _HasRMLocomotion) == 0x00103C, "Member 'UMaiCharacterMovementComponent::_HasRMLocomotion' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _MoveBlockedBy) == 0x001040, "Member 'UMaiCharacterMovementComponent::_MoveBlockedBy' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _SideMovement) == 0x001128, "Member 'UMaiCharacterMovementComponent::_SideMovement' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _AllowSideMovement) == 0x001129, "Member 'UMaiCharacterMovementComponent::_AllowSideMovement' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _SideMin) == 0x00112C, "Member 'UMaiCharacterMovementComponent::_SideMin' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _SideMax) == 0x001130, "Member 'UMaiCharacterMovementComponent::_SideMax' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _SideDuration) == 0x001134, "Member 'UMaiCharacterMovementComponent::_SideDuration' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _SideDurationMin) == 0x001138, "Member 'UMaiCharacterMovementComponent::_SideDurationMin' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _SideDurationMax) == 0x00113C, "Member 'UMaiCharacterMovementComponent::_SideDurationMax' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, _SideMinSpeed) == 0x001140, "Member 'UMaiCharacterMovementComponent::_SideMinSpeed' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, ForwardMovementLimit) == 0x001144, "Member 'UMaiCharacterMovementComponent::ForwardMovementLimit' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, BackwardsMovementLimit) == 0x001148, "Member 'UMaiCharacterMovementComponent::BackwardsMovementLimit' has a wrong offset!");
static_assert(offsetof(UMaiCharacterMovementComponent, SidewaysMovementLimit) == 0x00114C, "Member 'UMaiCharacterMovementComponent::SidewaysMovementLimit' has a wrong offset!");

// Class Mai.NeverUsedActionPoint
// 0x0000 (0x0088 - 0x0088)
class UNeverUsedActionPoint final : public UDaiCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeverUsedActionPoint">();
	}
	static class UNeverUsedActionPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNeverUsedActionPoint>();
	}
};
static_assert(alignof(UNeverUsedActionPoint) == 0x000008, "Wrong alignment on UNeverUsedActionPoint");
static_assert(sizeof(UNeverUsedActionPoint) == 0x000088, "Wrong size on UNeverUsedActionPoint");

// Class Mai.MaiController
// 0x04A8 (0x0880 - 0x03D8)
class AMaiController : public AAIController
{
public:
	class UMaiWallFollowing*                      _WallWalking;                                      // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBeingActionsComponent*                 _ActionsComponent;                                 // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class AMaiActionGraph>         _SoftActionGraph;                                  // 0x03E8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, SaveGame, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMaiActionGraph*                        _ActionGraph;                                      // 0x0418(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMaiActionPoint*                        _CurrentActionPoint;                               // 0x0420(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMaiActionPoint*                        _LastGraphPoint;                                   // 0x0428(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMaiActionPoint*                        _LastPathPoint;                                    // 0x0430(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMaiActionPoint*                        _NextActionPoint;                                  // 0x0438(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMaiActionPoint*                        _AbandonActionPoint;                               // 0x0440(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AMaiActionPoint*, float>           _PointCooldowns;                                   // 0x0448(0x0050)(Edit, EditConst, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	class UMaiActionSequenceComponent*            _ActionPointSequence;                              // 0x0498(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMaiActionPointState                          _CapState;                                         // 0x04A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A1[0x3];                                      // 0x04A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         _NotifyOnReselect : 1;                             // 0x04A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         _SetAcceptableRadiusFromAP : 1;                    // 0x04A4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4A5[0x3];                                      // 0x04A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         _HistorySize;                                      // 0x04A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A9[0x7];                                      // 0x04A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     _LocationFilterClass;                              // 0x04B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _WorkLocation;                                     // 0x04B8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _DisableControlRotation;                           // 0x04D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D1[0x7];                                      // 0x04D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBehaviorTree>           _SoftBehaviorTree;                                 // 0x04D8(0x0030)(Edit, SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlackboardData*                        _BlackboardAsset;                                  // 0x0508(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FMaiBlackboardValue>            _BlackboardConfig;                                 // 0x0510(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FDaiBlockade                           _BlockBT;                                          // 0x0520(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDaiBlockade                           _PauseBT;                                          // 0x0538(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           _BehaviorStack;                                    // 0x0550(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	struct FMaiBlackboardData                     _BlackboardData;                                   // 0x0560(0x0280)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, SaveGame, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	class FName                                   _BBBlocked;                                        // 0x07E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _BBCurrentActionPoint;                             // 0x07E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _BBDespawnLocation;                                // 0x07F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _BBHomeLocation;                                   // 0x07F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _BBPlayer;                                         // 0x0800(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENavMeshState                                 _WaitForNavMesh;                                   // 0x0808(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_809[0x7];                                      // 0x0809(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMoveBlocked;                                     // 0x0810(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_820[0x60];                                     // 0x0820(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AbortAction(class AAIController* AIController, TSubclassOf<class UBeingAction> ActionClass);
	static void AbortAllActions(class AAIController* AIController, class AActor* InstigatedBy);
	static void PushAction(class AAIController* AIController, class UBeingAction* Action, EAIRequestPriority Priority, class AActor* InstigatedBy);
	static void ReportTouchEvent(class AController* TouchReceiver, class AActor* Other, const struct FVector& Location);

	void AbandonActionPoint(class AMaiActionPoint* ActionPoint, bool Immediately);
	void AIDebuggerTick(class AMaiDebugger* Debugger, float DeltaSeconds);
	void ChangeWorkLocation();
	void DebugLog(const class FString& Log, const struct FLinearColor& Color);
	void DisableBehaviorTree(class FName Reason);
	void EnableBehaviorTree(class FName Reason);
	void FilterActionPointsByCooldown(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints);
	void FilterGraphPointsScript(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, class AActor* Origin);
	class AMaiActionGraph* GetActionGraph();
	class UAISenseConfig* GetSenseConfig(TSubclassOf<class UAISense> SenseClass);
	class UMaiWallFollowing* GetWallPathFollowing();
	void IgnorePoint(class AMaiActionPoint* Point, float Cooldown);
	bool IsCurrentlyPerceived(class AActor* Actor, bool OnlyHostile, struct FAIStimulus* Stimulus);
	bool IsLocationSafe(const struct FVector& Location);
	void LoadBlackboard();
	void LostAttackSlot();
	void LostToken();
	void OnActionGraphChanged(class AMaiActionGraph* ActionGraph);
	void OnActionPointAbandoned(class AMaiActionPoint* ActionPoint);
	void OnActionPointReached(class AMaiActionPoint* ActionPoint);
	void OnActionPointSelected(class AMaiActionPoint* ActionPoint);
	void OnInitBehaviors();
	void OnNavigationData();
	void OnPerceived(class AActor* Actor, const struct FAIStimulus& Stimulus);
	void OnPointerLoaded(class FName Key, class AActor* Actor);
	void PopBehaviorName(class FName behaviorName);
	void PushBehaviorName(class FName behaviorName);
	void ReachCurrentActionPoint(const struct FGameplayTag& InjectTag, bool RunActions);
	void ReceivedAttackSlot();
	uint8 ReceiveTokens(uint8 Pool);
	void RunActionPointActions(const struct FGameplayTag& InjectTag, class AMaiActionPoint* ActionPoint);
	void RunActionPointWaitWork(const struct FGameplayTag& InjectTag, class AMaiActionPoint* ActionPoint);
	void SaveActorPointer(class FName Key, class AActor* Actor);
	void SaveBlackboard();
	bool SelectActionPoint(const TMap<class AMaiActionPoint*, uint8>& ActionPoints, EPointSelection Method, class AActor* Origin);
	void SelectNearestActionGraph(class FName GraphTag);
	bool SelectNextActionPoint(EPointSelection Method, class AActor* Origin);
	void SetCurrentActionGraph(class AMaiActionGraph* PointGraph);
	bool SetCurrentActionPoint(class AMaiActionPoint* ActionPoint, bool Reset);
	void SetDespawnLocation(const struct FVector& Location);
	void SetGoalActionPoint(class AMaiActionPoint* GoalPoint, class AMaiActionPoint* SubgoalPoint, class FName SequenceTag);
	void SetPartyID(uint8 PartyID);
	bool TeleportFrom(const struct FVector& Location, float Distance, bool ForceDirect);
	bool TeleportInFrontOf(class AActor* Actor, float Distance);
	bool TeleportTowards(const struct FVector& Location, float Distance);
	void UsedCurrentActionPoint();

	class ANavigationData* GetNavData() const;
	uint8 GetPartyID() const;
	class AMaiActionPoint* GetPrevActionPoint() const;
	const struct FVector GetWorkLocation() const;
	float GetYoungestStimulusAge(const class AActor* Actor) const;
	bool HasAction(TSubclassOf<class UBeingAction> ActionClass) const;
	bool HasAnyAction() const;
	bool HasAnyBehaviorName(const TArray<class FName>& behaviorNames) const;
	bool HasBehaviorName(class FName behaviorName) const;
	bool HasValidNavData() const;
	bool HavePlaceToAvoid(class APawn* Other) const;
	bool IsBehaviorTreeRunning() const;
	bool IsCurrentActionPointReached() const;
	bool IsCurrentWayPointReached() const;
	bool IsIndoor() const;
	class FName TopBehaviorName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiController">();
	}
	static class AMaiController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiController>();
	}
};
static_assert(alignof(AMaiController) == 0x000008, "Wrong alignment on AMaiController");
static_assert(sizeof(AMaiController) == 0x000880, "Wrong size on AMaiController");
static_assert(offsetof(AMaiController, _WallWalking) == 0x0003D8, "Member 'AMaiController::_WallWalking' has a wrong offset!");
static_assert(offsetof(AMaiController, _ActionsComponent) == 0x0003E0, "Member 'AMaiController::_ActionsComponent' has a wrong offset!");
static_assert(offsetof(AMaiController, _SoftActionGraph) == 0x0003E8, "Member 'AMaiController::_SoftActionGraph' has a wrong offset!");
static_assert(offsetof(AMaiController, _ActionGraph) == 0x000418, "Member 'AMaiController::_ActionGraph' has a wrong offset!");
static_assert(offsetof(AMaiController, _CurrentActionPoint) == 0x000420, "Member 'AMaiController::_CurrentActionPoint' has a wrong offset!");
static_assert(offsetof(AMaiController, _LastGraphPoint) == 0x000428, "Member 'AMaiController::_LastGraphPoint' has a wrong offset!");
static_assert(offsetof(AMaiController, _LastPathPoint) == 0x000430, "Member 'AMaiController::_LastPathPoint' has a wrong offset!");
static_assert(offsetof(AMaiController, _NextActionPoint) == 0x000438, "Member 'AMaiController::_NextActionPoint' has a wrong offset!");
static_assert(offsetof(AMaiController, _AbandonActionPoint) == 0x000440, "Member 'AMaiController::_AbandonActionPoint' has a wrong offset!");
static_assert(offsetof(AMaiController, _PointCooldowns) == 0x000448, "Member 'AMaiController::_PointCooldowns' has a wrong offset!");
static_assert(offsetof(AMaiController, _ActionPointSequence) == 0x000498, "Member 'AMaiController::_ActionPointSequence' has a wrong offset!");
static_assert(offsetof(AMaiController, _CapState) == 0x0004A0, "Member 'AMaiController::_CapState' has a wrong offset!");
static_assert(offsetof(AMaiController, _HistorySize) == 0x0004A8, "Member 'AMaiController::_HistorySize' has a wrong offset!");
static_assert(offsetof(AMaiController, _LocationFilterClass) == 0x0004B0, "Member 'AMaiController::_LocationFilterClass' has a wrong offset!");
static_assert(offsetof(AMaiController, _WorkLocation) == 0x0004B8, "Member 'AMaiController::_WorkLocation' has a wrong offset!");
static_assert(offsetof(AMaiController, _DisableControlRotation) == 0x0004D0, "Member 'AMaiController::_DisableControlRotation' has a wrong offset!");
static_assert(offsetof(AMaiController, _SoftBehaviorTree) == 0x0004D8, "Member 'AMaiController::_SoftBehaviorTree' has a wrong offset!");
static_assert(offsetof(AMaiController, _BlackboardAsset) == 0x000508, "Member 'AMaiController::_BlackboardAsset' has a wrong offset!");
static_assert(offsetof(AMaiController, _BlackboardConfig) == 0x000510, "Member 'AMaiController::_BlackboardConfig' has a wrong offset!");
static_assert(offsetof(AMaiController, _BlockBT) == 0x000520, "Member 'AMaiController::_BlockBT' has a wrong offset!");
static_assert(offsetof(AMaiController, _PauseBT) == 0x000538, "Member 'AMaiController::_PauseBT' has a wrong offset!");
static_assert(offsetof(AMaiController, _BehaviorStack) == 0x000550, "Member 'AMaiController::_BehaviorStack' has a wrong offset!");
static_assert(offsetof(AMaiController, _BlackboardData) == 0x000560, "Member 'AMaiController::_BlackboardData' has a wrong offset!");
static_assert(offsetof(AMaiController, _BBBlocked) == 0x0007E0, "Member 'AMaiController::_BBBlocked' has a wrong offset!");
static_assert(offsetof(AMaiController, _BBCurrentActionPoint) == 0x0007E8, "Member 'AMaiController::_BBCurrentActionPoint' has a wrong offset!");
static_assert(offsetof(AMaiController, _BBDespawnLocation) == 0x0007F0, "Member 'AMaiController::_BBDespawnLocation' has a wrong offset!");
static_assert(offsetof(AMaiController, _BBHomeLocation) == 0x0007F8, "Member 'AMaiController::_BBHomeLocation' has a wrong offset!");
static_assert(offsetof(AMaiController, _BBPlayer) == 0x000800, "Member 'AMaiController::_BBPlayer' has a wrong offset!");
static_assert(offsetof(AMaiController, _WaitForNavMesh) == 0x000808, "Member 'AMaiController::_WaitForNavMesh' has a wrong offset!");
static_assert(offsetof(AMaiController, OnMoveBlocked) == 0x000810, "Member 'AMaiController::OnMoveBlocked' has a wrong offset!");

// Class Mai.MaiControllerExt
// 0x0058 (0x08D8 - 0x0880)
class AMaiControllerExt : public AMaiController
{
public:
	EMaiParty                                     _Party;                                            // 0x0880(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_881[0x7];                                      // 0x0881(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _ArchEnemy;                                        // 0x0888(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _ForcedEnemy;                                      // 0x0890(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _FightingEnemy;                                    // 0x0898(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ClearChaseWhenPerceived;                          // 0x08A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, SaveGame, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IgnoreAll;                                        // 0x08A1(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8A2[0x2];                                      // 0x08A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _BBArchEnemy;                                      // 0x08A4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _BBInstigator;                                     // 0x08AC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _BBAlertLocation;                                  // 0x08B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _BBChaseLocation;                                  // 0x08BC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C4[0x4];                                      // 0x08C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnArchEnemyChange;                                 // 0x08C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ClearForceChase();
	void ClearIgnoreAll();
	class AActor* FindEnemyToFight();
	void ForceChase(class AActor* Enemy, bool ClearWhenPerceived);
	void SetAlertInstigator(class AActor* Actor);
	void SetAlertLocation(const struct FVector& Location);
	void SetArchEnemy(class AActor* Enemy);
	void SetChaseLocation(const struct FVector& Location);
	void SetFightingEnemy(class AActor* Enemy);
	void SetForcedEnemy(class AActor* Enemy);
	void SetIgnoreAll();
	void SetParty(EMaiParty Party);
	void UpdateEnemyData();

	class AActor* GetAlertInstigator() const;
	struct FVector GetAlertLocation() const;
	class AActor* GetArchEnemy() const;
	struct FVector GetChaseLocation() const;
	class AActor* GetFightingEnemy() const;
	class AActor* GetForcedEnemy() const;
	EMaiParty GetParty() const;
	bool IsFightingWith(class AActor* Enemy) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiControllerExt">();
	}
	static class AMaiControllerExt* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiControllerExt>();
	}
};
static_assert(alignof(AMaiControllerExt) == 0x000008, "Wrong alignment on AMaiControllerExt");
static_assert(sizeof(AMaiControllerExt) == 0x0008D8, "Wrong size on AMaiControllerExt");
static_assert(offsetof(AMaiControllerExt, _Party) == 0x000880, "Member 'AMaiControllerExt::_Party' has a wrong offset!");
static_assert(offsetof(AMaiControllerExt, _ArchEnemy) == 0x000888, "Member 'AMaiControllerExt::_ArchEnemy' has a wrong offset!");
static_assert(offsetof(AMaiControllerExt, _ForcedEnemy) == 0x000890, "Member 'AMaiControllerExt::_ForcedEnemy' has a wrong offset!");
static_assert(offsetof(AMaiControllerExt, _FightingEnemy) == 0x000898, "Member 'AMaiControllerExt::_FightingEnemy' has a wrong offset!");
static_assert(offsetof(AMaiControllerExt, _ClearChaseWhenPerceived) == 0x0008A0, "Member 'AMaiControllerExt::_ClearChaseWhenPerceived' has a wrong offset!");
static_assert(offsetof(AMaiControllerExt, _IgnoreAll) == 0x0008A1, "Member 'AMaiControllerExt::_IgnoreAll' has a wrong offset!");
static_assert(offsetof(AMaiControllerExt, _BBArchEnemy) == 0x0008A4, "Member 'AMaiControllerExt::_BBArchEnemy' has a wrong offset!");
static_assert(offsetof(AMaiControllerExt, _BBInstigator) == 0x0008AC, "Member 'AMaiControllerExt::_BBInstigator' has a wrong offset!");
static_assert(offsetof(AMaiControllerExt, _BBAlertLocation) == 0x0008B4, "Member 'AMaiControllerExt::_BBAlertLocation' has a wrong offset!");
static_assert(offsetof(AMaiControllerExt, _BBChaseLocation) == 0x0008BC, "Member 'AMaiControllerExt::_BBChaseLocation' has a wrong offset!");
static_assert(offsetof(AMaiControllerExt, OnArchEnemyChange) == 0x0008C8, "Member 'AMaiControllerExt::OnArchEnemyChange' has a wrong offset!");

// Class Mai.MaiCoverComponent
// 0x0018 (0x00E0 - 0x00C8)
class UMaiCoverComponent final : public UDaiTagsComponent
{
public:
	bool                                          _FullCover;                                        // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaiCoverUser*>                  _Users;                                            // 0x00D0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)

public:
	bool IsActorInCover(class AActor* Actor);
	bool IsUserInCover(class UMaiCoverUser* User);
	void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiCoverComponent">();
	}
	static class UMaiCoverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiCoverComponent>();
	}
};
static_assert(alignof(UMaiCoverComponent) == 0x000008, "Wrong alignment on UMaiCoverComponent");
static_assert(sizeof(UMaiCoverComponent) == 0x0000E0, "Wrong size on UMaiCoverComponent");
static_assert(offsetof(UMaiCoverComponent, _FullCover) == 0x0000C8, "Member 'UMaiCoverComponent::_FullCover' has a wrong offset!");
static_assert(offsetof(UMaiCoverComponent, _Users) == 0x0000D0, "Member 'UMaiCoverComponent::_Users' has a wrong offset!");

// Class Mai.MaiCoverTrigger
// 0x0010 (0x02C8 - 0x02B8)
class AMaiCoverTrigger final : public ATriggerBox
{
public:
	class UMaiCoverComponent*                     _Cover;                                            // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _FullCover;                                        // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiCoverTrigger">();
	}
	static class AMaiCoverTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiCoverTrigger>();
	}
};
static_assert(alignof(AMaiCoverTrigger) == 0x000008, "Wrong alignment on AMaiCoverTrigger");
static_assert(sizeof(AMaiCoverTrigger) == 0x0002C8, "Wrong size on AMaiCoverTrigger");
static_assert(offsetof(AMaiCoverTrigger, _Cover) == 0x0002B8, "Member 'AMaiCoverTrigger::_Cover' has a wrong offset!");
static_assert(offsetof(AMaiCoverTrigger, _FullCover) == 0x0002C0, "Member 'AMaiCoverTrigger::_FullCover' has a wrong offset!");

// Class Mai.MaiCoverUser
// 0x0038 (0x00D8 - 0x00A0)
class UMaiCoverUser final : public UActorComponent
{
public:
	TArray<class UMaiCoverComponent*>             _MyCovers;                                         // 0x00A0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          _Enabled;                                          // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             _OnEnterCover;                                     // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _OnLeaveCover;                                     // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool IsInCover(const struct FGameplayTag& Filter) const;
	bool IsInFullCover(const struct FGameplayTag& Filter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiCoverUser">();
	}
	static class UMaiCoverUser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiCoverUser>();
	}
};
static_assert(alignof(UMaiCoverUser) == 0x000008, "Wrong alignment on UMaiCoverUser");
static_assert(sizeof(UMaiCoverUser) == 0x0000D8, "Wrong size on UMaiCoverUser");
static_assert(offsetof(UMaiCoverUser, _MyCovers) == 0x0000A0, "Member 'UMaiCoverUser::_MyCovers' has a wrong offset!");
static_assert(offsetof(UMaiCoverUser, _Enabled) == 0x0000B0, "Member 'UMaiCoverUser::_Enabled' has a wrong offset!");
static_assert(offsetof(UMaiCoverUser, _OnEnterCover) == 0x0000B8, "Member 'UMaiCoverUser::_OnEnterCover' has a wrong offset!");
static_assert(offsetof(UMaiCoverUser, _OnLeaveCover) == 0x0000C8, "Member 'UMaiCoverUser::_OnLeaveCover' has a wrong offset!");

// Class Mai.MaiPointOfInterest
// 0x0018 (0x0468 - 0x0450)
class AMaiPointOfInterest : public AMaiActionPoint
{
public:
	class UMaiDetectionAreaComponent*             _DetectionArea;                                    // 0x0450(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Cooldown;                                         // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45C[0xC];                                      // 0x045C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDisable();
	void OnEnable();
	void SwitchOff();
	void SwitchOn();
	void SwitchOnFor(float Duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiPointOfInterest">();
	}
	static class AMaiPointOfInterest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiPointOfInterest>();
	}
};
static_assert(alignof(AMaiPointOfInterest) == 0x000008, "Wrong alignment on AMaiPointOfInterest");
static_assert(sizeof(AMaiPointOfInterest) == 0x000468, "Wrong size on AMaiPointOfInterest");
static_assert(offsetof(AMaiPointOfInterest, _DetectionArea) == 0x000450, "Member 'AMaiPointOfInterest::_DetectionArea' has a wrong offset!");
static_assert(offsetof(AMaiPointOfInterest, _Cooldown) == 0x000458, "Member 'AMaiPointOfInterest::_Cooldown' has a wrong offset!");

// Class Mai.MaiDecoy
// 0x0020 (0x0488 - 0x0468)
class AMaiDecoy final : public AMaiPointOfInterest
{
public:
	class UMaiLightEmitter*                       _LightEmitter;                                     // 0x0468(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaiNoiseEmitter*                       _NoiseEmitter;                                     // 0x0470(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBeingVisibilityLevelStat*              _VisibilityLevel;                                  // 0x0478(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Hearable;                                         // 0x0480(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Visible;                                          // 0x0481(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Smelly;                                           // 0x0482(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _NoiseEnabled;                                     // 0x0483(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _VisibilityEnabled;                                // 0x0484(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _OdorEnabled;                                      // 0x0485(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_486[0x2];                                      // 0x0486(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiDecoy">();
	}
	static class AMaiDecoy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiDecoy>();
	}
};
static_assert(alignof(AMaiDecoy) == 0x000008, "Wrong alignment on AMaiDecoy");
static_assert(sizeof(AMaiDecoy) == 0x000488, "Wrong size on AMaiDecoy");
static_assert(offsetof(AMaiDecoy, _LightEmitter) == 0x000468, "Member 'AMaiDecoy::_LightEmitter' has a wrong offset!");
static_assert(offsetof(AMaiDecoy, _NoiseEmitter) == 0x000470, "Member 'AMaiDecoy::_NoiseEmitter' has a wrong offset!");
static_assert(offsetof(AMaiDecoy, _VisibilityLevel) == 0x000478, "Member 'AMaiDecoy::_VisibilityLevel' has a wrong offset!");
static_assert(offsetof(AMaiDecoy, _Hearable) == 0x000480, "Member 'AMaiDecoy::_Hearable' has a wrong offset!");
static_assert(offsetof(AMaiDecoy, _Visible) == 0x000481, "Member 'AMaiDecoy::_Visible' has a wrong offset!");
static_assert(offsetof(AMaiDecoy, _Smelly) == 0x000482, "Member 'AMaiDecoy::_Smelly' has a wrong offset!");
static_assert(offsetof(AMaiDecoy, _NoiseEnabled) == 0x000483, "Member 'AMaiDecoy::_NoiseEnabled' has a wrong offset!");
static_assert(offsetof(AMaiDecoy, _VisibilityEnabled) == 0x000484, "Member 'AMaiDecoy::_VisibilityEnabled' has a wrong offset!");
static_assert(offsetof(AMaiDecoy, _OdorEnabled) == 0x000485, "Member 'AMaiDecoy::_OdorEnabled' has a wrong offset!");

// Class Mai.MaiCuriosityComponent
// 0x0158 (0x01F8 - 0x00A0)
class UMaiCuriosityComponent : public UActorComponent
{
public:
	TArray<class AMaiActionPoint*>                _DetectedPoints;                                   // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<class AMaiActionPoint*>                _PointsInPerception;                               // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	class AMaiPointOfInterest*                    _PointOfInterest;                                  // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGuid, float>                     _PointCooldowns;                                   // 0x00C8(0x0050)(Edit, EditConst, SaveGame, AdvancedDisplay, NativeAccessSpecifierPublic)
	TSet<struct FGuid>                            _PointsToIgnore;                                   // 0x0118(0x0050)(Edit, EditConst, SaveGame, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          _UseDetection;                                     // 0x0168(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _UseSenses;                                        // 0x0169(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _AutoSelect;                                       // 0x016A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaiSelectionMethod                           _SelectionMethod;                                  // 0x016B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SearchCooldown;                                   // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _LastChance;                                       // 0x0170(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _InvalidColor;                                     // 0x0174(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _ValidColor;                                       // 0x0184(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _SelectedColor;                                    // 0x0194(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             PerceivePoint;                                     // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SelectPoint;                                       // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8[0x30];                                     // 0x01C8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugCuriosity();
	void IgnorePoint(class AMaiPointOfInterest* Point);
	void OnTargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus);
	class AMaiPointOfInterest* SelectPointOfInterest(EMaiSelectionMethod Selection, TSubclassOf<class AMaiPointOfInterest> PointClass);
	void UpdateDetectedPoints(float AreaExtent);
	void UpdatePointsInPerception(TSubclassOf<class AMaiPointOfInterest> PointClass, float AreaExtent);

	bool ShouldIgnorePoint(class AMaiPointOfInterest* Point) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiCuriosityComponent">();
	}
	static class UMaiCuriosityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiCuriosityComponent>();
	}
};
static_assert(alignof(UMaiCuriosityComponent) == 0x000008, "Wrong alignment on UMaiCuriosityComponent");
static_assert(sizeof(UMaiCuriosityComponent) == 0x0001F8, "Wrong size on UMaiCuriosityComponent");
static_assert(offsetof(UMaiCuriosityComponent, _DetectedPoints) == 0x0000A0, "Member 'UMaiCuriosityComponent::_DetectedPoints' has a wrong offset!");
static_assert(offsetof(UMaiCuriosityComponent, _PointsInPerception) == 0x0000B0, "Member 'UMaiCuriosityComponent::_PointsInPerception' has a wrong offset!");
static_assert(offsetof(UMaiCuriosityComponent, _PointOfInterest) == 0x0000C0, "Member 'UMaiCuriosityComponent::_PointOfInterest' has a wrong offset!");
static_assert(offsetof(UMaiCuriosityComponent, _PointCooldowns) == 0x0000C8, "Member 'UMaiCuriosityComponent::_PointCooldowns' has a wrong offset!");
static_assert(offsetof(UMaiCuriosityComponent, _PointsToIgnore) == 0x000118, "Member 'UMaiCuriosityComponent::_PointsToIgnore' has a wrong offset!");
static_assert(offsetof(UMaiCuriosityComponent, _UseDetection) == 0x000168, "Member 'UMaiCuriosityComponent::_UseDetection' has a wrong offset!");
static_assert(offsetof(UMaiCuriosityComponent, _UseSenses) == 0x000169, "Member 'UMaiCuriosityComponent::_UseSenses' has a wrong offset!");
static_assert(offsetof(UMaiCuriosityComponent, _AutoSelect) == 0x00016A, "Member 'UMaiCuriosityComponent::_AutoSelect' has a wrong offset!");
static_assert(offsetof(UMaiCuriosityComponent, _SelectionMethod) == 0x00016B, "Member 'UMaiCuriosityComponent::_SelectionMethod' has a wrong offset!");
static_assert(offsetof(UMaiCuriosityComponent, _SearchCooldown) == 0x00016C, "Member 'UMaiCuriosityComponent::_SearchCooldown' has a wrong offset!");
static_assert(offsetof(UMaiCuriosityComponent, _LastChance) == 0x000170, "Member 'UMaiCuriosityComponent::_LastChance' has a wrong offset!");
static_assert(offsetof(UMaiCuriosityComponent, _InvalidColor) == 0x000174, "Member 'UMaiCuriosityComponent::_InvalidColor' has a wrong offset!");
static_assert(offsetof(UMaiCuriosityComponent, _ValidColor) == 0x000184, "Member 'UMaiCuriosityComponent::_ValidColor' has a wrong offset!");
static_assert(offsetof(UMaiCuriosityComponent, _SelectedColor) == 0x000194, "Member 'UMaiCuriosityComponent::_SelectedColor' has a wrong offset!");
static_assert(offsetof(UMaiCuriosityComponent, PerceivePoint) == 0x0001A8, "Member 'UMaiCuriosityComponent::PerceivePoint' has a wrong offset!");
static_assert(offsetof(UMaiCuriosityComponent, SelectPoint) == 0x0001B8, "Member 'UMaiCuriosityComponent::SelectPoint' has a wrong offset!");

// Class Mai.MaiInterestedComponent
// 0x0000 (0x01F8 - 0x01F8)
class UMaiInterestedComponent final : public UMaiCuriosityComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiInterestedComponent">();
	}
	static class UMaiInterestedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiInterestedComponent>();
	}
};
static_assert(alignof(UMaiInterestedComponent) == 0x000008, "Wrong alignment on UMaiInterestedComponent");
static_assert(sizeof(UMaiInterestedComponent) == 0x0001F8, "Wrong size on UMaiInterestedComponent");

// Class Mai.AIDataProvider_FromScript
// 0x0010 (0x0038 - 0x0028)
class UAIDataProvider_FromScript final : public UAIDataProvider
{
public:
	float                                         FloatValue;                                        // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntValue;                                          // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoolValue;                                         // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ScriptBindData(const class APawn* Pawn);
	void SetBoolValue(bool Value);
	void SetFloatValue(float Value);
	void SetIntValue(int32 Value);

	class FString ScriptToString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDataProvider_FromScript">();
	}
	static class UAIDataProvider_FromScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDataProvider_FromScript>();
	}
};
static_assert(alignof(UAIDataProvider_FromScript) == 0x000008, "Wrong alignment on UAIDataProvider_FromScript");
static_assert(sizeof(UAIDataProvider_FromScript) == 0x000038, "Wrong size on UAIDataProvider_FromScript");
static_assert(offsetof(UAIDataProvider_FromScript, FloatValue) == 0x000028, "Member 'UAIDataProvider_FromScript::FloatValue' has a wrong offset!");
static_assert(offsetof(UAIDataProvider_FromScript, IntValue) == 0x00002C, "Member 'UAIDataProvider_FromScript::IntValue' has a wrong offset!");
static_assert(offsetof(UAIDataProvider_FromScript, BoolValue) == 0x000030, "Member 'UAIDataProvider_FromScript::BoolValue' has a wrong offset!");

// Class Mai.AIDataProvider_MulParams
// 0x0008 (0x0048 - 0x0040)
class UAIDataProvider_MulParams final : public UAIDataProvider_QueryParams
{
public:
	float                                         Mod;                                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDataProvider_MulParams">();
	}
	static class UAIDataProvider_MulParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDataProvider_MulParams>();
	}
};
static_assert(alignof(UAIDataProvider_MulParams) == 0x000008, "Wrong alignment on UAIDataProvider_MulParams");
static_assert(sizeof(UAIDataProvider_MulParams) == 0x000048, "Wrong size on UAIDataProvider_MulParams");
static_assert(offsetof(UAIDataProvider_MulParams, Mod) == 0x000040, "Member 'UAIDataProvider_MulParams::Mod' has a wrong offset!");

// Class Mai.MaiDebugger
// 0x00E0 (0x0390 - 0x02B0)
class AMaiDebugger final : public AActor
{
public:
	class UMaiSenseDebugger*                      AllSenses;                                         // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaiSenseDebugger*                      HearingSense;                                      // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaiSenseDebugger*                      SightSense;                                        // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaiSenseDebugger*                      SmellSense;                                        // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TLazyObjectPtr<class AActor>                  _DebuggedActor;                                    // 0x02D0(0x001C)(Edit, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _DebugAutoActive : 1;                              // 0x02EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DebugActive : 1;                                  // 0x02EC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DebugHearing : 1;                                 // 0x02EC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DebugSight : 1;                                   // 0x02EC(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DebugSmell : 1;                                   // 0x02EC(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DebugNoises : 1;                                  // 0x02EC(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DebugVisibility : 1;                              // 0x02EC(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DebugOdor : 1;                                    // 0x02EC(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DebugAggro : 1;                                   // 0x02ED(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DebugAttack : 1;                                  // 0x02ED(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DebugCuriosity : 1;                               // 0x02ED(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DebugActionPath : 1;                              // 0x02ED(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DebugNavPath : 1;                                 // 0x02ED(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DebugMovement : 1;                                // 0x02ED(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2EE[0x2];                                      // 0x02EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, bool>                       _DebugState;                                       // 0x02F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         _DebugUnreal : 1;                                  // 0x0340(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DebugNavMesh : 1;                                 // 0x0340(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DebugAInfo : 1;                                   // 0x0340(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DebugBehaviorTree : 1;                            // 0x0340(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DebugEQS : 1;                                     // 0x0340(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DebugPerception : 1;                              // 0x0340(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _DisableExtensions : 1;                            // 0x0340(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APawn*>                          _AllAIBeings;                                      // 0x0348(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AIDebugActorChanged;                               // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AIDebuggerTick;                                    // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_378[0x18];                                     // 0x0378(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AiDebugPrint(class AActor* Actor, const class FString& InString, bool ToScreen, bool ToLog, const struct FLinearColor& Color, float Duration, bool IgnoreActor, const class FString& Category);
	static void AiDebugPrint2(class AActor* Actor, const class FString& InString, const struct FMaiDebugPrintParams& Params_0);
	static bool GetAIDebugActionPath(class APawn* Being);
	static class AActor* GetAIDebugActor(class UObject* WorldContext);
	static bool GetAIDebugAggro(class APawn* Being);
	static bool GetAIDebugAttack(class APawn* Being);
	static bool GetAIDebugCuriosity(class APawn* Being);
	static class AMaiDebugger* GetAIDebugger(class UObject* WorldContext, bool OnlyIfActive);
	static bool GetAIDebugGState(class UObject* WorldContext, class FName Name_0);
	static bool GetAIDebugHearing(class UObject* WorldContext);
	static bool GetAIDebugMovement(class APawn* Being);
	static bool GetAIDebugNavPath(class APawn* Being);
	static bool GetAIDebugNoises(class APawn* Being);
	static bool GetAIDebugOdor(class APawn* Being);
	static bool GetAIDebugSight(class UObject* WorldContext);
	static bool GetAIDebugSmell(class UObject* WorldContext);
	static bool GetAIDebugState(class APawn* Being, class FName Name_0);
	static bool GetAIDebugVisibility(class APawn* Being);

	void AIDebugActionPath(bool Debug);
	void AIDebugActor(class FName Name_0);
	void AIDebugAddState(class FName Name_0, bool Debug);
	void AIDebugAggro(bool Debug);
	void AIDebugAInfo(bool Debug);
	void AIDebugAttack(bool Debug);
	void AIDebugBehaviorTree(bool Debug);
	void AIDebugCuriosity(bool Debug);
	void AIDebugEQS(bool Debug);
	void AIDebugEQSDetails();
	void AIDebugEQSSwitch();
	void AIDebugger(bool Activate);
	void AIDebugHearing(bool Debug);
	void AIDebugHUD();
	void AIDebugMovement(bool Debug);
	void AIDebugNavMesh(bool Debug);
	void AIDebugNavPath(bool Debug);
	void AIDebugNextActor();
	void AIDebugNoises(bool Debug);
	void AIDebugOdor(bool Debug);
	void AIDebugPerception(bool Debug);
	void AIDebugPrevActor();
	void AIDebugSight(bool Debug);
	void AIDebugSmell(bool Debug);
	void AIDebugSpectator();
	void AIDebugState(class FName Name_0, bool Debug);
	void AIDebugUnreal(bool Debug);
	void AIDebugVisibility(bool Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiDebugger">();
	}
	static class AMaiDebugger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiDebugger>();
	}
};
static_assert(alignof(AMaiDebugger) == 0x000008, "Wrong alignment on AMaiDebugger");
static_assert(sizeof(AMaiDebugger) == 0x000390, "Wrong size on AMaiDebugger");
static_assert(offsetof(AMaiDebugger, AllSenses) == 0x0002B0, "Member 'AMaiDebugger::AllSenses' has a wrong offset!");
static_assert(offsetof(AMaiDebugger, HearingSense) == 0x0002B8, "Member 'AMaiDebugger::HearingSense' has a wrong offset!");
static_assert(offsetof(AMaiDebugger, SightSense) == 0x0002C0, "Member 'AMaiDebugger::SightSense' has a wrong offset!");
static_assert(offsetof(AMaiDebugger, SmellSense) == 0x0002C8, "Member 'AMaiDebugger::SmellSense' has a wrong offset!");
static_assert(offsetof(AMaiDebugger, _DebuggedActor) == 0x0002D0, "Member 'AMaiDebugger::_DebuggedActor' has a wrong offset!");
static_assert(offsetof(AMaiDebugger, _DebugState) == 0x0002F0, "Member 'AMaiDebugger::_DebugState' has a wrong offset!");
static_assert(offsetof(AMaiDebugger, _AllAIBeings) == 0x000348, "Member 'AMaiDebugger::_AllAIBeings' has a wrong offset!");
static_assert(offsetof(AMaiDebugger, AIDebugActorChanged) == 0x000358, "Member 'AMaiDebugger::AIDebugActorChanged' has a wrong offset!");
static_assert(offsetof(AMaiDebugger, AIDebuggerTick) == 0x000368, "Member 'AMaiDebugger::AIDebuggerTick' has a wrong offset!");

// Class Mai.MaiEqsContext_BlackboardKey
// 0x0000 (0x0028 - 0x0028)
class UMaiEqsContext_BlackboardKey final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiEqsContext_BlackboardKey">();
	}
	static class UMaiEqsContext_BlackboardKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiEqsContext_BlackboardKey>();
	}
};
static_assert(alignof(UMaiEqsContext_BlackboardKey) == 0x000008, "Wrong alignment on UMaiEqsContext_BlackboardKey");
static_assert(sizeof(UMaiEqsContext_BlackboardKey) == 0x000028, "Wrong size on UMaiEqsContext_BlackboardKey");

// Class Mai.MaiEqsContext_BlackboardLocation
// 0x0000 (0x0028 - 0x0028)
class UMaiEqsContext_BlackboardLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiEqsContext_BlackboardLocation">();
	}
	static class UMaiEqsContext_BlackboardLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiEqsContext_BlackboardLocation>();
	}
};
static_assert(alignof(UMaiEqsContext_BlackboardLocation) == 0x000008, "Wrong alignment on UMaiEqsContext_BlackboardLocation");
static_assert(sizeof(UMaiEqsContext_BlackboardLocation) == 0x000028, "Wrong size on UMaiEqsContext_BlackboardLocation");

// Class Mai.MaiEqsGenerator_CloseTo
// 0x0068 (0x00B8 - 0x0050)
class UMaiEqsGenerator_CloseTo final : public UEnvQueryGenerator
{
public:
	struct FVector                                _Direction;                                        // 0x0050(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              _SearchRadius;                                     // 0x0068(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        _Offsets;                                          // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           _SearchCenter;                                     // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiEqsGenerator_CloseTo">();
	}
	static class UMaiEqsGenerator_CloseTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiEqsGenerator_CloseTo>();
	}
};
static_assert(alignof(UMaiEqsGenerator_CloseTo) == 0x000008, "Wrong alignment on UMaiEqsGenerator_CloseTo");
static_assert(sizeof(UMaiEqsGenerator_CloseTo) == 0x0000B8, "Wrong size on UMaiEqsGenerator_CloseTo");
static_assert(offsetof(UMaiEqsGenerator_CloseTo, _Direction) == 0x000050, "Member 'UMaiEqsGenerator_CloseTo::_Direction' has a wrong offset!");
static_assert(offsetof(UMaiEqsGenerator_CloseTo, _SearchRadius) == 0x000068, "Member 'UMaiEqsGenerator_CloseTo::_SearchRadius' has a wrong offset!");
static_assert(offsetof(UMaiEqsGenerator_CloseTo, _Offsets) == 0x0000A0, "Member 'UMaiEqsGenerator_CloseTo::_Offsets' has a wrong offset!");
static_assert(offsetof(UMaiEqsGenerator_CloseTo, _SearchCenter) == 0x0000B0, "Member 'UMaiEqsGenerator_CloseTo::_SearchCenter' has a wrong offset!");

// Class Mai.MaiEqsGenerator_WallMeshGrid
// 0x0158 (0x01A8 - 0x0050)
class UMaiEqsGenerator_WallMeshGrid final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderFloatValue              _GridHalfSize;                                     // 0x0050(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              _SpaceBetween;                                     // 0x0088(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           _GenerateAround;                                   // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               _OnFloor;                                          // 0x00C8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               _OnWall;                                           // 0x0100(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               _OnCeil;                                           // 0x0138(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              _UpOffset;                                         // 0x0170(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiEqsGenerator_WallMeshGrid">();
	}
	static class UMaiEqsGenerator_WallMeshGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiEqsGenerator_WallMeshGrid>();
	}
};
static_assert(alignof(UMaiEqsGenerator_WallMeshGrid) == 0x000008, "Wrong alignment on UMaiEqsGenerator_WallMeshGrid");
static_assert(sizeof(UMaiEqsGenerator_WallMeshGrid) == 0x0001A8, "Wrong size on UMaiEqsGenerator_WallMeshGrid");
static_assert(offsetof(UMaiEqsGenerator_WallMeshGrid, _GridHalfSize) == 0x000050, "Member 'UMaiEqsGenerator_WallMeshGrid::_GridHalfSize' has a wrong offset!");
static_assert(offsetof(UMaiEqsGenerator_WallMeshGrid, _SpaceBetween) == 0x000088, "Member 'UMaiEqsGenerator_WallMeshGrid::_SpaceBetween' has a wrong offset!");
static_assert(offsetof(UMaiEqsGenerator_WallMeshGrid, _GenerateAround) == 0x0000C0, "Member 'UMaiEqsGenerator_WallMeshGrid::_GenerateAround' has a wrong offset!");
static_assert(offsetof(UMaiEqsGenerator_WallMeshGrid, _OnFloor) == 0x0000C8, "Member 'UMaiEqsGenerator_WallMeshGrid::_OnFloor' has a wrong offset!");
static_assert(offsetof(UMaiEqsGenerator_WallMeshGrid, _OnWall) == 0x000100, "Member 'UMaiEqsGenerator_WallMeshGrid::_OnWall' has a wrong offset!");
static_assert(offsetof(UMaiEqsGenerator_WallMeshGrid, _OnCeil) == 0x000138, "Member 'UMaiEqsGenerator_WallMeshGrid::_OnCeil' has a wrong offset!");
static_assert(offsetof(UMaiEqsGenerator_WallMeshGrid, _UpOffset) == 0x000170, "Member 'UMaiEqsGenerator_WallMeshGrid::_UpOffset' has a wrong offset!");

// Class Mai.MaiEqsTest_AttackLocations
// 0x0008 (0x0200 - 0x01F8)
class UMaiEqsTest_AttackLocations final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           _Enemy;                                            // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiEqsTest_AttackLocations">();
	}
	static class UMaiEqsTest_AttackLocations* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiEqsTest_AttackLocations>();
	}
};
static_assert(alignof(UMaiEqsTest_AttackLocations) == 0x000008, "Wrong alignment on UMaiEqsTest_AttackLocations");
static_assert(sizeof(UMaiEqsTest_AttackLocations) == 0x000200, "Wrong size on UMaiEqsTest_AttackLocations");
static_assert(offsetof(UMaiEqsTest_AttackLocations, _Enemy) == 0x0001F8, "Member 'UMaiEqsTest_AttackLocations::_Enemy' has a wrong offset!");

// Class Mai.MaiEqsTest_VisitedAP
// 0x0008 (0x0200 - 0x01F8)
class UMaiEqsTest_VisitedAP final : public UEnvQueryTest
{
public:
	EEqsVisitedAPScore                            _ScoreType;                                        // 0x01F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiEqsTest_VisitedAP">();
	}
	static class UMaiEqsTest_VisitedAP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiEqsTest_VisitedAP>();
	}
};
static_assert(alignof(UMaiEqsTest_VisitedAP) == 0x000008, "Wrong alignment on UMaiEqsTest_VisitedAP");
static_assert(sizeof(UMaiEqsTest_VisitedAP) == 0x000200, "Wrong size on UMaiEqsTest_VisitedAP");
static_assert(offsetof(UMaiEqsTest_VisitedAP, _ScoreType) == 0x0001F8, "Member 'UMaiEqsTest_VisitedAP::_ScoreType' has a wrong offset!");

// Class Mai.MaiFlyingComponent
// 0x00A0 (0x0140 - 0x00A0)
class UMaiFlyingComponent final : public UActorComponent
{
public:
	float                                         _FlyingTimer;                                      // 0x00A0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _FlyingLanding;                                    // 0x00A4(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _WantedSpeed;                                      // 0x00A8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _GoalLocation;                                     // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _FlyingGoalLocation;                               // 0x00C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _FlyingSubGoalLocation;                            // 0x00E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        _FlyingPath;                                       // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	class AMaiFlyingGraph*                        _FlyingGraph;                                      // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMaiCharacter*                          _Character;                                        // 0x0110(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _AcceptanceRadius;                                 // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _MinSpeed;                                         // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _StartSpeed;                                       // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _InterpSpeed;                                      // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _LandingDistance;                                  // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _PathRebuildDistance;                              // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SubGoalReachedDistance;                           // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SubGoalCheckPeriod;                               // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Debug;                                            // 0x0138(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiFlyingComponent">();
	}
	static class UMaiFlyingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiFlyingComponent>();
	}
};
static_assert(alignof(UMaiFlyingComponent) == 0x000008, "Wrong alignment on UMaiFlyingComponent");
static_assert(sizeof(UMaiFlyingComponent) == 0x000140, "Wrong size on UMaiFlyingComponent");
static_assert(offsetof(UMaiFlyingComponent, _FlyingTimer) == 0x0000A0, "Member 'UMaiFlyingComponent::_FlyingTimer' has a wrong offset!");
static_assert(offsetof(UMaiFlyingComponent, _FlyingLanding) == 0x0000A4, "Member 'UMaiFlyingComponent::_FlyingLanding' has a wrong offset!");
static_assert(offsetof(UMaiFlyingComponent, _WantedSpeed) == 0x0000A8, "Member 'UMaiFlyingComponent::_WantedSpeed' has a wrong offset!");
static_assert(offsetof(UMaiFlyingComponent, _GoalLocation) == 0x0000B0, "Member 'UMaiFlyingComponent::_GoalLocation' has a wrong offset!");
static_assert(offsetof(UMaiFlyingComponent, _FlyingGoalLocation) == 0x0000C8, "Member 'UMaiFlyingComponent::_FlyingGoalLocation' has a wrong offset!");
static_assert(offsetof(UMaiFlyingComponent, _FlyingSubGoalLocation) == 0x0000E0, "Member 'UMaiFlyingComponent::_FlyingSubGoalLocation' has a wrong offset!");
static_assert(offsetof(UMaiFlyingComponent, _FlyingPath) == 0x0000F8, "Member 'UMaiFlyingComponent::_FlyingPath' has a wrong offset!");
static_assert(offsetof(UMaiFlyingComponent, _FlyingGraph) == 0x000108, "Member 'UMaiFlyingComponent::_FlyingGraph' has a wrong offset!");
static_assert(offsetof(UMaiFlyingComponent, _Character) == 0x000110, "Member 'UMaiFlyingComponent::_Character' has a wrong offset!");
static_assert(offsetof(UMaiFlyingComponent, _AcceptanceRadius) == 0x000118, "Member 'UMaiFlyingComponent::_AcceptanceRadius' has a wrong offset!");
static_assert(offsetof(UMaiFlyingComponent, _MinSpeed) == 0x00011C, "Member 'UMaiFlyingComponent::_MinSpeed' has a wrong offset!");
static_assert(offsetof(UMaiFlyingComponent, _StartSpeed) == 0x000120, "Member 'UMaiFlyingComponent::_StartSpeed' has a wrong offset!");
static_assert(offsetof(UMaiFlyingComponent, _InterpSpeed) == 0x000124, "Member 'UMaiFlyingComponent::_InterpSpeed' has a wrong offset!");
static_assert(offsetof(UMaiFlyingComponent, _LandingDistance) == 0x000128, "Member 'UMaiFlyingComponent::_LandingDistance' has a wrong offset!");
static_assert(offsetof(UMaiFlyingComponent, _PathRebuildDistance) == 0x00012C, "Member 'UMaiFlyingComponent::_PathRebuildDistance' has a wrong offset!");
static_assert(offsetof(UMaiFlyingComponent, _SubGoalReachedDistance) == 0x000130, "Member 'UMaiFlyingComponent::_SubGoalReachedDistance' has a wrong offset!");
static_assert(offsetof(UMaiFlyingComponent, _SubGoalCheckPeriod) == 0x000134, "Member 'UMaiFlyingComponent::_SubGoalCheckPeriod' has a wrong offset!");
static_assert(offsetof(UMaiFlyingComponent, _Debug) == 0x000138, "Member 'UMaiFlyingComponent::_Debug' has a wrong offset!");

// Class Mai.MaiFlyingPointComponent
// 0x0000 (0x02A0 - 0x02A0)
class UMaiFlyingPointComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiFlyingPointComponent">();
	}
	static class UMaiFlyingPointComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiFlyingPointComponent>();
	}
};
static_assert(alignof(UMaiFlyingPointComponent) == 0x000010, "Wrong alignment on UMaiFlyingPointComponent");
static_assert(sizeof(UMaiFlyingPointComponent) == 0x0002A0, "Wrong size on UMaiFlyingPointComponent");

// Class Mai.MaiFlyingGraph
// 0x0018 (0x02C8 - 0x02B0)
class AMaiFlyingGraph final : public AActor
{
public:
	class UMaiFlyingGraphComponent*               _FlyingGraph;                                      // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class APawn*>                          _GraphWalkers;                                     // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	class AMaiFlyingPoint* FindNearestPoint(const struct FVector& Location, float Radius, class AMaiController* User) const;
	int32 GetPointCount() const;
	void GetPoints(TArray<class AMaiFlyingPoint*>* ActionPoints) const;
	void GetPointsInRange(TArray<class AMaiFlyingPoint*>* ActionPoints, const struct FVector& Pos, float Radius) const;
	class AMaiFlyingPoint* GetRandomPoint(const TArray<class AMaiFlyingPoint*>& ActionPoints) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiFlyingGraph">();
	}
	static class AMaiFlyingGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiFlyingGraph>();
	}
};
static_assert(alignof(AMaiFlyingGraph) == 0x000008, "Wrong alignment on AMaiFlyingGraph");
static_assert(sizeof(AMaiFlyingGraph) == 0x0002C8, "Wrong size on AMaiFlyingGraph");
static_assert(offsetof(AMaiFlyingGraph, _FlyingGraph) == 0x0002B0, "Member 'AMaiFlyingGraph::_FlyingGraph' has a wrong offset!");
static_assert(offsetof(AMaiFlyingGraph, _GraphWalkers) == 0x0002B8, "Member 'AMaiFlyingGraph::_GraphWalkers' has a wrong offset!");

// Class Mai.MaiFlyingGraphComponent
// 0x0030 (0x02D0 - 0x02A0)
class UMaiFlyingGraphComponent final : public USceneComponent
{
public:
	TArray<class AMaiFlyingPoint*>                _ActionPoints;                                     // 0x02A0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class AMaiFlyingPoint*>                _PointsToUpdate;                                   // 0x02B0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         _Height;                                           // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Radius;                                           // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _MaxDist;                                          // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _MaxConnectionsCount;                              // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class AMaiFlyingPoint* FindNearestPoint(const struct FVector& Location) const;
	int32 GetPointCount() const;
	void GetPoints(TArray<class AMaiFlyingPoint*>* ActionPoints) const;
	void GetPointsInRange(TArray<class AMaiFlyingPoint*>* ActionPoints, const struct FVector& Pos, float Radius) const;
	class AMaiFlyingPoint* GetRandomPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiFlyingGraphComponent">();
	}
	static class UMaiFlyingGraphComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiFlyingGraphComponent>();
	}
};
static_assert(alignof(UMaiFlyingGraphComponent) == 0x000010, "Wrong alignment on UMaiFlyingGraphComponent");
static_assert(sizeof(UMaiFlyingGraphComponent) == 0x0002D0, "Wrong size on UMaiFlyingGraphComponent");
static_assert(offsetof(UMaiFlyingGraphComponent, _ActionPoints) == 0x0002A0, "Member 'UMaiFlyingGraphComponent::_ActionPoints' has a wrong offset!");
static_assert(offsetof(UMaiFlyingGraphComponent, _PointsToUpdate) == 0x0002B0, "Member 'UMaiFlyingGraphComponent::_PointsToUpdate' has a wrong offset!");
static_assert(offsetof(UMaiFlyingGraphComponent, _Height) == 0x0002C0, "Member 'UMaiFlyingGraphComponent::_Height' has a wrong offset!");
static_assert(offsetof(UMaiFlyingGraphComponent, _Radius) == 0x0002C4, "Member 'UMaiFlyingGraphComponent::_Radius' has a wrong offset!");
static_assert(offsetof(UMaiFlyingGraphComponent, _MaxDist) == 0x0002C8, "Member 'UMaiFlyingGraphComponent::_MaxDist' has a wrong offset!");
static_assert(offsetof(UMaiFlyingGraphComponent, _MaxConnectionsCount) == 0x0002CC, "Member 'UMaiFlyingGraphComponent::_MaxConnectionsCount' has a wrong offset!");

// Class Mai.MaiFollowingComponent
// 0x0088 (0x0340 - 0x02B8)
class UMaiFollowingComponent final : public UPathFollowingComponent
{
public:
	FMulticastInlineDelegateProperty_             StartMoveToPoint;                                  // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x28];                                     // 0x02C8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _OffsetFromCornersDistance;                        // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _UseViewLocation;                                  // 0x02F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F5[0x3];                                      // 0x02F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            _CharacterMoveComp;                                // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UNavigationQueryFilter>     _FilterClass;                                      // 0x0300(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMaiNavLink*                            _PortalOwner;                                      // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x4];                                      // 0x0310(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _EnablePortals;                                    // 0x0314(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_315[0x3];                                      // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _PortalMaxDistance;                                // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _EnableShortcuts;                                  // 0x031C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31D[0x3];                                      // 0x031D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _ShourtcutDistance;                                // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     _ShortcutFilterClass;                              // 0x0328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ObservePath;                                      // 0x0330(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_331[0x3];                                      // 0x0331(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _ObservePathPeriod;                                // 0x0334(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiFollowingComponent">();
	}
	static class UMaiFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiFollowingComponent>();
	}
};
static_assert(alignof(UMaiFollowingComponent) == 0x000008, "Wrong alignment on UMaiFollowingComponent");
static_assert(sizeof(UMaiFollowingComponent) == 0x000340, "Wrong size on UMaiFollowingComponent");
static_assert(offsetof(UMaiFollowingComponent, StartMoveToPoint) == 0x0002B8, "Member 'UMaiFollowingComponent::StartMoveToPoint' has a wrong offset!");
static_assert(offsetof(UMaiFollowingComponent, _OffsetFromCornersDistance) == 0x0002F0, "Member 'UMaiFollowingComponent::_OffsetFromCornersDistance' has a wrong offset!");
static_assert(offsetof(UMaiFollowingComponent, _UseViewLocation) == 0x0002F4, "Member 'UMaiFollowingComponent::_UseViewLocation' has a wrong offset!");
static_assert(offsetof(UMaiFollowingComponent, _CharacterMoveComp) == 0x0002F8, "Member 'UMaiFollowingComponent::_CharacterMoveComp' has a wrong offset!");
static_assert(offsetof(UMaiFollowingComponent, _FilterClass) == 0x000300, "Member 'UMaiFollowingComponent::_FilterClass' has a wrong offset!");
static_assert(offsetof(UMaiFollowingComponent, _PortalOwner) == 0x000308, "Member 'UMaiFollowingComponent::_PortalOwner' has a wrong offset!");
static_assert(offsetof(UMaiFollowingComponent, _EnablePortals) == 0x000314, "Member 'UMaiFollowingComponent::_EnablePortals' has a wrong offset!");
static_assert(offsetof(UMaiFollowingComponent, _PortalMaxDistance) == 0x000318, "Member 'UMaiFollowingComponent::_PortalMaxDistance' has a wrong offset!");
static_assert(offsetof(UMaiFollowingComponent, _EnableShortcuts) == 0x00031C, "Member 'UMaiFollowingComponent::_EnableShortcuts' has a wrong offset!");
static_assert(offsetof(UMaiFollowingComponent, _ShourtcutDistance) == 0x000320, "Member 'UMaiFollowingComponent::_ShourtcutDistance' has a wrong offset!");
static_assert(offsetof(UMaiFollowingComponent, _ShortcutFilterClass) == 0x000328, "Member 'UMaiFollowingComponent::_ShortcutFilterClass' has a wrong offset!");
static_assert(offsetof(UMaiFollowingComponent, _ObservePath) == 0x000330, "Member 'UMaiFollowingComponent::_ObservePath' has a wrong offset!");
static_assert(offsetof(UMaiFollowingComponent, _ObservePathPeriod) == 0x000334, "Member 'UMaiFollowingComponent::_ObservePathPeriod' has a wrong offset!");

// Class Mai.MaiFunctions
// 0x0000 (0x0028 - 0x0028)
class UMaiFunctions final : public UDaiFunctions
{
public:
	static void ActionsAbortByClass(class AController* Controller, TSubclassOf<class UBeingAction> ActionClass, bool Exact);
	static void ActionsAbortByPriority(class AController* Controller, EAIRequestPriority Priority, bool Exact);
	static void ActionsAbortInstigatedBy(class AController* Controller, const class UObject* InstigatedBy);
	static bool ActionsAdd(class AController* Controller, class UBeingAction* Action, EAIRequestPriority Priority, class UObject* InstigatedBy);
	static void ActionsClearAll(class AController* Controller);
	static class UBeingAction* ActionsGetCurrent(const class AController* Controller);
	static bool ActionsHasAny(const class AController* Controller);
	static bool ActionsHasOfClass(const class AController* Controller, TSubclassOf<class UBeingAction> ActionClass);
	static bool ActionsIsActive(const class AController* Controller, TSubclassOf<class UBeingAction> ActionClass);
	static void AllowPhysicsRotationDuringRootMotion(class ACharacter* Being, bool Allow, uint8 Priority);
	static struct FVector CalcAvaragePosition(const TArray<class AActor*>& Actors, const class AActor* Weighted);
	static struct FVector CalcDirLocation(class APawn* Being, class APawn* Target, const struct FVector& Source, float Radius, bool Inversed);
	static bool CanGoDirectly(class UObject* WorldContext, const struct FVector& PointA, const struct FVector& PointB, class ANavigationData* NavData, TSubclassOf<class UNavigationQueryFilter> FilterClass, float Tolerance);
	static bool CanWalkOnWalls(class APawn* Being);
	static void ClearBlackboard(class AAIController* Controller);
	static void ClearPhysicsRotationDuringRootMotion(class ACharacter* Being, uint8 Priority);
	static void DisableActionSync(class AActor* Actor);
	static void DisableActor(class AActor* Actor, bool Disable);
	static void DisableBehaviorTree(class AActor* Actor, class FName Reason);
	static bool DoesPathToLocationExists(class UObject* WorldContext, const struct FVector& PathStart, const struct FVector& PathEnd, class AActor* PathfindingContext, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	static void DrawLastLocations(class UBeingLocationTracker* Tracker, float Extent);
	static void EnableBehaviorTree(class AActor* Actor, class FName Reason);
	static void FilterActionPoints_ByClass(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, TSubclassOf<class AMaiActionPoint> PointClass);
	static void FilterActionPoints_ByCondition(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, class AActor* Caller, class UDaiCondition* Condition);
	static void FilterActionPoints_ByConditions(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, class AActor* Caller, const struct FDaiConditions& Conditions);
	static void FilterActionPoints_ByUseConditions(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, class AActor* User);
	static void FilterActionPoints_ByWeight(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, uint8 IgnoreWeight);
	static void FilterActionPoints_InDetectionArea(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, const struct FVector& Location, float AreaExtent);
	static void FilterActionPoints_InRange(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, const struct FVector& Location, float Radius);
	static void FilterActionPoints_InsideRange(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, const struct FVector& Location, float Min, float Max);
	static void FilterActionPoints_InVisibilityRadius(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, const struct FVector& Location, float Radius, float PerceptionMod);
	static void FilterActionPoints_IsSafe(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, class AActor* Actor);
	static void FilterActionPoints_OutRange(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, const struct FVector& Location, float Radius);
	static void FilterActionPoints_SortByRange(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, const struct FVector& Location);
	static void FilterBeings_By2D5Distance(const TArray<class APawn*>& InBeings, TArray<class APawn*>* OutBeings, class AActor* Actor, float MaxDist, float MinDist);
	static void FilterBeings_ByAggro(const TArray<class APawn*>& InBeings, TArray<class APawn*>* OutBeings, class APawn* Being, bool Neutral, bool Cautious, bool Aggressive);
	static void FilterBeings_ByAngle(const TArray<class APawn*>& InBeings, TArray<class APawn*>* OutBeings, const struct FVector& Origin, const struct FVector& Direction, float Angle, bool InAngle);
	static void FilterBeings_ByAttitude(const TArray<class APawn*>& InBeings, TArray<class APawn*>* OutBeings, class APawn* Being, bool Friendly, bool Neutral, bool Hostile);
	static void FilterBeings_ByDistance(const TArray<class APawn*>& InBeings, TArray<class APawn*>* OutBeings, EDaiDistanceType DistanceType, const struct FVector& Origin, float MaxDist, float MinDist);
	static void FilterBeings_OnlyAlive(const TArray<class APawn*>& InBeings, TArray<class APawn*>* OutBeings);
	static TArray<class APawn*> FindAllBeingsByTag(const class UObject* Context, class FName Tag, TSubclassOf<class APawn> beingClass, bool IncludeDisabled);
	static TArray<class APawn*> FindAllBeingsWithInterface(const class UObject* Context, class FName Tag, TSubclassOf<class IInterface> beingInterface);
	static bool FindAllEnemies(class AMaiController* Controller, TArray<class AActor*>* Enemies);
	static class AActor* FindArchEnemy(class AMaiController* Controller);
	static class UActorComponent* FindComponentFromAI(class AActor* Actor, TSubclassOf<class UActorComponent> ComponentClass);
	static class AMaiActionPoint* FindFarestActionPoint(const TArray<class AMaiActionPoint*>& InPoints, const struct FVector& Location);
	static uint8 FindHighestWeight(const TArray<class AMaiActionPoint*>& InPoints);
	static bool FindLastLocationNotInNarrowArea(struct FVector* Location, class AActor* Actor);
	static class AMaiActionGraph* FindNearestActionGraph(class UObject* Context, const struct FVector& Location, class FName GraphTag, bool CheckPoints);
	static class AMaiActionPoint* FindNearestActionPoint(const TArray<class AMaiActionPoint*>& InPoints, const struct FVector& Location);
	static class APawn* FindNearestBeingByTag(const class UObject* Context, const struct FVector& Origin, class FName Tag, TSubclassOf<class APawn> beingClass);
	static class AMaiFlyingGraph* FindNearestFlyingGraph(class UObject* Context, const struct FVector& Location, class FName GraphTag, bool CheckPoints);
	static class AMaiActionPoint* FindRandomActionPoint(const TArray<class AMaiActionPoint*>& InPoints, bool UseWeights);
	static float Get2D5Distance(const struct FVector& Origin, const struct FVector& Target, float HeightTolerance, float RadiusTolerance);
	static float Get2D5DistanceBetween(class AActor* Origin, class AActor* Target, bool Overlap);
	static float Get2D5DistanceTo(class AActor* Origin, const struct FVector& Target, bool Overlap);
	static void GetActorActionPoints(class AActor* Actor, TArray<class AMaiActionPoint*>* OutPoints);
	static float GetActorDistToNearestBeing(class AActor* Actor, class FName Tag, TSubclassOf<class APawn> beingClass, class APawn** NearestBeing);
	static struct FTransform GetAgentTransform(class AActor* Agent);
	static void GetAllActionPoints(class UObject* Context, class FName PointTag, TSubclassOf<class AMaiActionPoint> PointClass, TArray<class AMaiActionPoint*>* OutPoints);
	static void GetAllActorsActionPoints(class UObject* Context, class FName ActorTag, TSubclassOf<class AActor> ActorClass, TArray<class AMaiActionPoint*>* OutPoints);
	static void GetAllGraphsActionPoints(class UObject* Context, class FName GraphTag, TSubclassOf<class AMaiActionGraph> GraphClass, TArray<class AMaiActionPoint*>* OutPoints);
	static class UAnimationAsset* GetAnimOnNavByAngle(class AActor* Actor, const struct FGameplayTagContainer& Tags, float Hangle, struct FDaiAnimPlayParams* PlayParams, bool CheckComponents);
	static class UAnimationAsset* GetAnimOnNavByTags(class AActor* Actor, const struct FGameplayTagContainer& Tags, struct FDaiAnimPlayParams* PlayParams, bool CheckComponents);
	static ETeamAttitude GetAttitudeTowards(class APawn* Being, class APawn* Other);
	static class UBTNode* GetBehaviorTreeActiveNode(class AAIController* Controller);
	static class FString GetBehaviorTreeInfo(class AAIController* Controller);
	static float GetBlackboardFloat(class UBlackboardComponent* Blackboard, const struct FMaiBlackboardFloat& Value);
	static class FString GetBlackboardInfo(class AAIController* Controller);
	static int32 GetBlackboardInt(class UBlackboardComponent* Blackboard, const struct FMaiBlackboardInt& Value);
	static class UObject* GetCurrentCustomLinkOb(class APawn* Being);
	static struct FVector GetCurrentGoalLocation(class APawn* Being);
	static struct FVector GetCurrentPathPointLocation(class APawn* Being, int32 Point, bool FromStart);
	static struct FVector GetCurrentTargetLocation(class APawn* Being);
	static uint8 GetDifficultyByteFromTable(const class UObject* WorldContext, const struct FMaiTableOfBytesDiff& Table, int32 Index_0);
	static float GetDifficultyFloat(const class UObject* WorldContext, const struct FMaiFloatDiff& Value);
	static void GetGraphActionPoints(class AMaiActionGraph* Graph, TArray<class AMaiActionPoint*>* OutPoints);
	static class UObject* GetJumpData(class APawn* Being, float* Lenght, float* Height);
	static struct FVector GetLocalDirection(class AActor* Origin, const struct FVector& Dir);
	static struct FVector GetLocalDirectionTo(class AActor* Origin, class AActor* Other);
	static class AMaiCharacter* GetMaiCharacterByClass(class AActor* Actor, TSubclassOf<class AMaiCharacter> ActorClass);
	static class AMaiController* GetMaiControllerByClass(class AActor* Actor, TSubclassOf<class AMaiController> ActorClass);
	static class UMaiManager* GetMaiManager(class UObject* WorldContext);
	static class UActorComponent* GetManagerByClass(const class UObject* WorldContext, TSubclassOf<class UActorComponent> ManagerClass);
	static class UMaiNodeSystem* GetPathNodeSystem(class UObject* WorldContext);
	static bool GetRandomLocationInNavigableRadius(class UObject* WorldContext, struct FVector* OutLocation, const struct FVector& Origin, float Radius, class ANavigationData* NavData, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	static bool HasPathNearTo(class APawn* Being, class AActor* Actor, float Epsilon);
	static void InitializePathFollower(class UPathFollowingComponent* Follower);
	static bool IsActorInCone(const struct FVector& Origin, const struct FVector& Direction, float Angle, float Length, class AActor* Actor);
	static bool IsInChaseArea(class AActor* Actor, const struct FVector& Location, float Extent);
	static bool IsInCover(class AActor* Actor, const struct FGameplayTag& Filter);
	static bool IsInFullCover(class AActor* Actor, const struct FGameplayTag& Filter);
	static bool IsInNarrowArea(class AActor* Actor);
	static bool IsInNarrowTrigger(class AActor* Actor);
	static bool IsLocationInCone(const struct FVector& Origin, const struct FVector& Direction, float Angle, float Length, const struct FVector& Location, float Radius, float Hheight, const struct FRotator& Rotation);
	static bool IsMoveLineClear(struct FHitResult* HitResult, class AActor* Owner, class AActor* Other, const struct FVector& Start, const struct FVector& End);
	static bool IsMoveLineToOtherClear(class AActor* Owner, class AActor* Other);
	static bool IsMovingToGoalLocation(class APawn* Being);
	static bool IsShootLineClear(struct FHitResult* HitResult, class AActor* Owner, class AActor* Other, const struct FVector& Start, const struct FVector& End);
	static bool IsShootLineToOtherClear(class AActor* Owner, class AActor* Other);
	static void PauseBehaviorTree(class AActor* Actor, class FName Reason);
	static void PausePathFollowing(class AAIController* Controller);
	static bool ProjectPointToNavigation(class UObject* WorldContext, struct FVector* OutLocation, const struct FVector& Point, class ANavigationData* NavData, TSubclassOf<class UNavigationQueryFilter> FilterClass, const struct FVector& QueryExtent);
	static void RequestDirectMove(class APawn* Being, const struct FVector& MoveVelocity, bool bForceMaxSpeed);
	static void RequestDirectMoveTo(class APawn* Being, const struct FVector& Location, bool bForceMaxSpeed, bool SmoothCurves);
	static void ResetAggressiveEnemies(class APawn* Being);
	static void ResetBeing(class APawn* Being);
	static void ResetEnemiesInRange(class APawn* Being, float MaxRange);
	static void RestartBehaviorTree(class AAIController* Controller, bool HardReset);
	static void ResumeBehaviorTree(class AActor* Actor, class FName Reason);
	static void ResumePathFollowing(class AAIController* Controller);
	static class APawn* SelectBeingInFront(const TArray<class APawn*>& beings, const struct FVector& Origin, const struct FVector& Direction, TSubclassOf<class AActor> beingClass);
	static bool SetBlackboardValue(class UBlackboardComponent* Blackboard, const struct FMaiBlackboardValue& Value);
	static void SetIgnoreMe(class AActor* Actor, bool Ignore, class FName Reason);
	static void SetIgnoreOther(class AActor* Actor, class AActor* Other, bool Ignore);
	static bool ShouldBeIgnored(class AActor* Actor);
	static bool ShouldIgnoreOther(class AActor* Actor, class AActor* Other);
	static void Test_Distance(const TArray<class AActor*>& Actors, TArray<float>* Results, const struct FVector& Origin);
	static void Test_Dot(const TArray<class AActor*>& Actors, TArray<float>* Results, const struct FVector& Origin, const struct FVector& Direction);
	static TArray<float> Tests_Combine2(const TArray<float>& W1, const TArray<float>& W2);
	static int32 Tests_HighestWeightIntex(const TArray<float>& Weights);
	static void Tests_Weights(const TArray<float>& Raw, TArray<float>* Weights, bool Inverse, float Mul, float MinClamp, float MaxClamp);
	static bool UnregisterPerceptionStimuliSource(class UObject* WorldContextObject, TSubclassOf<class UAISense> Sense, class AActor* Target);
	static void UpdateCrowdAgentParams(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiFunctions">();
	}
	static class UMaiFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiFunctions>();
	}
};
static_assert(alignof(UMaiFunctions) == 0x000008, "Wrong alignment on UMaiFunctions");
static_assert(sizeof(UMaiFunctions) == 0x000028, "Wrong size on UMaiFunctions");

// Class Mai.MaiHealth
// 0x0078 (0x0118 - 0x00A0)
class UMaiHealth final : public UActorComponent
{
public:
	float                                         _HealthMul[0xA];                                   // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _MaxHealth;                                        // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Health;                                           // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Immortal;                                         // 0x00D0(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDead;                                            // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRevive;                                          // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHealthChange;                                    // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHealthChangeEx;                                  // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Heal();
	void Kill();
	void ReceiveCure(float Cure, class AActor* Instigator);
	void ReceiveDamage(float Damage, class AActor* Instigator);
	void Revive();
	void SetHealth(int32 NewHealth);
	void SetImmortal(bool Immortal);

	int32 GetHealth() const;
	int32 GetHealthPercent() const;
	int32 GetMaxHealth() const;
	bool IsDead() const;
	bool IsImmortal() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiHealth">();
	}
	static class UMaiHealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiHealth>();
	}
};
static_assert(alignof(UMaiHealth) == 0x000008, "Wrong alignment on UMaiHealth");
static_assert(sizeof(UMaiHealth) == 0x000118, "Wrong size on UMaiHealth");
static_assert(offsetof(UMaiHealth, _HealthMul) == 0x0000A0, "Member 'UMaiHealth::_HealthMul' has a wrong offset!");
static_assert(offsetof(UMaiHealth, _MaxHealth) == 0x0000C8, "Member 'UMaiHealth::_MaxHealth' has a wrong offset!");
static_assert(offsetof(UMaiHealth, _Health) == 0x0000CC, "Member 'UMaiHealth::_Health' has a wrong offset!");
static_assert(offsetof(UMaiHealth, _Immortal) == 0x0000D0, "Member 'UMaiHealth::_Immortal' has a wrong offset!");
static_assert(offsetof(UMaiHealth, OnDead) == 0x0000D8, "Member 'UMaiHealth::OnDead' has a wrong offset!");
static_assert(offsetof(UMaiHealth, OnRevive) == 0x0000E8, "Member 'UMaiHealth::OnRevive' has a wrong offset!");
static_assert(offsetof(UMaiHealth, OnHealthChange) == 0x0000F8, "Member 'UMaiHealth::OnHealthChange' has a wrong offset!");
static_assert(offsetof(UMaiHealth, OnHealthChangeEx) == 0x000108, "Member 'UMaiHealth::OnHealthChangeEx' has a wrong offset!");

// Class Mai.MaiReincarnationComponent
// 0x0040 (0x05F0 - 0x05B0)
class UMaiReincarnationComponent final : public UMaiAreaComponent
{
public:
	TArray<struct FMaiReincarnationInfo>          _Data;                                             // 0x05A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         _MaxNumber;                                        // 0x05B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ReviveCountLimit;                                 // 0x05B9(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _OverridenParams;                                  // 0x05BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5BB[0x5];                                      // 0x05BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaiReincarnationInfo>          _OverridenData;                                    // 0x05C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, SaveGame, NativeAccessSpecifierPublic)
	uint8                                         _OverridenMaxNumber;                               // 0x05D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _ReviveCounter;                                    // 0x05D1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, SaveGame, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D2[0x2];                                      // 0x05D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _EnterCounter;                                     // 0x05D4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, SaveGame, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _CalcEntrance;                                     // 0x05D8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, SaveGame, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D9[0x17];                                     // 0x05D9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearOverrideData();
	void DecreaseEnterCounter();
	void EnableCalcEntrance();
	void FillParams(class UMaiReincarnationComponent* Other);
	void OnEnterReincarnateArea();
	void OnLeaveReincarnateArea();
	bool Reincarnate(float HealthPercent);
	void SetOverrideData(uint8 MaxReincarnationNumber, const TArray<struct FMaiReincarnationInfo>& Data);

	bool AllowReincarnation() const;
	uint8 GetSeizuresNumber() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiReincarnationComponent">();
	}
	static class UMaiReincarnationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiReincarnationComponent>();
	}
};
static_assert(alignof(UMaiReincarnationComponent) == 0x000010, "Wrong alignment on UMaiReincarnationComponent");
static_assert(sizeof(UMaiReincarnationComponent) == 0x0005F0, "Wrong size on UMaiReincarnationComponent");
static_assert(offsetof(UMaiReincarnationComponent, _Data) == 0x0005A8, "Member 'UMaiReincarnationComponent::_Data' has a wrong offset!");
static_assert(offsetof(UMaiReincarnationComponent, _MaxNumber) == 0x0005B8, "Member 'UMaiReincarnationComponent::_MaxNumber' has a wrong offset!");
static_assert(offsetof(UMaiReincarnationComponent, _ReviveCountLimit) == 0x0005B9, "Member 'UMaiReincarnationComponent::_ReviveCountLimit' has a wrong offset!");
static_assert(offsetof(UMaiReincarnationComponent, _OverridenParams) == 0x0005BA, "Member 'UMaiReincarnationComponent::_OverridenParams' has a wrong offset!");
static_assert(offsetof(UMaiReincarnationComponent, _OverridenData) == 0x0005C0, "Member 'UMaiReincarnationComponent::_OverridenData' has a wrong offset!");
static_assert(offsetof(UMaiReincarnationComponent, _OverridenMaxNumber) == 0x0005D0, "Member 'UMaiReincarnationComponent::_OverridenMaxNumber' has a wrong offset!");
static_assert(offsetof(UMaiReincarnationComponent, _ReviveCounter) == 0x0005D1, "Member 'UMaiReincarnationComponent::_ReviveCounter' has a wrong offset!");
static_assert(offsetof(UMaiReincarnationComponent, _EnterCounter) == 0x0005D4, "Member 'UMaiReincarnationComponent::_EnterCounter' has a wrong offset!");
static_assert(offsetof(UMaiReincarnationComponent, _CalcEntrance) == 0x0005D8, "Member 'UMaiReincarnationComponent::_CalcEntrance' has a wrong offset!");

// Class Mai.MaiEditorSelectableInterface
// 0x0000 (0x0028 - 0x0028)
class IMaiEditorSelectableInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiEditorSelectableInterface">();
	}
	static class IMaiEditorSelectableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMaiEditorSelectableInterface>();
	}
};
static_assert(alignof(IMaiEditorSelectableInterface) == 0x000008, "Wrong alignment on IMaiEditorSelectableInterface");
static_assert(sizeof(IMaiEditorSelectableInterface) == 0x000028, "Wrong size on IMaiEditorSelectableInterface");

// Class Mai.MaiLightEmitter
// 0x0130 (0x03D0 - 0x02A0)
class UMaiLightEmitter final : public USceneComponent
{
public:
	bool                                          _Enabled;                                          // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _AutoRegister;                                     // 0x02A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _CastLightRays;                                    // 0x02A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _RayCount;                                         // 0x02A3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Angle;                                            // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Range;                                            // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _RayRadius;                                        // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _PointRange;                                       // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _YawPeriod;                                        // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _FirstValidRay;                                    // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _NextRay;                                          // 0x02B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA[0x6];                                      // 0x02BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaiLightRay>                   _RayList;                                          // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  _Observer;                                         // 0x02D0(0x0030)(Edit, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _AIHalfAngle;                                      // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _AIRange;                                          // 0x0304(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FMaiLightRaySegment>       _ValidRaySegments;                                 // 0x0308(0x0050)(Edit, DisableEditOnTemplate, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        _PointList;                                        // 0x0358(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        _IgnoredPointList;                                 // 0x0368(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        _RayPointList;                                     // 0x0378(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        _SightPointList;                                   // 0x0388(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	ECollisionChannel                             _TraceChannel;                                     // 0x0398(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _TraceIgnoreActors;                                // 0x03A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LightEmitterChange;                                // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LightingState;                                     // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool IsInLight(const struct FVector& Location, float Radius, float Hheight, const struct FRotator& Rotation);
	void LightLight();
	void SetAngle(float Angle);
	void SetRange(float Range);
	void TestLight();
	void TurnOffLight();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiLightEmitter">();
	}
	static class UMaiLightEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiLightEmitter>();
	}
};
static_assert(alignof(UMaiLightEmitter) == 0x000010, "Wrong alignment on UMaiLightEmitter");
static_assert(sizeof(UMaiLightEmitter) == 0x0003D0, "Wrong size on UMaiLightEmitter");
static_assert(offsetof(UMaiLightEmitter, _Enabled) == 0x0002A0, "Member 'UMaiLightEmitter::_Enabled' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _AutoRegister) == 0x0002A1, "Member 'UMaiLightEmitter::_AutoRegister' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _CastLightRays) == 0x0002A2, "Member 'UMaiLightEmitter::_CastLightRays' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _RayCount) == 0x0002A3, "Member 'UMaiLightEmitter::_RayCount' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _Angle) == 0x0002A4, "Member 'UMaiLightEmitter::_Angle' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _Range) == 0x0002A8, "Member 'UMaiLightEmitter::_Range' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _RayRadius) == 0x0002AC, "Member 'UMaiLightEmitter::_RayRadius' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _PointRange) == 0x0002B0, "Member 'UMaiLightEmitter::_PointRange' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _YawPeriod) == 0x0002B4, "Member 'UMaiLightEmitter::_YawPeriod' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _FirstValidRay) == 0x0002B8, "Member 'UMaiLightEmitter::_FirstValidRay' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _NextRay) == 0x0002B9, "Member 'UMaiLightEmitter::_NextRay' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _RayList) == 0x0002C0, "Member 'UMaiLightEmitter::_RayList' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _Observer) == 0x0002D0, "Member 'UMaiLightEmitter::_Observer' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _AIHalfAngle) == 0x000300, "Member 'UMaiLightEmitter::_AIHalfAngle' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _AIRange) == 0x000304, "Member 'UMaiLightEmitter::_AIRange' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _ValidRaySegments) == 0x000308, "Member 'UMaiLightEmitter::_ValidRaySegments' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _PointList) == 0x000358, "Member 'UMaiLightEmitter::_PointList' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _IgnoredPointList) == 0x000368, "Member 'UMaiLightEmitter::_IgnoredPointList' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _RayPointList) == 0x000378, "Member 'UMaiLightEmitter::_RayPointList' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _SightPointList) == 0x000388, "Member 'UMaiLightEmitter::_SightPointList' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _TraceChannel) == 0x000398, "Member 'UMaiLightEmitter::_TraceChannel' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, _TraceIgnoreActors) == 0x0003A0, "Member 'UMaiLightEmitter::_TraceIgnoreActors' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, LightEmitterChange) == 0x0003B0, "Member 'UMaiLightEmitter::LightEmitterChange' has a wrong offset!");
static_assert(offsetof(UMaiLightEmitter, LightingState) == 0x0003C0, "Member 'UMaiLightEmitter::LightingState' has a wrong offset!");

// Class Mai.MaiLightsManager
// 0x00C0 (0x0160 - 0x00A0)
class UMaiLightsManager final : public UActorComponent
{
public:
	TMap<TWeakObjectPtr<class UMaiLightEmitter>, struct FMaiLightData> _AllLights;                                        // 0x00A0(0x0050)(Edit, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class UMaiLightObserver*, struct FMaiLightedActors> _Observers;                                        // 0x00F0(0x0050)(Edit, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class UMaiLightEmitter>> _DirtyLights;                                      // 0x0140(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UMaiLightObserver*>              _DirtyObservers;                                   // 0x0150(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UMaiLightsManager* GetLightsManager(const class UObject* WorldContext);

	void OnLightEmitterChange(class UMaiLightEmitter* Light);
	void OnLightObserverChange(class UMaiLightObserver* Observer);
	void RefreshLighting();

	bool GetIsLit(class AActor* Observer) const;
	class UMaiLightEmitter* GetLitLight(const class UMaiLightObserver* Observer) const;
	bool TestIsLit(class AActor* Observer, float Radius, float Hheight, const struct FVector& Offset) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiLightsManager">();
	}
	static class UMaiLightsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiLightsManager>();
	}
};
static_assert(alignof(UMaiLightsManager) == 0x000008, "Wrong alignment on UMaiLightsManager");
static_assert(sizeof(UMaiLightsManager) == 0x000160, "Wrong size on UMaiLightsManager");
static_assert(offsetof(UMaiLightsManager, _AllLights) == 0x0000A0, "Member 'UMaiLightsManager::_AllLights' has a wrong offset!");
static_assert(offsetof(UMaiLightsManager, _Observers) == 0x0000F0, "Member 'UMaiLightsManager::_Observers' has a wrong offset!");
static_assert(offsetof(UMaiLightsManager, _DirtyLights) == 0x000140, "Member 'UMaiLightsManager::_DirtyLights' has a wrong offset!");
static_assert(offsetof(UMaiLightsManager, _DirtyObservers) == 0x000150, "Member 'UMaiLightsManager::_DirtyObservers' has a wrong offset!");

// Class Mai.MaiLookAtComponent
// 0x0060 (0x05C0 - 0x0560)
#pragma pack(push, 0x1)
class alignas(0x10) UMaiLookAtComponent : public UArrowComponent
{
public:
	float                                         _LoseRanageExt;                                    // 0x0558(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _HeadPitchOffset;                                  // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _HeadYawOffset;                                    // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _HeadRotationRate;                                 // 0x0564(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ConstantInterp;                                   // 0x0568(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Debug;                                            // 0x0569(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Enabled;                                          // 0x056A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ExceedingLimit;                                   // 0x056B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56C[0x4];                                      // 0x056C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaiLookAtData>                 _LookAtData;                                       // 0x0570(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               _HeadLocalRotation;                                // 0x0580(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               _TargetLocalRotation;                              // 0x0598(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	int32                                         _CurrentPriority;                                  // 0x05B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B4[0x4];                                      // 0x05B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearLookAt(int32 Priority);
	void DisableLookAt(int32 Priority);
	void EnableLookAt(int32 Priority);
	void LookAtActor(class AActor* Actor, float MaxRange, uint8 Priority);
	void LookAtComponent(class USceneComponent* Comp, float MaxRange, uint8 Priority);
	void LookAtLocation(const struct FVector& Location, float MaxRange, uint8 Priority);
	void SetLookAtRotation(const struct FRotator& Rotation, float MaxRange, uint8 Priority);

	const struct FRotator GetHeadLocalRotation() const;
	class AActor* GetLookAtActor(uint8 Priority) const;
	const struct FVector GetLookAtLocation(uint8 Priority) const;
	const struct FRotator GetLookAtRotation(uint8 Priority) const;
	bool IsLookAtEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiLookAtComponent">();
	}
	static class UMaiLookAtComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiLookAtComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMaiLookAtComponent) == 0x000010, "Wrong alignment on UMaiLookAtComponent");
static_assert(sizeof(UMaiLookAtComponent) == 0x0005C0, "Wrong size on UMaiLookAtComponent");
static_assert(offsetof(UMaiLookAtComponent, _LoseRanageExt) == 0x000558, "Member 'UMaiLookAtComponent::_LoseRanageExt' has a wrong offset!");
static_assert(offsetof(UMaiLookAtComponent, _HeadPitchOffset) == 0x00055C, "Member 'UMaiLookAtComponent::_HeadPitchOffset' has a wrong offset!");
static_assert(offsetof(UMaiLookAtComponent, _HeadYawOffset) == 0x000560, "Member 'UMaiLookAtComponent::_HeadYawOffset' has a wrong offset!");
static_assert(offsetof(UMaiLookAtComponent, _HeadRotationRate) == 0x000564, "Member 'UMaiLookAtComponent::_HeadRotationRate' has a wrong offset!");
static_assert(offsetof(UMaiLookAtComponent, _ConstantInterp) == 0x000568, "Member 'UMaiLookAtComponent::_ConstantInterp' has a wrong offset!");
static_assert(offsetof(UMaiLookAtComponent, _Debug) == 0x000569, "Member 'UMaiLookAtComponent::_Debug' has a wrong offset!");
static_assert(offsetof(UMaiLookAtComponent, _Enabled) == 0x00056A, "Member 'UMaiLookAtComponent::_Enabled' has a wrong offset!");
static_assert(offsetof(UMaiLookAtComponent, _ExceedingLimit) == 0x00056B, "Member 'UMaiLookAtComponent::_ExceedingLimit' has a wrong offset!");
static_assert(offsetof(UMaiLookAtComponent, _LookAtData) == 0x000570, "Member 'UMaiLookAtComponent::_LookAtData' has a wrong offset!");
static_assert(offsetof(UMaiLookAtComponent, _HeadLocalRotation) == 0x000580, "Member 'UMaiLookAtComponent::_HeadLocalRotation' has a wrong offset!");
static_assert(offsetof(UMaiLookAtComponent, _TargetLocalRotation) == 0x000598, "Member 'UMaiLookAtComponent::_TargetLocalRotation' has a wrong offset!");
static_assert(offsetof(UMaiLookAtComponent, _CurrentPriority) == 0x0005B0, "Member 'UMaiLookAtComponent::_CurrentPriority' has a wrong offset!");

// Class Mai.MaiManager
// 0x0090 (0x0130 - 0x00A0)
class UMaiManager final : public UActorComponent
{
public:
	struct FPartyAttitudes                        _Attitudes;                                        // 0x00A0(0x0010)(Edit, NativeAccessSpecifierPublic)
	TSubclassOf<class AMaiDebugger>               _DebuggerClass;                                    // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMaiDebugger*                           _Debugger;                                         // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x70];                                      // 0x00C0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static EMaiDifficultyLevel GetDifficultyLevel(const class UObject* WorldContext);

	void LockNavMeshGeneration(bool Lock, class FName Reason);
	void NegateBool(const class FString& VariableName);
	void SetNavigationForStreamingLevel(bool Set);
	void SetPartyAttitude(uint8 PartyID1, uint8 PartyID2, EPartyAttitude Attitude);

	EPartyAttitude GetPartyAttitude(uint8 PartyID1, uint8 PartyID2) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiManager">();
	}
	static class UMaiManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiManager>();
	}
};
static_assert(alignof(UMaiManager) == 0x000008, "Wrong alignment on UMaiManager");
static_assert(sizeof(UMaiManager) == 0x000130, "Wrong size on UMaiManager");
static_assert(offsetof(UMaiManager, _Attitudes) == 0x0000A0, "Member 'UMaiManager::_Attitudes' has a wrong offset!");
static_assert(offsetof(UMaiManager, _DebuggerClass) == 0x0000B0, "Member 'UMaiManager::_DebuggerClass' has a wrong offset!");
static_assert(offsetof(UMaiManager, _Debugger) == 0x0000B8, "Member 'UMaiManager::_Debugger' has a wrong offset!");

// Class Mai.MaiSettings
// 0x0108 (0x0140 - 0x0038)
class UMaiSettings final : public UDeveloperSettings
{
public:
	int32                                         _PartiesCount;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaiPartyData>                  _Parties;                                          // 0x0040(0x0010)(Edit, EditFixedSize, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FMaiPartyAttitudeData>          _Attitudes;                                        // 0x0050(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         _TokenTypesCount;                                  // 0x0060(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaiTokenData>                  _TokenTypes;                                       // 0x0068(0x0010)(Edit, EditFixedSize, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FMaiWallNavGeneration                  _GenConfig;                                        // 0x0078(0x0028)(Edit, Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0xA0];                                      // 0x00A0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSettings">();
	}
	static class UMaiSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSettings>();
	}
};
static_assert(alignof(UMaiSettings) == 0x000008, "Wrong alignment on UMaiSettings");
static_assert(sizeof(UMaiSettings) == 0x000140, "Wrong size on UMaiSettings");
static_assert(offsetof(UMaiSettings, _PartiesCount) == 0x000038, "Member 'UMaiSettings::_PartiesCount' has a wrong offset!");
static_assert(offsetof(UMaiSettings, _Parties) == 0x000040, "Member 'UMaiSettings::_Parties' has a wrong offset!");
static_assert(offsetof(UMaiSettings, _Attitudes) == 0x000050, "Member 'UMaiSettings::_Attitudes' has a wrong offset!");
static_assert(offsetof(UMaiSettings, _TokenTypesCount) == 0x000060, "Member 'UMaiSettings::_TokenTypesCount' has a wrong offset!");
static_assert(offsetof(UMaiSettings, _TokenTypes) == 0x000068, "Member 'UMaiSettings::_TokenTypes' has a wrong offset!");
static_assert(offsetof(UMaiSettings, _GenConfig) == 0x000078, "Member 'UMaiSettings::_GenConfig' has a wrong offset!");

// Class Mai.MaiSystem
// 0x00B8 (0x0220 - 0x0168)
class UMaiSystem final : public UAISystem
{
public:
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaiNodeSystem*                         _NodeSystem;                                       // 0x0170(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaiWallSystem*                         _WallSystem;                                       // 0x0178(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x10];                                     // 0x0180(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UShapeComponent*>                _NarrowAreas;                                      // 0x0190(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UShapeComponent*>                _NarrowTriggers;                                   // 0x01A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B0[0x70];                                     // 0x01B0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSystem">();
	}
	static class UMaiSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSystem>();
	}
};
static_assert(alignof(UMaiSystem) == 0x000008, "Wrong alignment on UMaiSystem");
static_assert(sizeof(UMaiSystem) == 0x000220, "Wrong size on UMaiSystem");
static_assert(offsetof(UMaiSystem, _NodeSystem) == 0x000170, "Member 'UMaiSystem::_NodeSystem' has a wrong offset!");
static_assert(offsetof(UMaiSystem, _WallSystem) == 0x000178, "Member 'UMaiSystem::_WallSystem' has a wrong offset!");
static_assert(offsetof(UMaiSystem, _NarrowAreas) == 0x000190, "Member 'UMaiSystem::_NarrowAreas' has a wrong offset!");
static_assert(offsetof(UMaiSystem, _NarrowTriggers) == 0x0001A0, "Member 'UMaiSystem::_NarrowTriggers' has a wrong offset!");

// Class Mai.MaiMessage
// 0x0018 (0x0040 - 0x0028)
class UMaiMessage : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _Sender;                                           // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMaiMessage* MakeMessage(class UObject* WorldContextObject, TSubclassOf<class UMaiMessage> MsgClass, class AActor* Sender);

	void Broadcast(const struct FMaiReceiverFilter& Filter, float SpreadingSpeed);
	void Deliver(class APawn* Receiver);
	void MarkCaptured();
	void MarkReceived();
	void ScriptDeliver(class APawn* Receiver);
	void Send(const struct FMaiReceiverFilter& Filter, float SpreadingSpeed);

	bool IsCaptured() const;
	bool IsReceived() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiMessage">();
	}
	static class UMaiMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiMessage>();
	}
};
static_assert(alignof(UMaiMessage) == 0x000008, "Wrong alignment on UMaiMessage");
static_assert(sizeof(UMaiMessage) == 0x000040, "Wrong size on UMaiMessage");
static_assert(offsetof(UMaiMessage, _Sender) == 0x000030, "Member 'UMaiMessage::_Sender' has a wrong offset!");

// Class Mai.MessageReceiverInterface
// 0x0000 (0x0028 - 0x0028)
class IMessageReceiverInterface final : public IInterface
{
public:
	void ReceiveMessage(class UMaiMessage* Message);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageReceiverInterface">();
	}
	static class IMessageReceiverInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMessageReceiverInterface>();
	}
};
static_assert(alignof(IMessageReceiverInterface) == 0x000008, "Wrong alignment on IMessageReceiverInterface");
static_assert(sizeof(IMessageReceiverInterface) == 0x000028, "Wrong size on IMessageReceiverInterface");

// Class Mai.MaiMessagesManager
// 0x0010 (0x0050 - 0x0040)
class UMaiMessagesManager final : public UTickableWorldSubsystem
{
public:
	TArray<struct FMaiDelayedMessage>             _DelayedMessages;                                  // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiMessagesManager">();
	}
	static class UMaiMessagesManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiMessagesManager>();
	}
};
static_assert(alignof(UMaiMessagesManager) == 0x000008, "Wrong alignment on UMaiMessagesManager");
static_assert(sizeof(UMaiMessagesManager) == 0x000050, "Wrong size on UMaiMessagesManager");
static_assert(offsetof(UMaiMessagesManager, _DelayedMessages) == 0x000040, "Member 'UMaiMessagesManager::_DelayedMessages' has a wrong offset!");

// Class Mai.MaiStartBlowMsg
// 0x0008 (0x0048 - 0x0040)
class UMaiStartBlowMsg final : public UMaiMessage
{
public:
	TSubclassOf<class UDamageType>                _DamageType;                                       // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiStartBlowMsg">();
	}
	static class UMaiStartBlowMsg* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiStartBlowMsg>();
	}
};
static_assert(alignof(UMaiStartBlowMsg) == 0x000008, "Wrong alignment on UMaiStartBlowMsg");
static_assert(sizeof(UMaiStartBlowMsg) == 0x000048, "Wrong size on UMaiStartBlowMsg");
static_assert(offsetof(UMaiStartBlowMsg, _DamageType) == 0x000040, "Member 'UMaiStartBlowMsg::_DamageType' has a wrong offset!");

// Class Mai.MsgStartBlowReceiverInterface
// 0x0000 (0x0028 - 0x0028)
class IMsgStartBlowReceiverInterface final : public IInterface
{
public:
	void ReceiveStartBlowMsg(class UMaiMessage* Message, class AActor* Attacker, TSubclassOf<class UDamageType> DamageType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgStartBlowReceiverInterface">();
	}
	static class IMsgStartBlowReceiverInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMsgStartBlowReceiverInterface>();
	}
};
static_assert(alignof(IMsgStartBlowReceiverInterface) == 0x000008, "Wrong alignment on IMsgStartBlowReceiverInterface");
static_assert(sizeof(IMsgStartBlowReceiverInterface) == 0x000028, "Wrong size on IMsgStartBlowReceiverInterface");

// Class Mai.MaiEndBlowMsg
// 0x0000 (0x0040 - 0x0040)
class UMaiEndBlowMsg final : public UMaiMessage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiEndBlowMsg">();
	}
	static class UMaiEndBlowMsg* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiEndBlowMsg>();
	}
};
static_assert(alignof(UMaiEndBlowMsg) == 0x000008, "Wrong alignment on UMaiEndBlowMsg");
static_assert(sizeof(UMaiEndBlowMsg) == 0x000040, "Wrong size on UMaiEndBlowMsg");

// Class Mai.MaiMadeDodgeMsg
// 0x0000 (0x0040 - 0x0040)
class UMaiMadeDodgeMsg final : public UMaiMessage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiMadeDodgeMsg">();
	}
	static class UMaiMadeDodgeMsg* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiMadeDodgeMsg>();
	}
};
static_assert(alignof(UMaiMadeDodgeMsg) == 0x000008, "Wrong alignment on UMaiMadeDodgeMsg");
static_assert(sizeof(UMaiMadeDodgeMsg) == 0x000040, "Wrong size on UMaiMadeDodgeMsg");

// Class Mai.MaiNarrowAreaBox
// 0x0000 (0x0590 - 0x0590)
class UMaiNarrowAreaBox final : public UMaiNavBox
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNarrowAreaBox">();
	}
	static class UMaiNarrowAreaBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiNarrowAreaBox>();
	}
};
static_assert(alignof(UMaiNarrowAreaBox) == 0x000010, "Wrong alignment on UMaiNarrowAreaBox");
static_assert(sizeof(UMaiNarrowAreaBox) == 0x000590, "Wrong size on UMaiNarrowAreaBox");

// Class Mai.NavArea_Crouch
// 0x0000 (0x0048 - 0x0048)
class UNavArea_Crouch final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Crouch">();
	}
	static class UNavArea_Crouch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Crouch>();
	}
};
static_assert(alignof(UNavArea_Crouch) == 0x000008, "Wrong alignment on UNavArea_Crouch");
static_assert(sizeof(UNavArea_Crouch) == 0x000048, "Wrong size on UNavArea_Crouch");

// Class Mai.NavArea_NotSupported
// 0x0010 (0x0058 - 0x0048)
class UNavArea_NotSupported final : public UNavArea
{
public:
	TSubclassOf<class UNavArea>                   SupportedArea;                                     // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   NotSupportedArea;                                  // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_NotSupported">();
	}
	static class UNavArea_NotSupported* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_NotSupported>();
	}
};
static_assert(alignof(UNavArea_NotSupported) == 0x000008, "Wrong alignment on UNavArea_NotSupported");
static_assert(sizeof(UNavArea_NotSupported) == 0x000058, "Wrong size on UNavArea_NotSupported");
static_assert(offsetof(UNavArea_NotSupported, SupportedArea) == 0x000048, "Member 'UNavArea_NotSupported::SupportedArea' has a wrong offset!");
static_assert(offsetof(UNavArea_NotSupported, NotSupportedArea) == 0x000050, "Member 'UNavArea_NotSupported::NotSupportedArea' has a wrong offset!");

// Class Mai.MaiNavAreaGetterInterface
// 0x0000 (0x0028 - 0x0028)
class IMaiNavAreaGetterInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNavAreaGetterInterface">();
	}
	static class IMaiNavAreaGetterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMaiNavAreaGetterInterface>();
	}
};
static_assert(alignof(IMaiNavAreaGetterInterface) == 0x000008, "Wrong alignment on IMaiNavAreaGetterInterface");
static_assert(sizeof(IMaiNavAreaGetterInterface) == 0x000028, "Wrong size on IMaiNavAreaGetterInterface");

// Class Mai.MaiNavLink
// 0x00B8 (0x03B8 - 0x0300)
class AMaiNavLink final : public ANavLinkProxy
{
public:
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       _LinkStartCollision;                               // 0x0308(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       _LinkEndCollision;                                 // 0x0310(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULineBatchComponent*                    _DebugLines;                                       // 0x0318(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _PortalLength;                                     // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _PortalWidth;                                      // 0x0324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _UsePrecision;                                     // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _AutoAttachCollision;                              // 0x032C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _CheckPortalSide;                                  // 0x032D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32E[0x2];                                      // 0x032E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTakeOwnership;                                   // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReturnOwnership;                                 // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0x68];                                     // 0x0350(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakMoveToLink(class APawn* Being, bool StartSide);
	void ClearPathsForWaitingCharacters(bool StartSide);
	void FinishUsingBy(class APawn* Being, bool StartSide);
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void ReturnOwnership(class APawn* Being);
	void SetNavigationRelevancy(bool IsRelevant);
	void StartMoveToLink(class APawn* Being, bool StartSide);
	void StartUsingBy(class APawn* Being, bool StartSide);
	void TakeOwnership(class APawn* Being);
	void UpdateNavMesh();

	class UNavLinkCustomComponent* GetSmartLinkComp() const;
	bool IsOnBeingPath(class APawn* Being, bool CheckFromNext) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNavLink">();
	}
	static class AMaiNavLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiNavLink>();
	}
};
static_assert(alignof(AMaiNavLink) == 0x000008, "Wrong alignment on AMaiNavLink");
static_assert(sizeof(AMaiNavLink) == 0x0003B8, "Wrong size on AMaiNavLink");
static_assert(offsetof(AMaiNavLink, _LinkStartCollision) == 0x000308, "Member 'AMaiNavLink::_LinkStartCollision' has a wrong offset!");
static_assert(offsetof(AMaiNavLink, _LinkEndCollision) == 0x000310, "Member 'AMaiNavLink::_LinkEndCollision' has a wrong offset!");
static_assert(offsetof(AMaiNavLink, _DebugLines) == 0x000318, "Member 'AMaiNavLink::_DebugLines' has a wrong offset!");
static_assert(offsetof(AMaiNavLink, _PortalLength) == 0x000320, "Member 'AMaiNavLink::_PortalLength' has a wrong offset!");
static_assert(offsetof(AMaiNavLink, _PortalWidth) == 0x000324, "Member 'AMaiNavLink::_PortalWidth' has a wrong offset!");
static_assert(offsetof(AMaiNavLink, _UsePrecision) == 0x000328, "Member 'AMaiNavLink::_UsePrecision' has a wrong offset!");
static_assert(offsetof(AMaiNavLink, _AutoAttachCollision) == 0x00032C, "Member 'AMaiNavLink::_AutoAttachCollision' has a wrong offset!");
static_assert(offsetof(AMaiNavLink, _CheckPortalSide) == 0x00032D, "Member 'AMaiNavLink::_CheckPortalSide' has a wrong offset!");
static_assert(offsetof(AMaiNavLink, OnTakeOwnership) == 0x000330, "Member 'AMaiNavLink::OnTakeOwnership' has a wrong offset!");
static_assert(offsetof(AMaiNavLink, OnReturnOwnership) == 0x000340, "Member 'AMaiNavLink::OnReturnOwnership' has a wrong offset!");

// Class Mai.MaiNavLinkComponent
// 0x0008 (0x01D8 - 0x01D0)
class UMaiNavLinkComponent final : public UNavLinkCustomComponent
{
public:
	uint8                                         Pad_1D0[0x8];                                      // 0x01D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetLinkEnabled(bool NewEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNavLinkComponent">();
	}
	static class UMaiNavLinkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiNavLinkComponent>();
	}
};
static_assert(alignof(UMaiNavLinkComponent) == 0x000008, "Wrong alignment on UMaiNavLinkComponent");
static_assert(sizeof(UMaiNavLinkComponent) == 0x0001D8, "Wrong size on UMaiNavLinkComponent");

// Class Mai.MaiNavLinkDrawer
// 0x0000 (0x0580 - 0x0580)
class UMaiNavLinkDrawer final : public ULineBatchComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNavLinkDrawer">();
	}
	static class UMaiNavLinkDrawer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiNavLinkDrawer>();
	}
};
static_assert(alignof(UMaiNavLinkDrawer) == 0x000010, "Wrong alignment on UMaiNavLinkDrawer");
static_assert(sizeof(UMaiNavLinkDrawer) == 0x000580, "Wrong size on UMaiNavLinkDrawer");

// Class Mai.MaiNavModifierComponent
// 0x0010 (0x01A0 - 0x0190)
class UMaiNavModifierComponent final : public UNavModifierComponent
{
public:
	uint8                                         Pad_190[0x10];                                     // 0x0190(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNavModifierComponent">();
	}
	static class UMaiNavModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiNavModifierComponent>();
	}
};
static_assert(alignof(UMaiNavModifierComponent) == 0x000010, "Wrong alignment on UMaiNavModifierComponent");
static_assert(sizeof(UMaiNavModifierComponent) == 0x0001A0, "Wrong size on UMaiNavModifierComponent");

// Class Mai.MaiNavShape
// 0x0000 (0x0028 - 0x0028)
class IMaiNavShape final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNavShape">();
	}
	static class IMaiNavShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMaiNavShape>();
	}
};
static_assert(alignof(IMaiNavShape) == 0x000008, "Wrong alignment on IMaiNavShape");
static_assert(sizeof(IMaiNavShape) == 0x000028, "Wrong size on IMaiNavShape");

// Class Mai.MaiNavCapsule
// 0x0000 (0x0570 - 0x0570)
class UMaiNavCapsule final : public UCapsuleComponent
{
public:
	void DisableArea();
	void EnableArea();
	void SetAreaClass(TSubclassOf<class UNavArea> NewAreaClass);

	bool IsInArea(const struct FVector& Location, float Extent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNavCapsule">();
	}
	static class UMaiNavCapsule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiNavCapsule>();
	}
};
static_assert(alignof(UMaiNavCapsule) == 0x000010, "Wrong alignment on UMaiNavCapsule");
static_assert(sizeof(UMaiNavCapsule) == 0x000570, "Wrong size on UMaiNavCapsule");

// Class Mai.MaiNavSphere
// 0x0000 (0x0570 - 0x0570)
class UMaiNavSphere final : public USphereComponent
{
public:
	void DisableArea();
	void EnableArea();
	void SetAreaClass(TSubclassOf<class UNavArea> NewAreaClass);

	bool IsInArea(const struct FVector& Location, float Extent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNavSphere">();
	}
	static class UMaiNavSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiNavSphere>();
	}
};
static_assert(alignof(UMaiNavSphere) == 0x000010, "Wrong alignment on UMaiNavSphere");
static_assert(sizeof(UMaiNavSphere) == 0x000570, "Wrong size on UMaiNavSphere");

// Class Mai.MaiNodeFollowing
// 0x00A0 (0x0140 - 0x00A0)
class UMaiNodeFollowing final : public UActorComponent
{
public:
	float                                         _MinSpeed;                                         // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _StartSpeed;                                       // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _InterpSpeed;                                      // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _LandingDistance;                                  // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _MoveLanding;                                      // 0x00B0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _MoveTimer;                                        // 0x00B4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _WantedSpeed;                                      // 0x00B8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _GoalLocation;                                     // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _MoveGoalLocation;                                 // 0x00D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _MoveSubGoalLocation;                              // 0x00F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        _MovePath;                                         // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _SpeedCurve;                                       // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMaiCharacter*                          _Character;                                        // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _AcceptanceRadius;                                 // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _PathRebuildDistance;                              // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SubGoalReachedDistance;                           // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SubGoalCheckPeriod;                               // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             _CollisionChannel;                                 // 0x0138(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _UseCollisionChannel;                              // 0x0139(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Debug;                                            // 0x013A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13B[0x5];                                      // 0x013B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool MoveTo(const struct FVector& GoalLocation);
	bool PreparePathTo(const struct FVector& GoalLocation);

	bool IsGoalReached(const struct FVector& GoalLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNodeFollowing">();
	}
	static class UMaiNodeFollowing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiNodeFollowing>();
	}
};
static_assert(alignof(UMaiNodeFollowing) == 0x000008, "Wrong alignment on UMaiNodeFollowing");
static_assert(sizeof(UMaiNodeFollowing) == 0x000140, "Wrong size on UMaiNodeFollowing");
static_assert(offsetof(UMaiNodeFollowing, _MinSpeed) == 0x0000A0, "Member 'UMaiNodeFollowing::_MinSpeed' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _StartSpeed) == 0x0000A4, "Member 'UMaiNodeFollowing::_StartSpeed' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _InterpSpeed) == 0x0000A8, "Member 'UMaiNodeFollowing::_InterpSpeed' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _LandingDistance) == 0x0000AC, "Member 'UMaiNodeFollowing::_LandingDistance' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _MoveLanding) == 0x0000B0, "Member 'UMaiNodeFollowing::_MoveLanding' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _MoveTimer) == 0x0000B4, "Member 'UMaiNodeFollowing::_MoveTimer' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _WantedSpeed) == 0x0000B8, "Member 'UMaiNodeFollowing::_WantedSpeed' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _GoalLocation) == 0x0000C0, "Member 'UMaiNodeFollowing::_GoalLocation' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _MoveGoalLocation) == 0x0000D8, "Member 'UMaiNodeFollowing::_MoveGoalLocation' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _MoveSubGoalLocation) == 0x0000F0, "Member 'UMaiNodeFollowing::_MoveSubGoalLocation' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _MovePath) == 0x000108, "Member 'UMaiNodeFollowing::_MovePath' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _SpeedCurve) == 0x000118, "Member 'UMaiNodeFollowing::_SpeedCurve' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _Character) == 0x000120, "Member 'UMaiNodeFollowing::_Character' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _AcceptanceRadius) == 0x000128, "Member 'UMaiNodeFollowing::_AcceptanceRadius' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _PathRebuildDistance) == 0x00012C, "Member 'UMaiNodeFollowing::_PathRebuildDistance' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _SubGoalReachedDistance) == 0x000130, "Member 'UMaiNodeFollowing::_SubGoalReachedDistance' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _SubGoalCheckPeriod) == 0x000134, "Member 'UMaiNodeFollowing::_SubGoalCheckPeriod' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _CollisionChannel) == 0x000138, "Member 'UMaiNodeFollowing::_CollisionChannel' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _UseCollisionChannel) == 0x000139, "Member 'UMaiNodeFollowing::_UseCollisionChannel' has a wrong offset!");
static_assert(offsetof(UMaiNodeFollowing, _Debug) == 0x00013A, "Member 'UMaiNodeFollowing::_Debug' has a wrong offset!");

// Class Mai.MaiPathNodeComponent
// 0x0000 (0x02A0 - 0x02A0)
class UMaiPathNodeComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiPathNodeComponent">();
	}
	static class UMaiPathNodeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiPathNodeComponent>();
	}
};
static_assert(alignof(UMaiPathNodeComponent) == 0x000010, "Wrong alignment on UMaiPathNodeComponent");
static_assert(sizeof(UMaiPathNodeComponent) == 0x0002A0, "Wrong size on UMaiPathNodeComponent");

// Class Mai.MaiNodeGraphComponent
// 0x0090 (0x0330 - 0x02A0)
class UMaiNodeGraphComponent final : public USceneComponent
{
public:
	TMap<class UMaiPathNodeComponent*, struct FMaiNodeRef> _PathNodes;                                        // 0x02A0(0x0050)(Edit, Transient, EditConst, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<class UMaiPathNodeComponent*>          _NodesToUpdate;                                    // 0x02F0(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<struct FMaiNodeData>                   _AllNodesData;                                     // 0x0300(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         _Height;                                           // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Radius;                                           // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _MaxDist;                                          // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _MaxConnectionsCount;                              // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             _CollisionChannel;                                 // 0x0320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_321[0x3];                                      // 0x0321(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 _Color;                                            // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegenerateGraph();

	class UMaiPathNodeComponent* FindNearestNode(const struct FVector& Location) const;
	void GetAllNodes(TArray<struct FMaiNodeRef>* NodesList) const;
	void GetNodesInRange(TArray<struct FMaiNodeRef>* NodesList, const struct FVector& Pos, float Radius) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNodeGraphComponent">();
	}
	static class UMaiNodeGraphComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiNodeGraphComponent>();
	}
};
static_assert(alignof(UMaiNodeGraphComponent) == 0x000010, "Wrong alignment on UMaiNodeGraphComponent");
static_assert(sizeof(UMaiNodeGraphComponent) == 0x000330, "Wrong size on UMaiNodeGraphComponent");
static_assert(offsetof(UMaiNodeGraphComponent, _PathNodes) == 0x0002A0, "Member 'UMaiNodeGraphComponent::_PathNodes' has a wrong offset!");
static_assert(offsetof(UMaiNodeGraphComponent, _NodesToUpdate) == 0x0002F0, "Member 'UMaiNodeGraphComponent::_NodesToUpdate' has a wrong offset!");
static_assert(offsetof(UMaiNodeGraphComponent, _AllNodesData) == 0x000300, "Member 'UMaiNodeGraphComponent::_AllNodesData' has a wrong offset!");
static_assert(offsetof(UMaiNodeGraphComponent, _Height) == 0x000310, "Member 'UMaiNodeGraphComponent::_Height' has a wrong offset!");
static_assert(offsetof(UMaiNodeGraphComponent, _Radius) == 0x000314, "Member 'UMaiNodeGraphComponent::_Radius' has a wrong offset!");
static_assert(offsetof(UMaiNodeGraphComponent, _MaxDist) == 0x000318, "Member 'UMaiNodeGraphComponent::_MaxDist' has a wrong offset!");
static_assert(offsetof(UMaiNodeGraphComponent, _MaxConnectionsCount) == 0x00031C, "Member 'UMaiNodeGraphComponent::_MaxConnectionsCount' has a wrong offset!");
static_assert(offsetof(UMaiNodeGraphComponent, _CollisionChannel) == 0x000320, "Member 'UMaiNodeGraphComponent::_CollisionChannel' has a wrong offset!");
static_assert(offsetof(UMaiNodeGraphComponent, _Color) == 0x000324, "Member 'UMaiNodeGraphComponent::_Color' has a wrong offset!");

// Class Mai.MaiNodeGraphVolume
// 0x0008 (0x02F0 - 0x02E8)
class AMaiNodeGraphVolume final : public AVolume
{
public:
	class UMaiNodeGraphComponent*                 NodeGraph;                                         // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void RegenerateGraph();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNodeGraphVolume">();
	}
	static class AMaiNodeGraphVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiNodeGraphVolume>();
	}
};
static_assert(alignof(AMaiNodeGraphVolume) == 0x000008, "Wrong alignment on AMaiNodeGraphVolume");
static_assert(sizeof(AMaiNodeGraphVolume) == 0x0002F0, "Wrong size on AMaiNodeGraphVolume");
static_assert(offsetof(AMaiNodeGraphVolume, NodeGraph) == 0x0002E8, "Member 'AMaiNodeGraphVolume::NodeGraph' has a wrong offset!");

// Class Mai.MaiNodeSystem
// 0x0030 (0x0058 - 0x0028)
class UMaiNodeSystem final : public UObject
{
public:
	TArray<class AMaiNodeGraphVolume*>            _GraphVolumes;                                     // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaiPathNodeComponent*>          _AllPathNodes;                                     // 0x0038(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class ANodeGraphTester*>               _PathTesters;                                      // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void UpdateInActorBounds(class AActor* Actor);
	void UpdateInBounds(const struct FBox& Box);
	void UpdateInComponentBounds(class USceneComponent* Scene);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNodeSystem">();
	}
	static class UMaiNodeSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiNodeSystem>();
	}
};
static_assert(alignof(UMaiNodeSystem) == 0x000008, "Wrong alignment on UMaiNodeSystem");
static_assert(sizeof(UMaiNodeSystem) == 0x000058, "Wrong size on UMaiNodeSystem");
static_assert(offsetof(UMaiNodeSystem, _GraphVolumes) == 0x000028, "Member 'UMaiNodeSystem::_GraphVolumes' has a wrong offset!");
static_assert(offsetof(UMaiNodeSystem, _AllPathNodes) == 0x000038, "Member 'UMaiNodeSystem::_AllPathNodes' has a wrong offset!");
static_assert(offsetof(UMaiNodeSystem, _PathTesters) == 0x000048, "Member 'UMaiNodeSystem::_PathTesters' has a wrong offset!");

// Class Mai.MaiNodePathDrawer
// 0x0010 (0x0580 - 0x0570)
class UMaiNodePathDrawer final : public UBillboardComponent
{
public:
	uint8                                         Pad_570[0x10];                                     // 0x0570(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNodePathDrawer">();
	}
	static class UMaiNodePathDrawer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiNodePathDrawer>();
	}
};
static_assert(alignof(UMaiNodePathDrawer) == 0x000010, "Wrong alignment on UMaiNodePathDrawer");
static_assert(sizeof(UMaiNodePathDrawer) == 0x000580, "Wrong size on UMaiNodePathDrawer");

// Class Mai.NodeGraphTester
// 0x0008 (0x02B8 - 0x02B0)
class ANodeGraphTester : public AActor
{
public:
	class UMaiNodePathDrawer*                     _NodePath;                                         // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NodeGraphTester">();
	}
	static class ANodeGraphTester* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANodeGraphTester>();
	}
};
static_assert(alignof(ANodeGraphTester) == 0x000008, "Wrong alignment on ANodeGraphTester");
static_assert(sizeof(ANodeGraphTester) == 0x0002B8, "Wrong size on ANodeGraphTester");
static_assert(offsetof(ANodeGraphTester, _NodePath) == 0x0002B0, "Member 'ANodeGraphTester::_NodePath' has a wrong offset!");

// Class Mai.NodePathStartTester
// 0x0000 (0x02B8 - 0x02B8)
class ANodePathStartTester final : public ANodeGraphTester
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NodePathStartTester">();
	}
	static class ANodePathStartTester* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANodePathStartTester>();
	}
};
static_assert(alignof(ANodePathStartTester) == 0x000008, "Wrong alignment on ANodePathStartTester");
static_assert(sizeof(ANodePathStartTester) == 0x0002B8, "Wrong size on ANodePathStartTester");

// Class Mai.NodePathEndTester
// 0x0000 (0x02B8 - 0x02B8)
class ANodePathEndTester final : public ANodeGraphTester
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NodePathEndTester">();
	}
	static class ANodePathEndTester* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANodePathEndTester>();
	}
};
static_assert(alignof(ANodePathEndTester) == 0x000008, "Wrong alignment on ANodePathEndTester");
static_assert(sizeof(ANodePathEndTester) == 0x0002B8, "Wrong size on ANodePathEndTester");

// Class Mai.MaiNoiseEmitter
// 0x0060 (0x0300 - 0x02A0)
class UMaiNoiseEmitter : public USceneComponent
{
public:
	float                                         _Aggro;                                            // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _NoiseRange;                                       // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Range;                                            // 0x02A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _MaxRange;                                         // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Loudness;                                         // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Period;                                           // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _NoiseTag;                                         // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  _Instigator;                                       // 0x02C0(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndNoise();
	void MakeLongNoise(float Duration);
	void MakeNoise();
	void StartNoise();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNoiseEmitter">();
	}
	static class UMaiNoiseEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiNoiseEmitter>();
	}
};
static_assert(alignof(UMaiNoiseEmitter) == 0x000010, "Wrong alignment on UMaiNoiseEmitter");
static_assert(sizeof(UMaiNoiseEmitter) == 0x000300, "Wrong size on UMaiNoiseEmitter");
static_assert(offsetof(UMaiNoiseEmitter, _Aggro) == 0x0002A0, "Member 'UMaiNoiseEmitter::_Aggro' has a wrong offset!");
static_assert(offsetof(UMaiNoiseEmitter, _NoiseRange) == 0x0002A4, "Member 'UMaiNoiseEmitter::_NoiseRange' has a wrong offset!");
static_assert(offsetof(UMaiNoiseEmitter, _Range) == 0x0002A8, "Member 'UMaiNoiseEmitter::_Range' has a wrong offset!");
static_assert(offsetof(UMaiNoiseEmitter, _MaxRange) == 0x0002AC, "Member 'UMaiNoiseEmitter::_MaxRange' has a wrong offset!");
static_assert(offsetof(UMaiNoiseEmitter, _Loudness) == 0x0002B0, "Member 'UMaiNoiseEmitter::_Loudness' has a wrong offset!");
static_assert(offsetof(UMaiNoiseEmitter, _Period) == 0x0002B4, "Member 'UMaiNoiseEmitter::_Period' has a wrong offset!");
static_assert(offsetof(UMaiNoiseEmitter, _NoiseTag) == 0x0002B8, "Member 'UMaiNoiseEmitter::_NoiseTag' has a wrong offset!");
static_assert(offsetof(UMaiNoiseEmitter, _Instigator) == 0x0002C0, "Member 'UMaiNoiseEmitter::_Instigator' has a wrong offset!");

// Class Mai.MaiNoiseSilencerComponent
// 0x0008 (0x00A8 - 0x00A0)
class UMaiNoiseSilencerComponent final : public UActorComponent
{
public:
	float                                         _MuteLevel;                                        // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNoiseSilencerComponent">();
	}
	static class UMaiNoiseSilencerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiNoiseSilencerComponent>();
	}
};
static_assert(alignof(UMaiNoiseSilencerComponent) == 0x000008, "Wrong alignment on UMaiNoiseSilencerComponent");
static_assert(sizeof(UMaiNoiseSilencerComponent) == 0x0000A8, "Wrong size on UMaiNoiseSilencerComponent");
static_assert(offsetof(UMaiNoiseSilencerComponent, _MuteLevel) == 0x0000A0, "Member 'UMaiNoiseSilencerComponent::_MuteLevel' has a wrong offset!");

// Class Mai.MaiNoiseSilencerVolume
// 0x0008 (0x02F0 - 0x02E8)
class AMaiNoiseSilencerVolume final : public AVolume
{
public:
	class UMaiNoiseSilencerComponent*             NoiseSilencer;                                     // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiNoiseSilencerVolume">();
	}
	static class AMaiNoiseSilencerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiNoiseSilencerVolume>();
	}
};
static_assert(alignof(AMaiNoiseSilencerVolume) == 0x000008, "Wrong alignment on AMaiNoiseSilencerVolume");
static_assert(sizeof(AMaiNoiseSilencerVolume) == 0x0002F0, "Wrong size on AMaiNoiseSilencerVolume");
static_assert(offsetof(AMaiNoiseSilencerVolume, NoiseSilencer) == 0x0002E8, "Member 'AMaiNoiseSilencerVolume::NoiseSilencer' has a wrong offset!");

// Class Mai.BroadcastMessageNotify
// 0x0030 (0x00C8 - 0x0098)
class UBroadcastMessageNotify final : public UDaiNotify
{
public:
	class UMaiMessage*                            _Message;                                          // 0x0098(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMaiReceiverFilter                     _Filter;                                           // 0x00A0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         _SpreadingSpeed;                                   // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BroadcastMessageNotify">();
	}
	static class UBroadcastMessageNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBroadcastMessageNotify>();
	}
};
static_assert(alignof(UBroadcastMessageNotify) == 0x000008, "Wrong alignment on UBroadcastMessageNotify");
static_assert(sizeof(UBroadcastMessageNotify) == 0x0000C8, "Wrong size on UBroadcastMessageNotify");
static_assert(offsetof(UBroadcastMessageNotify, _Message) == 0x000098, "Member 'UBroadcastMessageNotify::_Message' has a wrong offset!");
static_assert(offsetof(UBroadcastMessageNotify, _Filter) == 0x0000A0, "Member 'UBroadcastMessageNotify::_Filter' has a wrong offset!");
static_assert(offsetof(UBroadcastMessageNotify, _SpreadingSpeed) == 0x0000C0, "Member 'UBroadcastMessageNotify::_SpreadingSpeed' has a wrong offset!");

// Class Mai.ChangeGameplayTagNotify
// 0x0090 (0x0128 - 0x0098)
class UChangeGameplayTagNotify final : public UDaiNotify
{
public:
	struct FDaiContext                            _Notified;                                         // 0x0098(0x0080)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTag                           _Tag;                                              // 0x0118(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENotifyTagOperation                           _Operation;                                        // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeGameplayTagNotify">();
	}
	static class UChangeGameplayTagNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeGameplayTagNotify>();
	}
};
static_assert(alignof(UChangeGameplayTagNotify) == 0x000008, "Wrong alignment on UChangeGameplayTagNotify");
static_assert(sizeof(UChangeGameplayTagNotify) == 0x000128, "Wrong size on UChangeGameplayTagNotify");
static_assert(offsetof(UChangeGameplayTagNotify, _Notified) == 0x000098, "Member 'UChangeGameplayTagNotify::_Notified' has a wrong offset!");
static_assert(offsetof(UChangeGameplayTagNotify, _Tag) == 0x000118, "Member 'UChangeGameplayTagNotify::_Tag' has a wrong offset!");
static_assert(offsetof(UChangeGameplayTagNotify, _Operation) == 0x000120, "Member 'UChangeGameplayTagNotify::_Operation' has a wrong offset!");

// Class Mai.PushBeingActionNotify
// 0x0008 (0x00A0 - 0x0098)
class UPushBeingActionNotify final : public UDaiNotify
{
public:
	class UBeingAction*                           _Action;                                           // 0x0098(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PushBeingActionNotify">();
	}
	static class UPushBeingActionNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPushBeingActionNotify>();
	}
};
static_assert(alignof(UPushBeingActionNotify) == 0x000008, "Wrong alignment on UPushBeingActionNotify");
static_assert(sizeof(UPushBeingActionNotify) == 0x0000A0, "Wrong size on UPushBeingActionNotify");
static_assert(offsetof(UPushBeingActionNotify, _Action) == 0x000098, "Member 'UPushBeingActionNotify::_Action' has a wrong offset!");

// Class Mai.SetBoardValueNotify
// 0x00F8 (0x0190 - 0x0098)
class USetBoardValueNotify final : public UDaiNotify
{
public:
	struct FDaiContext                            _Notified;                                         // 0x0098(0x0080)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FMaiBlackboardValue                    _BoardValue;                                       // 0x0118(0x0078)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetBoardValueNotify">();
	}
	static class USetBoardValueNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetBoardValueNotify>();
	}
};
static_assert(alignof(USetBoardValueNotify) == 0x000008, "Wrong alignment on USetBoardValueNotify");
static_assert(sizeof(USetBoardValueNotify) == 0x000190, "Wrong size on USetBoardValueNotify");
static_assert(offsetof(USetBoardValueNotify, _Notified) == 0x000098, "Member 'USetBoardValueNotify::_Notified' has a wrong offset!");
static_assert(offsetof(USetBoardValueNotify, _BoardValue) == 0x000118, "Member 'USetBoardValueNotify::_BoardValue' has a wrong offset!");

// Class Mai.MaiRotationLimitsComponent
// 0x0030 (0x02D0 - 0x02A0)
class UMaiRotationLimitsComponent final : public USceneComponent
{
public:
	float                                         _MinPitch;                                         // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _MaxPitch;                                         // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _MinYaw;                                           // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _MaxYaw;                                           // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _MinRoll;                                          // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _MaxRoll;                                          // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               _RotationRate;                                     // 0x02B8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiRotationLimitsComponent">();
	}
	static class UMaiRotationLimitsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiRotationLimitsComponent>();
	}
};
static_assert(alignof(UMaiRotationLimitsComponent) == 0x000010, "Wrong alignment on UMaiRotationLimitsComponent");
static_assert(sizeof(UMaiRotationLimitsComponent) == 0x0002D0, "Wrong size on UMaiRotationLimitsComponent");
static_assert(offsetof(UMaiRotationLimitsComponent, _MinPitch) == 0x0002A0, "Member 'UMaiRotationLimitsComponent::_MinPitch' has a wrong offset!");
static_assert(offsetof(UMaiRotationLimitsComponent, _MaxPitch) == 0x0002A4, "Member 'UMaiRotationLimitsComponent::_MaxPitch' has a wrong offset!");
static_assert(offsetof(UMaiRotationLimitsComponent, _MinYaw) == 0x0002A8, "Member 'UMaiRotationLimitsComponent::_MinYaw' has a wrong offset!");
static_assert(offsetof(UMaiRotationLimitsComponent, _MaxYaw) == 0x0002AC, "Member 'UMaiRotationLimitsComponent::_MaxYaw' has a wrong offset!");
static_assert(offsetof(UMaiRotationLimitsComponent, _MinRoll) == 0x0002B0, "Member 'UMaiRotationLimitsComponent::_MinRoll' has a wrong offset!");
static_assert(offsetof(UMaiRotationLimitsComponent, _MaxRoll) == 0x0002B4, "Member 'UMaiRotationLimitsComponent::_MaxRoll' has a wrong offset!");
static_assert(offsetof(UMaiRotationLimitsComponent, _RotationRate) == 0x0002B8, "Member 'UMaiRotationLimitsComponent::_RotationRate' has a wrong offset!");

// Class Mai.MaiSenseConfigDebugger
// 0x0000 (0x0028 - 0x0028)
class IMaiSenseConfigDebugger final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSenseConfigDebugger">();
	}
	static class IMaiSenseConfigDebugger* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMaiSenseConfigDebugger>();
	}
};
static_assert(alignof(IMaiSenseConfigDebugger) == 0x000008, "Wrong alignment on IMaiSenseConfigDebugger");
static_assert(sizeof(IMaiSenseConfigDebugger) == 0x000028, "Wrong size on IMaiSenseConfigDebugger");

// Class Mai.MaiSenseConfig_Hearing
// 0x0028 (0x0070 - 0x0048)
class UMaiSenseConfig_Hearing final : public UAISenseConfig
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DistanceCurve;                                     // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HearingRange;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HearingRangeThroughWalls;                          // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         HearingThroughWalls : 1;                           // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoSHearingRange;                                   // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseLoSHearing : 1;                                // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSenseConfig_Hearing">();
	}
	static class UMaiSenseConfig_Hearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSenseConfig_Hearing>();
	}
};
static_assert(alignof(UMaiSenseConfig_Hearing) == 0x000008, "Wrong alignment on UMaiSenseConfig_Hearing");
static_assert(sizeof(UMaiSenseConfig_Hearing) == 0x000070, "Wrong size on UMaiSenseConfig_Hearing");
static_assert(offsetof(UMaiSenseConfig_Hearing, DistanceCurve) == 0x000050, "Member 'UMaiSenseConfig_Hearing::DistanceCurve' has a wrong offset!");
static_assert(offsetof(UMaiSenseConfig_Hearing, HearingRange) == 0x000058, "Member 'UMaiSenseConfig_Hearing::HearingRange' has a wrong offset!");
static_assert(offsetof(UMaiSenseConfig_Hearing, HearingRangeThroughWalls) == 0x00005C, "Member 'UMaiSenseConfig_Hearing::HearingRangeThroughWalls' has a wrong offset!");
static_assert(offsetof(UMaiSenseConfig_Hearing, LoSHearingRange) == 0x000064, "Member 'UMaiSenseConfig_Hearing::LoSHearingRange' has a wrong offset!");
static_assert(offsetof(UMaiSenseConfig_Hearing, DetectionByAffiliation) == 0x00006C, "Member 'UMaiSenseConfig_Hearing::DetectionByAffiliation' has a wrong offset!");

// Class Mai.MaiSenseConfig_Sight
// 0x0018 (0x0088 - 0x0070)
class UMaiSenseConfig_Sight final : public UAISenseConfig_Sight
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DistanceCurve;                                     // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AngleCurve;                                        // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSenseConfig_Sight">();
	}
	static class UMaiSenseConfig_Sight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSenseConfig_Sight>();
	}
};
static_assert(alignof(UMaiSenseConfig_Sight) == 0x000008, "Wrong alignment on UMaiSenseConfig_Sight");
static_assert(sizeof(UMaiSenseConfig_Sight) == 0x000088, "Wrong size on UMaiSenseConfig_Sight");
static_assert(offsetof(UMaiSenseConfig_Sight, DistanceCurve) == 0x000078, "Member 'UMaiSenseConfig_Sight::DistanceCurve' has a wrong offset!");
static_assert(offsetof(UMaiSenseConfig_Sight, AngleCurve) == 0x000080, "Member 'UMaiSenseConfig_Sight::AngleCurve' has a wrong offset!");

// Class Mai.MaiSenseConfig_Smell
// 0x0018 (0x0088 - 0x0070)
class UMaiSenseConfig_Smell final : public UAISenseConfig_Sight
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DistanceCurve;                                     // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AngleCurve;                                        // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSenseConfig_Smell">();
	}
	static class UMaiSenseConfig_Smell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSenseConfig_Smell>();
	}
};
static_assert(alignof(UMaiSenseConfig_Smell) == 0x000008, "Wrong alignment on UMaiSenseConfig_Smell");
static_assert(sizeof(UMaiSenseConfig_Smell) == 0x000088, "Wrong size on UMaiSenseConfig_Smell");
static_assert(offsetof(UMaiSenseConfig_Smell, DistanceCurve) == 0x000078, "Member 'UMaiSenseConfig_Smell::DistanceCurve' has a wrong offset!");
static_assert(offsetof(UMaiSenseConfig_Smell, AngleCurve) == 0x000080, "Member 'UMaiSenseConfig_Smell::AngleCurve' has a wrong offset!");

// Class Mai.MaiSense_Hearing
// 0x0078 (0x00F8 - 0x0080)
class UMaiSense_Hearing final : public UAISense
{
public:
	TArray<struct FMaiNoiseEvent>                 NoiseEvents;                                       // 0x0080(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         SpeedOfSound;                                      // 0x0090(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultMuteLevel;                                  // 0x0094(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             DefaultHearingCollisionChannel;                    // 0x0098(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseNavMesh;                                        // 0x0099(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CheckNavCost;                                      // 0x009A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B[0x5];                                       // 0x009B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     SoundNavigationFilter;                             // 0x00A0(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x50];                                      // 0x00A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ReportNoiseEvent(class UObject* WorldContext, const struct FVector& NoiseLocation, class AActor* Instigator, class FName Tag, float Aggro, float NoiseRange, float MaxRange, float Loudness, class AActor* IgnoreActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSense_Hearing">();
	}
	static class UMaiSense_Hearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSense_Hearing>();
	}
};
static_assert(alignof(UMaiSense_Hearing) == 0x000008, "Wrong alignment on UMaiSense_Hearing");
static_assert(sizeof(UMaiSense_Hearing) == 0x0000F8, "Wrong size on UMaiSense_Hearing");
static_assert(offsetof(UMaiSense_Hearing, NoiseEvents) == 0x000080, "Member 'UMaiSense_Hearing::NoiseEvents' has a wrong offset!");
static_assert(offsetof(UMaiSense_Hearing, SpeedOfSound) == 0x000090, "Member 'UMaiSense_Hearing::SpeedOfSound' has a wrong offset!");
static_assert(offsetof(UMaiSense_Hearing, DefaultMuteLevel) == 0x000094, "Member 'UMaiSense_Hearing::DefaultMuteLevel' has a wrong offset!");
static_assert(offsetof(UMaiSense_Hearing, DefaultHearingCollisionChannel) == 0x000098, "Member 'UMaiSense_Hearing::DefaultHearingCollisionChannel' has a wrong offset!");
static_assert(offsetof(UMaiSense_Hearing, UseNavMesh) == 0x000099, "Member 'UMaiSense_Hearing::UseNavMesh' has a wrong offset!");
static_assert(offsetof(UMaiSense_Hearing, CheckNavCost) == 0x00009A, "Member 'UMaiSense_Hearing::CheckNavCost' has a wrong offset!");
static_assert(offsetof(UMaiSense_Hearing, SoundNavigationFilter) == 0x0000A0, "Member 'UMaiSense_Hearing::SoundNavigationFilter' has a wrong offset!");

// Class Mai.MaiSenseEvent_Hearing
// 0x0060 (0x0088 - 0x0028)
class UMaiSenseEvent_Hearing final : public UAISenseEvent
{
public:
	struct FMaiNoiseEvent                         Event;                                             // 0x0028(0x0060)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSenseEvent_Hearing">();
	}
	static class UMaiSenseEvent_Hearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSenseEvent_Hearing>();
	}
};
static_assert(alignof(UMaiSenseEvent_Hearing) == 0x000008, "Wrong alignment on UMaiSenseEvent_Hearing");
static_assert(sizeof(UMaiSenseEvent_Hearing) == 0x000088, "Wrong size on UMaiSenseEvent_Hearing");
static_assert(offsetof(UMaiSenseEvent_Hearing, Event) == 0x000028, "Member 'UMaiSenseEvent_Hearing::Event' has a wrong offset!");

// Class Mai.MaiSense_Sight
// 0x0000 (0x0170 - 0x0170)
class UMaiSense_Sight final : public UAISense_Sight
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSense_Sight">();
	}
	static class UMaiSense_Sight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSense_Sight>();
	}
};
static_assert(alignof(UMaiSense_Sight) == 0x000008, "Wrong alignment on UMaiSense_Sight");
static_assert(sizeof(UMaiSense_Sight) == 0x000170, "Wrong size on UMaiSense_Sight");

// Class Mai.MaiSense_Smell
// 0x0000 (0x0170 - 0x0170)
class UMaiSense_Smell final : public UAISense_Sight
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSense_Smell">();
	}
	static class UMaiSense_Smell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSense_Smell>();
	}
};
static_assert(alignof(UMaiSense_Smell) == 0x000008, "Wrong alignment on UMaiSense_Smell");
static_assert(sizeof(UMaiSense_Smell) == 0x000170, "Wrong size on UMaiSense_Smell");

// Class Mai.MaiSense_The6thSense
// 0x0020 (0x00A0 - 0x0080)
class UMaiSense_The6thSense final : public UAISense
{
public:
	TArray<struct FMaiThe6thSenseEvent>           The6thSenseEvents;                                 // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMaiThe6thSenseEvent>           The6thSenseDisabledEvents;                         // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static void Report6thSenseConstEvent(class UObject* WorldContext, class FName Tag, bool Enable, class AActor* Instigator, const struct FVector& Location, float Power);
	static void Report6thSenseEvent(class UObject* WorldContext, class FName Tag, bool Enable, class AActor* Instigator, float Power);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSense_The6thSense">();
	}
	static class UMaiSense_The6thSense* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSense_The6thSense>();
	}
};
static_assert(alignof(UMaiSense_The6thSense) == 0x000008, "Wrong alignment on UMaiSense_The6thSense");
static_assert(sizeof(UMaiSense_The6thSense) == 0x0000A0, "Wrong size on UMaiSense_The6thSense");
static_assert(offsetof(UMaiSense_The6thSense, The6thSenseEvents) == 0x000080, "Member 'UMaiSense_The6thSense::The6thSenseEvents' has a wrong offset!");
static_assert(offsetof(UMaiSense_The6thSense, The6thSenseDisabledEvents) == 0x000090, "Member 'UMaiSense_The6thSense::The6thSenseDisabledEvents' has a wrong offset!");

// Class Mai.MaiSenseEvent_The6thSense
// 0x0048 (0x0070 - 0x0028)
class UMaiSenseEvent_The6thSense final : public UAISenseEvent
{
public:
	struct FMaiThe6thSenseEvent                   Event;                                             // 0x0028(0x0048)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSenseEvent_The6thSense">();
	}
	static class UMaiSenseEvent_The6thSense* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSenseEvent_The6thSense>();
	}
};
static_assert(alignof(UMaiSenseEvent_The6thSense) == 0x000008, "Wrong alignment on UMaiSenseEvent_The6thSense");
static_assert(sizeof(UMaiSenseEvent_The6thSense) == 0x000070, "Wrong size on UMaiSenseEvent_The6thSense");
static_assert(offsetof(UMaiSenseEvent_The6thSense, Event) == 0x000028, "Member 'UMaiSenseEvent_The6thSense::Event' has a wrong offset!");

// Class Mai.MaiSpawner
// 0x0110 (0x03C0 - 0x02B0)
class AMaiSpawner : public AActor
{
public:
	class UTextRenderComponent*                   _Text;                                             // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _LastGroundName;                                   // 0x02B8(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _SpawnOnPersistant;                                // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _UniqueTag;                                        // 0x02CC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaiSpawnAreaComponent*>         _SpawnAreas;                                       // 0x02D8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaiChaseAreaComponent*>         _ChaseAreas;                                       // 0x02E8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	bool                                          _AutoSpawn;                                        // 0x02F8(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _Enabled;                                          // 0x02F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int8                                          _Spawned;                                          // 0x02FA(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FB[0x5];                                      // 0x02FB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _AddGameplayTags;                                  // 0x0300(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _RemoveGameplayTags;                               // 0x0320(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDaiConditions                         _CanSpawnConditions;                               // 0x0340(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FDaiNotifies                           _OnSpawnNotifies;                                  // 0x0370(0x0018)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FDaiNotifies                           _OnDespawnNotifies;                                // 0x0388(0x0018)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             AfterSpawn;                                        // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             BeforeDespawn;                                     // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool BlockSpawn();
	void ChangeAutoSpawn(bool Active);
	void Despawn();
	void OnDespawn(class AActor* Actor);
	void OnSpawn(class AActor* Actor);
	void OnSpawnController(class AAIController* Controller);
	void PIEDespawn();
	void PIESpawn();
	void SetActive(bool Active);
	void Spawn();
	class AActor* SpawnSingle();
	void UpdateAutoSpawn();

	bool IsActive() const;
	bool IsInChaseArea(const struct FVector& Location, float Extent) const;
	bool IsInSpawnArea(const struct FVector& Location, float Extent) const;
	bool ShouldAutoSpawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSpawner">();
	}
	static class AMaiSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiSpawner>();
	}
};
static_assert(alignof(AMaiSpawner) == 0x000008, "Wrong alignment on AMaiSpawner");
static_assert(sizeof(AMaiSpawner) == 0x0003C0, "Wrong size on AMaiSpawner");
static_assert(offsetof(AMaiSpawner, _Text) == 0x0002B0, "Member 'AMaiSpawner::_Text' has a wrong offset!");
static_assert(offsetof(AMaiSpawner, _LastGroundName) == 0x0002B8, "Member 'AMaiSpawner::_LastGroundName' has a wrong offset!");
static_assert(offsetof(AMaiSpawner, _SpawnOnPersistant) == 0x0002C8, "Member 'AMaiSpawner::_SpawnOnPersistant' has a wrong offset!");
static_assert(offsetof(AMaiSpawner, _UniqueTag) == 0x0002CC, "Member 'AMaiSpawner::_UniqueTag' has a wrong offset!");
static_assert(offsetof(AMaiSpawner, _SpawnAreas) == 0x0002D8, "Member 'AMaiSpawner::_SpawnAreas' has a wrong offset!");
static_assert(offsetof(AMaiSpawner, _ChaseAreas) == 0x0002E8, "Member 'AMaiSpawner::_ChaseAreas' has a wrong offset!");
static_assert(offsetof(AMaiSpawner, _AutoSpawn) == 0x0002F8, "Member 'AMaiSpawner::_AutoSpawn' has a wrong offset!");
static_assert(offsetof(AMaiSpawner, _Enabled) == 0x0002F9, "Member 'AMaiSpawner::_Enabled' has a wrong offset!");
static_assert(offsetof(AMaiSpawner, _Spawned) == 0x0002FA, "Member 'AMaiSpawner::_Spawned' has a wrong offset!");
static_assert(offsetof(AMaiSpawner, _AddGameplayTags) == 0x000300, "Member 'AMaiSpawner::_AddGameplayTags' has a wrong offset!");
static_assert(offsetof(AMaiSpawner, _RemoveGameplayTags) == 0x000320, "Member 'AMaiSpawner::_RemoveGameplayTags' has a wrong offset!");
static_assert(offsetof(AMaiSpawner, _CanSpawnConditions) == 0x000340, "Member 'AMaiSpawner::_CanSpawnConditions' has a wrong offset!");
static_assert(offsetof(AMaiSpawner, _OnSpawnNotifies) == 0x000370, "Member 'AMaiSpawner::_OnSpawnNotifies' has a wrong offset!");
static_assert(offsetof(AMaiSpawner, _OnDespawnNotifies) == 0x000388, "Member 'AMaiSpawner::_OnDespawnNotifies' has a wrong offset!");
static_assert(offsetof(AMaiSpawner, AfterSpawn) == 0x0003A0, "Member 'AMaiSpawner::AfterSpawn' has a wrong offset!");
static_assert(offsetof(AMaiSpawner, BeforeDespawn) == 0x0003B0, "Member 'AMaiSpawner::BeforeDespawn' has a wrong offset!");

// Class Mai.MaiSingleSpawner
// 0x00C0 (0x0480 - 0x03C0)
class AMaiSingleSpawner : public AMaiSpawner
{
public:
	class AActor*                                 _ActorSpawned;                                     // 0x03C0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     _ActorToSpawn;                                     // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FMaiSpawnInfo>                  _SpawnVariants;                                    // 0x03D8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          _EnableVariants;                                   // 0x03E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AAIController>              _AIControllerClass;                                // 0x03F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _OverrideAIControllerClass;                        // 0x03F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBehaviorTree>           _BehaviorTree;                                     // 0x0400(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _OverrideBehaviorTree;                             // 0x0430(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_431[0x7];                                      // 0x0431(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaiBlackboardValue>            _BlackboardConfig;                                 // 0x0438(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class AMaiActionGraph>         _ActionGraph;                                      // 0x0448(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _ActorTag;                                         // 0x0478(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnInitBehaviors(class AAIController* Controller);
	void ReleaseSpawnedActor();
	void SetActorClass(TSubclassOf<class AActor> ActorClass);
	void SetAIControllerClass(TSubclassOf<class AAIController> AiClass);
	class AActor* SpawnUnique();

	class AActor* GetSpawnedActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSingleSpawner">();
	}
	static class AMaiSingleSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiSingleSpawner>();
	}
};
static_assert(alignof(AMaiSingleSpawner) == 0x000008, "Wrong alignment on AMaiSingleSpawner");
static_assert(sizeof(AMaiSingleSpawner) == 0x000480, "Wrong size on AMaiSingleSpawner");
static_assert(offsetof(AMaiSingleSpawner, _ActorSpawned) == 0x0003C0, "Member 'AMaiSingleSpawner::_ActorSpawned' has a wrong offset!");
static_assert(offsetof(AMaiSingleSpawner, _ActorToSpawn) == 0x0003D0, "Member 'AMaiSingleSpawner::_ActorToSpawn' has a wrong offset!");
static_assert(offsetof(AMaiSingleSpawner, _SpawnVariants) == 0x0003D8, "Member 'AMaiSingleSpawner::_SpawnVariants' has a wrong offset!");
static_assert(offsetof(AMaiSingleSpawner, _EnableVariants) == 0x0003E8, "Member 'AMaiSingleSpawner::_EnableVariants' has a wrong offset!");
static_assert(offsetof(AMaiSingleSpawner, _AIControllerClass) == 0x0003F0, "Member 'AMaiSingleSpawner::_AIControllerClass' has a wrong offset!");
static_assert(offsetof(AMaiSingleSpawner, _OverrideAIControllerClass) == 0x0003F8, "Member 'AMaiSingleSpawner::_OverrideAIControllerClass' has a wrong offset!");
static_assert(offsetof(AMaiSingleSpawner, _BehaviorTree) == 0x000400, "Member 'AMaiSingleSpawner::_BehaviorTree' has a wrong offset!");
static_assert(offsetof(AMaiSingleSpawner, _OverrideBehaviorTree) == 0x000430, "Member 'AMaiSingleSpawner::_OverrideBehaviorTree' has a wrong offset!");
static_assert(offsetof(AMaiSingleSpawner, _BlackboardConfig) == 0x000438, "Member 'AMaiSingleSpawner::_BlackboardConfig' has a wrong offset!");
static_assert(offsetof(AMaiSingleSpawner, _ActionGraph) == 0x000448, "Member 'AMaiSingleSpawner::_ActionGraph' has a wrong offset!");
static_assert(offsetof(AMaiSingleSpawner, _ActorTag) == 0x000478, "Member 'AMaiSingleSpawner::_ActorTag' has a wrong offset!");

// Class Mai.MaiMultiSpawner
// 0x0038 (0x03F8 - 0x03C0)
class AMaiMultiSpawner final : public AMaiSpawner
{
public:
	TArray<class AActor*>                         _SpawnedActors;                                    // 0x03C0(0x0010)(Edit, ZeroConstructor, Transient, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<struct FMaiSpawnInfo>                  _SpawnInfo;                                        // 0x03D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         _SpawnLimit;                                       // 0x03E0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMaiWaveSpawn                          _WaveSpawn;                                        // 0x03E4(0x0010)(Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeInfoWeight(int32 Index_0, uint8 Weight);
	void StartWaveSpawn(int32 Count, float MinDelay, float MaxDelay);
	void StopWaveSpawn();

	TArray<class AActor*> GetSpawnedActors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiMultiSpawner">();
	}
	static class AMaiMultiSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiMultiSpawner>();
	}
};
static_assert(alignof(AMaiMultiSpawner) == 0x000008, "Wrong alignment on AMaiMultiSpawner");
static_assert(sizeof(AMaiMultiSpawner) == 0x0003F8, "Wrong size on AMaiMultiSpawner");
static_assert(offsetof(AMaiMultiSpawner, _SpawnedActors) == 0x0003C0, "Member 'AMaiMultiSpawner::_SpawnedActors' has a wrong offset!");
static_assert(offsetof(AMaiMultiSpawner, _SpawnInfo) == 0x0003D0, "Member 'AMaiMultiSpawner::_SpawnInfo' has a wrong offset!");
static_assert(offsetof(AMaiMultiSpawner, _SpawnLimit) == 0x0003E0, "Member 'AMaiMultiSpawner::_SpawnLimit' has a wrong offset!");
static_assert(offsetof(AMaiMultiSpawner, _WaveSpawn) == 0x0003E4, "Member 'AMaiMultiSpawner::_WaveSpawn' has a wrong offset!");

// Class Mai.MaiSlicedTask
// 0x0000 (0x0028 - 0x0028)
class UMaiSlicedTask : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSlicedTask">();
	}
	static class UMaiSlicedTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSlicedTask>();
	}
};
static_assert(alignof(UMaiSlicedTask) == 0x000008, "Wrong alignment on UMaiSlicedTask");
static_assert(sizeof(UMaiSlicedTask) == 0x000028, "Wrong size on UMaiSlicedTask");

// Class Mai.MaiSpawnPawnTask
// 0x0018 (0x0040 - 0x0028)
class UMaiSpawnPawnTask final : public UMaiSlicedTask
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            _Controller;                                       // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APawn*                                  _Pawn;                                             // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSpawnPawnTask">();
	}
	static class UMaiSpawnPawnTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSpawnPawnTask>();
	}
};
static_assert(alignof(UMaiSpawnPawnTask) == 0x000008, "Wrong alignment on UMaiSpawnPawnTask");
static_assert(sizeof(UMaiSpawnPawnTask) == 0x000040, "Wrong size on UMaiSpawnPawnTask");
static_assert(offsetof(UMaiSpawnPawnTask, _Controller) == 0x000030, "Member 'UMaiSpawnPawnTask::_Controller' has a wrong offset!");
static_assert(offsetof(UMaiSpawnPawnTask, _Pawn) == 0x000038, "Member 'UMaiSpawnPawnTask::_Pawn' has a wrong offset!");

// Class Mai.MaiSpawnerManager
// 0x0268 (0x0308 - 0x00A0)
class UMaiSpawnerManager : public UActorComponent
{
public:
	uint8                                         _SaveVersion;                                      // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FMaiSpawnerID> _ActiveSpawners;                                   // 0x00A8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FGuid>       _UniqueActors;                                     // 0x00F8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<struct FGuid, struct FMaiSpawnedActor>   _AllSpawnedActors;                                 // 0x0148(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<struct FGuid, struct FMaiSpawnerData>    _AllSpawners;                                      // 0x0198(0x0050)(Protected, NativeAccessSpecifierProtected)
	int32                                         _NextUid;                                          // 0x01E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1EC[0x4];                                      // 0x01EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AMaiSpawner*>                    _LoadedSpawners;                                   // 0x01F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FMaiWaveSpawn>       _WaveSpawn;                                        // 0x0200(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FTransform>        _NewSpawnedActors;                                 // 0x0250(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AMaiSpawner*>                    _PendingSpawners;                                  // 0x02A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaiSlicedTask*>                 _SlicedTasks;                                      // 0x02B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x20];                                     // 0x02C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _DrawStamp;                                        // 0x02E0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaiSpawnerDebugStamp>          _DebugStamps;                                      // 0x02E8(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnSpawnUniqueActor;                                // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static struct FMaiSpawnerID GetSpawnerIDByRef(class UObject* WorldContext, class AMaiSpawner* Spawner);
	static struct FMaiSpawnerID GetSpawnerIDBySoftRef(class UObject* WorldContext, TSoftObjectPtr<class AMaiSpawner> SoftRef);
	static struct FMaiSpawnerID GetSpawnerIDByTag(class UObject* WorldContext, class FName Tag);
	static struct FMaiSpawnerID GetSpawnerIDFromSpawned(class UObject* WorldContext, class AActor* Spawned);
	static class UMaiSpawnerManager* GetSpawnerManager(const class UObject* WorldContext);

	void AIPrintAllSpawnedActors();
	void AIPrintAllSpawners();
	void AIPrintSpawnedActors();
	void AIPrintSpawnersWithActors();
	class AActor* AISpawnSingle(class FName SpawnerTag);
	void ClearWorldState();
	void DesiredDespawnActor(class AActor* Actor);
	void DespawnActor(class AActor* Actor, bool DisableSpawner, bool ForceDestroy, bool ForgetIt);
	void DespawnByTag(class FName SpawnerTag);
	void DespwnAnyoneWhoWants();
	void DestroyController(class APawn* Actor, bool DisableSpawner);
	void GC();
	void SetWaveSpawn(class FName SpawnerTag, int32 Count, float MinDelay, float MaxDelay);
	void SP_AutoSpawnMode(const struct FMaiSpawnerID& SpawnerID);
	void SP_Despawn(const struct FMaiSpawnerID& SpawnerID, bool ClearActorEntry);
	void SP_DespawnUnique(const struct FGameplayTag& ActorTag);
	void SP_Disable(const struct FMaiSpawnerID& SpawnerID);
	void SP_Enable(const struct FMaiSpawnerID& SpawnerID);
	void SP_ManualSpawnMode(const struct FMaiSpawnerID& SpawnerID);
	void SP_Reincarnate(const struct FMaiSpawnerID& SpawnerID, uint8 HealthPercent);
	void SP_Spawn(const struct FMaiSpawnerID& SpawnerID);
	class AActor* SP_SpawnUnique(const struct FGameplayTag& ActorTag, const struct FMaiSpawnerID& SpawnerID);
	void SpawnAllByTag(class FName SpawnerTag, TArray<class AActor*>* Actors);
	void SpawnByTag(class FName SpawnerTag);
	class AActor* SpawnNearestByTag(class FName SpawnerTag, const struct FVector& Location);
	void StartWaveSpawn(class FName SpawnerTag, int32 Count, float MinDelay, float MaxDelay);
	void StopWaveSpawn(class FName SpawnerTag);

	class AActor* FindOrigin(const class AActor* Actor) const;
	class AMaiSpawner* FindSpawner(const class AActor* Actor) const;
	bool IsLevelLoaded(class AActor* Actor) const;
	class AActor* SP_GetSpawnedActor(const struct FMaiSpawnerID& SpawnerID) const;
	class AMaiSpawner* SP_GetSpawner(const struct FMaiSpawnerID& SpawnerID) const;
	bool SP_HasSpawnedActor(const struct FMaiSpawnerID& SpawnerID) const;
	bool SP_IsActive(const struct FMaiSpawnerID& SpawnerID) const;
	bool SP_IsInAutoSpawnMode(const struct FMaiSpawnerID& SpawnerID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSpawnerManager">();
	}
	static class UMaiSpawnerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSpawnerManager>();
	}
};
static_assert(alignof(UMaiSpawnerManager) == 0x000008, "Wrong alignment on UMaiSpawnerManager");
static_assert(sizeof(UMaiSpawnerManager) == 0x000308, "Wrong size on UMaiSpawnerManager");
static_assert(offsetof(UMaiSpawnerManager, _SaveVersion) == 0x0000A0, "Member 'UMaiSpawnerManager::_SaveVersion' has a wrong offset!");
static_assert(offsetof(UMaiSpawnerManager, _ActiveSpawners) == 0x0000A8, "Member 'UMaiSpawnerManager::_ActiveSpawners' has a wrong offset!");
static_assert(offsetof(UMaiSpawnerManager, _UniqueActors) == 0x0000F8, "Member 'UMaiSpawnerManager::_UniqueActors' has a wrong offset!");
static_assert(offsetof(UMaiSpawnerManager, _AllSpawnedActors) == 0x000148, "Member 'UMaiSpawnerManager::_AllSpawnedActors' has a wrong offset!");
static_assert(offsetof(UMaiSpawnerManager, _AllSpawners) == 0x000198, "Member 'UMaiSpawnerManager::_AllSpawners' has a wrong offset!");
static_assert(offsetof(UMaiSpawnerManager, _NextUid) == 0x0001E8, "Member 'UMaiSpawnerManager::_NextUid' has a wrong offset!");
static_assert(offsetof(UMaiSpawnerManager, _LoadedSpawners) == 0x0001F0, "Member 'UMaiSpawnerManager::_LoadedSpawners' has a wrong offset!");
static_assert(offsetof(UMaiSpawnerManager, _WaveSpawn) == 0x000200, "Member 'UMaiSpawnerManager::_WaveSpawn' has a wrong offset!");
static_assert(offsetof(UMaiSpawnerManager, _NewSpawnedActors) == 0x000250, "Member 'UMaiSpawnerManager::_NewSpawnedActors' has a wrong offset!");
static_assert(offsetof(UMaiSpawnerManager, _PendingSpawners) == 0x0002A0, "Member 'UMaiSpawnerManager::_PendingSpawners' has a wrong offset!");
static_assert(offsetof(UMaiSpawnerManager, _SlicedTasks) == 0x0002B0, "Member 'UMaiSpawnerManager::_SlicedTasks' has a wrong offset!");
static_assert(offsetof(UMaiSpawnerManager, _DrawStamp) == 0x0002E0, "Member 'UMaiSpawnerManager::_DrawStamp' has a wrong offset!");
static_assert(offsetof(UMaiSpawnerManager, _DebugStamps) == 0x0002E8, "Member 'UMaiSpawnerManager::_DebugStamps' has a wrong offset!");
static_assert(offsetof(UMaiSpawnerManager, OnSpawnUniqueActor) == 0x0002F8, "Member 'UMaiSpawnerManager::OnSpawnUniqueActor' has a wrong offset!");

// Class Mai.MaiProjectOnSplineTester
// 0x0000 (0x0570 - 0x0570)
class UMaiProjectOnSplineTester final : public UBillboardComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiProjectOnSplineTester">();
	}
	static class UMaiProjectOnSplineTester* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiProjectOnSplineTester>();
	}
};
static_assert(alignof(UMaiProjectOnSplineTester) == 0x000010, "Wrong alignment on UMaiProjectOnSplineTester");
static_assert(sizeof(UMaiProjectOnSplineTester) == 0x000570, "Wrong size on UMaiProjectOnSplineTester");

// Class Mai.MaiSplineActor
// 0x0010 (0x02C0 - 0x02B0)
class AMaiSplineActor final : public AActor
{
public:
	class USplineComponent*                       Spline;                                            // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _DistanceThreshold;                                // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _MaxIterations;                                    // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FVector ProjectOnSpline(const struct FVector& Location) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSplineActor">();
	}
	static class AMaiSplineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiSplineActor>();
	}
};
static_assert(alignof(AMaiSplineActor) == 0x000008, "Wrong alignment on AMaiSplineActor");
static_assert(sizeof(AMaiSplineActor) == 0x0002C0, "Wrong size on AMaiSplineActor");
static_assert(offsetof(AMaiSplineActor, Spline) == 0x0002B0, "Member 'AMaiSplineActor::Spline' has a wrong offset!");
static_assert(offsetof(AMaiSplineActor, _DistanceThreshold) == 0x0002B8, "Member 'AMaiSplineActor::_DistanceThreshold' has a wrong offset!");
static_assert(offsetof(AMaiSplineActor, _MaxIterations) == 0x0002BC, "Member 'AMaiSplineActor::_MaxIterations' has a wrong offset!");

// Class Mai.MaiSplineFollower
// 0x0028 (0x00C8 - 0x00A0)
class UMaiSplineFollower final : public UActorComponent
{
public:
	class AMaiSplineActor*                        _Spline;                                           // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SplineDist;                                       // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SplineSpeed;                                      // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMaiCharacter*                          _Character;                                        // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _OnMoveFinished;                                   // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class AMaiSplineActor* SpawnSplineToAP(class APawn* Pawn, class AMaiActionPoint* Point);

	void MoveOnSpline(float DeltaTime);
	void RequestSplineMove(class AMaiSplineActor* Spline);
	void SetSpline(class AMaiSplineActor* Spline);
	void StopSplineMove();

	bool IsMoving() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSplineFollower">();
	}
	static class UMaiSplineFollower* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSplineFollower>();
	}
};
static_assert(alignof(UMaiSplineFollower) == 0x000008, "Wrong alignment on UMaiSplineFollower");
static_assert(sizeof(UMaiSplineFollower) == 0x0000C8, "Wrong size on UMaiSplineFollower");
static_assert(offsetof(UMaiSplineFollower, _Spline) == 0x0000A0, "Member 'UMaiSplineFollower::_Spline' has a wrong offset!");
static_assert(offsetof(UMaiSplineFollower, _SplineDist) == 0x0000A8, "Member 'UMaiSplineFollower::_SplineDist' has a wrong offset!");
static_assert(offsetof(UMaiSplineFollower, _SplineSpeed) == 0x0000AC, "Member 'UMaiSplineFollower::_SplineSpeed' has a wrong offset!");
static_assert(offsetof(UMaiSplineFollower, _Character) == 0x0000B0, "Member 'UMaiSplineFollower::_Character' has a wrong offset!");
static_assert(offsetof(UMaiSplineFollower, _OnMoveFinished) == 0x0000B8, "Member 'UMaiSplineFollower::_OnMoveFinished' has a wrong offset!");

// Class Mai.MaiState
// 0x0000 (0x00C8 - 0x00C8)
class UMaiState : public UBeingState
{
public:
	class AAIController* GetOwnerAI() const;
	class ACharacter* GetOwnerCH() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiState">();
	}
	static class UMaiState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiState>();
	}
};
static_assert(alignof(UMaiState) == 0x000008, "Wrong alignment on UMaiState");
static_assert(sizeof(UMaiState) == 0x0000C8, "Wrong size on UMaiState");

// Class Mai.MaiSnapState
// 0x0070 (0x0138 - 0x00C8)
class UMaiSnapState final : public UMaiState
{
public:
	struct FVector                                _SnapTo;                                           // 0x00C8(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x21];                                      // 0x00E0(0x0021)(Fixing Size After Last Property [ Dumper-7 ])
	EEasingFunc                                   _EasingFunc;                                       // 0x0101(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x36];                                     // 0x0102(0x0036)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Config(const struct FVector& Location, class AActor* FaceTo, float Timeout, EEasingFunc EasingFunc);
	void Config2(const struct FVector& Location, const struct FVector& FaceTo, float Timeout, EEasingFunc EasingFunc);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiSnapState">();
	}
	static class UMaiSnapState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiSnapState>();
	}
};
static_assert(alignof(UMaiSnapState) == 0x000008, "Wrong alignment on UMaiSnapState");
static_assert(sizeof(UMaiSnapState) == 0x000138, "Wrong size on UMaiSnapState");
static_assert(offsetof(UMaiSnapState, _SnapTo) == 0x0000C8, "Member 'UMaiSnapState::_SnapTo' has a wrong offset!");
static_assert(offsetof(UMaiSnapState, _EasingFunc) == 0x000101, "Member 'UMaiSnapState::_EasingFunc' has a wrong offset!");

// Class Mai.MaiBlowReactionState
// 0x00B8 (0x0180 - 0x00C8)
class UMaiBlowReactionState final : public UMaiState
{
public:
	struct FMaiHitDifficulty                      _DifficultyConfig[0xA];                            // 0x00C8(0x0010)(Edit, NativeAccessSpecifierPublic)
	uint8                                         _HitCounter;                                       // 0x0168(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _HitResetCooldown;                                 // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           _HitResetHandle;                                   // 0x0170(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _CaptureBlowMSG;                                   // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void IncreaseHits();
	void OnBlowStartMSG(class UMaiMessage* Msg, class AActor* Attacker, TSubclassOf<class UDamageType> DamageClass);
	void OnEnemyBlow(class APawn* Enemy, TSubclassOf<class UDamageType> DamageClass);
	void OnGotHit(class APawn* Enemy, TSubclassOf<class UDamageType> DamageClass);
	void OverrideChanceArray(const TArray<uint8>& _Chances);
	void ResetHitCounter();

	uint8 GetChance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiBlowReactionState">();
	}
	static class UMaiBlowReactionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiBlowReactionState>();
	}
};
static_assert(alignof(UMaiBlowReactionState) == 0x000008, "Wrong alignment on UMaiBlowReactionState");
static_assert(sizeof(UMaiBlowReactionState) == 0x000180, "Wrong size on UMaiBlowReactionState");
static_assert(offsetof(UMaiBlowReactionState, _DifficultyConfig) == 0x0000C8, "Member 'UMaiBlowReactionState::_DifficultyConfig' has a wrong offset!");
static_assert(offsetof(UMaiBlowReactionState, _HitCounter) == 0x000168, "Member 'UMaiBlowReactionState::_HitCounter' has a wrong offset!");
static_assert(offsetof(UMaiBlowReactionState, _HitResetCooldown) == 0x00016C, "Member 'UMaiBlowReactionState::_HitResetCooldown' has a wrong offset!");
static_assert(offsetof(UMaiBlowReactionState, _HitResetHandle) == 0x000170, "Member 'UMaiBlowReactionState::_HitResetHandle' has a wrong offset!");
static_assert(offsetof(UMaiBlowReactionState, _CaptureBlowMSG) == 0x000178, "Member 'UMaiBlowReactionState::_CaptureBlowMSG' has a wrong offset!");

// Class Mai.MaiWasPushedState
// 0x0018 (0x00E0 - 0x00C8)
class UMaiWasPushedState final : public UMaiState
{
public:
	bool                                          _CanBePushed;                                      // 0x00C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  _Other;                                            // 0x00D0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _BBAwayFocus;                                      // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool IsBlockedByOther() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiWasPushedState">();
	}
	static class UMaiWasPushedState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiWasPushedState>();
	}
};
static_assert(alignof(UMaiWasPushedState) == 0x000008, "Wrong alignment on UMaiWasPushedState");
static_assert(sizeof(UMaiWasPushedState) == 0x0000E0, "Wrong size on UMaiWasPushedState");
static_assert(offsetof(UMaiWasPushedState, _CanBePushed) == 0x0000C8, "Member 'UMaiWasPushedState::_CanBePushed' has a wrong offset!");
static_assert(offsetof(UMaiWasPushedState, _Other) == 0x0000D0, "Member 'UMaiWasPushedState::_Other' has a wrong offset!");
static_assert(offsetof(UMaiWasPushedState, _BBAwayFocus) == 0x0000D8, "Member 'UMaiWasPushedState::_BBAwayFocus' has a wrong offset!");

// Class Mai.MaiIsMoveLineToEnemyClearStat
// 0x0000 (0x0128 - 0x0128)
class UMaiIsMoveLineToEnemyClearStat : public UMaiIsLineToEnemyClearStat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiIsMoveLineToEnemyClearStat">();
	}
	static class UMaiIsMoveLineToEnemyClearStat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiIsMoveLineToEnemyClearStat>();
	}
};
static_assert(alignof(UMaiIsMoveLineToEnemyClearStat) == 0x000008, "Wrong alignment on UMaiIsMoveLineToEnemyClearStat");
static_assert(sizeof(UMaiIsMoveLineToEnemyClearStat) == 0x000128, "Wrong size on UMaiIsMoveLineToEnemyClearStat");

// Class Mai.MaiIsShootLineToEnemyClearStat
// 0x0000 (0x0128 - 0x0128)
class UMaiIsShootLineToEnemyClearStat : public UMaiIsLineToEnemyClearStat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiIsShootLineToEnemyClearStat">();
	}
	static class UMaiIsShootLineToEnemyClearStat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiIsShootLineToEnemyClearStat>();
	}
};
static_assert(alignof(UMaiIsShootLineToEnemyClearStat) == 0x000008, "Wrong alignment on UMaiIsShootLineToEnemyClearStat");
static_assert(sizeof(UMaiIsShootLineToEnemyClearStat) == 0x000128, "Wrong size on UMaiIsShootLineToEnemyClearStat");

// Class Mai.MaiTickLODInterface
// 0x0000 (0x0028 - 0x0028)
class IMaiTickLODInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiTickLODInterface">();
	}
	static class IMaiTickLODInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMaiTickLODInterface>();
	}
};
static_assert(alignof(IMaiTickLODInterface) == 0x000008, "Wrong alignment on IMaiTickLODInterface");
static_assert(sizeof(IMaiTickLODInterface) == 0x000028, "Wrong size on IMaiTickLODInterface");

// Class Mai.MaiTickLODComponent
// 0x0058 (0x00F8 - 0x00A0)
class UMaiTickLODComponent : public UActorComponent
{
public:
	EMaiTickLOD                                   _TickLOD;                                          // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UActorComponent*, struct FMaiTickIntervalRange> _ComponentIntervals;                               // 0x00A8(0x0050)(Edit, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void SetComponentMaxInterval(class UActorComponent* Component, float Interval);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiTickLODComponent">();
	}
	static class UMaiTickLODComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiTickLODComponent>();
	}
};
static_assert(alignof(UMaiTickLODComponent) == 0x000008, "Wrong alignment on UMaiTickLODComponent");
static_assert(sizeof(UMaiTickLODComponent) == 0x0000F8, "Wrong size on UMaiTickLODComponent");
static_assert(offsetof(UMaiTickLODComponent, _TickLOD) == 0x0000A0, "Member 'UMaiTickLODComponent::_TickLOD' has a wrong offset!");
static_assert(offsetof(UMaiTickLODComponent, _ComponentIntervals) == 0x0000A8, "Member 'UMaiTickLODComponent::_ComponentIntervals' has a wrong offset!");

// Class Mai.MaiMasterLODComponent
// 0x0028 (0x0120 - 0x00F8)
class UMaiMasterLODComponent final : public UMaiTickLODComponent
{
public:
	struct FMaiTickLODConfig                      _LODConfig[0x3];                                   // 0x00F8(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaiTickLODComponent*                   _SlaveComponent;                                   // 0x0118(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ForceLOD0(bool Force);
	void OnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiMasterLODComponent">();
	}
	static class UMaiMasterLODComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiMasterLODComponent>();
	}
};
static_assert(alignof(UMaiMasterLODComponent) == 0x000008, "Wrong alignment on UMaiMasterLODComponent");
static_assert(sizeof(UMaiMasterLODComponent) == 0x000120, "Wrong size on UMaiMasterLODComponent");
static_assert(offsetof(UMaiMasterLODComponent, _LODConfig) == 0x0000F8, "Member 'UMaiMasterLODComponent::_LODConfig' has a wrong offset!");
static_assert(offsetof(UMaiMasterLODComponent, _SlaveComponent) == 0x000118, "Member 'UMaiMasterLODComponent::_SlaveComponent' has a wrong offset!");

// Class Mai.MaiWallFollowing
// 0x0178 (0x0218 - 0x00A0)
class UMaiWallFollowing final : public UActorComponent
{
public:
	float                                         _MoveTimer;                                        // 0x00A0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _WantedSpeed;                                      // 0x00A4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _GoalLocation;                                     // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _GoalUp;                                           // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 _GoalActor;                                        // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _MoveGoalLocation;                                 // 0x00E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _MoveSubGoalLocation;                              // 0x00F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _SubGoalIndex;                                     // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaiWallPathPoint>              _MovePath;                                         // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _SpeedCurve;                                       // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _FloorCost;                                        // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _WallCost;                                         // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _CeilCost;                                         // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaiOnMeshState                               _OnMeshState;                                      // 0x013C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D[0x3];                                      // 0x013D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _AvoidActor;                                       // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _AvoidRadius;                                      // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _AvoidOffset;                                      // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _AvoidCost;                                        // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _AvoidCountLimit;                                  // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x18];                                     // 0x0158(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _IsUsingLink;                                      // 0x0170(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMaiCharacter*                          _Character;                                        // 0x0178(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x8];                                      // 0x0180(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _PathRebuildDistance;                              // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SubGoalReachedDistance;                           // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SubGoalCheckPeriod;                               // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SubGoalCheckDistance;                             // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _ChangeSurfaceDistance;                            // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             _CollisionChannel;                                 // 0x019C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _UseCollisionChannel;                              // 0x019D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _UseAvoidance;                                     // 0x019E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _AllowUpdateUpVector;                              // 0x019F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SurfaceChangedDelegate;                            // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StartedSqueezeDelegate;                            // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FinishedSqueezeDelegate;                           // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPathRebuild;                                     // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E0[0x38];                                     // 0x01E0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishUsingSurfaceLink();
	bool MoveTo(const struct FVector& GoalLocation);
	void RebuildPath();
	void SnapToFloorMesh(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiWallFollowing">();
	}
	static class UMaiWallFollowing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiWallFollowing>();
	}
};
static_assert(alignof(UMaiWallFollowing) == 0x000008, "Wrong alignment on UMaiWallFollowing");
static_assert(sizeof(UMaiWallFollowing) == 0x000218, "Wrong size on UMaiWallFollowing");
static_assert(offsetof(UMaiWallFollowing, _MoveTimer) == 0x0000A0, "Member 'UMaiWallFollowing::_MoveTimer' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _WantedSpeed) == 0x0000A4, "Member 'UMaiWallFollowing::_WantedSpeed' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _GoalLocation) == 0x0000A8, "Member 'UMaiWallFollowing::_GoalLocation' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _GoalUp) == 0x0000C0, "Member 'UMaiWallFollowing::_GoalUp' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _GoalActor) == 0x0000D8, "Member 'UMaiWallFollowing::_GoalActor' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _MoveGoalLocation) == 0x0000E0, "Member 'UMaiWallFollowing::_MoveGoalLocation' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _MoveSubGoalLocation) == 0x0000F8, "Member 'UMaiWallFollowing::_MoveSubGoalLocation' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _SubGoalIndex) == 0x000110, "Member 'UMaiWallFollowing::_SubGoalIndex' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _MovePath) == 0x000118, "Member 'UMaiWallFollowing::_MovePath' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _SpeedCurve) == 0x000128, "Member 'UMaiWallFollowing::_SpeedCurve' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _FloorCost) == 0x000130, "Member 'UMaiWallFollowing::_FloorCost' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _WallCost) == 0x000134, "Member 'UMaiWallFollowing::_WallCost' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _CeilCost) == 0x000138, "Member 'UMaiWallFollowing::_CeilCost' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _OnMeshState) == 0x00013C, "Member 'UMaiWallFollowing::_OnMeshState' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _AvoidActor) == 0x000140, "Member 'UMaiWallFollowing::_AvoidActor' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _AvoidRadius) == 0x000148, "Member 'UMaiWallFollowing::_AvoidRadius' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _AvoidOffset) == 0x00014C, "Member 'UMaiWallFollowing::_AvoidOffset' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _AvoidCost) == 0x000150, "Member 'UMaiWallFollowing::_AvoidCost' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _AvoidCountLimit) == 0x000154, "Member 'UMaiWallFollowing::_AvoidCountLimit' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _IsUsingLink) == 0x000170, "Member 'UMaiWallFollowing::_IsUsingLink' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _Character) == 0x000178, "Member 'UMaiWallFollowing::_Character' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _PathRebuildDistance) == 0x000188, "Member 'UMaiWallFollowing::_PathRebuildDistance' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _SubGoalReachedDistance) == 0x00018C, "Member 'UMaiWallFollowing::_SubGoalReachedDistance' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _SubGoalCheckPeriod) == 0x000190, "Member 'UMaiWallFollowing::_SubGoalCheckPeriod' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _SubGoalCheckDistance) == 0x000194, "Member 'UMaiWallFollowing::_SubGoalCheckDistance' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _ChangeSurfaceDistance) == 0x000198, "Member 'UMaiWallFollowing::_ChangeSurfaceDistance' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _CollisionChannel) == 0x00019C, "Member 'UMaiWallFollowing::_CollisionChannel' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _UseCollisionChannel) == 0x00019D, "Member 'UMaiWallFollowing::_UseCollisionChannel' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _UseAvoidance) == 0x00019E, "Member 'UMaiWallFollowing::_UseAvoidance' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, _AllowUpdateUpVector) == 0x00019F, "Member 'UMaiWallFollowing::_AllowUpdateUpVector' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, SurfaceChangedDelegate) == 0x0001A0, "Member 'UMaiWallFollowing::SurfaceChangedDelegate' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, StartedSqueezeDelegate) == 0x0001B0, "Member 'UMaiWallFollowing::StartedSqueezeDelegate' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, FinishedSqueezeDelegate) == 0x0001C0, "Member 'UMaiWallFollowing::FinishedSqueezeDelegate' has a wrong offset!");
static_assert(offsetof(UMaiWallFollowing, OnPathRebuild) == 0x0001D0, "Member 'UMaiWallFollowing::OnPathRebuild' has a wrong offset!");

// Class Mai.MaiWallNavGenerator
// 0x04E8 (0x0588 - 0x00A0)
class UMaiWallNavGenerator final : public UActorComponent
{
public:
	TSubclassOf<class UNavigationQueryFilter>     _DefaultNavigationFilterClass;                     // 0x00A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMaiWallNavGeneration                  _GenConfig;                                        // 0x00A8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<int32, class UMaiWallNavTile*>           _Tiles;                                            // 0x00D0(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint32                                        _BuildingTilesNum;                                 // 0x0120(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMaiWallNavDraw                        _DrawConfig;                                       // 0x0124(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AActor>                  _TestPosA;                                         // 0x0168(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  _TestPosB;                                         // 0x0198(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _InnerRadius;                                      // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _OuterRadius;                                      // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Count;                                            // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AActor>                  _AvoidActor;                                       // 0x01D8(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _AvoidDistance;                                    // 0x0208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _AvoidCost;                                        // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _OnFloor;                                          // 0x0210(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _OnWall;                                           // 0x0211(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _OnCeil;                                           // 0x0212(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_213[0x1];                                      // 0x0213(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _FloorCost;                                        // 0x0214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _WallCost;                                         // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _CeilCost;                                         // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_220[0x2F0];                                    // 0x0220(0x02F0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaiWallNavTile*>                _TilesToBuild;                                     // 0x0510(0x0010)(Edit, ZeroConstructor, Transient, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_520[0x68];                                     // 0x0520(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BuildNavMesh();
	void RebuildCell();
	void RebuildNavMesh();
	void Test_SlicedFindPath();

	void Test_CanGoto() const;
	void Test_FindNearest() const;
	void Test_FindPath() const;
	void Test_FindRandomReachable() const;
	void Test_GenerateGrid() const;
	void Test_IsOnNavMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiWallNavGenerator">();
	}
	static class UMaiWallNavGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiWallNavGenerator>();
	}
};
static_assert(alignof(UMaiWallNavGenerator) == 0x000008, "Wrong alignment on UMaiWallNavGenerator");
static_assert(sizeof(UMaiWallNavGenerator) == 0x000588, "Wrong size on UMaiWallNavGenerator");
static_assert(offsetof(UMaiWallNavGenerator, _DefaultNavigationFilterClass) == 0x0000A0, "Member 'UMaiWallNavGenerator::_DefaultNavigationFilterClass' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _GenConfig) == 0x0000A8, "Member 'UMaiWallNavGenerator::_GenConfig' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _Tiles) == 0x0000D0, "Member 'UMaiWallNavGenerator::_Tiles' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _BuildingTilesNum) == 0x000120, "Member 'UMaiWallNavGenerator::_BuildingTilesNum' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _DrawConfig) == 0x000124, "Member 'UMaiWallNavGenerator::_DrawConfig' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _TestPosA) == 0x000168, "Member 'UMaiWallNavGenerator::_TestPosA' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _TestPosB) == 0x000198, "Member 'UMaiWallNavGenerator::_TestPosB' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _InnerRadius) == 0x0001C8, "Member 'UMaiWallNavGenerator::_InnerRadius' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _OuterRadius) == 0x0001CC, "Member 'UMaiWallNavGenerator::_OuterRadius' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _Count) == 0x0001D0, "Member 'UMaiWallNavGenerator::_Count' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _AvoidActor) == 0x0001D8, "Member 'UMaiWallNavGenerator::_AvoidActor' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _AvoidDistance) == 0x000208, "Member 'UMaiWallNavGenerator::_AvoidDistance' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _AvoidCost) == 0x00020C, "Member 'UMaiWallNavGenerator::_AvoidCost' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _OnFloor) == 0x000210, "Member 'UMaiWallNavGenerator::_OnFloor' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _OnWall) == 0x000211, "Member 'UMaiWallNavGenerator::_OnWall' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _OnCeil) == 0x000212, "Member 'UMaiWallNavGenerator::_OnCeil' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _FloorCost) == 0x000214, "Member 'UMaiWallNavGenerator::_FloorCost' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _WallCost) == 0x000218, "Member 'UMaiWallNavGenerator::_WallCost' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _CeilCost) == 0x00021C, "Member 'UMaiWallNavGenerator::_CeilCost' has a wrong offset!");
static_assert(offsetof(UMaiWallNavGenerator, _TilesToBuild) == 0x000510, "Member 'UMaiWallNavGenerator::_TilesToBuild' has a wrong offset!");

// Class Mai.MaiWallNavMeshDataChunk
// 0x0010 (0x0040 - 0x0030)
class UMaiWallNavMeshDataChunk final : public UNavigationDataChunk
{
public:
	TArray<struct FMaiWallMeshTileData>           _Tiles;                                            // 0x0030(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiWallNavMeshDataChunk">();
	}
	static class UMaiWallNavMeshDataChunk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiWallNavMeshDataChunk>();
	}
};
static_assert(alignof(UMaiWallNavMeshDataChunk) == 0x000008, "Wrong alignment on UMaiWallNavMeshDataChunk");
static_assert(sizeof(UMaiWallNavMeshDataChunk) == 0x000040, "Wrong size on UMaiWallNavMeshDataChunk");
static_assert(offsetof(UMaiWallNavMeshDataChunk, _Tiles) == 0x000030, "Member 'UMaiWallNavMeshDataChunk::_Tiles' has a wrong offset!");

// Class Mai.MaiWallNavMesh
// 0x0008 (0x05D8 - 0x05D0)
class AMaiWallNavMesh final : public ARecastNavMesh
{
public:
	class UMaiWallNavGenerator*                   WallMeshGen;                                       // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiWallNavMesh">();
	}
	static class AMaiWallNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiWallNavMesh>();
	}
};
static_assert(alignof(AMaiWallNavMesh) == 0x000008, "Wrong alignment on AMaiWallNavMesh");
static_assert(sizeof(AMaiWallNavMesh) == 0x0005D8, "Wrong size on AMaiWallNavMesh");
static_assert(offsetof(AMaiWallNavMesh, WallMeshGen) == 0x0005D0, "Member 'AMaiWallNavMesh::WallMeshGen' has a wrong offset!");

// Class Mai.MaiWallNavTile
// 0x0738 (0x0760 - 0x0028)
class UMaiWallNavTile final : public UObject
{
public:
	uint8                                         Pad_28[0x5A4];                                     // 0x0028(0x05A4)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _AsyncPhase;                                       // 0x05CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D0[0x8];                                      // 0x05D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMaiWallNavSurface                     _NavSurfs[0x6];                                    // 0x05D8(0x0020)(NativeAccessSpecifierPublic)
	TArray<struct FMaiWallNavContour>             _NavCountours;                                     // 0x0698(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMaiWallNavPolyLink>            _NavLinks;                                         // 0x06A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMaiWallOffMeshConnection>      _NavOffMeshConnections;                            // 0x06B8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         _TileID;                                           // 0x06C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _CellsInRow;                                       // 0x06CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _BoxOrigin;                                        // 0x06D0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _BoxExtent;                                        // 0x06E8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _Margin;                                           // 0x0700(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_704[0x4];                                      // 0x0704(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMaiWallNavGeneration                  _GenConfig;                                        // 0x0708(0x0028)(NativeAccessSpecifierPublic)
	uint8                                         Pad_730[0x30];                                     // 0x0730(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiWallNavTile">();
	}
	static class UMaiWallNavTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiWallNavTile>();
	}
};
static_assert(alignof(UMaiWallNavTile) == 0x000008, "Wrong alignment on UMaiWallNavTile");
static_assert(sizeof(UMaiWallNavTile) == 0x000760, "Wrong size on UMaiWallNavTile");
static_assert(offsetof(UMaiWallNavTile, _AsyncPhase) == 0x0005CC, "Member 'UMaiWallNavTile::_AsyncPhase' has a wrong offset!");
static_assert(offsetof(UMaiWallNavTile, _NavSurfs) == 0x0005D8, "Member 'UMaiWallNavTile::_NavSurfs' has a wrong offset!");
static_assert(offsetof(UMaiWallNavTile, _NavCountours) == 0x000698, "Member 'UMaiWallNavTile::_NavCountours' has a wrong offset!");
static_assert(offsetof(UMaiWallNavTile, _NavLinks) == 0x0006A8, "Member 'UMaiWallNavTile::_NavLinks' has a wrong offset!");
static_assert(offsetof(UMaiWallNavTile, _NavOffMeshConnections) == 0x0006B8, "Member 'UMaiWallNavTile::_NavOffMeshConnections' has a wrong offset!");
static_assert(offsetof(UMaiWallNavTile, _TileID) == 0x0006C8, "Member 'UMaiWallNavTile::_TileID' has a wrong offset!");
static_assert(offsetof(UMaiWallNavTile, _CellsInRow) == 0x0006CC, "Member 'UMaiWallNavTile::_CellsInRow' has a wrong offset!");
static_assert(offsetof(UMaiWallNavTile, _BoxOrigin) == 0x0006D0, "Member 'UMaiWallNavTile::_BoxOrigin' has a wrong offset!");
static_assert(offsetof(UMaiWallNavTile, _BoxExtent) == 0x0006E8, "Member 'UMaiWallNavTile::_BoxExtent' has a wrong offset!");
static_assert(offsetof(UMaiWallNavTile, _Margin) == 0x000700, "Member 'UMaiWallNavTile::_Margin' has a wrong offset!");
static_assert(offsetof(UMaiWallNavTile, _GenConfig) == 0x000708, "Member 'UMaiWallNavTile::_GenConfig' has a wrong offset!");

// Class Mai.MaiWallSystem
// 0x0080 (0x00A8 - 0x0028)
class UMaiWallSystem final : public UObject
{
public:
	TArray<class AMaiWallVolume*>                 _WallVolumes;                                      // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaiPathNodeComponent*>          _AllPathNodes;                                     // 0x0038(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class ANodeGraphTester*>               _PathTesters;                                      // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x50];                                      // 0x0058(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMaiWallSystem* GetWallSystem(class UObject* WorldContext);

	void AIWallMesh_RebuildCell();

	bool FindRandomPointOnWallMesh(struct FVector* Outpoint, float Radius, const struct FVector& Pos, const struct FVector& Up, const struct FVector& Extent) const;
	bool FindReachablePointOnWallMesh(struct FVector* Outpoint, float Radius, const struct FVector& Pos, const struct FVector& Up) const;
	bool IsOnWallMesh(const struct FVector& Pos, const struct FVector& Up, const struct FVector& Extent) const;
	bool ProjectPointOnWallMesh(struct FVector* Outpoint, const struct FVector& Pos, const struct FVector& Up, const struct FVector& Extent, const struct FVector& Offset) const;
	bool RaycastOnWallMesh(struct FVector* HitPoint, const struct FVector& Start, const struct FVector& Destination, const struct FVector& StartUp, const struct FVector& DestUp) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiWallSystem">();
	}
	static class UMaiWallSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiWallSystem>();
	}
};
static_assert(alignof(UMaiWallSystem) == 0x000008, "Wrong alignment on UMaiWallSystem");
static_assert(sizeof(UMaiWallSystem) == 0x0000A8, "Wrong size on UMaiWallSystem");
static_assert(offsetof(UMaiWallSystem, _WallVolumes) == 0x000028, "Member 'UMaiWallSystem::_WallVolumes' has a wrong offset!");
static_assert(offsetof(UMaiWallSystem, _AllPathNodes) == 0x000038, "Member 'UMaiWallSystem::_AllPathNodes' has a wrong offset!");
static_assert(offsetof(UMaiWallSystem, _PathTesters) == 0x000048, "Member 'UMaiWallSystem::_PathTesters' has a wrong offset!");

// Class Mai.MaiWallVolume
// 0x0008 (0x02F0 - 0x02E8)
class AMaiWallVolume final : public AVolume
{
public:
	class UMaiWallNavGenerator*                   WallMeshGen;                                       // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void RegenerateGraph();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiWallVolume">();
	}
	static class AMaiWallVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaiWallVolume>();
	}
};
static_assert(alignof(AMaiWallVolume) == 0x000008, "Wrong alignment on AMaiWallVolume");
static_assert(sizeof(AMaiWallVolume) == 0x0002F0, "Wrong size on AMaiWallVolume");
static_assert(offsetof(AMaiWallVolume, WallMeshGen) == 0x0002E8, "Member 'AMaiWallVolume::WallMeshGen' has a wrong offset!");

// Class Mai.MaiWorkSet
// 0x0010 (0x0040 - 0x0030)
class UMaiWorkSet final : public UDataAsset
{
public:
	TArray<struct FMaiWork>                       _WorkList;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiWorkSet">();
	}
	static class UMaiWorkSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiWorkSet>();
	}
};
static_assert(alignof(UMaiWorkSet) == 0x000008, "Wrong alignment on UMaiWorkSet");
static_assert(sizeof(UMaiWorkSet) == 0x000040, "Wrong size on UMaiWorkSet");
static_assert(offsetof(UMaiWorkSet, _WorkList) == 0x000030, "Member 'UMaiWorkSet::_WorkList' has a wrong offset!");

// Class Mai.EnvQueryItemType_WallPoint
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryItemType_WallPoint final : public UEnvQueryItemType_VectorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryItemType_WallPoint">();
	}
	static class UEnvQueryItemType_WallPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryItemType_WallPoint>();
	}
};
static_assert(alignof(UEnvQueryItemType_WallPoint) == 0x000008, "Wrong alignment on UEnvQueryItemType_WallPoint");
static_assert(sizeof(UEnvQueryItemType_WallPoint) == 0x000030, "Wrong size on UEnvQueryItemType_WallPoint");

// Class Mai.MaiEqsTest_WallMeshProject
// 0x0028 (0x0220 - 0x01F8)
class UMaiEqsTest_WallMeshProject final : public UEnvQueryTest
{
public:
	float                                         ProjectDown;                                       // 0x01F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectUp;                                         // 0x01FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExtentX;                                           // 0x0200(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _UpVector;                                         // 0x0208(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiEqsTest_WallMeshProject">();
	}
	static class UMaiEqsTest_WallMeshProject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiEqsTest_WallMeshProject>();
	}
};
static_assert(alignof(UMaiEqsTest_WallMeshProject) == 0x000008, "Wrong alignment on UMaiEqsTest_WallMeshProject");
static_assert(sizeof(UMaiEqsTest_WallMeshProject) == 0x000220, "Wrong size on UMaiEqsTest_WallMeshProject");
static_assert(offsetof(UMaiEqsTest_WallMeshProject, ProjectDown) == 0x0001F8, "Member 'UMaiEqsTest_WallMeshProject::ProjectDown' has a wrong offset!");
static_assert(offsetof(UMaiEqsTest_WallMeshProject, ProjectUp) == 0x0001FC, "Member 'UMaiEqsTest_WallMeshProject::ProjectUp' has a wrong offset!");
static_assert(offsetof(UMaiEqsTest_WallMeshProject, ExtentX) == 0x000200, "Member 'UMaiEqsTest_WallMeshProject::ExtentX' has a wrong offset!");
static_assert(offsetof(UMaiEqsTest_WallMeshProject, _UpVector) == 0x000208, "Member 'UMaiEqsTest_WallMeshProject::_UpVector' has a wrong offset!");

// Class Mai.MaiEqsTest_WallPathfinding
// 0x00C8 (0x02C0 - 0x01F8)
class UMaiEqsTest_WallPathfinding final : public UEnvQueryTest
{
public:
	EMaiEnvTestPathfinding                        _TestMode;                                         // 0x01F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           _Context;                                          // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               _PathFromContext;                                  // 0x0208(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               _SkipUnreachable;                                  // 0x0240(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              _SearchRadius;                                     // 0x0278(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          _StraightPath;                                     // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     _FilterClass;                                      // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaiEqsTest_WallPathfinding">();
	}
	static class UMaiEqsTest_WallPathfinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaiEqsTest_WallPathfinding>();
	}
};
static_assert(alignof(UMaiEqsTest_WallPathfinding) == 0x000008, "Wrong alignment on UMaiEqsTest_WallPathfinding");
static_assert(sizeof(UMaiEqsTest_WallPathfinding) == 0x0002C0, "Wrong size on UMaiEqsTest_WallPathfinding");
static_assert(offsetof(UMaiEqsTest_WallPathfinding, _TestMode) == 0x0001F8, "Member 'UMaiEqsTest_WallPathfinding::_TestMode' has a wrong offset!");
static_assert(offsetof(UMaiEqsTest_WallPathfinding, _Context) == 0x000200, "Member 'UMaiEqsTest_WallPathfinding::_Context' has a wrong offset!");
static_assert(offsetof(UMaiEqsTest_WallPathfinding, _PathFromContext) == 0x000208, "Member 'UMaiEqsTest_WallPathfinding::_PathFromContext' has a wrong offset!");
static_assert(offsetof(UMaiEqsTest_WallPathfinding, _SkipUnreachable) == 0x000240, "Member 'UMaiEqsTest_WallPathfinding::_SkipUnreachable' has a wrong offset!");
static_assert(offsetof(UMaiEqsTest_WallPathfinding, _SearchRadius) == 0x000278, "Member 'UMaiEqsTest_WallPathfinding::_SearchRadius' has a wrong offset!");
static_assert(offsetof(UMaiEqsTest_WallPathfinding, _StraightPath) == 0x0002B0, "Member 'UMaiEqsTest_WallPathfinding::_StraightPath' has a wrong offset!");
static_assert(offsetof(UMaiEqsTest_WallPathfinding, _FilterClass) == 0x0002B8, "Member 'UMaiEqsTest_WallPathfinding::_FilterClass' has a wrong offset!");

}

