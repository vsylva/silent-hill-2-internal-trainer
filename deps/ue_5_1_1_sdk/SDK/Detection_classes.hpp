#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Detection

#include "Basic.hpp"

#include "Detection_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Class Detection.DetectableBaseComponent
// 0x0030 (0x02D0 - 0x02A0)
#pragma pack(push, 0x1)
class alignas(0x10) UDetectableBaseComponent : public USceneComponent
{
public:
	class UShapeComponent*                        Shape;                                             // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDetectableShapeDiscoveryMethod               DiscoveryMethod;                                   // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDetectableShapeDiscoveryScope                DiscoveryScope;                                    // 0x02A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AA[0x2];                                      // 0x02AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DiscoveryShapeName;                                // 0x02AC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UShapeComponent*                        SelectedShape;                                     // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindShape(class UShapeComponent* NewShape);
	class UShapeComponent* GetShape();
	class UBoxComponent* GetShapeAsBox();
	class UCapsuleComponent* GetShapeAsCapsule();
	class USphereComponent* GetShapeAsSphere();

	bool ContainsPoint(const struct FVector& WorldLocation) const;
	bool HasShape() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DetectableBaseComponent">();
	}
	static class UDetectableBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDetectableBaseComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UDetectableBaseComponent) == 0x000010, "Wrong alignment on UDetectableBaseComponent");
static_assert(sizeof(UDetectableBaseComponent) == 0x0002D0, "Wrong size on UDetectableBaseComponent");
static_assert(offsetof(UDetectableBaseComponent, Shape) == 0x0002A0, "Member 'UDetectableBaseComponent::Shape' has a wrong offset!");
static_assert(offsetof(UDetectableBaseComponent, DiscoveryMethod) == 0x0002A8, "Member 'UDetectableBaseComponent::DiscoveryMethod' has a wrong offset!");
static_assert(offsetof(UDetectableBaseComponent, DiscoveryScope) == 0x0002A9, "Member 'UDetectableBaseComponent::DiscoveryScope' has a wrong offset!");
static_assert(offsetof(UDetectableBaseComponent, DiscoveryShapeName) == 0x0002AC, "Member 'UDetectableBaseComponent::DiscoveryShapeName' has a wrong offset!");
static_assert(offsetof(UDetectableBaseComponent, SelectedShape) == 0x0002B8, "Member 'UDetectableBaseComponent::SelectedShape' has a wrong offset!");

// Class Detection.RaycastDetectableComponent
// 0x04B0 (0x0780 - 0x02D0)
class URaycastDetectableComponent : public UDetectableBaseComponent
{
public:
	FMulticastInlineDelegateProperty_             OnDetectedBy;                                      // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnLostBy;                                          // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRaycastDetectableChannelConfig> ChannelConfigs;                                    // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x488];                                    // 0x02F8(0x0488)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DetectedBy__DelegateSignature(class AActor* Detector, ECollisionChannel CollisionChannel, const struct FRaycastDetectableDetectEventData& Data, const struct FHitResult& HitResult);
	void DisableDetection();
	bool DisableDetectionOnChannel(const ECollisionChannel CollisionChannel);
	void EnableDetection();
	bool EnableDetectionOnChannel(const ECollisionChannel CollisionChannel);
	bool GetWasEverDetected();
	void LoseDetectors();
	void LoseDetectorsOnChannel(const ECollisionChannel CollisionChannel);
	void LostBy__DelegateSignature(class AActor* Detector, ECollisionChannel CollisionChannel, const struct FRaycastDetectableLoseEventData& Data);

	bool CanBeDetectedByActor(class AActor* Detector, const float Distance) const;
	bool CanBeDetectedByActorOnChannel(class AActor* Detector, const ECollisionChannel CollisionChannel, const float Distance) const;
	bool CanBeDetectedOnChannel(const ECollisionChannel CollisionChannel) const;
	ERaycastDetectableDistanceMethod GetDistanceMethodForChannel(const ECollisionChannel CollisionChannel) const;
	bool IsDetectedByActor(class AActor* Detector) const;
	bool IsDetectedByActorOnChannel(class AActor* Detector, const ECollisionChannel CollisionChannel) const;
	bool IsDetectedOnChannel(const ECollisionChannel CollisionChannel) const;
	bool IsUsingChannel(const ECollisionChannel CollisionChannel, const bool MustBeEnabled) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaycastDetectableComponent">();
	}
	static class URaycastDetectableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaycastDetectableComponent>();
	}
};
static_assert(alignof(URaycastDetectableComponent) == 0x000010, "Wrong alignment on URaycastDetectableComponent");
static_assert(sizeof(URaycastDetectableComponent) == 0x000780, "Wrong size on URaycastDetectableComponent");
static_assert(offsetof(URaycastDetectableComponent, OnDetectedBy) == 0x0002C8, "Member 'URaycastDetectableComponent::OnDetectedBy' has a wrong offset!");
static_assert(offsetof(URaycastDetectableComponent, OnLostBy) == 0x0002D8, "Member 'URaycastDetectableComponent::OnLostBy' has a wrong offset!");
static_assert(offsetof(URaycastDetectableComponent, ChannelConfigs) == 0x0002E8, "Member 'URaycastDetectableComponent::ChannelConfigs' has a wrong offset!");

// Class Detection.RaycastDetectorComponent
// 0x0110 (0x01B0 - 0x00A0)
class URaycastDetectorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x110];                                     // 0x00A0(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LoseDetectedObjects(struct FRaycastDetectorTraceData* Data);
	void ProcessData(struct FRaycastDetectorTraceData* Data, const struct FVector& TraceStart, const struct FVector& TraceEnd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaycastDetectorComponent">();
	}
	static class URaycastDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaycastDetectorComponent>();
	}
};
static_assert(alignof(URaycastDetectorComponent) == 0x000008, "Wrong alignment on URaycastDetectorComponent");
static_assert(sizeof(URaycastDetectorComponent) == 0x0001B0, "Wrong size on URaycastDetectorComponent");

// Class Detection.ScreenDetectableComponent
// 0x0320 (0x05F0 - 0x02D0)
class UScreenDetectableComponent : public UDetectableBaseComponent
{
public:
	FMulticastInlineDelegateProperty_             OnDetected;                                        // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnLost;                                            // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	EScreenDetectableCheckQuality                 Quality;                                           // 0x02E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseTraces;                                         // 0x02E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             TraceChannel;                                      // 0x02EA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          LimitTraceRange;                                   // 0x02EB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TraceRange;                                        // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          LimitTraceAngle;                                   // 0x0300(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceAngle;                                        // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          StartEnabled;                                      // 0x0308(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DrawDebug;                                         // 0x0309(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30A[0x6];                                      // 0x030A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        RelativeCheckLocations;                            // 0x0310(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	EScreenDetectableStatus                       CurrentStatus;                                     // 0x0320(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_321[0x2CF];                                    // 0x0321(0x02CF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Detected__DelegateSignature(class UScreenDetectableComponent* Detectable);
	void Lost__DelegateSignature(class UScreenDetectableComponent* Detectable);
	void SetDetectionEnabled(class UObject* Object, const bool Enabled);

	EScreenDetectableStatus GetCurrentStatus() const;
	bool IsDetected() const;
	bool IsDetectionEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenDetectableComponent">();
	}
	static class UScreenDetectableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenDetectableComponent>();
	}
};
static_assert(alignof(UScreenDetectableComponent) == 0x000010, "Wrong alignment on UScreenDetectableComponent");
static_assert(sizeof(UScreenDetectableComponent) == 0x0005F0, "Wrong size on UScreenDetectableComponent");
static_assert(offsetof(UScreenDetectableComponent, OnDetected) == 0x0002C8, "Member 'UScreenDetectableComponent::OnDetected' has a wrong offset!");
static_assert(offsetof(UScreenDetectableComponent, OnLost) == 0x0002D8, "Member 'UScreenDetectableComponent::OnLost' has a wrong offset!");
static_assert(offsetof(UScreenDetectableComponent, Quality) == 0x0002E8, "Member 'UScreenDetectableComponent::Quality' has a wrong offset!");
static_assert(offsetof(UScreenDetectableComponent, UseTraces) == 0x0002E9, "Member 'UScreenDetectableComponent::UseTraces' has a wrong offset!");
static_assert(offsetof(UScreenDetectableComponent, TraceChannel) == 0x0002EA, "Member 'UScreenDetectableComponent::TraceChannel' has a wrong offset!");
static_assert(offsetof(UScreenDetectableComponent, LimitTraceRange) == 0x0002EB, "Member 'UScreenDetectableComponent::LimitTraceRange' has a wrong offset!");
static_assert(offsetof(UScreenDetectableComponent, TraceRange) == 0x0002F0, "Member 'UScreenDetectableComponent::TraceRange' has a wrong offset!");
static_assert(offsetof(UScreenDetectableComponent, LimitTraceAngle) == 0x000300, "Member 'UScreenDetectableComponent::LimitTraceAngle' has a wrong offset!");
static_assert(offsetof(UScreenDetectableComponent, TraceAngle) == 0x000304, "Member 'UScreenDetectableComponent::TraceAngle' has a wrong offset!");
static_assert(offsetof(UScreenDetectableComponent, StartEnabled) == 0x000308, "Member 'UScreenDetectableComponent::StartEnabled' has a wrong offset!");
static_assert(offsetof(UScreenDetectableComponent, DrawDebug) == 0x000309, "Member 'UScreenDetectableComponent::DrawDebug' has a wrong offset!");
static_assert(offsetof(UScreenDetectableComponent, RelativeCheckLocations) == 0x000310, "Member 'UScreenDetectableComponent::RelativeCheckLocations' has a wrong offset!");
static_assert(offsetof(UScreenDetectableComponent, CurrentStatus) == 0x000320, "Member 'UScreenDetectableComponent::CurrentStatus' has a wrong offset!");

}

