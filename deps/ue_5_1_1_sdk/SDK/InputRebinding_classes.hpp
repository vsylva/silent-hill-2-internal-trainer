#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: InputRebinding

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "InputRebinding_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class InputRebinding.InputRebindingSaveData
// 0x0028 (0x0050 - 0x0028)
class UInputRebindingSaveData final : public USaveGame
{
public:
	struct FBindingList                           BindingList;                                       // 0x0028(0x0028)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputRebindingSaveData">();
	}
	static class UInputRebindingSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputRebindingSaveData>();
	}
};
static_assert(alignof(UInputRebindingSaveData) == 0x000008, "Wrong alignment on UInputRebindingSaveData");
static_assert(sizeof(UInputRebindingSaveData) == 0x000050, "Wrong size on UInputRebindingSaveData");
static_assert(offsetof(UInputRebindingSaveData, BindingList) == 0x000028, "Member 'UInputRebindingSaveData::BindingList' has a wrong offset!");

// Class InputRebinding.InputRebindingSettings
// 0x0068 (0x00A0 - 0x0038)
class UInputRebindingSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UUE4KeyNames>            KeyNames;                                          // 0x0038(0x0030)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMappingDisplayInfo>     ActionNames;                                       // 0x0068(0x0030)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AllowModifierKeyBinding;                           // 0x0098(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputRebindingSettings">();
	}
	static class UInputRebindingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputRebindingSettings>();
	}
};
static_assert(alignof(UInputRebindingSettings) == 0x000008, "Wrong alignment on UInputRebindingSettings");
static_assert(sizeof(UInputRebindingSettings) == 0x0000A0, "Wrong size on UInputRebindingSettings");
static_assert(offsetof(UInputRebindingSettings, KeyNames) == 0x000038, "Member 'UInputRebindingSettings::KeyNames' has a wrong offset!");
static_assert(offsetof(UInputRebindingSettings, ActionNames) == 0x000068, "Member 'UInputRebindingSettings::ActionNames' has a wrong offset!");
static_assert(offsetof(UInputRebindingSettings, AllowModifierKeyBinding) == 0x000098, "Member 'UInputRebindingSettings::AllowModifierKeyBinding' has a wrong offset!");

// Class InputRebinding.MappingDisplayInfo
// 0x00A8 (0x00D8 - 0x0030)
class UMappingDisplayInfo final : public UDataAsset
{
public:
	TArray<struct FActionDisplayInfo>             ActionInfos;                                       // 0x0030(0x0010)(Edit, EditFixedSize, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAxisDisplayInfo>               AxisInfos;                                         // 0x0040(0x0010)(Edit, EditFixedSize, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FToggleableInfo>                Toggleable;                                        // 0x0050(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAnalogAxisInfo>                AnalogAxisInfos;                                   // 0x0060(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseInputStates;                                   // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInputState>                    InputStates;                                       // 0x0078(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<struct FUE4InputHandle, struct FInputState> ActionNonConflicts;                                // 0x0088(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MappingDisplayInfo">();
	}
	static class UMappingDisplayInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMappingDisplayInfo>();
	}
};
static_assert(alignof(UMappingDisplayInfo) == 0x000008, "Wrong alignment on UMappingDisplayInfo");
static_assert(sizeof(UMappingDisplayInfo) == 0x0000D8, "Wrong size on UMappingDisplayInfo");
static_assert(offsetof(UMappingDisplayInfo, ActionInfos) == 0x000030, "Member 'UMappingDisplayInfo::ActionInfos' has a wrong offset!");
static_assert(offsetof(UMappingDisplayInfo, AxisInfos) == 0x000040, "Member 'UMappingDisplayInfo::AxisInfos' has a wrong offset!");
static_assert(offsetof(UMappingDisplayInfo, Toggleable) == 0x000050, "Member 'UMappingDisplayInfo::Toggleable' has a wrong offset!");
static_assert(offsetof(UMappingDisplayInfo, AnalogAxisInfos) == 0x000060, "Member 'UMappingDisplayInfo::AnalogAxisInfos' has a wrong offset!");
static_assert(offsetof(UMappingDisplayInfo, bUseInputStates) == 0x000070, "Member 'UMappingDisplayInfo::bUseInputStates' has a wrong offset!");
static_assert(offsetof(UMappingDisplayInfo, InputStates) == 0x000078, "Member 'UMappingDisplayInfo::InputStates' has a wrong offset!");
static_assert(offsetof(UMappingDisplayInfo, ActionNonConflicts) == 0x000088, "Member 'UMappingDisplayInfo::ActionNonConflicts' has a wrong offset!");

// Class InputRebinding.RebindableInput
// 0x00C8 (0x00F0 - 0x0028)
class URebindableInput final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             PreSaveCreation;                                   // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             PostSaveCreation;                                  // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             PreLoad;                                           // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             PostLoad;                                          // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x60];                                      // 0x0068(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBindingList                           BindingList;                                       // 0x00C8(0x0028)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RebindableInput">();
	}
	static class URebindableInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<URebindableInput>();
	}
};
static_assert(alignof(URebindableInput) == 0x000008, "Wrong alignment on URebindableInput");
static_assert(sizeof(URebindableInput) == 0x0000F0, "Wrong size on URebindableInput");
static_assert(offsetof(URebindableInput, PreSaveCreation) == 0x000028, "Member 'URebindableInput::PreSaveCreation' has a wrong offset!");
static_assert(offsetof(URebindableInput, PostSaveCreation) == 0x000038, "Member 'URebindableInput::PostSaveCreation' has a wrong offset!");
static_assert(offsetof(URebindableInput, PreLoad) == 0x000048, "Member 'URebindableInput::PreLoad' has a wrong offset!");
static_assert(offsetof(URebindableInput, PostLoad) == 0x000058, "Member 'URebindableInput::PostLoad' has a wrong offset!");
static_assert(offsetof(URebindableInput, BindingList) == 0x0000C8, "Member 'URebindableInput::BindingList' has a wrong offset!");

// Class InputRebinding.UE4KeyTexts
// 0x0010 (0x0040 - 0x0030)
class UUE4KeyTexts : public UDataAsset
{
public:
	TArray<struct FUE4KeyName>                    Keys;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UE4KeyTexts">();
	}
	static class UUE4KeyTexts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUE4KeyTexts>();
	}
};
static_assert(alignof(UUE4KeyTexts) == 0x000008, "Wrong alignment on UUE4KeyTexts");
static_assert(sizeof(UUE4KeyTexts) == 0x000040, "Wrong size on UUE4KeyTexts");
static_assert(offsetof(UUE4KeyTexts, Keys) == 0x000030, "Member 'UUE4KeyTexts::Keys' has a wrong offset!");

// Class InputRebinding.UE4KeyNames
// 0x0000 (0x0040 - 0x0040)
class UUE4KeyNames final : public UUE4KeyTexts
{
public:
	static class FText GetKeyTranslatedDisplayName(const struct FKey& Key);
	static class FText GetKeyTranslatedText(const struct FKey& Key, bool UseKeyTag, bool UseTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UE4KeyNames">();
	}
	static class UUE4KeyNames* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUE4KeyNames>();
	}
};
static_assert(alignof(UUE4KeyNames) == 0x000008, "Wrong alignment on UUE4KeyNames");
static_assert(sizeof(UUE4KeyNames) == 0x000040, "Wrong size on UUE4KeyNames");

}

