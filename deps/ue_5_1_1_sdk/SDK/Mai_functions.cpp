#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Mai

#include "Basic.hpp"

#include "Mai_classes.hpp"
#include "Mai_parameters.hpp"


namespace SDK
{

// Function Mai.MaiAction.SetActionName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAction::SetActionName(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction", "SetActionName");

	Params::MaiAction_SetActionName Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAction.GetActionName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMaiAction::GetActionName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction", "GetActionName");

	Params::MaiAction_GetActionName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAction.IsActionFinished
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiAction::IsActionFinished() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction", "IsActionFinished");

	Params::MaiAction_IsActionFinished Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCrowdAgent.InitializeCrowd
// (Final, Native, Public, BlueprintCallable)

void UMaiCrowdAgent::InitializeCrowd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCrowdAgent", "InitializeCrowd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiActionGraph.FindNearestPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiActionPoint*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiActionPoint* AMaiActionGraph::FindNearestPoint(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionGraph", "FindNearestPoint");

	Params::MaiActionGraph_FindNearestPoint Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiActionGraph.GetActionPointCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMaiActionGraph::GetActionPointCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionGraph", "GetActionPointCount");

	Params::MaiActionGraph_GetActionPointCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiActionGraph.GetActionPoints
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AMaiActionPoint*>          ActionPoints                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AMaiActionGraph::GetActionPoints(TArray<class AMaiActionPoint*>* ActionPoints) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionGraph", "GetActionPoints");

	Params::MaiActionGraph_GetActionPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ActionPoints != nullptr)
		*ActionPoints = std::move(Parms.ActionPoints);
}


// Function Mai.MaiActionGraph.GetActionPointsWithQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AMaiActionPoint*>          ActionPoints                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FMaiActionPointQuery             Query                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AMaiActionGraph::GetActionPointsWithQuery(TArray<class AMaiActionPoint*>* ActionPoints, const struct FMaiActionPointQuery& Query) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionGraph", "GetActionPointsWithQuery");

	Params::MaiActionGraph_GetActionPointsWithQuery Parms{};

	Parms.Query = std::move(Query);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ActionPoints != nullptr)
		*ActionPoints = std::move(Parms.ActionPoints);
}


// Function Mai.MaiActionGraph.GetNextActionPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMaiActionPoint*                  Ap                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SequenceTag                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiActionPoint*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiActionPoint* AMaiActionGraph::GetNextActionPoint(class AMaiActionPoint* Ap, class FName SequenceTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionGraph", "GetNextActionPoint");

	Params::MaiActionGraph_GetNextActionPoint Parms{};

	Parms.Ap = Ap;
	Parms.SequenceTag = SequenceTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiActionGraph.GetSequenceActionPoints
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AMaiActionPoint*>          ActionPoints                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FName                             SequenceTag                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiActionGraph::GetSequenceActionPoints(TArray<class AMaiActionPoint*>* ActionPoints, class FName SequenceTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionGraph", "GetSequenceActionPoints");

	Params::MaiActionGraph_GetSequenceActionPoints Parms{};

	Parms.SequenceTag = SequenceTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ActionPoints != nullptr)
		*ActionPoints = std::move(Parms.ActionPoints);
}


// Function Mai.MaiPointGraphComponent.FindNearestPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiActionPoint*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiActionPoint* UMaiPointGraphComponent::FindNearestPoint(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiPointGraphComponent", "FindNearestPoint");

	Params::MaiPointGraphComponent_FindNearestPoint Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiPointGraphComponent.GetActionPointCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMaiPointGraphComponent::GetActionPointCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiPointGraphComponent", "GetActionPointCount");

	Params::MaiPointGraphComponent_GetActionPointCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiPointGraphComponent.GetActionPoints
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AMaiActionPoint*>          ActionPoints                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FName                             WithTag                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiPointGraphComponent::GetActionPoints(TArray<class AMaiActionPoint*>* ActionPoints, class FName WithTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiPointGraphComponent", "GetActionPoints");

	Params::MaiPointGraphComponent_GetActionPoints Parms{};

	Parms.WithTag = WithTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ActionPoints != nullptr)
		*ActionPoints = std::move(Parms.ActionPoints);
}


// Function Mai.MaiPointGraphComponent.GetActionPointsWithQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AMaiActionPoint*>          ActionPoints                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FMaiActionPointQuery             Query                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMaiPointGraphComponent::GetActionPointsWithQuery(TArray<class AMaiActionPoint*>* ActionPoints, const struct FMaiActionPointQuery& Query) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiPointGraphComponent", "GetActionPointsWithQuery");

	Params::MaiPointGraphComponent_GetActionPointsWithQuery Parms{};

	Parms.Query = std::move(Query);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ActionPoints != nullptr)
		*ActionPoints = std::move(Parms.ActionPoints);
}


// Function Mai.MaiPointGraphComponent.GetRandomActionPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMaiActionPoint*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiActionPoint* UMaiPointGraphComponent::GetRandomActionPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiPointGraphComponent", "GetRandomActionPoint");

	Params::MaiPointGraphComponent_GetRandomActionPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiActionSequenceComponent.GetNextActionPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMaiActionPoint*                  Point                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ConditionCaller                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiActionPoint*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiActionPoint* UMaiActionSequenceComponent::GetNextActionPoint(class AMaiActionPoint* Point, class APawn* ConditionCaller) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionSequenceComponent", "GetNextActionPoint");

	Params::MaiActionSequenceComponent_GetNextActionPoint Parms{};

	Parms.Point = Point;
	Parms.ConditionCaller = ConditionCaller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiActionSequenceComponent.GetSequenceActionPoints
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AMaiActionPoint*>          Points                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMaiActionSequenceComponent::GetSequenceActionPoints(TArray<class AMaiActionPoint*>* Points) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionSequenceComponent", "GetSequenceActionPoints");

	Params::MaiActionSequenceComponent_GetSequenceActionPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Points != nullptr)
		*Points = std::move(Parms.Points);
}


// Function Mai.MaiActionSequenceComponent.GetTargetActionPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMaiActionPoint*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiActionPoint* UMaiActionSequenceComponent::GetTargetActionPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionSequenceComponent", "GetTargetActionPoint");

	Params::MaiActionSequenceComponent_GetTargetActionPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiActionPoint.OnActionPointAbandoned
// (Event, Public, BlueprintEvent)
// Parameters:
// class AMaiController*                   User                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiActionPoint::OnActionPointAbandoned(class AMaiController* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionPoint", "OnActionPointAbandoned");

	Params::MaiActionPoint_OnActionPointAbandoned Parms{};

	Parms.User = User;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiActionPoint.OnActionPointReached
// (Event, Public, BlueprintEvent)
// Parameters:
// class AMaiController*                   User                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiActionPoint::OnActionPointReached(class AMaiController* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionPoint", "OnActionPointReached");

	Params::MaiActionPoint_OnActionPointReached Parms{};

	Parms.User = User;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiActionPoint.OnActionPointSelected
// (Event, Public, BlueprintEvent)
// Parameters:
// class AMaiController*                   User                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiActionPoint::OnActionPointSelected(class AMaiController* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionPoint", "OnActionPointSelected");

	Params::MaiActionPoint_OnActionPointSelected Parms{};

	Parms.User = User;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiActionPoint.OnPlaceInWorld
// (Event, Public, BlueprintEvent)

void AMaiActionPoint::OnPlaceInWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionPoint", "OnPlaceInWorld");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Mai.MaiActionPoint.PrepareActionSet
// (Event, Public, BlueprintEvent)
// Parameters:
// class AMaiController*                   User                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiActionPoint::PrepareActionSet(class AMaiController* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionPoint", "PrepareActionSet");

	Params::MaiActionPoint_PrepareActionSet Parms{};

	Parms.User = User;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiActionPoint.PrepareToWork
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AMaiController*                   User                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiActionPoint::PrepareToWork(class AMaiController* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionPoint", "PrepareToWork");

	Params::MaiActionPoint_PrepareToWork Parms{};

	Parms.User = User;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiActionPoint.ResetUseCounter
// (Final, Native, Public, BlueprintCallable)

void AMaiActionPoint::ResetUseCounter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionPoint", "ResetUseCounter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiActionPoint.Used
// (Final, Native, Public, BlueprintCallable)

void AMaiActionPoint::Used()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionPoint", "Used");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiActionPoint.CanBeUsedBy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMaiController*                   User                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiActionPoint::CanBeUsedBy(class AMaiController* User) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionPoint", "CanBeUsedBy");

	Params::MaiActionPoint_CanBeUsedBy Parms{};

	Parms.User = User;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiActionPoint.GetActionRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AMaiActionPoint::GetActionRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionPoint", "GetActionRotation");

	Params::MaiActionPoint_GetActionRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiActionPoint.GetSequence
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             SequenceTag                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiActionSequenceComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiActionSequenceComponent* AMaiActionPoint::GetSequence(class FName SequenceTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionPoint", "GetSequence");

	Params::MaiActionPoint_GetSequence Parms{};

	Parms.SequenceTag = SequenceTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiActionPoint.GetWeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 AMaiActionPoint::GetWeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionPoint", "GetWeight");

	Params::MaiActionPoint_GetWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiActionPoint.HasAnyWork
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiActionPoint::HasAnyWork() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionPoint", "HasAnyWork");

	Params::MaiActionPoint_HasAnyWork Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiActionPoint.InDetectionArea
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AreaExtent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiActionPoint::InDetectionArea(const struct FVector& Location, float AreaExtent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionPoint", "InDetectionArea");

	Params::MaiActionPoint_InDetectionArea Parms{};

	Parms.Location = std::move(Location);
	Parms.AreaExtent = AreaExtent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiActionPoint.IsUsable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiActionPoint::IsUsable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionPoint", "IsUsable");

	Params::MaiActionPoint_IsUsable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiActionPoint.IsUsableBy
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class AMaiController*                   User                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiActionPoint::IsUsableBy(class AMaiController* User) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionPoint", "IsUsableBy");

	Params::MaiActionPoint_IsUsableBy Parms{};

	Parms.User = User;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiActionPoint.IsVisibleFrom
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultVisibilityRange                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PerceptionMod                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiActionPoint::IsVisibleFrom(const struct FVector& Location, float DefaultVisibilityRange, float PerceptionMod) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiActionPoint", "IsVisibleFrom");

	Params::MaiActionPoint_IsVisibleFrom Parms{};

	Parms.Location = std::move(Location);
	Parms.DefaultVisibilityRange = DefaultVisibilityRange;
	Parms.PerceptionMod = PerceptionMod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiNavBox.DisableArea
// (Final, Native, Public, BlueprintCallable)

void UMaiNavBox::DisableArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavBox", "DisableArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNavBox.EnableArea
// (Final, Native, Public, BlueprintCallable)

void UMaiNavBox::EnableArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavBox", "EnableArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNavBox.SetAreaClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UNavArea>             NewAreaClass                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiNavBox::SetAreaClass(TSubclassOf<class UNavArea> NewAreaClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavBox", "SetAreaClass");

	Params::MaiNavBox_SetAreaClass Parms{};

	Parms.NewAreaClass = NewAreaClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNavBox.IsInArea
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiNavBox::IsInArea(const struct FVector& Location, float Extent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavBox", "IsInArea");

	Params::MaiNavBox_IsInArea Parms{};

	Parms.Location = std::move(Location);
	Parms.Extent = Extent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiNarrowTriggerBox.OnOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMaiNarrowTriggerBox::OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNarrowTriggerBox", "OnOverlapBegin");

	Params::MaiNarrowTriggerBox_OnOverlapBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNarrowTriggerBox.OnOverlapEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiNarrowTriggerBox::OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNarrowTriggerBox", "OnOverlapEnd");

	Params::MaiNarrowTriggerBox_OnOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAction_AnimationBase.OnOwnerMontageEnds
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAction_AnimationBase::OnOwnerMontageEnds(class UAnimMontage* Montage, bool Interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction_AnimationBase", "OnOwnerMontageEnds");

	Params::MaiAction_AnimationBase_OnOwnerMontageEnds Parms{};

	Parms.Montage = Montage;
	Parms.Interrupted = Interrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAction_AnimationBase.SetOwnerCH
// (Native, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       OwnerCH                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAction_AnimationBase::SetOwnerCH(class ACharacter* OwnerCH)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction_AnimationBase", "SetOwnerCH");

	Params::MaiAction_AnimationBase_SetOwnerCH Parms{};

	Parms.OwnerCH = OwnerCH;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAction_AnimationBase.SetOwnerMontage
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAction_AnimationBase::SetOwnerMontage(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction_AnimationBase", "SetOwnerMontage");

	Params::MaiAction_AnimationBase_SetOwnerMontage Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAction_SynchronizationBase.OnOtherMontageEnds
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAction_SynchronizationBase::OnOtherMontageEnds(class UAnimMontage* Montage, bool Interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction_SynchronizationBase", "OnOtherMontageEnds");

	Params::MaiAction_SynchronizationBase_OnOtherMontageEnds Parms{};

	Parms.Montage = Montage;
	Parms.Interrupted = Interrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAction_SynchronizationBase.PossessOther
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UMaiAction_SynchronizationBase::PossessOther()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction_SynchronizationBase", "PossessOther");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAction_SynchronizationBase.ReleaseOther
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UMaiAction_SynchronizationBase::ReleaseOther()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction_SynchronizationBase", "ReleaseOther");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAction_SynchronizationBase.SetOtherCH
// (Native, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       OtherCH                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAction_SynchronizationBase::SetOtherCH(class ACharacter* OtherCH)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction_SynchronizationBase", "SetOtherCH");

	Params::MaiAction_SynchronizationBase_SetOtherCH Parms{};

	Parms.OtherCH = OtherCH;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAction_SynchronizationBase.SetOtherMontage
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAction_SynchronizationBase::SetOtherMontage(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction_SynchronizationBase", "SetOtherMontage");

	Params::MaiAction_SynchronizationBase_SetOtherMontage Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAction_Snap2Base.OnSectionEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             Section                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAction_Snap2Base::OnSectionEnd(class FName Section)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction_Snap2Base", "OnSectionEnd");

	Params::MaiAction_Snap2Base_OnSectionEnd Parms{};

	Parms.Section = Section;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiAction_Snap2Base.OnSectionStart
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             Section                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAction_Snap2Base::OnSectionStart(class FName Section)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction_Snap2Base", "OnSectionStart");

	Params::MaiAction_Snap2Base_OnSectionStart Parms{};

	Parms.Section = Section;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiAction_Snap1Base.CalculateIdealTransforms
// (Native, Public, BlueprintCallable)

void UMaiAction_Snap1Base::CalculateIdealTransforms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction_Snap1Base", "CalculateIdealTransforms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAction_Snap1Base.OnSectionEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             Section                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAction_Snap1Base::OnSectionEnd(class FName Section)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction_Snap1Base", "OnSectionEnd");

	Params::MaiAction_Snap1Base_OnSectionEnd Parms{};

	Parms.Section = Section;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiAction_Snap1Base.OnSectionStart
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             Section                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAction_Snap1Base::OnSectionStart(class FName Section)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction_Snap1Base", "OnSectionStart");

	Params::MaiAction_Snap1Base_OnSectionStart Parms{};

	Parms.Section = Section;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiAction_Snap1Base.PlayOwnerMontage
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UMaiAction_Snap1Base::PlayOwnerMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction_Snap1Base", "PlayOwnerMontage");

	Params::MaiAction_Snap1Base_PlayOwnerMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAction_Snap1Base.GetSectionOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMaiAction_Snap1Base::GetSectionOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction_Snap1Base", "GetSectionOffset");

	Params::MaiAction_Snap1Base_GetSectionOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAction_MoveOnSpline.createActionMoveOnSpline
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiSplineActor*                  Spline                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiAction_MoveOnSpline*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiAction_MoveOnSpline* UMaiAction_MoveOnSpline::CreateActionMoveOnSpline(class UObject* WorldContextObject, class AMaiSplineActor* Spline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiAction_MoveOnSpline", "createActionMoveOnSpline");

	Params::MaiAction_MoveOnSpline_CreateActionMoveOnSpline Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Spline = Spline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAction_MoveOnSpline.createActionMoveOnSplineToAP
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiActionPoint*                  Point                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiAction_MoveOnSpline*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiAction_MoveOnSpline* UMaiAction_MoveOnSpline::CreateActionMoveOnSplineToAP(class UObject* WorldContextObject, class APawn* Pawn, class AMaiActionPoint* Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiAction_MoveOnSpline", "createActionMoveOnSplineToAP");

	Params::MaiAction_MoveOnSpline_CreateActionMoveOnSplineToAP Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Pawn = Pawn;
	Parms.Point = Point;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAction_PlayAnimation.createActionPlayAnimWithParams
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDaiAnimPlayParams               AnimParams                                             (Parm, NativeAccessSpecifierPublic)
// class FName                             blockBT                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LoopCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiAction_PlayAnimation*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiAction_PlayAnimation* UMaiAction_PlayAnimation::CreateActionPlayAnimWithParams(class UObject* WorldContextObject, const struct FDaiAnimPlayParams& AnimParams, class FName blockBT, int32 LoopCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiAction_PlayAnimation", "createActionPlayAnimWithParams");

	Params::MaiAction_PlayAnimation_CreateActionPlayAnimWithParams Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimParams = std::move(AnimParams);
	Parms.blockBT = blockBT;
	Parms.LoopCount = LoopCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAction_PlayAnimation.createActionPlayFromTags
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            AnimTags                                               (Parm, NativeAccessSpecifierPublic)
// class FName                             blockBT                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LoopCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiAction_PlayAnimation*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiAction_PlayAnimation* UMaiAction_PlayAnimation::CreateActionPlayFromTags(class UObject* WorldContextObject, const struct FGameplayTagContainer& AnimTags, class FName blockBT, int32 LoopCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiAction_PlayAnimation", "createActionPlayFromTags");

	Params::MaiAction_PlayAnimation_CreateActionPlayFromTags Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimTags = std::move(AnimTags);
	Parms.blockBT = blockBT;
	Parms.LoopCount = LoopCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAction_PlayAnimation.createActionPlayLoopedAnim
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            AnimTags                                               (Parm, NativeAccessSpecifierPublic)
// class FName                             blockBT                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LoopCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiAction_PlayAnimation*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiAction_PlayAnimation* UMaiAction_PlayAnimation::CreateActionPlayLoopedAnim(class UObject* WorldContextObject, const struct FGameplayTagContainer& AnimTags, class FName blockBT, int32 LoopCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiAction_PlayAnimation", "createActionPlayLoopedAnim");

	Params::MaiAction_PlayAnimation_CreateActionPlayLoopedAnim Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimTags = std::move(AnimTags);
	Parms.blockBT = blockBT;
	Parms.LoopCount = LoopCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAction_ExtMovementAnimation.createActionExtMovementAnimation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            AnimTags                                               (Parm, NativeAccessSpecifierPublic)
// class AMaiNavLink*                      NavLink                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StartSide                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UMaiAction_ExtMovementAnimation>ActionClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiAction_ExtMovementAnimation*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiAction_ExtMovementAnimation* UMaiAction_ExtMovementAnimation::CreateActionExtMovementAnimation(class UObject* WorldContextObject, const struct FGameplayTagContainer& AnimTags, class AMaiNavLink* NavLink, bool StartSide, TSubclassOf<class UMaiAction_ExtMovementAnimation> ActionClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiAction_ExtMovementAnimation", "createActionExtMovementAnimation");

	Params::MaiAction_ExtMovementAnimation_CreateActionExtMovementAnimation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimTags = std::move(AnimTags);
	Parms.NavLink = NavLink;
	Parms.StartSide = StartSide;
	Parms.ActionClass = ActionClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAction_ChangeSurface.createActionChangeSurface
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            AnimTags                                               (Parm, NativeAccessSpecifierPublic)
// struct FTransform                       TargetTransform                                        (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UMaiAction_ChangeSurface>ActionClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiAction_ChangeSurface*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiAction_ChangeSurface* UMaiAction_ChangeSurface::CreateActionChangeSurface(class UObject* WorldContextObject, const struct FGameplayTagContainer& AnimTags, const struct FTransform& TargetTransform, TSubclassOf<class UMaiAction_ChangeSurface> ActionClass, float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiAction_ChangeSurface", "createActionChangeSurface");

	Params::MaiAction_ChangeSurface_CreateActionChangeSurface Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimTags = std::move(AnimTags);
	Parms.TargetTransform = std::move(TargetTransform);
	Parms.ActionClass = ActionClass;
	Parms.PlayRate = PlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAction_SyncAnimations.createActionSyncAnims
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            OwnerAnimTags                                          (Parm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            OtherAnimTags                                          (Parm, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UMaiAction_SyncAnimations>ActionClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             behaviorName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiAction_SyncAnimations*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiAction_SyncAnimations* UMaiAction_SyncAnimations::CreateActionSyncAnims(class UObject* WorldContextObject, const struct FGameplayTagContainer& OwnerAnimTags, const struct FGameplayTagContainer& OtherAnimTags, class AActor* Other, TSubclassOf<class UMaiAction_SyncAnimations> ActionClass, class FName behaviorName, float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiAction_SyncAnimations", "createActionSyncAnims");

	Params::MaiAction_SyncAnimations_CreateActionSyncAnims Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.OwnerAnimTags = std::move(OwnerAnimTags);
	Parms.OtherAnimTags = std::move(OtherAnimTags);
	Parms.Other = Other;
	Parms.ActionClass = ActionClass;
	Parms.behaviorName = behaviorName;
	Parms.PlayRate = PlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAction_SyncAnimations.createActionSyncAnimsSingle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     OwnerAnimTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     OtherAnimTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UMaiAction_SyncAnimations>ActionClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             behaviorName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiAction_SyncAnimations*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiAction_SyncAnimations* UMaiAction_SyncAnimations::CreateActionSyncAnimsSingle(class UObject* WorldContextObject, const struct FGameplayTag& OwnerAnimTag, const struct FGameplayTag& OtherAnimTag, class AActor* Other, TSubclassOf<class UMaiAction_SyncAnimations> ActionClass, class FName behaviorName, float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiAction_SyncAnimations", "createActionSyncAnimsSingle");

	Params::MaiAction_SyncAnimations_CreateActionSyncAnimsSingle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.OwnerAnimTag = std::move(OwnerAnimTag);
	Parms.OtherAnimTag = std::move(OtherAnimTag);
	Parms.Other = Other;
	Parms.ActionClass = ActionClass;
	Parms.behaviorName = behaviorName;
	Parms.PlayRate = PlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAction_SyncAnimations.createActionSyncFromConfig
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMaiSyncActionConfig             Config                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             behaviorName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiAction_SyncAnimations*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiAction_SyncAnimations* UMaiAction_SyncAnimations::CreateActionSyncFromConfig(class UObject* WorldContext, class AActor* Other, const struct FMaiSyncActionConfig& Config, class FName behaviorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiAction_SyncAnimations", "createActionSyncFromConfig");

	Params::MaiAction_SyncAnimations_CreateActionSyncFromConfig Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Other = Other;
	Parms.Config = std::move(Config);
	Parms.behaviorName = behaviorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAction_SyncAnimations.createActionSyncFromRow
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDataTableRowHandle              Row                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UMaiAction_SyncAnimations*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiAction_SyncAnimations* UMaiAction_SyncAnimations::CreateActionSyncFromRow(class UObject* WorldContext, class AActor* Other, const struct FDataTableRowHandle& Row)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiAction_SyncAnimations", "createActionSyncFromRow");

	Params::MaiAction_SyncAnimations_CreateActionSyncFromRow Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Other = Other;
	Parms.Row = std::move(Row);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAction_SyncAnimations.CalculateIdealTransforms
// (Final, Native, Public, BlueprintCallable)

void UMaiAction_SyncAnimations::CalculateIdealTransforms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction_SyncAnimations", "CalculateIdealTransforms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAction_SyncAnimations.PlayOtherMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UMaiAction_SyncAnimations::PlayOtherMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction_SyncAnimations", "PlayOtherMontage");

	Params::MaiAction_SyncAnimations_PlayOtherMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAction_SyncAnimations.PlayOwnerMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UMaiAction_SyncAnimations::PlayOwnerMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAction_SyncAnimations", "PlayOwnerMontage");

	Params::MaiAction_SyncAnimations_PlayOwnerMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAction_RotateTo.createActionRotateToActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Precision                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiAction_RotateTo*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiAction_RotateTo* UMaiAction_RotateTo::CreateActionRotateToActor(class UObject* WorldContextObject, class AActor* Actor, float Precision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiAction_RotateTo", "createActionRotateToActor");

	Params::MaiAction_RotateTo_CreateActionRotateToActor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Actor = Actor;
	Parms.Precision = Precision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAction_RotateTo.createActionRotateToLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Precision                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiAction_RotateTo*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiAction_RotateTo* UMaiAction_RotateTo::CreateActionRotateToLocation(class UObject* WorldContextObject, const struct FVector& Location, float Precision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiAction_RotateTo", "createActionRotateToLocation");

	Params::MaiAction_RotateTo_CreateActionRotateToLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = std::move(Location);
	Parms.Precision = Precision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAction_WaitUntilStops.createActionWaitUntilStops
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiAction_WaitUntilStops*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiAction_WaitUntilStops* UMaiAction_WaitUntilStops::CreateActionWaitUntilStops(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiAction_WaitUntilStops", "createActionWaitUntilStops");

	Params::MaiAction_WaitUntilStops_CreateActionWaitUntilStops Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAggroMeter.getAggroMeter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiAggroMeter*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiAggroMeter* UMaiAggroMeter::GetAggroMeter(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiAggroMeter", "getAggroMeter");

	Params::MaiAggroMeter_GetAggroMeter Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAggroMeter.getSenseTypeForStimulus
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIStimulus                      Stimulus                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EMaiSenseType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMaiSenseType UMaiAggroMeter::GetSenseTypeForStimulus(class UObject* WorldContextObject, const struct FAIStimulus& Stimulus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiAggroMeter", "getSenseTypeForStimulus");

	Params::MaiAggroMeter_GetSenseTypeForStimulus Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Stimulus = std::move(Stimulus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAggroMeter.AddAggro
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Aggro                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAggroMeter::AddAggro(float Aggro, bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "AddAggro");

	Params::MaiAggroMeter_AddAggro Parms{};

	Parms.Aggro = Aggro;
	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAggroMeter.AddGainMod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDaiFloatModifier*                Mod                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMaiSenseType                           Sense                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAggroMeter::AddGainMod(class UDaiFloatModifier* Mod, EMaiSenseType Sense, class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "AddGainMod");

	Params::MaiAggroMeter_AddGainMod Parms{};

	Parms.Mod = Mod;
	Parms.Sense = Sense;
	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAggroMeter.ClearWeakDisableGain
// (Final, Native, Public, BlueprintCallable)

void UMaiAggroMeter::ClearWeakDisableGain()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "ClearWeakDisableGain");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAggroMeter.DisableDecay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Disable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAggroMeter::DisableDecay(bool Disable, class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "DisableDecay");

	Params::MaiAggroMeter_DisableDecay Parms{};

	Parms.Disable = Disable;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAggroMeter.DisableGain
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Disable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAggroMeter::DisableGain(bool Disable, class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "DisableGain");

	Params::MaiAggroMeter_DisableGain Parms{};

	Parms.Disable = Disable;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAggroMeter.OnTargetPerceptionUpdated
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIStimulus                      Stimulus                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UMaiAggroMeter::OnTargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "OnTargetPerceptionUpdated");

	Params::MaiAggroMeter_OnTargetPerceptionUpdated Parms{};

	Parms.Actor = Actor;
	Parms.Stimulus = std::move(Stimulus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAggroMeter.RemoveGainMod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDaiFloatModifier*                Mod                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMaiSenseType                           Sense                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAggroMeter::RemoveGainMod(class UDaiFloatModifier* Mod, EMaiSenseType Sense, class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "RemoveGainMod");

	Params::MaiAggroMeter_RemoveGainMod Parms{};

	Parms.Mod = Mod;
	Parms.Sense = Sense;
	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAggroMeter.SetAggro
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewAggro                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAggroMeter::SetAggro(float NewAggro, bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "SetAggro");

	Params::MaiAggroMeter_SetAggro Parms{};

	Parms.NewAggro = NewAggro;
	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAggroMeter.SetBehaviorStance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMaiAggroStance                         Stance                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAggroMeter::SetBehaviorStance(EMaiAggroStance Stance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "SetBehaviorStance");

	Params::MaiAggroMeter_SetBehaviorStance Parms{};

	Parms.Stance = Stance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAggroMeter.WeakDisableGain
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Disable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAggroMeter::WeakDisableGain(bool Disable, class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "WeakDisableGain");

	Params::MaiAggroMeter_WeakDisableGain Parms{};

	Parms.Disable = Disable;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAggroMeter.GetAggro
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaiAggroMeter::GetAggro() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "GetAggro");

	Params::MaiAggroMeter_GetAggro Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAggroMeter.GetBehaviorStance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMaiAggroStance                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMaiAggroStance UMaiAggroMeter::GetBehaviorStance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "GetBehaviorStance");

	Params::MaiAggroMeter_GetBehaviorStance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAggroMeter.GetDebugColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UMaiAggroMeter::GetDebugColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "GetDebugColor");

	Params::MaiAggroMeter_GetDebugColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAggroMeter.GetDebugText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMaiAggroMeter::GetDebugText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "GetDebugText");

	Params::MaiAggroMeter_GetDebugText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAggroMeter.GetMostHated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMaiAggroMeter::GetMostHated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "GetMostHated");

	Params::MaiAggroMeter_GetMostHated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAggroMeter.GetStance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMaiAggroStance                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMaiAggroStance UMaiAggroMeter::GetStance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "GetStance");

	Params::MaiAggroMeter_GetStance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAggroMeter.GetStanceMaxAggro
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMaiAggroStance                         Stance                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaiAggroMeter::GetStanceMaxAggro(EMaiAggroStance Stance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "GetStanceMaxAggro");

	Params::MaiAggroMeter_GetStanceMaxAggro Parms{};

	Parms.Stance = Stance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAggroMeter.GetStanceMinAggro
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMaiAggroStance                         Stance                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaiAggroMeter::GetStanceMinAggro(EMaiAggroStance Stance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "GetStanceMinAggro");

	Params::MaiAggroMeter_GetStanceMinAggro Parms{};

	Parms.Stance = Stance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAggroMeter.IsAggressive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiAggroMeter::IsAggressive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "IsAggressive");

	Params::MaiAggroMeter_IsAggressive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAggroMeter.IsAggroGainDisabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiAggroMeter::IsAggroGainDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "IsAggroGainDisabled");

	Params::MaiAggroMeter_IsAggroGainDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAggroMeter.IsCautious
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiAggroMeter::IsCautious() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "IsCautious");

	Params::MaiAggroMeter_IsCautious Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAggroMeter.IsNeutral
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiAggroMeter::IsNeutral() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAggroMeter", "IsNeutral");

	Params::MaiAggroMeter_IsNeutral Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSense_SightDecorator.IsInSight
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiSenseDebugger*                Debugger                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiSense_SightDecorator::IsInSight(class AActor* Actor, class UMaiSenseDebugger* Debugger) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSense_SightDecorator", "IsInSight");

	Params::MaiSense_SightDecorator_IsInSight Parms{};

	Parms.Actor = Actor;
	Parms.Debugger = Debugger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFloatAggroModifier.GetStimulus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAIStimulus                ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FAIStimulus UMaiFloatAggroModifier::GetStimulus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiFloatAggroModifier", "GetStimulus");

	Params::MaiFloatAggroModifier_GetStimulus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MsgMadeDodgeReceiverInterface.ReceiveMadeDodgeMsg
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMaiMessage*                      Message                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Sender                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMsgMadeDodgeReceiverInterface::ReceiveMadeDodgeMsg(class UMaiMessage* Message, class AActor* Sender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MsgMadeDodgeReceiverInterface", "ReceiveMadeDodgeMsg");

	Params::MsgMadeDodgeReceiverInterface_ReceiveMadeDodgeMsg Parms{};

	Parms.Message = Message;
	Parms.Sender = Sender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAreaComponent.GetAreaShape
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Extents                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMaiShapeType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMaiShapeType UMaiAreaComponent::GetAreaShape(struct FVector* Extents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAreaComponent", "GetAreaShape");

	Params::MaiAreaComponent_GetAreaShape Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Extents != nullptr)
		*Extents = std::move(Parms.Extents);

	return Parms.ReturnValue;
}


// Function Mai.MaiAreaComponent.GetRandomPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMaiAreaComponent::GetRandomPoint(float Extent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAreaComponent", "GetRandomPoint");

	Params::MaiAreaComponent_GetRandomPoint Parms{};

	Parms.Extent = Extent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAreaComponent.IsInArea
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiAreaComponent::IsInArea(const struct FVector& Location, float Extent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAreaComponent", "IsInArea");

	Params::MaiAreaComponent_IsInArea Parms{};

	Parms.Location = std::move(Location);
	Parms.Extent = Extent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFlyingPoint.IsReachableFrom
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiController*                   User                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiFlyingPoint::IsReachableFrom(const struct FVector& Location, class AMaiController* User) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiFlyingPoint", "IsReachableFrom");

	Params::MaiFlyingPoint_IsReachableFrom Parms{};

	Parms.Location = std::move(Location);
	Parms.User = User;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttack.DisableFocus
// (Final, Native, Public, BlueprintCallable)

void UMaiAttack::DisableFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "DisableFocus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttack.DisableSnap
// (Final, Native, Public, BlueprintCallable)

void UMaiAttack::DisableSnap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "DisableSnap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttack.EnableFocus
// (Final, Native, Public, BlueprintCallable)

void UMaiAttack::EnableFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "EnableFocus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttack.EnableSnap
// (Final, Native, Public, BlueprintCallable)

void UMaiAttack::EnableSnap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "EnableSnap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttack.EndAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Abort                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::EndAttack(bool Abort)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "EndAttack");

	Params::MaiAttack_EndAttack Parms{};

	Parms.Abort = Abort;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttack.EventAllowDodge
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::EventAllowDodge(class AActor* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "EventAllowDodge");

	Params::MaiAttack_EventAllowDodge Parms{};

	Parms.Owner = Owner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiAttack.EventAttackHit
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::EventAttackHit(class AActor* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "EventAttackHit");

	Params::MaiAttack_EventAttackHit Parms{};

	Parms.Owner = Owner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiAttack.EventAttackMiss
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::EventAttackMiss(class AActor* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "EventAttackMiss");

	Params::MaiAttack_EventAttackMiss Parms{};

	Parms.Owner = Owner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiAttack.EventBeginAttack
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::EventBeginAttack(class AActor* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "EventBeginAttack");

	Params::MaiAttack_EventBeginAttack Parms{};

	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttack.EventEndBlow
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::EventEndBlow(class AActor* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "EventEndBlow");

	Params::MaiAttack_EventEndBlow Parms{};

	Parms.Owner = Owner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiAttack.EventInitAttack
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::EventInitAttack(class AActor* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "EventInitAttack");

	Params::MaiAttack_EventInitAttack Parms{};

	Parms.Owner = Owner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiAttack.EventStartBlow
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ImpactID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::EventStartBlow(class AActor* Owner, int32 ImpactID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "EventStartBlow");

	Params::MaiAttack_EventStartBlow Parms{};

	Parms.Owner = Owner;
	Parms.ImpactID = ImpactID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiAttack.EventStopAttack
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Aborted                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::EventStopAttack(class AActor* Owner, bool Aborted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "EventStopAttack");

	Params::MaiAttack_EventStopAttack Parms{};

	Parms.Owner = Owner;
	Parms.Aborted = Aborted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttack.EventTickAttack
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::EventTickAttack(class AActor* Owner, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "EventTickAttack");

	Params::MaiAttack_EventTickAttack Parms{};

	Parms.Owner = Owner;
	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttack.LoadRowHandle
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FDataTableRowHandle              AttackRow                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMaiAttack::LoadRowHandle(const struct FDataTableRowHandle& AttackRow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "LoadRowHandle");

	Params::MaiAttack_LoadRowHandle Parms{};

	Parms.AttackRow = std::move(AttackRow);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiAttack.SetAllowDodgeReaction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Allow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::SetAllowDodgeReaction(bool Allow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "SetAllowDodgeReaction");

	Params::MaiAttack_SetAllowDodgeReaction Parms{};

	Parms.Allow = Allow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttack.SetAttackCommited
// (Final, Native, Public, BlueprintCallable)

void UMaiAttack::SetAttackCommited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "SetAttackCommited");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttack.SetAttackCone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Dir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::SetAttackCone(float Angle, float Dir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "SetAttackCone");

	Params::MaiAttack_SetAttackCone Parms{};

	Parms.Angle = Angle;
	Parms.Dir = Dir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttack.SetAttackRange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::SetAttackRange(float Min, float Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "SetAttackRange");

	Params::MaiAttack_SetAttackRange Parms{};

	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttack.SetBehavior
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBehaviorTree*                    Behavior                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayTag>             AnimTags                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMaiAttack::SetBehavior(class UBehaviorTree* Behavior, const TArray<struct FGameplayTag>& AnimTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "SetBehavior");

	Params::MaiAttack_SetBehavior Parms{};

	Parms.Behavior = Behavior;
	Parms.AnimTags = std::move(AnimTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttack.SetCooldown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::SetCooldown(float Min, float Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "SetCooldown");

	Params::MaiAttack_SetCooldown Parms{};

	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttack.SetDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UDamageType>          DamageType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::SetDamage(TSubclassOf<class UDamageType> DamageType, int32 Min, int32 Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "SetDamage");

	Params::MaiAttack_SetDamage Parms{};

	Parms.DamageType = DamageType;
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttack.SetFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMaiAttackFocus                         Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Charging                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::SetFocus(EMaiAttackFocus Mode, float Charging)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "SetFocus");

	Params::MaiAttack_SetFocus Parms{};

	Parms.Mode = Mode;
	Parms.Charging = Charging;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttack.SetLogicalImpact
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Dir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::SetLogicalImpact(bool Enable, float Range, float Angle, float Dir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "SetLogicalImpact");

	Params::MaiAttack_SetLogicalImpact Parms{};

	Parms.Enable = Enable;
	Parms.Range = Range;
	Parms.Angle = Angle;
	Parms.Dir = Dir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttack.SetSnapMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMaiAttackSnap                          Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::SetSnapMode(EMaiAttackSnap Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "SetSnapMode");

	Params::MaiAttack_SetSnapMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttack.GetAllowDodgeReaction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiAttack::GetAllowDodgeReaction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "GetAllowDodgeReaction");

	Params::MaiAttack_GetAllowDodgeReaction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttack.GetAttackerComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaiAttackerComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiAttackerComponent* UMaiAttack::GetAttackerComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "GetAttackerComponent");

	Params::MaiAttack_GetAttackerComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttack.GetAttackRange
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Min                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttack::GetAttackRange(float* Min, float* Max) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "GetAttackRange");

	Params::MaiAttack_GetAttackRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Min != nullptr)
		*Min = Parms.Min;

	if (Max != nullptr)
		*Max = Parms.Max;
}


// Function Mai.MaiAttack.GetAttackTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMaiAttack::GetAttackTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "GetAttackTarget");

	Params::MaiAttack_GetAttackTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttack.GetDamage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ImpactID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaiAttack::GetDamage(int32 ImpactID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "GetDamage");

	Params::MaiAttack_GetDamage Parms{};

	Parms.ImpactID = ImpactID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttack.GetDamageType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ImpactID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UDamageType> UMaiAttack::GetDamageType(int32 ImpactID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "GetDamageType");

	Params::MaiAttack_GetDamageType Parms{};

	Parms.ImpactID = ImpactID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttack.GetImpactAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ImpactID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaiAttack::GetImpactAngle(int32 ImpactID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "GetImpactAngle");

	Params::MaiAttack_GetImpactAngle Parms{};

	Parms.ImpactID = ImpactID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttack.GetImpactDir
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ImpactID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaiAttack::GetImpactDir(int32 ImpactID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "GetImpactDir");

	Params::MaiAttack_GetImpactDir Parms{};

	Parms.ImpactID = ImpactID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttack.GetImpactRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ImpactID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaiAttack::GetImpactRange(int32 ImpactID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "GetImpactRange");

	Params::MaiAttack_GetImpactRange Parms{};

	Parms.ImpactID = ImpactID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttack.GetOwnerActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMaiAttack::GetOwnerActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "GetOwnerActor");

	Params::MaiAttack_GetOwnerActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttack.GetOwnerAI
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AAIController*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAIController* UMaiAttack::GetOwnerAI() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "GetOwnerAI");

	Params::MaiAttack_GetOwnerAI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttack.GetOwnerCH
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UMaiAttack::GetOwnerCH() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "GetOwnerCH");

	Params::MaiAttack_GetOwnerCH Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttack.IsFocusing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiAttack::IsFocusing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "IsFocusing");

	Params::MaiAttack_IsFocusing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttack.IsSnapping
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiAttack::IsSnapping() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttack", "IsSnapping");

	Params::MaiAttack_IsSnapping Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiLightObserver.TurnOff
// (Final, Native, Public, BlueprintCallable)

void UMaiLightObserver::TurnOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLightObserver", "TurnOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiLightObserver.TurnOn
// (Final, Native, Public, BlueprintCallable)

void UMaiLightObserver::TurnOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLightObserver", "TurnOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiLightObserver.GetIsLit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiLightObserver::GetIsLit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLightObserver", "GetIsLit");

	Params::MaiLightObserver_GetIsLit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiLightObserver.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiLightObserver::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLightObserver", "IsEnabled");

	Params::MaiLightObserver_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiScriptAttack.OnOwnerMontageEnds
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiScriptAttack::OnOwnerMontageEnds(class UAnimMontage* Montage, bool Interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiScriptAttack", "OnOwnerMontageEnds");

	Params::MaiScriptAttack_OnOwnerMontageEnds Parms{};

	Parms.Montage = Montage;
	Parms.Interrupted = Interrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiScriptAttack.PlayOwnerMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UMaiScriptAttack::PlayOwnerMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiScriptAttack", "PlayOwnerMontage");

	Params::MaiScriptAttack_PlayOwnerMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiScriptAttack.SelectBestAnim
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Forward                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiScriptAttack::SelectBestAnim(const struct FVector& Forward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiScriptAttack", "SelectBestAnim");

	Params::MaiScriptAttack_SelectBestAnim Parms{};

	Parms.Forward = std::move(Forward);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiScriptAttack.SetOwnerMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiScriptAttack::SetOwnerMontage(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiScriptAttack", "SetOwnerMontage");

	Params::MaiScriptAttack_SetOwnerMontage Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiScriptAttack.SetSliding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      Curve                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiScriptAttack::SetSliding(float Distance, class UCurveFloat* Curve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiScriptAttack", "SetSliding");

	Params::MaiScriptAttack_SetSliding Parms{};

	Parms.Distance = Distance;
	Parms.Curve = Curve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttackerComponent.getAttacker
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiAttackerComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiAttackerComponent* UMaiAttackerComponent::GetAttacker(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiAttackerComponent", "getAttacker");

	Params::MaiAttackerComponent_GetAttacker Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttackerComponent.ApplyDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SingleDamage                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiAttackerComponent::ApplyDamage(class AActor* Enemy, const struct FHitResult& Hit, TSubclassOf<class UDamageType> DamageType, float Damage, bool SingleDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "ApplyDamage");

	Params::MaiAttackerComponent_ApplyDamage Parms{};

	Parms.Enemy = Enemy;
	Parms.Hit = std::move(Hit);
	Parms.DamageType = DamageType;
	Parms.Damage = Damage;
	Parms.SingleDamage = SingleDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttackerComponent.BeginAttack
// (Final, Native, Public, BlueprintCallable)

void UMaiAttackerComponent::BeginAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "BeginAttack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttackerComponent.ChangeAttacksBT
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBehaviorTree*                    AttacksTree                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttackerComponent::ChangeAttacksBT(class UBehaviorTree* AttacksTree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "ChangeAttacksBT");

	Params::MaiAttackerComponent_ChangeAttacksBT Parms{};

	Parms.AttacksTree = AttacksTree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttackerComponent.CleanUpAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             AttackName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttackerComponent::CleanUpAttack(class FName AttackName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "CleanUpAttack");

	Params::MaiAttackerComponent_CleanUpAttack Parms{};

	Parms.AttackName = AttackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttackerComponent.DebugAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttackerComponent::DebugAttack(class AActor* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "DebugAttack");

	Params::MaiAttackerComponent_DebugAttack Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttackerComponent.EnableChaseMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttackerComponent::EnableChaseMode(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "EnableChaseMode");

	Params::MaiAttackerComponent_EnableChaseMode Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttackerComponent.EnableFocusOnEnemy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttackerComponent::EnableFocusOnEnemy(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "EnableFocusOnEnemy");

	Params::MaiAttackerComponent_EnableFocusOnEnemy Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttackerComponent.EndBlow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ImpactID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttackerComponent::EndBlow(int32 ImpactID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "EndBlow");

	Params::MaiAttackerComponent_EndBlow Parms{};

	Parms.ImpactID = ImpactID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttackerComponent.FillAttacks
// (Final, Native, Public, BlueprintCallable)

void UMaiAttackerComponent::FillAttacks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "FillAttacks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttackerComponent.ForceMiss
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Miss                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttackerComponent::ForceMiss(bool Miss)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "ForceMiss");

	Params::MaiAttackerComponent_ForceMiss Parms{};

	Parms.Miss = Miss;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttackerComponent.ForceNextAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             AttackName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttackerComponent::ForceNextAttack(class FName AttackName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "ForceNextAttack");

	Params::MaiAttackerComponent_ForceNextAttack Parms{};

	Parms.AttackName = AttackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttackerComponent.InjectBT
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Inject                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttackerComponent::InjectBT(bool Inject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "InjectBT");

	Params::MaiAttackerComponent_InjectBT Parms{};

	Parms.Inject = Inject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttackerComponent.RunPureAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttackName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttackerComponent::RunPureAttack(class AActor* Enemy, class FName AttackName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "RunPureAttack");

	Params::MaiAttackerComponent_RunPureAttack Parms{};

	Parms.Enemy = Enemy;
	Parms.AttackName = AttackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttackerComponent.SelectAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttackName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttackerComponent::SelectAttack(class AActor* Enemy, class FName AttackName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "SelectAttack");

	Params::MaiAttackerComponent_SelectAttack Parms{};

	Parms.Enemy = Enemy;
	Parms.AttackName = AttackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttackerComponent.StartBlow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ImpactID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttackerComponent::StartBlow(int32 ImpactID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "StartBlow");

	Params::MaiAttackerComponent_StartBlow Parms{};

	Parms.ImpactID = ImpactID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttackerComponent.StopAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Aborted                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttackName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiAttackerComponent::StopAttack(bool Aborted, class FName AttackName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "StopAttack");

	Params::MaiAttackerComponent_StopAttack Parms{};

	Parms.Aborted = Aborted;
	Parms.AttackName = AttackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiAttackerComponent.TryApplyLogicalDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ImpactID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiAttackerComponent::TryApplyLogicalDamage(class AActor* Enemy, float Damage, int32 ImpactID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "TryApplyLogicalDamage");

	Params::MaiAttackerComponent_TryApplyLogicalDamage Parms{};

	Parms.Enemy = Enemy;
	Parms.Damage = Damage;
	Parms.ImpactID = ImpactID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttackerComponent.TryApplyPhysicalDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiAttackerComponent::TryApplyPhysicalDamage(class AActor* Enemy, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "TryApplyPhysicalDamage");

	Params::MaiAttackerComponent_TryApplyPhysicalDamage Parms{};

	Parms.Enemy = Enemy;
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttackerComponent.FindBestAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaiAttack*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiAttack* UMaiAttackerComponent::FindBestAttack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "FindBestAttack");

	Params::MaiAttackerComponent_FindBestAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttackerComponent.GetAttackRangeType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttackName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMaiAttackRange                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMaiAttackRange UMaiAttackerComponent::GetAttackRangeType(class AActor* Enemy, class FName AttackName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "GetAttackRangeType");

	Params::MaiAttackerComponent_GetAttackRangeType Parms{};

	Parms.Enemy = Enemy;
	Parms.AttackName = AttackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttackerComponent.GetCurrentAttackTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMaiAttackerComponent::GetCurrentAttackTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "GetCurrentAttackTarget");

	Params::MaiAttackerComponent_GetCurrentAttackTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttackerComponent.GetCurrentAttackTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaiAttackerComponent::GetCurrentAttackTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "GetCurrentAttackTime");

	Params::MaiAttackerComponent_GetCurrentAttackTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttackerComponent.HasAnyValidAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMaiAttackRange                         Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckCone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckToken                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiAttackerComponent::HasAnyValidAttack(class AActor* Enemy, EMaiAttackRange Range, bool CheckCone, bool CheckToken) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "HasAnyValidAttack");

	Params::MaiAttackerComponent_HasAnyValidAttack Parms{};

	Parms.Enemy = Enemy;
	Parms.Range = Range;
	Parms.CheckCone = CheckCone;
	Parms.CheckToken = CheckToken;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttackerComponent.HasHit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiAttackerComponent::HasHit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "HasHit");

	Params::MaiAttackerComponent_HasHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttackerComponent.IsInAttackRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VelocityScale                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiAttackerComponent::IsInAttackRange(class AActor* Enemy, float VelocityScale) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "IsInAttackRange");

	Params::MaiAttackerComponent_IsInAttackRange Parms{};

	Parms.Enemy = Enemy;
	Parms.VelocityScale = VelocityScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiAttackerComponent.IsMissed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiAttackerComponent::IsMissed(class AActor* Enemy) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiAttackerComponent", "IsMissed");

	Params::MaiAttackerComponent_IsMissed Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiBTService_Notify.ReceiveNotify
// (Event, Public, BlueprintEvent)
// Parameters:
// class AAIController*                    OwnerController                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ControlledPawn                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiBTService_Notify::ReceiveNotify(class AAIController* OwnerController, class APawn* ControlledPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiBTService_Notify", "ReceiveNotify");

	Params::MaiBTService_Notify_ReceiveNotify Parms{};

	Parms.OwnerController = OwnerController;
	Parms.ControlledPawn = ControlledPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiHostileAttackers.getHostileAttackers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiHostileAttackers*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiHostileAttackers* UMaiHostileAttackers::GetHostileAttackers(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiHostileAttackers", "getHostileAttackers");

	Params::MaiHostileAttackers_GetHostileAttackers Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiHostileAttackers.AddAttacker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiHostileAttackers::AddAttacker(class AActor* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "AddAttacker");

	Params::MaiHostileAttackers_AddAttacker Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiHostileAttackers.CaptureTokenLock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Lock                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiHostileAttackers::CaptureTokenLock(class AActor* Enemy, bool Lock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "CaptureTokenLock");

	Params::MaiHostileAttackers_CaptureTokenLock Parms{};

	Parms.Enemy = Enemy;
	Parms.Lock = Lock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHostileAttackers.ChangeMaxActiveAttackers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiHostileAttackers::ChangeMaxActiveAttackers(uint8 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "ChangeMaxActiveAttackers");

	Params::MaiHostileAttackers_ChangeMaxActiveAttackers Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHostileAttackers.DebugAttacker
// (Final, Native, Public, BlueprintCallable)

void UMaiHostileAttackers::DebugAttacker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "DebugAttacker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHostileAttackers.HardLockTokens
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiHostileAttackers::HardLockTokens(class FName Reason, class AActor* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "HardLockTokens");

	Params::MaiHostileAttackers_HardLockTokens Parms{};

	Parms.Reason = Reason;
	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHostileAttackers.IgnoreLockFor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OnlyIfLocked                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiHostileAttackers::IgnoreLockFor(class FName Reason, class AActor* Enemy, bool OnlyIfLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "IgnoreLockFor");

	Params::MaiHostileAttackers_IgnoreLockFor Parms{};

	Parms.Reason = Reason;
	Parms.Enemy = Enemy;
	Parms.OnlyIfLocked = OnlyIfLocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHostileAttackers.LockTokens
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Lock                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiHostileAttackers::LockTokens(class FName Reason, bool Lock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "LockTokens");

	Params::MaiHostileAttackers_LockTokens Parms{};

	Parms.Reason = Reason;
	Parms.Lock = Lock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHostileAttackers.LockTokensDistribution
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Lock                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiHostileAttackers::LockTokensDistribution(class FName Reason, bool Lock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "LockTokensDistribution");

	Params::MaiHostileAttackers_LockTokensDistribution Parms{};

	Parms.Reason = Reason;
	Parms.Lock = Lock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHostileAttackers.OfferSlotToOthers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiHostileAttackers::OfferSlotToOthers(class AActor* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "OfferSlotToOthers");

	Params::MaiHostileAttackers_OfferSlotToOthers Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHostileAttackers.ReleaseAttackPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiHostileAttackers::ReleaseAttackPosition(class AActor* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "ReleaseAttackPosition");

	Params::MaiHostileAttackers_ReleaseAttackPosition Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHostileAttackers.RemoveAllAttackers
// (Final, Native, Public, BlueprintCallable)

void UMaiHostileAttackers::RemoveAllAttackers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "RemoveAllAttackers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHostileAttackers.RemoveAttacker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiHostileAttackers::RemoveAttacker(class AActor* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "RemoveAttacker");

	Params::MaiHostileAttackers_RemoveAttacker Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHostileAttackers.ReturnToken
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AddCooldown                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiHostileAttackers::ReturnToken(class AActor* Enemy, bool AddCooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "ReturnToken");

	Params::MaiHostileAttackers_ReturnToken Parms{};

	Parms.Enemy = Enemy;
	Parms.AddCooldown = AddCooldown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHostileAttackers.TakeAttackPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiHostileAttackers::TakeAttackPosition(class AActor* Enemy, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "TakeAttackPosition");

	Params::MaiHostileAttackers_TakeAttackPosition Parms{};

	Parms.Enemy = Enemy;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHostileAttackers.TakeToken
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMaiToken                               Token                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     IgnoreLocks                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiHostileAttackers::TakeToken(class AActor* Enemy, EMaiToken Token, const TArray<class FName>& IgnoreLocks, bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "TakeToken");

	Params::MaiHostileAttackers_TakeToken Parms{};

	Parms.Enemy = Enemy;
	Parms.Token = Token;
	Parms.IgnoreLocks = std::move(IgnoreLocks);
	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiHostileAttackers.UpdateActiveAttackers
// (Final, Native, Protected)

void UMaiHostileAttackers::UpdateActiveAttackers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "UpdateActiveAttackers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHostileAttackers.CanCaptureToken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiHostileAttackers::CanCaptureToken(class AActor* Enemy) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "CanCaptureToken");

	Params::MaiHostileAttackers_CanCaptureToken Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiHostileAttackers.CanGetSlot
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiHostileAttackers::CanGetSlot(class AActor* Enemy) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "CanGetSlot");

	Params::MaiHostileAttackers_CanGetSlot Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiHostileAttackers.CanHaveSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiHostileAttackers::CanHaveSlot(class AActor* Enemy) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "CanHaveSlot");

	Params::MaiHostileAttackers_CanHaveSlot Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiHostileAttackers.DisallowSlotGive
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiHostileAttackers::DisallowSlotGive(class AActor* Enemy) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "DisallowSlotGive");

	Params::MaiHostileAttackers_DisallowSlotGive Parms{};

	Parms.Enemy = Enemy;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mai.MaiHostileAttackers.GetAttackerCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UMaiHostileAttackers::GetAttackerCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "GetAttackerCount");

	Params::MaiHostileAttackers_GetAttackerCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiHostileAttackers.GetSlotHoldersCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AActor>               Klass                                                  (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UMaiHostileAttackers::GetSlotHoldersCount(TSubclassOf<class AActor> Klass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "GetSlotHoldersCount");

	Params::MaiHostileAttackers_GetSlotHoldersCount Parms{};

	Parms.Klass = Klass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiHostileAttackers.GetTokenHolder
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMaiHostileAttackers::GetTokenHolder() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "GetTokenHolder");

	Params::MaiHostileAttackers_GetTokenHolder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiHostileAttackers.GetTokenLockOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMaiHostileAttackers::GetTokenLockOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "GetTokenLockOwner");

	Params::MaiHostileAttackers_GetTokenLockOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiHostileAttackers.HasAnyAttacker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiHostileAttackers::HasAnyAttacker() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "HasAnyAttacker");

	Params::MaiHostileAttackers_HasAnyAttacker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiHostileAttackers.HasHardLock
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiHostileAttackers::HasHardLock() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "HasHardLock");

	Params::MaiHostileAttackers_HasHardLock Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiHostileAttackers.HasOtherAttacker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiHostileAttackers::HasOtherAttacker(class AActor* Enemy) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "HasOtherAttacker");

	Params::MaiHostileAttackers_HasOtherAttacker Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiHostileAttackers.HasToken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiHostileAttackers::HasToken(class AActor* Enemy) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHostileAttackers", "HasToken");

	Params::MaiHostileAttackers_HasToken Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MsgEndBlowReceiverInterface.ReceiveEndBlowMsg
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMaiMessage*                      Message                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMsgEndBlowReceiverInterface::ReceiveEndBlowMsg(class UMaiMessage* Message, class AActor* Attacker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MsgEndBlowReceiverInterface", "ReceiveEndBlowMsg");

	Params::MsgEndBlowReceiverInterface_ReceiveEndBlowMsg Parms{};

	Parms.Message = Message;
	Parms.Attacker = Attacker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.BTTask_BeingActionBase.OnActionEvent
// (Native, Protected)
// Parameters:
// class UBeingAction*                     Action                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBeingActionEventType                   EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBTTask_BeingActionBase::OnActionEvent(class UBeingAction* Action, EBeingActionEventType EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTTask_BeingActionBase", "OnActionEvent");

	Params::BTTask_BeingActionBase_OnActionEvent Parms{};

	Parms.Action = Action;
	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiBTTask_State.OnStateStatusChanged
// (Final, Native, Public)
// Parameters:
// EStateStatus                            Status                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiBTTask_State::OnStateStatusChanged(EStateStatus Status)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiBTTask_State", "OnStateStatusChanged");

	Params::MaiBTTask_State_OnStateStatusChanged Parms{};

	Parms.Status = Status;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacter.getFixedCapsuleLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMaiCharacter::GetFixedCapsuleLocation(class APawn* Pawn, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiCharacter", "getFixedCapsuleLocation");

	Params::MaiCharacter_GetFixedCapsuleLocation Parms{};

	Parms.Pawn = Pawn;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCharacter.getFixedGroundLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMaiCharacter::GetFixedGroundLocation(class APawn* Pawn, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiCharacter", "getFixedGroundLocation");

	Params::MaiCharacter_GetFixedGroundLocation Parms{};

	Parms.Pawn = Pawn;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCharacter.AbortAttack
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             AttackName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiCharacter::AbortAttack(class FName AttackName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "AbortAttack");

	Params::MaiCharacter_AbortAttack Parms{};

	Parms.AttackName = AttackName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiCharacter.Activate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiCharacter::Activate(class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "Activate");

	Params::MaiCharacter_Activate Parms{};

	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacter.AIDebuggerTick
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AMaiDebugger*                     Debugger                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiCharacter::AIDebuggerTick(class AMaiDebugger* Debugger, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "AIDebuggerTick");

	Params::MaiCharacter_AIDebuggerTick Parms{};

	Parms.Debugger = Debugger;
	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacter.AppendGameplayTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            GameplayTags                                           (Parm, NativeAccessSpecifierPublic)

void AMaiCharacter::AppendGameplayTags(const struct FGameplayTagContainer& GameplayTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "AppendGameplayTags");

	Params::MaiCharacter_AppendGameplayTags Parms{};

	Parms.GameplayTags = std::move(GameplayTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacter.ClearGameplayTags
// (Final, Native, Public, BlueprintCallable)

void AMaiCharacter::ClearGameplayTags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "ClearGameplayTags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacter.Deactivate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiCharacter::Deactivate(class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "Deactivate");

	Params::MaiCharacter_Deactivate Parms{};

	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacter.DisableActor
// (Native, Event, Protected, BlueprintEvent)

void AMaiCharacter::DisableActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "DisableActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacter.DisableAttackColliders
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     CollidersTags                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void AMaiCharacter::DisableAttackColliders(const TArray<class FName>& CollidersTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "DisableAttackColliders");

	Params::MaiCharacter_DisableAttackColliders Parms{};

	Parms.CollidersTags = std::move(CollidersTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacter.EnableActor
// (Native, Event, Protected, BlueprintEvent)

void AMaiCharacter::EnableActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "EnableActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacter.EnableAttackColliders
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     CollidersTags                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void AMaiCharacter::EnableAttackColliders(const TArray<class FName>& CollidersTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "EnableAttackColliders");

	Params::MaiCharacter_EnableAttackColliders Parms{};

	Parms.CollidersTags = std::move(CollidersTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacter.LongFallDetected
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AMaiCharacter::LongFallDetected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "LongFallDetected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacter.ReceiveShouldDespawn
// (Event, Protected, BlueprintEvent)
// Parameters:
// EMaiDespawnReason                       Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiCharacter::ReceiveShouldDespawn(EMaiDespawnReason Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "ReceiveShouldDespawn");

	Params::MaiCharacter_ReceiveShouldDespawn Parms{};

	Parms.Reason = Reason;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mai.MaiCharacter.RemoveGameplayTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            GameplayTags                                           (Parm, NativeAccessSpecifierPublic)

void AMaiCharacter::RemoveGameplayTags(const struct FGameplayTagContainer& GameplayTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "RemoveGameplayTags");

	Params::MaiCharacter_RemoveGameplayTags Parms{};

	Parms.GameplayTags = std::move(GameplayTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacter.SetGameplayTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            GameplayTags                                           (Parm, NativeAccessSpecifierPublic)

void AMaiCharacter::SetGameplayTags(const struct FGameplayTagContainer& GameplayTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "SetGameplayTags");

	Params::MaiCharacter_SetGameplayTags Parms{};

	Parms.GameplayTags = std::move(GameplayTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacter.TakePointDamage
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMaiCharacter::TakePointDamage(float Damage, TSubclassOf<class UDamageType> DamageClass, class AController* EventInstigator, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "TakePointDamage");

	Params::MaiCharacter_TakePointDamage Parms{};

	Parms.Damage = Damage;
	Parms.DamageClass = DamageClass;
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCharacter.WantDespawn
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Despawn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiCharacter::WantDespawn(bool Despawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "WantDespawn");

	Params::MaiCharacter_WantDespawn Parms{};

	Parms.Despawn = Despawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiCharacter.GetMaiCharacterMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaiCharacterMovementComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiCharacterMovementComponent* AMaiCharacter::GetMaiCharacterMovement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "GetMaiCharacterMovement");

	Params::MaiCharacter_GetMaiCharacterMovement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCharacter.GetMaiController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMaiController*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiController* AMaiCharacter::GetMaiController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "GetMaiController");

	Params::MaiCharacter_GetMaiController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCharacter.GetMaiSpawner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMaiSpawner*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiSpawner* AMaiCharacter::GetMaiSpawner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "GetMaiSpawner");

	Params::MaiCharacter_GetMaiSpawner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCharacter.GetPrevLevelLocation
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   MinDist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMaiCharacter::GetPrevLevelLocation(float MinDist) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "GetPrevLevelLocation");

	Params::MaiCharacter_GetPrevLevelLocation Parms{};

	Parms.MinDist = MinDist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCharacter.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiCharacter::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "IsActive");

	Params::MaiCharacter_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCharacter.IsDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiCharacter::IsDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "IsDead");

	Params::MaiCharacter_IsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCharacter.IsNotMoving
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiCharacter::IsNotMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacter", "IsNotMoving");

	Params::MaiCharacter_IsNotMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCharacterMovementComponent.MoveToward
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Move                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiCharacterMovementComponent::MoveToward(const struct FVector& Move)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacterMovementComponent", "MoveToward");

	Params::MaiCharacterMovementComponent_MoveToward Parms{};

	Parms.Move = std::move(Move);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacterMovementComponent.SetCustomWalkSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiCharacterMovementComponent::SetCustomWalkSpeed(float NewSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacterMovementComponent", "SetCustomWalkSpeed");

	Params::MaiCharacterMovementComponent_SetCustomWalkSpeed Parms{};

	Parms.NewSpeed = NewSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacterMovementComponent.SetLimitedBackwardsMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MaximumBackwardsMovement                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiCharacterMovementComponent::SetLimitedBackwardsMovement(float MaximumBackwardsMovement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacterMovementComponent", "SetLimitedBackwardsMovement");

	Params::MaiCharacterMovementComponent_SetLimitedBackwardsMovement Parms{};

	Parms.MaximumBackwardsMovement = MaximumBackwardsMovement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacterMovementComponent.SetLimitedForwardMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MaximumForwardMovement                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiCharacterMovementComponent::SetLimitedForwardMovement(float MaximumForwardMovement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacterMovementComponent", "SetLimitedForwardMovement");

	Params::MaiCharacterMovementComponent_SetLimitedForwardMovement Parms{};

	Parms.MaximumForwardMovement = MaximumForwardMovement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacterMovementComponent.SetLimitedMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MaximumForwardMovement                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaximumBackwardMovement                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaximumSidewaysMovement                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiCharacterMovementComponent::SetLimitedMovement(float MaximumForwardMovement, float MaximumBackwardMovement, float MaximumSidewaysMovement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacterMovementComponent", "SetLimitedMovement");

	Params::MaiCharacterMovementComponent_SetLimitedMovement Parms{};

	Parms.MaximumForwardMovement = MaximumForwardMovement;
	Parms.MaximumBackwardMovement = MaximumBackwardMovement;
	Parms.MaximumSidewaysMovement = MaximumSidewaysMovement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacterMovementComponent.SetLimitedSidewaysMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MaximumSidewaysMovement                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiCharacterMovementComponent::SetLimitedSidewaysMovement(float MaximumSidewaysMovement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacterMovementComponent", "SetLimitedSidewaysMovement");

	Params::MaiCharacterMovementComponent_SetLimitedSidewaysMovement Parms{};

	Parms.MaximumSidewaysMovement = MaximumSidewaysMovement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacterMovementComponent.SetSideMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Side                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiCharacterMovementComponent::SetSideMovement(bool Side)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacterMovementComponent", "SetSideMovement");

	Params::MaiCharacterMovementComponent_SetSideMovement Parms{};

	Parms.Side = Side;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCharacterMovementComponent.GetLimitedBackwardsMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaiCharacterMovementComponent::GetLimitedBackwardsMovement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacterMovementComponent", "GetLimitedBackwardsMovement");

	Params::MaiCharacterMovementComponent_GetLimitedBackwardsMovement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCharacterMovementComponent.GetLimitedForwardMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaiCharacterMovementComponent::GetLimitedForwardMovement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacterMovementComponent", "GetLimitedForwardMovement");

	Params::MaiCharacterMovementComponent_GetLimitedForwardMovement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCharacterMovementComponent.GetLimitedSidewaysMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaiCharacterMovementComponent::GetLimitedSidewaysMovement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacterMovementComponent", "GetLimitedSidewaysMovement");

	Params::MaiCharacterMovementComponent_GetLimitedSidewaysMovement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCharacterMovementComponent.GetMaxWalkSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaiCharacterMovementComponent::GetMaxWalkSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCharacterMovementComponent", "GetMaxWalkSpeed");

	Params::MaiCharacterMovementComponent_GetMaxWalkSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.abortAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    AIController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UBeingAction>         ActionClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::AbortAction(class AAIController* AIController, TSubclassOf<class UBeingAction> ActionClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiController", "abortAction");

	Params::MaiController_AbortAction Parms{};

	Parms.AIController = AIController;
	Parms.ActionClass = ActionClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.abortAllActions
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    AIController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InstigatedBy                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::AbortAllActions(class AAIController* AIController, class AActor* InstigatedBy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiController", "abortAllActions");

	Params::MaiController_AbortAllActions Parms{};

	Parms.AIController = AIController;
	Parms.InstigatedBy = InstigatedBy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.pushAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    AIController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBeingAction*                     Action                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIRequestPriority                      Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InstigatedBy                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::PushAction(class AAIController* AIController, class UBeingAction* Action, EAIRequestPriority Priority, class AActor* InstigatedBy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiController", "pushAction");

	Params::MaiController_PushAction Parms{};

	Parms.AIController = AIController;
	Parms.Action = Action;
	Parms.Priority = Priority;
	Parms.InstigatedBy = InstigatedBy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.reportTouchEvent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AController*                      TouchReceiver                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::ReportTouchEvent(class AController* TouchReceiver, class AActor* Other, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiController", "reportTouchEvent");

	Params::MaiController_ReportTouchEvent Parms{};

	Parms.TouchReceiver = TouchReceiver;
	Parms.Other = Other;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.AbandonActionPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMaiActionPoint*                  ActionPoint                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Immediately                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::AbandonActionPoint(class AMaiActionPoint* ActionPoint, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "AbandonActionPoint");

	Params::MaiController_AbandonActionPoint Parms{};

	Parms.ActionPoint = ActionPoint;
	Parms.Immediately = Immediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.AIDebuggerTick
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AMaiDebugger*                     Debugger                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::AIDebuggerTick(class AMaiDebugger* Debugger, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "AIDebuggerTick");

	Params::MaiController_AIDebuggerTick Parms{};

	Parms.Debugger = Debugger;
	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.ChangeWorkLocation
// (Final, Native, Public, BlueprintCallable)

void AMaiController::ChangeWorkLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "ChangeWorkLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.DebugLog
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FString                           Log                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::DebugLog(const class FString& Log, const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "DebugLog");

	Params::MaiController_DebugLog Parms{};

	Parms.Log = std::move(Log);
	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.DisableBehaviorTree
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::DisableBehaviorTree(class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "DisableBehaviorTree");

	Params::MaiController_DisableBehaviorTree Parms{};

	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.EnableBehaviorTree
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::EnableBehaviorTree(class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "EnableBehaviorTree");

	Params::MaiController_EnableBehaviorTree Parms{};

	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.FilterActionPointsByCooldown
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AMaiActionPoint*>          InPoints                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AMaiController::FilterActionPointsByCooldown(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "FilterActionPointsByCooldown");

	Params::MaiController_FilterActionPointsByCooldown Parms{};

	Parms.InPoints = std::move(InPoints);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiController.FilterGraphPointsScript
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class AMaiActionPoint*>          InPoints                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AActor*                           Origin                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::FilterGraphPointsScript(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, class AActor* Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "FilterGraphPointsScript");

	Params::MaiController_FilterGraphPointsScript Parms{};

	Parms.InPoints = std::move(InPoints);
	Parms.Origin = Origin;

	UObject::ProcessEvent(Func, &Parms);

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiController.GetActionGraph
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMaiActionGraph*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiActionGraph* AMaiController::GetActionGraph()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "GetActionGraph");

	Params::MaiController_GetActionGraph Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.GetSenseConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UAISense>             SenseClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAISenseConfig*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAISenseConfig* AMaiController::GetSenseConfig(TSubclassOf<class UAISense> SenseClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "GetSenseConfig");

	Params::MaiController_GetSenseConfig Parms{};

	Parms.SenseClass = SenseClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.GetWallPathFollowing
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMaiWallFollowing*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiWallFollowing* AMaiController::GetWallPathFollowing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "GetWallPathFollowing");

	Params::MaiController_GetWallPathFollowing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.IgnorePoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMaiActionPoint*                  Point                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Cooldown                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::IgnorePoint(class AMaiActionPoint* Point, float Cooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "IgnorePoint");

	Params::MaiController_IgnorePoint Parms{};

	Parms.Point = Point;
	Parms.Cooldown = Cooldown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.IsCurrentlyPerceived
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OnlyHostile                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIStimulus                      Stimulus                                               (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiController::IsCurrentlyPerceived(class AActor* Actor, bool OnlyHostile, struct FAIStimulus* Stimulus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "IsCurrentlyPerceived");

	Params::MaiController_IsCurrentlyPerceived Parms{};

	Parms.Actor = Actor;
	Parms.OnlyHostile = OnlyHostile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Stimulus != nullptr)
		*Stimulus = std::move(Parms.Stimulus);

	return Parms.ReturnValue;
}


// Function Mai.MaiController.IsLocationSafe
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiController::IsLocationSafe(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "IsLocationSafe");

	Params::MaiController_IsLocationSafe Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.LoadBlackboard
// (Final, Native, Public, BlueprintCallable)

void AMaiController::LoadBlackboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "LoadBlackboard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.LostAttackSlot
// (Event, Public, BlueprintEvent)

void AMaiController::LostAttackSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "LostAttackSlot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Mai.MaiController.LostToken
// (Event, Public, BlueprintEvent)

void AMaiController::LostToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "LostToken");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Mai.MaiController.OnActionGraphChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class AMaiActionGraph*                  ActionGraph                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::OnActionGraphChanged(class AMaiActionGraph* ActionGraph)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "OnActionGraphChanged");

	Params::MaiController_OnActionGraphChanged Parms{};

	Parms.ActionGraph = ActionGraph;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiController.OnActionPointAbandoned
// (Event, Public, BlueprintEvent)
// Parameters:
// class AMaiActionPoint*                  ActionPoint                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::OnActionPointAbandoned(class AMaiActionPoint* ActionPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "OnActionPointAbandoned");

	Params::MaiController_OnActionPointAbandoned Parms{};

	Parms.ActionPoint = ActionPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiController.OnActionPointReached
// (Event, Public, BlueprintEvent)
// Parameters:
// class AMaiActionPoint*                  ActionPoint                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::OnActionPointReached(class AMaiActionPoint* ActionPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "OnActionPointReached");

	Params::MaiController_OnActionPointReached Parms{};

	Parms.ActionPoint = ActionPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiController.OnActionPointSelected
// (Event, Public, BlueprintEvent)
// Parameters:
// class AMaiActionPoint*                  ActionPoint                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::OnActionPointSelected(class AMaiActionPoint* ActionPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "OnActionPointSelected");

	Params::MaiController_OnActionPointSelected Parms{};

	Parms.ActionPoint = ActionPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiController.OnInitBehaviors
// (Event, Public, BlueprintEvent)

void AMaiController::OnInitBehaviors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "OnInitBehaviors");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Mai.MaiController.OnNavigationData
// (Event, Public, BlueprintEvent)

void AMaiController::OnNavigationData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "OnNavigationData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Mai.MaiController.OnPerceived
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIStimulus                      Stimulus                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AMaiController::OnPerceived(class AActor* Actor, const struct FAIStimulus& Stimulus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "OnPerceived");

	Params::MaiController_OnPerceived Parms{};

	Parms.Actor = Actor;
	Parms.Stimulus = std::move(Stimulus);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiController.OnPointerLoaded
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::OnPointerLoaded(class FName Key, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "OnPointerLoaded");

	Params::MaiController_OnPointerLoaded Parms{};

	Parms.Key = Key;
	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiController.PopBehaviorName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             behaviorName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::PopBehaviorName(class FName behaviorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "PopBehaviorName");

	Params::MaiController_PopBehaviorName Parms{};

	Parms.behaviorName = behaviorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.PushBehaviorName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             behaviorName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::PushBehaviorName(class FName behaviorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "PushBehaviorName");

	Params::MaiController_PushBehaviorName Parms{};

	Parms.behaviorName = behaviorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.ReachCurrentActionPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InjectTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    RunActions                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::ReachCurrentActionPoint(const struct FGameplayTag& InjectTag, bool RunActions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "ReachCurrentActionPoint");

	Params::MaiController_ReachCurrentActionPoint Parms{};

	Parms.InjectTag = std::move(InjectTag);
	Parms.RunActions = RunActions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.ReceivedAttackSlot
// (Event, Public, BlueprintEvent)

void AMaiController::ReceivedAttackSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "ReceivedAttackSlot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Mai.MaiController.ReceiveTokens
// (Event, Public, BlueprintEvent)
// Parameters:
// uint8                                   Pool                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 AMaiController::ReceiveTokens(uint8 Pool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "ReceiveTokens");

	Params::MaiController_ReceiveTokens Parms{};

	Parms.Pool = Pool;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mai.MaiController.RunActionPointActions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InjectTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiActionPoint*                  ActionPoint                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::RunActionPointActions(const struct FGameplayTag& InjectTag, class AMaiActionPoint* ActionPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "RunActionPointActions");

	Params::MaiController_RunActionPointActions Parms{};

	Parms.InjectTag = std::move(InjectTag);
	Parms.ActionPoint = ActionPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.RunActionPointWaitWork
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InjectTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiActionPoint*                  ActionPoint                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::RunActionPointWaitWork(const struct FGameplayTag& InjectTag, class AMaiActionPoint* ActionPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "RunActionPointWaitWork");

	Params::MaiController_RunActionPointWaitWork Parms{};

	Parms.InjectTag = std::move(InjectTag);
	Parms.ActionPoint = ActionPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.SaveActorPointer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::SaveActorPointer(class FName Key, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "SaveActorPointer");

	Params::MaiController_SaveActorPointer Parms{};

	Parms.Key = Key;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.SaveBlackboard
// (Final, Native, Public, BlueprintCallable)

void AMaiController::SaveBlackboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "SaveBlackboard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.SelectActionPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TMap<class AMaiActionPoint*, uint8>     ActionPoints                                           (Parm, NativeAccessSpecifierPublic)
// EPointSelection                         Method                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Origin                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiController::SelectActionPoint(const TMap<class AMaiActionPoint*, uint8>& ActionPoints, EPointSelection Method, class AActor* Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "SelectActionPoint");

	Params::MaiController_SelectActionPoint Parms{};

	Parms.ActionPoints = std::move(ActionPoints);
	Parms.Method = Method;
	Parms.Origin = Origin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.SelectNearestActionGraph
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             GraphTag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::SelectNearestActionGraph(class FName GraphTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "SelectNearestActionGraph");

	Params::MaiController_SelectNearestActionGraph Parms{};

	Parms.GraphTag = GraphTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.SelectNextActionPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPointSelection                         Method                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Origin                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiController::SelectNextActionPoint(EPointSelection Method, class AActor* Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "SelectNextActionPoint");

	Params::MaiController_SelectNextActionPoint Parms{};

	Parms.Method = Method;
	Parms.Origin = Origin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.SetCurrentActionGraph
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMaiActionGraph*                  PointGraph                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::SetCurrentActionGraph(class AMaiActionGraph* PointGraph)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "SetCurrentActionGraph");

	Params::MaiController_SetCurrentActionGraph Parms{};

	Parms.PointGraph = PointGraph;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.SetCurrentActionPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMaiActionPoint*                  ActionPoint                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Reset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiController::SetCurrentActionPoint(class AMaiActionPoint* ActionPoint, bool Reset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "SetCurrentActionPoint");

	Params::MaiController_SetCurrentActionPoint Parms{};

	Parms.ActionPoint = ActionPoint;
	Parms.Reset = Reset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.SetDespawnLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::SetDespawnLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "SetDespawnLocation");

	Params::MaiController_SetDespawnLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.SetGoalActionPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMaiActionPoint*                  GoalPoint                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiActionPoint*                  SubgoalPoint                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SequenceTag                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::SetGoalActionPoint(class AMaiActionPoint* GoalPoint, class AMaiActionPoint* SubgoalPoint, class FName SequenceTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "SetGoalActionPoint");

	Params::MaiController_SetGoalActionPoint Parms{};

	Parms.GoalPoint = GoalPoint;
	Parms.SubgoalPoint = SubgoalPoint;
	Parms.SequenceTag = SequenceTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.SetPartyID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   PartyID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiController::SetPartyID(uint8 PartyID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "SetPartyID");

	Params::MaiController_SetPartyID Parms{};

	Parms.PartyID = PartyID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.TeleportFrom
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceDirect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiController::TeleportFrom(const struct FVector& Location, float Distance, bool ForceDirect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "TeleportFrom");

	Params::MaiController_TeleportFrom Parms{};

	Parms.Location = std::move(Location);
	Parms.Distance = Distance;
	Parms.ForceDirect = ForceDirect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.TeleportInFrontOf
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiController::TeleportInFrontOf(class AActor* Actor, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "TeleportInFrontOf");

	Params::MaiController_TeleportInFrontOf Parms{};

	Parms.Actor = Actor;
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.TeleportTowards
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiController::TeleportTowards(const struct FVector& Location, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "TeleportTowards");

	Params::MaiController_TeleportTowards Parms{};

	Parms.Location = std::move(Location);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.UsedCurrentActionPoint
// (Final, Native, Public, BlueprintCallable)

void AMaiController::UsedCurrentActionPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "UsedCurrentActionPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiController.GetNavData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ANavigationData*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANavigationData* AMaiController::GetNavData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "GetNavData");

	Params::MaiController_GetNavData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.GetPartyID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 AMaiController::GetPartyID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "GetPartyID");

	Params::MaiController_GetPartyID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.GetPrevActionPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMaiActionPoint*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiActionPoint* AMaiController::GetPrevActionPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "GetPrevActionPoint");

	Params::MaiController_GetPrevActionPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.GetWorkLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector AMaiController::GetWorkLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "GetWorkLocation");

	Params::MaiController_GetWorkLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.GetYoungestStimulusAge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMaiController::GetYoungestStimulusAge(const class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "GetYoungestStimulusAge");

	Params::MaiController_GetYoungestStimulusAge Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.HasAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UBeingAction>         ActionClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiController::HasAction(TSubclassOf<class UBeingAction> ActionClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "HasAction");

	Params::MaiController_HasAction Parms{};

	Parms.ActionClass = ActionClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.HasAnyAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiController::HasAnyAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "HasAnyAction");

	Params::MaiController_HasAnyAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.HasAnyBehaviorName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     behaviorNames                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiController::HasAnyBehaviorName(const TArray<class FName>& behaviorNames) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "HasAnyBehaviorName");

	Params::MaiController_HasAnyBehaviorName Parms{};

	Parms.behaviorNames = std::move(behaviorNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.HasBehaviorName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             behaviorName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiController::HasBehaviorName(class FName behaviorName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "HasBehaviorName");

	Params::MaiController_HasBehaviorName Parms{};

	Parms.behaviorName = behaviorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.HasValidNavData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiController::HasValidNavData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "HasValidNavData");

	Params::MaiController_HasValidNavData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.HavePlaceToAvoid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiController::HavePlaceToAvoid(class APawn* Other) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "HavePlaceToAvoid");

	Params::MaiController_HavePlaceToAvoid Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.IsBehaviorTreeRunning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiController::IsBehaviorTreeRunning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "IsBehaviorTreeRunning");

	Params::MaiController_IsBehaviorTreeRunning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.IsCurrentActionPointReached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiController::IsCurrentActionPointReached() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "IsCurrentActionPointReached");

	Params::MaiController_IsCurrentActionPointReached Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.IsCurrentWayPointReached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiController::IsCurrentWayPointReached() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "IsCurrentWayPointReached");

	Params::MaiController_IsCurrentWayPointReached Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.IsIndoor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiController::IsIndoor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "IsIndoor");

	Params::MaiController_IsIndoor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiController.TopBehaviorName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AMaiController::TopBehaviorName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiController", "TopBehaviorName");

	Params::MaiController_TopBehaviorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiControllerExt.ClearForceChase
// (Final, Native, Public, BlueprintCallable)

void AMaiControllerExt::ClearForceChase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "ClearForceChase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiControllerExt.ClearIgnoreAll
// (Final, Native, Public, BlueprintCallable)

void AMaiControllerExt::ClearIgnoreAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "ClearIgnoreAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiControllerExt.FindEnemyToFight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AMaiControllerExt::FindEnemyToFight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "FindEnemyToFight");

	Params::MaiControllerExt_FindEnemyToFight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiControllerExt.ForceChase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ClearWhenPerceived                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiControllerExt::ForceChase(class AActor* Enemy, bool ClearWhenPerceived)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "ForceChase");

	Params::MaiControllerExt_ForceChase Parms{};

	Parms.Enemy = Enemy;
	Parms.ClearWhenPerceived = ClearWhenPerceived;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiControllerExt.SetAlertInstigator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiControllerExt::SetAlertInstigator(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "SetAlertInstigator");

	Params::MaiControllerExt_SetAlertInstigator Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiControllerExt.SetAlertLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiControllerExt::SetAlertLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "SetAlertLocation");

	Params::MaiControllerExt_SetAlertLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiControllerExt.SetArchEnemy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiControllerExt::SetArchEnemy(class AActor* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "SetArchEnemy");

	Params::MaiControllerExt_SetArchEnemy Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiControllerExt.SetChaseLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiControllerExt::SetChaseLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "SetChaseLocation");

	Params::MaiControllerExt_SetChaseLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiControllerExt.SetFightingEnemy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiControllerExt::SetFightingEnemy(class AActor* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "SetFightingEnemy");

	Params::MaiControllerExt_SetFightingEnemy Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiControllerExt.SetForcedEnemy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiControllerExt::SetForcedEnemy(class AActor* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "SetForcedEnemy");

	Params::MaiControllerExt_SetForcedEnemy Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiControllerExt.SetIgnoreAll
// (Final, Native, Public, BlueprintCallable)

void AMaiControllerExt::SetIgnoreAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "SetIgnoreAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiControllerExt.SetParty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMaiParty                               Party                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiControllerExt::SetParty(EMaiParty Party)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "SetParty");

	Params::MaiControllerExt_SetParty Parms{};

	Parms.Party = Party;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiControllerExt.UpdateEnemyData
// (Final, Native, Public, BlueprintCallable)

void AMaiControllerExt::UpdateEnemyData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "UpdateEnemyData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiControllerExt.GetAlertInstigator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AMaiControllerExt::GetAlertInstigator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "GetAlertInstigator");

	Params::MaiControllerExt_GetAlertInstigator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiControllerExt.GetAlertLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMaiControllerExt::GetAlertLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "GetAlertLocation");

	Params::MaiControllerExt_GetAlertLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiControllerExt.GetArchEnemy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AMaiControllerExt::GetArchEnemy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "GetArchEnemy");

	Params::MaiControllerExt_GetArchEnemy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiControllerExt.GetChaseLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMaiControllerExt::GetChaseLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "GetChaseLocation");

	Params::MaiControllerExt_GetChaseLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiControllerExt.GetFightingEnemy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AMaiControllerExt::GetFightingEnemy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "GetFightingEnemy");

	Params::MaiControllerExt_GetFightingEnemy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiControllerExt.GetForcedEnemy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AMaiControllerExt::GetForcedEnemy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "GetForcedEnemy");

	Params::MaiControllerExt_GetForcedEnemy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiControllerExt.GetParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMaiParty                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMaiParty AMaiControllerExt::GetParty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "GetParty");

	Params::MaiControllerExt_GetParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiControllerExt.IsFightingWith
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiControllerExt::IsFightingWith(class AActor* Enemy) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiControllerExt", "IsFightingWith");

	Params::MaiControllerExt_IsFightingWith Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCoverComponent.IsActorInCover
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiCoverComponent::IsActorInCover(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCoverComponent", "IsActorInCover");

	Params::MaiCoverComponent_IsActorInCover Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCoverComponent.IsUserInCover
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMaiCoverUser*                    User                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiCoverComponent::IsUserInCover(class UMaiCoverUser* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCoverComponent", "IsUserInCover");

	Params::MaiCoverComponent_IsUserInCover Parms{};

	Parms.User = User;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCoverComponent.OnOverlapBegin
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiCoverComponent::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCoverComponent", "OnOverlapBegin");

	Params::MaiCoverComponent_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCoverComponent.OnOverlapEnd
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiCoverComponent::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCoverComponent", "OnOverlapEnd");

	Params::MaiCoverComponent_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCoverUser.IsInCover
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     Filter                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiCoverUser::IsInCover(const struct FGameplayTag& Filter) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCoverUser", "IsInCover");

	Params::MaiCoverUser_IsInCover Parms{};

	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCoverUser.IsInFullCover
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     Filter                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiCoverUser::IsInFullCover(const struct FGameplayTag& Filter) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCoverUser", "IsInFullCover");

	Params::MaiCoverUser_IsInFullCover Parms{};

	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiPointOfInterest.OnDisable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AMaiPointOfInterest::OnDisable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiPointOfInterest", "OnDisable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiPointOfInterest.OnEnable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AMaiPointOfInterest::OnEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiPointOfInterest", "OnEnable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiPointOfInterest.SwitchOff
// (Final, Native, Public, BlueprintCallable)

void AMaiPointOfInterest::SwitchOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiPointOfInterest", "SwitchOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiPointOfInterest.SwitchOn
// (Final, Native, Public, BlueprintCallable)

void AMaiPointOfInterest::SwitchOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiPointOfInterest", "SwitchOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiPointOfInterest.SwitchOnFor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiPointOfInterest::SwitchOnFor(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiPointOfInterest", "SwitchOnFor");

	Params::MaiPointOfInterest_SwitchOnFor Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCuriosityComponent.DebugCuriosity
// (Final, Native, Public, BlueprintCallable)

void UMaiCuriosityComponent::DebugCuriosity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCuriosityComponent", "DebugCuriosity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCuriosityComponent.IgnorePoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMaiPointOfInterest*              Point                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiCuriosityComponent::IgnorePoint(class AMaiPointOfInterest* Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCuriosityComponent", "IgnorePoint");

	Params::MaiCuriosityComponent_IgnorePoint Parms{};

	Parms.Point = Point;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCuriosityComponent.OnTargetPerceptionUpdated
// (Final, Native, Public)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIStimulus                      Stimulus                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UMaiCuriosityComponent::OnTargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCuriosityComponent", "OnTargetPerceptionUpdated");

	Params::MaiCuriosityComponent_OnTargetPerceptionUpdated Parms{};

	Parms.Actor = Actor;
	Parms.Stimulus = std::move(Stimulus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCuriosityComponent.SelectPointOfInterest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMaiSelectionMethod                     Selection                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AMaiPointOfInterest>  PointClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiPointOfInterest*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiPointOfInterest* UMaiCuriosityComponent::SelectPointOfInterest(EMaiSelectionMethod Selection, TSubclassOf<class AMaiPointOfInterest> PointClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCuriosityComponent", "SelectPointOfInterest");

	Params::MaiCuriosityComponent_SelectPointOfInterest Parms{};

	Parms.Selection = Selection;
	Parms.PointClass = PointClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiCuriosityComponent.UpdateDetectedPoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   AreaExtent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiCuriosityComponent::UpdateDetectedPoints(float AreaExtent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCuriosityComponent", "UpdateDetectedPoints");

	Params::MaiCuriosityComponent_UpdateDetectedPoints Parms{};

	Parms.AreaExtent = AreaExtent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCuriosityComponent.UpdatePointsInPerception
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AMaiPointOfInterest>  PointClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AreaExtent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiCuriosityComponent::UpdatePointsInPerception(TSubclassOf<class AMaiPointOfInterest> PointClass, float AreaExtent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCuriosityComponent", "UpdatePointsInPerception");

	Params::MaiCuriosityComponent_UpdatePointsInPerception Parms{};

	Parms.PointClass = PointClass;
	Parms.AreaExtent = AreaExtent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiCuriosityComponent.ShouldIgnorePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMaiPointOfInterest*              Point                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiCuriosityComponent::ShouldIgnorePoint(class AMaiPointOfInterest* Point) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiCuriosityComponent", "ShouldIgnorePoint");

	Params::MaiCuriosityComponent_ShouldIgnorePoint Parms{};

	Parms.Point = Point;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.AIDataProvider_FromScript.ScriptBindData
// (Event, Public, BlueprintEvent)
// Parameters:
// class APawn*                            Pawn                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIDataProvider_FromScript::ScriptBindData(const class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIDataProvider_FromScript", "ScriptBindData");

	Params::AIDataProvider_FromScript_ScriptBindData Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.AIDataProvider_FromScript.SetBoolValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIDataProvider_FromScript::SetBoolValue(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIDataProvider_FromScript", "SetBoolValue");

	Params::AIDataProvider_FromScript_SetBoolValue Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.AIDataProvider_FromScript.SetFloatValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIDataProvider_FromScript::SetFloatValue(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIDataProvider_FromScript", "SetFloatValue");

	Params::AIDataProvider_FromScript_SetFloatValue Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.AIDataProvider_FromScript.SetIntValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIDataProvider_FromScript::SetIntValue(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIDataProvider_FromScript", "SetIntValue");

	Params::AIDataProvider_FromScript_SetIntValue Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.AIDataProvider_FromScript.ScriptToString
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAIDataProvider_FromScript::ScriptToString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIDataProvider_FromScript", "ScriptToString");

	Params::AIDataProvider_FromScript_ScriptToString Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mai.MaiDebugger.aiDebugPrint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ToScreen                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ToLog                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnoreActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Category                                               (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AiDebugPrint(class AActor* Actor, const class FString& InString, bool ToScreen, bool ToLog, const struct FLinearColor& Color, float Duration, bool IgnoreActor, const class FString& Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiDebugger", "aiDebugPrint");

	Params::MaiDebugger_AiDebugPrint Parms{};

	Parms.Actor = Actor;
	Parms.InString = std::move(InString);
	Parms.ToScreen = ToScreen;
	Parms.ToLog = ToLog;
	Parms.Color = std::move(Color);
	Parms.Duration = Duration;
	Parms.IgnoreActor = IgnoreActor;
	Parms.Category = std::move(Category);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.aiDebugPrint2
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMaiDebugPrintParams             Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, AdvancedDisplay, NativeAccessSpecifierPublic)

void AMaiDebugger::AiDebugPrint2(class AActor* Actor, const class FString& InString, const struct FMaiDebugPrintParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiDebugger", "aiDebugPrint2");

	Params::MaiDebugger_AiDebugPrint2 Parms{};

	Parms.Actor = Actor;
	Parms.InString = std::move(InString);
	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.getAIDebugActionPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiDebugger::GetAIDebugActionPath(class APawn* Being)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiDebugger", "getAIDebugActionPath");

	Params::MaiDebugger_GetAIDebugActionPath Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiDebugger.getAIDebugActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AMaiDebugger::GetAIDebugActor(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiDebugger", "getAIDebugActor");

	Params::MaiDebugger_GetAIDebugActor Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiDebugger.getAIDebugAggro
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiDebugger::GetAIDebugAggro(class APawn* Being)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiDebugger", "getAIDebugAggro");

	Params::MaiDebugger_GetAIDebugAggro Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiDebugger.getAIDebugAttack
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiDebugger::GetAIDebugAttack(class APawn* Being)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiDebugger", "getAIDebugAttack");

	Params::MaiDebugger_GetAIDebugAttack Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiDebugger.getAIDebugCuriosity
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiDebugger::GetAIDebugCuriosity(class APawn* Being)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiDebugger", "getAIDebugCuriosity");

	Params::MaiDebugger_GetAIDebugCuriosity Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiDebugger.getAIDebugger
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OnlyIfActive                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiDebugger*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiDebugger* AMaiDebugger::GetAIDebugger(class UObject* WorldContext, bool OnlyIfActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiDebugger", "getAIDebugger");

	Params::MaiDebugger_GetAIDebugger Parms{};

	Parms.WorldContext = WorldContext;
	Parms.OnlyIfActive = OnlyIfActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiDebugger.getAIDebugGState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiDebugger::GetAIDebugGState(class UObject* WorldContext, class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiDebugger", "getAIDebugGState");

	Params::MaiDebugger_GetAIDebugGState Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiDebugger.getAIDebugHearing
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiDebugger::GetAIDebugHearing(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiDebugger", "getAIDebugHearing");

	Params::MaiDebugger_GetAIDebugHearing Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiDebugger.getAIDebugMovement
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiDebugger::GetAIDebugMovement(class APawn* Being)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiDebugger", "getAIDebugMovement");

	Params::MaiDebugger_GetAIDebugMovement Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiDebugger.getAIDebugNavPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiDebugger::GetAIDebugNavPath(class APawn* Being)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiDebugger", "getAIDebugNavPath");

	Params::MaiDebugger_GetAIDebugNavPath Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiDebugger.getAIDebugNoises
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiDebugger::GetAIDebugNoises(class APawn* Being)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiDebugger", "getAIDebugNoises");

	Params::MaiDebugger_GetAIDebugNoises Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiDebugger.getAIDebugOdor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiDebugger::GetAIDebugOdor(class APawn* Being)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiDebugger", "getAIDebugOdor");

	Params::MaiDebugger_GetAIDebugOdor Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiDebugger.getAIDebugSight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiDebugger::GetAIDebugSight(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiDebugger", "getAIDebugSight");

	Params::MaiDebugger_GetAIDebugSight Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiDebugger.getAIDebugSmell
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiDebugger::GetAIDebugSmell(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiDebugger", "getAIDebugSmell");

	Params::MaiDebugger_GetAIDebugSmell Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiDebugger.getAIDebugState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiDebugger::GetAIDebugState(class APawn* Being, class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiDebugger", "getAIDebugState");

	Params::MaiDebugger_GetAIDebugState Parms{};

	Parms.Being = Being;
	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiDebugger.getAIDebugVisibility
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiDebugger::GetAIDebugVisibility(class APawn* Being)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiDebugger", "getAIDebugVisibility");

	Params::MaiDebugger_GetAIDebugVisibility Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiDebugger.AIDebugActionPath
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugActionPath(bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugActionPath");

	Params::MaiDebugger_AIDebugActionPath Parms{};

	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugActor
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugActor(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugActor");

	Params::MaiDebugger_AIDebugActor Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugAddState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugAddState(class FName Name_0, bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugAddState");

	Params::MaiDebugger_AIDebugAddState Parms{};

	Parms.Name_0 = Name_0;
	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugAggro
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugAggro(bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugAggro");

	Params::MaiDebugger_AIDebugAggro Parms{};

	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugAInfo
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugAInfo(bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugAInfo");

	Params::MaiDebugger_AIDebugAInfo Parms{};

	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugAttack
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugAttack(bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugAttack");

	Params::MaiDebugger_AIDebugAttack Parms{};

	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugBehaviorTree
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugBehaviorTree(bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugBehaviorTree");

	Params::MaiDebugger_AIDebugBehaviorTree Parms{};

	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugCuriosity
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugCuriosity(bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugCuriosity");

	Params::MaiDebugger_AIDebugCuriosity Parms{};

	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugEQS
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugEQS(bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugEQS");

	Params::MaiDebugger_AIDebugEQS Parms{};

	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugEQSDetails
// (Final, Exec, Native, Public, BlueprintCallable)

void AMaiDebugger::AIDebugEQSDetails()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugEQSDetails");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugEQSSwitch
// (Final, Exec, Native, Public, BlueprintCallable)

void AMaiDebugger::AIDebugEQSSwitch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugEQSSwitch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugger
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Activate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugger(bool Activate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugger");

	Params::MaiDebugger_AIDebugger Parms{};

	Parms.Activate = Activate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugHearing
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugHearing(bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugHearing");

	Params::MaiDebugger_AIDebugHearing Parms{};

	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugHUD
// (Final, Exec, Native, Public, BlueprintCallable)

void AMaiDebugger::AIDebugHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugHUD");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugMovement
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugMovement(bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugMovement");

	Params::MaiDebugger_AIDebugMovement Parms{};

	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugNavMesh
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugNavMesh(bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugNavMesh");

	Params::MaiDebugger_AIDebugNavMesh Parms{};

	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugNavPath
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugNavPath(bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugNavPath");

	Params::MaiDebugger_AIDebugNavPath Parms{};

	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugNextActor
// (Final, Exec, Native, Public, BlueprintCallable)

void AMaiDebugger::AIDebugNextActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugNextActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugNoises
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugNoises(bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugNoises");

	Params::MaiDebugger_AIDebugNoises Parms{};

	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugOdor
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugOdor(bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugOdor");

	Params::MaiDebugger_AIDebugOdor Parms{};

	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugPerception
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugPerception(bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugPerception");

	Params::MaiDebugger_AIDebugPerception Parms{};

	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugPrevActor
// (Final, Exec, Native, Public, BlueprintCallable)

void AMaiDebugger::AIDebugPrevActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugPrevActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugSight
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugSight(bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugSight");

	Params::MaiDebugger_AIDebugSight Parms{};

	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugSmell
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugSmell(bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugSmell");

	Params::MaiDebugger_AIDebugSmell Parms{};

	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugSpectator
// (Final, Native, Public, BlueprintCallable)

void AMaiDebugger::AIDebugSpectator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugSpectator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugState
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugState(class FName Name_0, bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugState");

	Params::MaiDebugger_AIDebugState Parms{};

	Parms.Name_0 = Name_0;
	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugUnreal
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugUnreal(bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugUnreal");

	Params::MaiDebugger_AIDebugUnreal Parms{};

	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiDebugger.AIDebugVisibility
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiDebugger::AIDebugVisibility(bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiDebugger", "AIDebugVisibility");

	Params::MaiDebugger_AIDebugVisibility Parms{};

	Parms.Debug = Debug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFlyingGraph.FindNearestPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiController*                   User                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiFlyingPoint*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiFlyingPoint* AMaiFlyingGraph::FindNearestPoint(const struct FVector& Location, float Radius, class AMaiController* User) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiFlyingGraph", "FindNearestPoint");

	Params::MaiFlyingGraph_FindNearestPoint Parms{};

	Parms.Location = std::move(Location);
	Parms.Radius = Radius;
	Parms.User = User;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFlyingGraph.GetPointCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMaiFlyingGraph::GetPointCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiFlyingGraph", "GetPointCount");

	Params::MaiFlyingGraph_GetPointCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFlyingGraph.GetPoints
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AMaiFlyingPoint*>          ActionPoints                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AMaiFlyingGraph::GetPoints(TArray<class AMaiFlyingPoint*>* ActionPoints) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiFlyingGraph", "GetPoints");

	Params::MaiFlyingGraph_GetPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ActionPoints != nullptr)
		*ActionPoints = std::move(Parms.ActionPoints);
}


// Function Mai.MaiFlyingGraph.GetPointsInRange
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AMaiFlyingPoint*>          ActionPoints                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Pos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiFlyingGraph::GetPointsInRange(TArray<class AMaiFlyingPoint*>* ActionPoints, const struct FVector& Pos, float Radius) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiFlyingGraph", "GetPointsInRange");

	Params::MaiFlyingGraph_GetPointsInRange Parms{};

	Parms.Pos = std::move(Pos);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ActionPoints != nullptr)
		*ActionPoints = std::move(Parms.ActionPoints);
}


// Function Mai.MaiFlyingGraph.GetRandomPoint
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AMaiFlyingPoint*>          ActionPoints                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AMaiFlyingPoint*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiFlyingPoint* AMaiFlyingGraph::GetRandomPoint(const TArray<class AMaiFlyingPoint*>& ActionPoints) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiFlyingGraph", "GetRandomPoint");

	Params::MaiFlyingGraph_GetRandomPoint Parms{};

	Parms.ActionPoints = std::move(ActionPoints);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFlyingGraphComponent.FindNearestPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiFlyingPoint*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiFlyingPoint* UMaiFlyingGraphComponent::FindNearestPoint(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiFlyingGraphComponent", "FindNearestPoint");

	Params::MaiFlyingGraphComponent_FindNearestPoint Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFlyingGraphComponent.GetPointCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMaiFlyingGraphComponent::GetPointCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiFlyingGraphComponent", "GetPointCount");

	Params::MaiFlyingGraphComponent_GetPointCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFlyingGraphComponent.GetPoints
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AMaiFlyingPoint*>          ActionPoints                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMaiFlyingGraphComponent::GetPoints(TArray<class AMaiFlyingPoint*>* ActionPoints) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiFlyingGraphComponent", "GetPoints");

	Params::MaiFlyingGraphComponent_GetPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ActionPoints != nullptr)
		*ActionPoints = std::move(Parms.ActionPoints);
}


// Function Mai.MaiFlyingGraphComponent.GetPointsInRange
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AMaiFlyingPoint*>          ActionPoints                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Pos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFlyingGraphComponent::GetPointsInRange(TArray<class AMaiFlyingPoint*>* ActionPoints, const struct FVector& Pos, float Radius) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiFlyingGraphComponent", "GetPointsInRange");

	Params::MaiFlyingGraphComponent_GetPointsInRange Parms{};

	Parms.Pos = std::move(Pos);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ActionPoints != nullptr)
		*ActionPoints = std::move(Parms.ActionPoints);
}


// Function Mai.MaiFlyingGraphComponent.GetRandomPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMaiFlyingPoint*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiFlyingPoint* UMaiFlyingGraphComponent::GetRandomPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiFlyingGraphComponent", "GetRandomPoint");

	Params::MaiFlyingGraphComponent_GetRandomPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.actionsAbortByClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UBeingAction>         ActionClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Exact                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::ActionsAbortByClass(class AController* Controller, TSubclassOf<class UBeingAction> ActionClass, bool Exact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "actionsAbortByClass");

	Params::MaiFunctions_ActionsAbortByClass Parms{};

	Parms.Controller = Controller;
	Parms.ActionClass = ActionClass;
	Parms.Exact = Exact;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.actionsAbortByPriority
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIRequestPriority                      Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Exact                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::ActionsAbortByPriority(class AController* Controller, EAIRequestPriority Priority, bool Exact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "actionsAbortByPriority");

	Params::MaiFunctions_ActionsAbortByPriority Parms{};

	Parms.Controller = Controller;
	Parms.Priority = Priority;
	Parms.Exact = Exact;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.actionsAbortInstigatedBy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InstigatedBy                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::ActionsAbortInstigatedBy(class AController* Controller, const class UObject* InstigatedBy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "actionsAbortInstigatedBy");

	Params::MaiFunctions_ActionsAbortInstigatedBy Parms{};

	Parms.Controller = Controller;
	Parms.InstigatedBy = InstigatedBy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.actionsAdd
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBeingAction*                     Action                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIRequestPriority                      Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InstigatedBy                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::ActionsAdd(class AController* Controller, class UBeingAction* Action, EAIRequestPriority Priority, class UObject* InstigatedBy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "actionsAdd");

	Params::MaiFunctions_ActionsAdd Parms{};

	Parms.Controller = Controller;
	Parms.Action = Action;
	Parms.Priority = Priority;
	Parms.InstigatedBy = InstigatedBy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.actionsClearAll
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::ActionsClearAll(class AController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "actionsClearAll");

	Params::MaiFunctions_ActionsClearAll Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.actionsGetCurrent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AController*                      Controller                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBeingAction*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBeingAction* UMaiFunctions::ActionsGetCurrent(const class AController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "actionsGetCurrent");

	Params::MaiFunctions_ActionsGetCurrent Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.actionsHasAny
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AController*                      Controller                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::ActionsHasAny(const class AController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "actionsHasAny");

	Params::MaiFunctions_ActionsHasAny Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.actionsHasOfClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AController*                      Controller                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UBeingAction>         ActionClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::ActionsHasOfClass(const class AController* Controller, TSubclassOf<class UBeingAction> ActionClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "actionsHasOfClass");

	Params::MaiFunctions_ActionsHasOfClass Parms{};

	Parms.Controller = Controller;
	Parms.ActionClass = ActionClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.actionsIsActive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AController*                      Controller                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UBeingAction>         ActionClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::ActionsIsActive(const class AController* Controller, TSubclassOf<class UBeingAction> ActionClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "actionsIsActive");

	Params::MaiFunctions_ActionsIsActive Parms{};

	Parms.Controller = Controller;
	Parms.ActionClass = ActionClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.allowPhysicsRotationDuringRootMotion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Allow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::AllowPhysicsRotationDuringRootMotion(class ACharacter* Being, bool Allow, uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "allowPhysicsRotationDuringRootMotion");

	Params::MaiFunctions_AllowPhysicsRotationDuringRootMotion Parms{};

	Parms.Being = Being;
	Parms.Allow = Allow;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.calcAvaragePosition
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Weighted                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMaiFunctions::CalcAvaragePosition(const TArray<class AActor*>& Actors, const class AActor* Weighted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "calcAvaragePosition");

	Params::MaiFunctions_CalcAvaragePosition Parms{};

	Parms.Actors = std::move(Actors);
	Parms.Weighted = Weighted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.calcDirLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Inversed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMaiFunctions::CalcDirLocation(class APawn* Being, class APawn* Target, const struct FVector& Source, float Radius, bool Inversed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "calcDirLocation");

	Params::MaiFunctions_CalcDirLocation Parms{};

	Parms.Being = Being;
	Parms.Target = Target;
	Parms.Source = std::move(Source);
	Parms.Radius = Radius;
	Parms.Inversed = Inversed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.canGoDirectly
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PointA                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PointB                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANavigationData*                  NavData                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNavigationQueryFilter>FilterClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::CanGoDirectly(class UObject* WorldContext, const struct FVector& PointA, const struct FVector& PointB, class ANavigationData* NavData, TSubclassOf<class UNavigationQueryFilter> FilterClass, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "canGoDirectly");

	Params::MaiFunctions_CanGoDirectly Parms{};

	Parms.WorldContext = WorldContext;
	Parms.PointA = std::move(PointA);
	Parms.PointB = std::move(PointB);
	Parms.NavData = NavData;
	Parms.FilterClass = FilterClass;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.canWalkOnWalls
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::CanWalkOnWalls(class APawn* Being)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "canWalkOnWalls");

	Params::MaiFunctions_CanWalkOnWalls Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.clearBlackboard
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::ClearBlackboard(class AAIController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "clearBlackboard");

	Params::MaiFunctions_ClearBlackboard Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.clearPhysicsRotationDuringRootMotion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::ClearPhysicsRotationDuringRootMotion(class ACharacter* Being, uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "clearPhysicsRotationDuringRootMotion");

	Params::MaiFunctions_ClearPhysicsRotationDuringRootMotion Parms{};

	Parms.Being = Being;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.disableActionSync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::DisableActionSync(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "disableActionSync");

	Params::MaiFunctions_DisableActionSync Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.DisableActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Disable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::DisableActor(class AActor* Actor, bool Disable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "DisableActor");

	Params::MaiFunctions_DisableActor Parms{};

	Parms.Actor = Actor;
	Parms.Disable = Disable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.DisableBehaviorTree
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::DisableBehaviorTree(class AActor* Actor, class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "DisableBehaviorTree");

	Params::MaiFunctions_DisableBehaviorTree Parms{};

	Parms.Actor = Actor;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.doesPathToLocationExists
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PathStart                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PathEnd                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           PathfindingContext                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNavigationQueryFilter>FilterClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::DoesPathToLocationExists(class UObject* WorldContext, const struct FVector& PathStart, const struct FVector& PathEnd, class AActor* PathfindingContext, TSubclassOf<class UNavigationQueryFilter> FilterClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "doesPathToLocationExists");

	Params::MaiFunctions_DoesPathToLocationExists Parms{};

	Parms.WorldContext = WorldContext;
	Parms.PathStart = std::move(PathStart);
	Parms.PathEnd = std::move(PathEnd);
	Parms.PathfindingContext = PathfindingContext;
	Parms.FilterClass = FilterClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.drawLastLocations
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBeingLocationTracker*            Tracker                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::DrawLastLocations(class UBeingLocationTracker* Tracker, float Extent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "drawLastLocations");

	Params::MaiFunctions_DrawLastLocations Parms{};

	Parms.Tracker = Tracker;
	Parms.Extent = Extent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.EnableBehaviorTree
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::EnableBehaviorTree(class AActor* Actor, class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "EnableBehaviorTree");

	Params::MaiFunctions_EnableBehaviorTree Parms{};

	Parms.Actor = Actor;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.filterActionPoints_ByClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AMaiActionPoint*>          InPoints                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TSubclassOf<class AMaiActionPoint>      PointClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::FilterActionPoints_ByClass(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, TSubclassOf<class AMaiActionPoint> PointClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "filterActionPoints_ByClass");

	Params::MaiFunctions_FilterActionPoints_ByClass Parms{};

	Parms.InPoints = std::move(InPoints);
	Parms.PointClass = PointClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiFunctions.filterActionPoints_ByCondition
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AMaiActionPoint*>          InPoints                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AActor*                           Caller                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDaiCondition*                    Condition                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::FilterActionPoints_ByCondition(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, class AActor* Caller, class UDaiCondition* Condition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "filterActionPoints_ByCondition");

	Params::MaiFunctions_FilterActionPoints_ByCondition Parms{};

	Parms.InPoints = std::move(InPoints);
	Parms.Caller = Caller;
	Parms.Condition = Condition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiFunctions.filterActionPoints_ByConditions
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AMaiActionPoint*>          InPoints                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AActor*                           Caller                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDaiConditions                   Conditions                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMaiFunctions::FilterActionPoints_ByConditions(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, class AActor* Caller, const struct FDaiConditions& Conditions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "filterActionPoints_ByConditions");

	Params::MaiFunctions_FilterActionPoints_ByConditions Parms{};

	Parms.InPoints = std::move(InPoints);
	Parms.Caller = Caller;
	Parms.Conditions = std::move(Conditions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiFunctions.filterActionPoints_ByUseConditions
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AMaiActionPoint*>          InPoints                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AActor*                           User                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::FilterActionPoints_ByUseConditions(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, class AActor* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "filterActionPoints_ByUseConditions");

	Params::MaiFunctions_FilterActionPoints_ByUseConditions Parms{};

	Parms.InPoints = std::move(InPoints);
	Parms.User = User;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiFunctions.filterActionPoints_ByWeight
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AMaiActionPoint*>          InPoints                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// uint8                                   IgnoreWeight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::FilterActionPoints_ByWeight(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, uint8 IgnoreWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "filterActionPoints_ByWeight");

	Params::MaiFunctions_FilterActionPoints_ByWeight Parms{};

	Parms.InPoints = std::move(InPoints);
	Parms.IgnoreWeight = IgnoreWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiFunctions.filterActionPoints_InDetectionArea
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AMaiActionPoint*>          InPoints                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AreaExtent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::FilterActionPoints_InDetectionArea(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, const struct FVector& Location, float AreaExtent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "filterActionPoints_InDetectionArea");

	Params::MaiFunctions_FilterActionPoints_InDetectionArea Parms{};

	Parms.InPoints = std::move(InPoints);
	Parms.Location = std::move(Location);
	Parms.AreaExtent = AreaExtent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiFunctions.filterActionPoints_InRange
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AMaiActionPoint*>          InPoints                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::FilterActionPoints_InRange(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, const struct FVector& Location, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "filterActionPoints_InRange");

	Params::MaiFunctions_FilterActionPoints_InRange Parms{};

	Parms.InPoints = std::move(InPoints);
	Parms.Location = std::move(Location);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiFunctions.filterActionPoints_InsideRange
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AMaiActionPoint*>          InPoints                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::FilterActionPoints_InsideRange(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, const struct FVector& Location, float Min, float Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "filterActionPoints_InsideRange");

	Params::MaiFunctions_FilterActionPoints_InsideRange Parms{};

	Parms.InPoints = std::move(InPoints);
	Parms.Location = std::move(Location);
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiFunctions.filterActionPoints_InVisibilityRadius
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AMaiActionPoint*>          InPoints                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PerceptionMod                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::FilterActionPoints_InVisibilityRadius(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, const struct FVector& Location, float Radius, float PerceptionMod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "filterActionPoints_InVisibilityRadius");

	Params::MaiFunctions_FilterActionPoints_InVisibilityRadius Parms{};

	Parms.InPoints = std::move(InPoints);
	Parms.Location = std::move(Location);
	Parms.Radius = Radius;
	Parms.PerceptionMod = PerceptionMod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiFunctions.filterActionPoints_IsSafe
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AMaiActionPoint*>          InPoints                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::FilterActionPoints_IsSafe(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "filterActionPoints_IsSafe");

	Params::MaiFunctions_FilterActionPoints_IsSafe Parms{};

	Parms.InPoints = std::move(InPoints);
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiFunctions.filterActionPoints_OutRange
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AMaiActionPoint*>          InPoints                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::FilterActionPoints_OutRange(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, const struct FVector& Location, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "filterActionPoints_OutRange");

	Params::MaiFunctions_FilterActionPoints_OutRange Parms{};

	Parms.InPoints = std::move(InPoints);
	Parms.Location = std::move(Location);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiFunctions.filterActionPoints_SortByRange
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AMaiActionPoint*>          InPoints                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::FilterActionPoints_SortByRange(const TArray<class AMaiActionPoint*>& InPoints, TArray<class AMaiActionPoint*>* OutPoints, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "filterActionPoints_SortByRange");

	Params::MaiFunctions_FilterActionPoints_SortByRange Parms{};

	Parms.InPoints = std::move(InPoints);
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiFunctions.filterBeings_By2D5Distance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class APawn*>                    InBeings                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class APawn*>                    OutBeings                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinDist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::FilterBeings_By2D5Distance(const TArray<class APawn*>& InBeings, TArray<class APawn*>* OutBeings, class AActor* Actor, float MaxDist, float MinDist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "filterBeings_By2D5Distance");

	Params::MaiFunctions_FilterBeings_By2D5Distance Parms{};

	Parms.InBeings = std::move(InBeings);
	Parms.Actor = Actor;
	Parms.MaxDist = MaxDist;
	Parms.MinDist = MinDist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBeings != nullptr)
		*OutBeings = std::move(Parms.OutBeings);
}


// Function Mai.MaiFunctions.filterBeings_ByAggro
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class APawn*>                    InBeings                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class APawn*>                    OutBeings                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Neutral                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Cautious                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Aggressive                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::FilterBeings_ByAggro(const TArray<class APawn*>& InBeings, TArray<class APawn*>* OutBeings, class APawn* Being, bool Neutral, bool Cautious, bool Aggressive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "filterBeings_ByAggro");

	Params::MaiFunctions_FilterBeings_ByAggro Parms{};

	Parms.InBeings = std::move(InBeings);
	Parms.Being = Being;
	Parms.Neutral = Neutral;
	Parms.Cautious = Cautious;
	Parms.Aggressive = Aggressive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBeings != nullptr)
		*OutBeings = std::move(Parms.OutBeings);
}


// Function Mai.MaiFunctions.filterBeings_ByAngle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class APawn*>                    InBeings                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class APawn*>                    OutBeings                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InAngle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::FilterBeings_ByAngle(const TArray<class APawn*>& InBeings, TArray<class APawn*>* OutBeings, const struct FVector& Origin, const struct FVector& Direction, float Angle, bool InAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "filterBeings_ByAngle");

	Params::MaiFunctions_FilterBeings_ByAngle Parms{};

	Parms.InBeings = std::move(InBeings);
	Parms.Origin = std::move(Origin);
	Parms.Direction = std::move(Direction);
	Parms.Angle = Angle;
	Parms.InAngle = InAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBeings != nullptr)
		*OutBeings = std::move(Parms.OutBeings);
}


// Function Mai.MaiFunctions.filterBeings_ByAttitude
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class APawn*>                    InBeings                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class APawn*>                    OutBeings                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Friendly                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Neutral                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Hostile                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::FilterBeings_ByAttitude(const TArray<class APawn*>& InBeings, TArray<class APawn*>* OutBeings, class APawn* Being, bool Friendly, bool Neutral, bool Hostile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "filterBeings_ByAttitude");

	Params::MaiFunctions_FilterBeings_ByAttitude Parms{};

	Parms.InBeings = std::move(InBeings);
	Parms.Being = Being;
	Parms.Friendly = Friendly;
	Parms.Neutral = Neutral;
	Parms.Hostile = Hostile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBeings != nullptr)
		*OutBeings = std::move(Parms.OutBeings);
}


// Function Mai.MaiFunctions.filterBeings_ByDistance
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class APawn*>                    InBeings                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class APawn*>                    OutBeings                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EDaiDistanceType                        DistanceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinDist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::FilterBeings_ByDistance(const TArray<class APawn*>& InBeings, TArray<class APawn*>* OutBeings, EDaiDistanceType DistanceType, const struct FVector& Origin, float MaxDist, float MinDist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "filterBeings_ByDistance");

	Params::MaiFunctions_FilterBeings_ByDistance Parms{};

	Parms.InBeings = std::move(InBeings);
	Parms.DistanceType = DistanceType;
	Parms.Origin = std::move(Origin);
	Parms.MaxDist = MaxDist;
	Parms.MinDist = MinDist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBeings != nullptr)
		*OutBeings = std::move(Parms.OutBeings);
}


// Function Mai.MaiFunctions.filterBeings_OnlyAlive
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class APawn*>                    InBeings                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class APawn*>                    OutBeings                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMaiFunctions::FilterBeings_OnlyAlive(const TArray<class APawn*>& InBeings, TArray<class APawn*>* OutBeings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "filterBeings_OnlyAlive");

	Params::MaiFunctions_FilterBeings_OnlyAlive Parms{};

	Parms.InBeings = std::move(InBeings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBeings != nullptr)
		*OutBeings = std::move(Parms.OutBeings);
}


// Function Mai.MaiFunctions.findAllBeingsByTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Context                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class APawn>                beingClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludeDisabled                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class APawn*>                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class APawn*> UMaiFunctions::FindAllBeingsByTag(const class UObject* Context, class FName Tag, TSubclassOf<class APawn> beingClass, bool IncludeDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "findAllBeingsByTag");

	Params::MaiFunctions_FindAllBeingsByTag Parms{};

	Parms.Context = Context;
	Parms.Tag = Tag;
	Parms.beingClass = beingClass;
	Parms.IncludeDisabled = IncludeDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.findAllBeingsWithInterface
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Context                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class IInterface>           beingInterface                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class APawn*>                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class APawn*> UMaiFunctions::FindAllBeingsWithInterface(const class UObject* Context, class FName Tag, TSubclassOf<class IInterface> beingInterface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "findAllBeingsWithInterface");

	Params::MaiFunctions_FindAllBeingsWithInterface Parms{};

	Parms.Context = Context;
	Parms.Tag = Tag;
	Parms.beingInterface = beingInterface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.findAllEnemies
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMaiController*                   Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   Enemies                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::FindAllEnemies(class AMaiController* Controller, TArray<class AActor*>* Enemies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "findAllEnemies");

	Params::MaiFunctions_FindAllEnemies Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Enemies != nullptr)
		*Enemies = std::move(Parms.Enemies);

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.findArchEnemy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMaiController*                   Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMaiFunctions::FindArchEnemy(class AMaiController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "findArchEnemy");

	Params::MaiFunctions_FindArchEnemy Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.findComponentFromAI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      ComponentClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* UMaiFunctions::FindComponentFromAI(class AActor* Actor, TSubclassOf<class UActorComponent> ComponentClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "findComponentFromAI");

	Params::MaiFunctions_FindComponentFromAI Parms{};

	Parms.Actor = Actor;
	Parms.ComponentClass = ComponentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.findFarestActionPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AMaiActionPoint*>          InPoints                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiActionPoint*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiActionPoint* UMaiFunctions::FindFarestActionPoint(const TArray<class AMaiActionPoint*>& InPoints, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "findFarestActionPoint");

	Params::MaiFunctions_FindFarestActionPoint Parms{};

	Parms.InPoints = std::move(InPoints);
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.findHighestWeight
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AMaiActionPoint*>          InPoints                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UMaiFunctions::FindHighestWeight(const TArray<class AMaiActionPoint*>& InPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "findHighestWeight");

	Params::MaiFunctions_FindHighestWeight Parms{};

	Parms.InPoints = std::move(InPoints);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.findLastLocationNotInNarrowArea
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::FindLastLocationNotInNarrowArea(struct FVector* Location, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "findLastLocationNotInNarrowArea");

	Params::MaiFunctions_FindLastLocationNotInNarrowArea Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.findNearestActionGraph
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             GraphTag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckPoints                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiActionGraph*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiActionGraph* UMaiFunctions::FindNearestActionGraph(class UObject* Context, const struct FVector& Location, class FName GraphTag, bool CheckPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "findNearestActionGraph");

	Params::MaiFunctions_FindNearestActionGraph Parms{};

	Parms.Context = Context;
	Parms.Location = std::move(Location);
	Parms.GraphTag = GraphTag;
	Parms.CheckPoints = CheckPoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.findNearestActionPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AMaiActionPoint*>          InPoints                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiActionPoint*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiActionPoint* UMaiFunctions::FindNearestActionPoint(const TArray<class AMaiActionPoint*>& InPoints, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "findNearestActionPoint");

	Params::MaiFunctions_FindNearestActionPoint Parms{};

	Parms.InPoints = std::move(InPoints);
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.findNearestBeingByTag
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Context                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class APawn>                beingClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UMaiFunctions::FindNearestBeingByTag(const class UObject* Context, const struct FVector& Origin, class FName Tag, TSubclassOf<class APawn> beingClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "findNearestBeingByTag");

	Params::MaiFunctions_FindNearestBeingByTag Parms{};

	Parms.Context = Context;
	Parms.Origin = std::move(Origin);
	Parms.Tag = Tag;
	Parms.beingClass = beingClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.findNearestFlyingGraph
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             GraphTag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckPoints                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiFlyingGraph*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiFlyingGraph* UMaiFunctions::FindNearestFlyingGraph(class UObject* Context, const struct FVector& Location, class FName GraphTag, bool CheckPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "findNearestFlyingGraph");

	Params::MaiFunctions_FindNearestFlyingGraph Parms{};

	Parms.Context = Context;
	Parms.Location = std::move(Location);
	Parms.GraphTag = GraphTag;
	Parms.CheckPoints = CheckPoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.findRandomActionPoint
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AMaiActionPoint*>          InPoints                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    UseWeights                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiActionPoint*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiActionPoint* UMaiFunctions::FindRandomActionPoint(const TArray<class AMaiActionPoint*>& InPoints, bool UseWeights)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "findRandomActionPoint");

	Params::MaiFunctions_FindRandomActionPoint Parms{};

	Parms.InPoints = std::move(InPoints);
	Parms.UseWeights = UseWeights;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.get2D5Distance
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HeightTolerance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RadiusTolerance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaiFunctions::Get2D5Distance(const struct FVector& Origin, const struct FVector& Target, float HeightTolerance, float RadiusTolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "get2D5Distance");

	Params::MaiFunctions_Get2D5Distance Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Target = std::move(Target);
	Parms.HeightTolerance = HeightTolerance;
	Parms.RadiusTolerance = RadiusTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.get2D5DistanceBetween
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Origin                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Overlap                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaiFunctions::Get2D5DistanceBetween(class AActor* Origin, class AActor* Target, bool Overlap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "get2D5DistanceBetween");

	Params::MaiFunctions_Get2D5DistanceBetween Parms{};

	Parms.Origin = Origin;
	Parms.Target = Target;
	Parms.Overlap = Overlap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.get2D5DistanceTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Origin                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Overlap                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaiFunctions::Get2D5DistanceTo(class AActor* Origin, const struct FVector& Target, bool Overlap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "get2D5DistanceTo");

	Params::MaiFunctions_Get2D5DistanceTo Parms{};

	Parms.Origin = Origin;
	Parms.Target = std::move(Target);
	Parms.Overlap = Overlap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getActorActionPoints
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMaiFunctions::GetActorActionPoints(class AActor* Actor, TArray<class AMaiActionPoint*>* OutPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getActorActionPoints");

	Params::MaiFunctions_GetActorActionPoints Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiFunctions.getActorDistToNearestBeing
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class APawn>                beingClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            NearestBeing                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaiFunctions::GetActorDistToNearestBeing(class AActor* Actor, class FName Tag, TSubclassOf<class APawn> beingClass, class APawn** NearestBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getActorDistToNearestBeing");

	Params::MaiFunctions_GetActorDistToNearestBeing Parms{};

	Parms.Actor = Actor;
	Parms.Tag = Tag;
	Parms.beingClass = beingClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NearestBeing != nullptr)
		*NearestBeing = Parms.NearestBeing;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getAgentTransform
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Agent                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UMaiFunctions::GetAgentTransform(class AActor* Agent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getAgentTransform");

	Params::MaiFunctions_GetAgentTransform Parms{};

	Parms.Agent = Agent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getAllActionPoints
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PointTag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AMaiActionPoint>      PointClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMaiFunctions::GetAllActionPoints(class UObject* Context, class FName PointTag, TSubclassOf<class AMaiActionPoint> PointClass, TArray<class AMaiActionPoint*>* OutPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getAllActionPoints");

	Params::MaiFunctions_GetAllActionPoints Parms{};

	Parms.Context = Context;
	Parms.PointTag = PointTag;
	Parms.PointClass = PointClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiFunctions.getAllActorsActionPoints
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActorTag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMaiFunctions::GetAllActorsActionPoints(class UObject* Context, class FName ActorTag, TSubclassOf<class AActor> ActorClass, TArray<class AMaiActionPoint*>* OutPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getAllActorsActionPoints");

	Params::MaiFunctions_GetAllActorsActionPoints Parms{};

	Parms.Context = Context;
	Parms.ActorTag = ActorTag;
	Parms.ActorClass = ActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiFunctions.getAllGraphsActionPoints
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             GraphTag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AMaiActionGraph>      GraphClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMaiFunctions::GetAllGraphsActionPoints(class UObject* Context, class FName GraphTag, TSubclassOf<class AMaiActionGraph> GraphClass, TArray<class AMaiActionPoint*>* OutPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getAllGraphsActionPoints");

	Params::MaiFunctions_GetAllGraphsActionPoints Parms{};

	Parms.Context = Context;
	Parms.GraphTag = GraphTag;
	Parms.GraphClass = GraphClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiFunctions.getAnimOnNavByAngle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            Tags                                                   (Parm, NativeAccessSpecifierPublic)
// float                                   Hangle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDaiAnimPlayParams               PlayParams                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    CheckComponents                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimationAsset*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimationAsset* UMaiFunctions::GetAnimOnNavByAngle(class AActor* Actor, const struct FGameplayTagContainer& Tags, float Hangle, struct FDaiAnimPlayParams* PlayParams, bool CheckComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getAnimOnNavByAngle");

	Params::MaiFunctions_GetAnimOnNavByAngle Parms{};

	Parms.Actor = Actor;
	Parms.Tags = std::move(Tags);
	Parms.Hangle = Hangle;
	Parms.CheckComponents = CheckComponents;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PlayParams != nullptr)
		*PlayParams = std::move(Parms.PlayParams);

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getAnimOnNavByTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            Tags                                                   (Parm, NativeAccessSpecifierPublic)
// struct FDaiAnimPlayParams               PlayParams                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    CheckComponents                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimationAsset*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimationAsset* UMaiFunctions::GetAnimOnNavByTags(class AActor* Actor, const struct FGameplayTagContainer& Tags, struct FDaiAnimPlayParams* PlayParams, bool CheckComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getAnimOnNavByTags");

	Params::MaiFunctions_GetAnimOnNavByTags Parms{};

	Parms.Actor = Actor;
	Parms.Tags = std::move(Tags);
	Parms.CheckComponents = CheckComponents;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PlayParams != nullptr)
		*PlayParams = std::move(Parms.PlayParams);

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getAttitudeTowards
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeamAttitude                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETeamAttitude UMaiFunctions::GetAttitudeTowards(class APawn* Being, class APawn* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getAttitudeTowards");

	Params::MaiFunctions_GetAttitudeTowards Parms{};

	Parms.Being = Being;
	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.GetBehaviorTreeActiveNode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBTNode*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBTNode* UMaiFunctions::GetBehaviorTreeActiveNode(class AAIController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "GetBehaviorTreeActiveNode");

	Params::MaiFunctions_GetBehaviorTreeActiveNode Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getBehaviorTreeInfo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMaiFunctions::GetBehaviorTreeInfo(class AAIController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getBehaviorTreeInfo");

	Params::MaiFunctions_GetBehaviorTreeInfo Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getBlackboardFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UBlackboardComponent*             Blackboard                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMaiBlackboardFloat              Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaiFunctions::GetBlackboardFloat(class UBlackboardComponent* Blackboard, const struct FMaiBlackboardFloat& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getBlackboardFloat");

	Params::MaiFunctions_GetBlackboardFloat Parms{};

	Parms.Blackboard = Blackboard;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getBlackboardInfo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMaiFunctions::GetBlackboardInfo(class AAIController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getBlackboardInfo");

	Params::MaiFunctions_GetBlackboardInfo Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getBlackboardInt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UBlackboardComponent*             Blackboard                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMaiBlackboardInt                Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMaiFunctions::GetBlackboardInt(class UBlackboardComponent* Blackboard, const struct FMaiBlackboardInt& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getBlackboardInt");

	Params::MaiFunctions_GetBlackboardInt Parms{};

	Parms.Blackboard = Blackboard;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getCurrentCustomLinkOb
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UMaiFunctions::GetCurrentCustomLinkOb(class APawn* Being)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getCurrentCustomLinkOb");

	Params::MaiFunctions_GetCurrentCustomLinkOb Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getCurrentGoalLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMaiFunctions::GetCurrentGoalLocation(class APawn* Being)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getCurrentGoalLocation");

	Params::MaiFunctions_GetCurrentGoalLocation Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getCurrentPathPointLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FromStart                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMaiFunctions::GetCurrentPathPointLocation(class APawn* Being, int32 Point, bool FromStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getCurrentPathPointLocation");

	Params::MaiFunctions_GetCurrentPathPointLocation Parms{};

	Parms.Being = Being;
	Parms.Point = Point;
	Parms.FromStart = FromStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getCurrentTargetLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMaiFunctions::GetCurrentTargetLocation(class APawn* Being)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getCurrentTargetLocation");

	Params::MaiFunctions_GetCurrentTargetLocation Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getDifficultyByteFromTable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMaiTableOfBytesDiff             Table                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UMaiFunctions::GetDifficultyByteFromTable(const class UObject* WorldContext, const struct FMaiTableOfBytesDiff& Table, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getDifficultyByteFromTable");

	Params::MaiFunctions_GetDifficultyByteFromTable Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Table = std::move(Table);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getDifficultyFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMaiFloatDiff                    Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaiFunctions::GetDifficultyFloat(const class UObject* WorldContext, const struct FMaiFloatDiff& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getDifficultyFloat");

	Params::MaiFunctions_GetDifficultyFloat Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getGraphActionPoints
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMaiActionGraph*                  Graph                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AMaiActionPoint*>          OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMaiFunctions::GetGraphActionPoints(class AMaiActionGraph* Graph, TArray<class AMaiActionPoint*>* OutPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getGraphActionPoints");

	Params::MaiFunctions_GetGraphActionPoints Parms{};

	Parms.Graph = Graph;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function Mai.MaiFunctions.getJumpData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Lenght                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UMaiFunctions::GetJumpData(class APawn* Being, float* Lenght, float* Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getJumpData");

	Params::MaiFunctions_GetJumpData Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Lenght != nullptr)
		*Lenght = Parms.Lenght;

	if (Height != nullptr)
		*Height = Parms.Height;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getLocalDirection
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Origin                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Dir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMaiFunctions::GetLocalDirection(class AActor* Origin, const struct FVector& Dir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getLocalDirection");

	Params::MaiFunctions_GetLocalDirection Parms{};

	Parms.Origin = Origin;
	Parms.Dir = std::move(Dir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getLocalDirectionTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Origin                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMaiFunctions::GetLocalDirectionTo(class AActor* Origin, class AActor* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getLocalDirectionTo");

	Params::MaiFunctions_GetLocalDirectionTo Parms{};

	Parms.Origin = Origin;
	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getMaiCharacterByClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AMaiCharacter>        ActorClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiCharacter* UMaiFunctions::GetMaiCharacterByClass(class AActor* Actor, TSubclassOf<class AMaiCharacter> ActorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getMaiCharacterByClass");

	Params::MaiFunctions_GetMaiCharacterByClass Parms{};

	Parms.Actor = Actor;
	Parms.ActorClass = ActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getMaiControllerByClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AMaiController>       ActorClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiController*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiController* UMaiFunctions::GetMaiControllerByClass(class AActor* Actor, TSubclassOf<class AMaiController> ActorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getMaiControllerByClass");

	Params::MaiFunctions_GetMaiControllerByClass Parms{};

	Parms.Actor = Actor;
	Parms.ActorClass = ActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getMaiManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiManager*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiManager* UMaiFunctions::GetMaiManager(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getMaiManager");

	Params::MaiFunctions_GetMaiManager Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getManagerByClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      ManagerClass                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* UMaiFunctions::GetManagerByClass(const class UObject* WorldContext, TSubclassOf<class UActorComponent> ManagerClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getManagerByClass");

	Params::MaiFunctions_GetManagerByClass Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ManagerClass = ManagerClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getPathNodeSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiNodeSystem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiNodeSystem* UMaiFunctions::GetPathNodeSystem(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getPathNodeSystem");

	Params::MaiFunctions_GetPathNodeSystem Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.getRandomLocationInNavigableRadius
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANavigationData*                  NavData                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNavigationQueryFilter>FilterClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::GetRandomLocationInNavigableRadius(class UObject* WorldContext, struct FVector* OutLocation, const struct FVector& Origin, float Radius, class ANavigationData* NavData, TSubclassOf<class UNavigationQueryFilter> FilterClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "getRandomLocationInNavigableRadius");

	Params::MaiFunctions_GetRandomLocationInNavigableRadius Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Origin = std::move(Origin);
	Parms.Radius = Radius;
	Parms.NavData = NavData;
	Parms.FilterClass = FilterClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.hasPathNearTo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Epsilon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::HasPathNearTo(class APawn* Being, class AActor* Actor, float Epsilon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "hasPathNearTo");

	Params::MaiFunctions_HasPathNearTo Parms{};

	Parms.Being = Being;
	Parms.Actor = Actor;
	Parms.Epsilon = Epsilon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.initializePathFollower
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPathFollowingComponent*          Follower                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::InitializePathFollower(class UPathFollowingComponent* Follower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "initializePathFollower");

	Params::MaiFunctions_InitializePathFollower Parms{};

	Parms.Follower = Follower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.isActorInCone
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::IsActorInCone(const struct FVector& Origin, const struct FVector& Direction, float Angle, float Length, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "isActorInCone");

	Params::MaiFunctions_IsActorInCone Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Direction = std::move(Direction);
	Parms.Angle = Angle;
	Parms.Length = Length;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.isInChaseArea
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::IsInChaseArea(class AActor* Actor, const struct FVector& Location, float Extent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "isInChaseArea");

	Params::MaiFunctions_IsInChaseArea Parms{};

	Parms.Actor = Actor;
	Parms.Location = std::move(Location);
	Parms.Extent = Extent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.IsInCover
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Filter                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::IsInCover(class AActor* Actor, const struct FGameplayTag& Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "IsInCover");

	Params::MaiFunctions_IsInCover Parms{};

	Parms.Actor = Actor;
	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.IsInFullCover
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Filter                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::IsInFullCover(class AActor* Actor, const struct FGameplayTag& Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "IsInFullCover");

	Params::MaiFunctions_IsInFullCover Parms{};

	Parms.Actor = Actor;
	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.isInNarrowArea
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::IsInNarrowArea(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "isInNarrowArea");

	Params::MaiFunctions_IsInNarrowArea Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.isInNarrowTrigger
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::IsInNarrowTrigger(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "isInNarrowTrigger");

	Params::MaiFunctions_IsInNarrowTrigger Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.isLocationInCone
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Hheight                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::IsLocationInCone(const struct FVector& Origin, const struct FVector& Direction, float Angle, float Length, const struct FVector& Location, float Radius, float Hheight, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "isLocationInCone");

	Params::MaiFunctions_IsLocationInCone Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Direction = std::move(Direction);
	Parms.Angle = Angle;
	Parms.Length = Length;
	Parms.Location = std::move(Location);
	Parms.Radius = Radius;
	Parms.Hheight = Hheight;
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.isMoveLineClear
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FHitResult                       HitResult                                              (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::IsMoveLineClear(struct FHitResult* HitResult, class AActor* Owner, class AActor* Other, const struct FVector& Start, const struct FVector& End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "isMoveLineClear");

	Params::MaiFunctions_IsMoveLineClear Parms{};

	Parms.Owner = Owner;
	Parms.Other = Other;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.isMoveLineToOtherClear
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::IsMoveLineToOtherClear(class AActor* Owner, class AActor* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "isMoveLineToOtherClear");

	Params::MaiFunctions_IsMoveLineToOtherClear Parms{};

	Parms.Owner = Owner;
	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.isMovingToGoalLocation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::IsMovingToGoalLocation(class APawn* Being)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "isMovingToGoalLocation");

	Params::MaiFunctions_IsMovingToGoalLocation Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.isShootLineClear
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FHitResult                       HitResult                                              (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::IsShootLineClear(struct FHitResult* HitResult, class AActor* Owner, class AActor* Other, const struct FVector& Start, const struct FVector& End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "isShootLineClear");

	Params::MaiFunctions_IsShootLineClear Parms{};

	Parms.Owner = Owner;
	Parms.Other = Other;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.isShootLineToOtherClear
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::IsShootLineToOtherClear(class AActor* Owner, class AActor* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "isShootLineToOtherClear");

	Params::MaiFunctions_IsShootLineToOtherClear Parms{};

	Parms.Owner = Owner;
	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.pauseBehaviorTree
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::PauseBehaviorTree(class AActor* Actor, class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "pauseBehaviorTree");

	Params::MaiFunctions_PauseBehaviorTree Parms{};

	Parms.Actor = Actor;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.pausePathFollowing
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::PausePathFollowing(class AAIController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "pausePathFollowing");

	Params::MaiFunctions_PausePathFollowing Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.projectPointToNavigation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Point                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANavigationData*                  NavData                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNavigationQueryFilter>FilterClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          QueryExtent                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::ProjectPointToNavigation(class UObject* WorldContext, struct FVector* OutLocation, const struct FVector& Point, class ANavigationData* NavData, TSubclassOf<class UNavigationQueryFilter> FilterClass, const struct FVector& QueryExtent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "projectPointToNavigation");

	Params::MaiFunctions_ProjectPointToNavigation Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Point = std::move(Point);
	Parms.NavData = NavData;
	Parms.FilterClass = FilterClass;
	Parms.QueryExtent = std::move(QueryExtent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.requestDirectMove
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          MoveVelocity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceMaxSpeed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::RequestDirectMove(class APawn* Being, const struct FVector& MoveVelocity, bool bForceMaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "requestDirectMove");

	Params::MaiFunctions_RequestDirectMove Parms{};

	Parms.Being = Being;
	Parms.MoveVelocity = std::move(MoveVelocity);
	Parms.bForceMaxSpeed = bForceMaxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.requestDirectMoveTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceMaxSpeed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SmoothCurves                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::RequestDirectMoveTo(class APawn* Being, const struct FVector& Location, bool bForceMaxSpeed, bool SmoothCurves)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "requestDirectMoveTo");

	Params::MaiFunctions_RequestDirectMoveTo Parms{};

	Parms.Being = Being;
	Parms.Location = std::move(Location);
	Parms.bForceMaxSpeed = bForceMaxSpeed;
	Parms.SmoothCurves = SmoothCurves;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.resetAggressiveEnemies
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::ResetAggressiveEnemies(class APawn* Being)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "resetAggressiveEnemies");

	Params::MaiFunctions_ResetAggressiveEnemies Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.resetBeing
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::ResetBeing(class APawn* Being)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "resetBeing");

	Params::MaiFunctions_ResetBeing Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.resetEnemiesInRange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::ResetEnemiesInRange(class APawn* Being, float MaxRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "resetEnemiesInRange");

	Params::MaiFunctions_ResetEnemiesInRange Parms{};

	Parms.Being = Being;
	Parms.MaxRange = MaxRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.restartBehaviorTree
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    HardReset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::RestartBehaviorTree(class AAIController* Controller, bool HardReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "restartBehaviorTree");

	Params::MaiFunctions_RestartBehaviorTree Parms{};

	Parms.Controller = Controller;
	Parms.HardReset = HardReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.resumeBehaviorTree
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::ResumeBehaviorTree(class AActor* Actor, class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "resumeBehaviorTree");

	Params::MaiFunctions_ResumeBehaviorTree Parms{};

	Parms.Actor = Actor;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.resumePathFollowing
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::ResumePathFollowing(class AAIController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "resumePathFollowing");

	Params::MaiFunctions_ResumePathFollowing Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.selectBeingInFront
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class APawn*>                    beings                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               beingClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UMaiFunctions::SelectBeingInFront(const TArray<class APawn*>& beings, const struct FVector& Origin, const struct FVector& Direction, TSubclassOf<class AActor> beingClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "selectBeingInFront");

	Params::MaiFunctions_SelectBeingInFront Parms{};

	Parms.beings = std::move(beings);
	Parms.Origin = std::move(Origin);
	Parms.Direction = std::move(Direction);
	Parms.beingClass = beingClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.setBlackboardValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBlackboardComponent*             Blackboard                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMaiBlackboardValue              Value                                                  (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::SetBlackboardValue(class UBlackboardComponent* Blackboard, const struct FMaiBlackboardValue& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "setBlackboardValue");

	Params::MaiFunctions_SetBlackboardValue Parms{};

	Parms.Blackboard = Blackboard;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.setIgnoreMe
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Ignore                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::SetIgnoreMe(class AActor* Actor, bool Ignore, class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "setIgnoreMe");

	Params::MaiFunctions_SetIgnoreMe Parms{};

	Parms.Actor = Actor;
	Parms.Ignore = Ignore;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.setIgnoreOther
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Ignore                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::SetIgnoreOther(class AActor* Actor, class AActor* Other, bool Ignore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "setIgnoreOther");

	Params::MaiFunctions_SetIgnoreOther Parms{};

	Parms.Actor = Actor;
	Parms.Other = Other;
	Parms.Ignore = Ignore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiFunctions.shouldBeIgnored
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::ShouldBeIgnored(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "shouldBeIgnored");

	Params::MaiFunctions_ShouldBeIgnored Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.shouldIgnoreOther
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::ShouldIgnoreOther(class AActor* Actor, class AActor* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "shouldIgnoreOther");

	Params::MaiFunctions_ShouldIgnoreOther Parms{};

	Parms.Actor = Actor;
	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.test_Distance
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<float>                           Results                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::Test_Distance(const TArray<class AActor*>& Actors, TArray<float>* Results, const struct FVector& Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "test_Distance");

	Params::MaiFunctions_Test_Distance Parms{};

	Parms.Actors = std::move(Actors);
	Parms.Origin = std::move(Origin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Results != nullptr)
		*Results = std::move(Parms.Results);
}


// Function Mai.MaiFunctions.test_Dot
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<float>                           Results                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::Test_Dot(const TArray<class AActor*>& Actors, TArray<float>* Results, const struct FVector& Origin, const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "test_Dot");

	Params::MaiFunctions_Test_Dot Parms{};

	Parms.Actors = std::move(Actors);
	Parms.Origin = std::move(Origin);
	Parms.Direction = std::move(Direction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Results != nullptr)
		*Results = std::move(Parms.Results);
}


// Function Mai.MaiFunctions.tests_Combine2
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<float>                           W1                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<float>                           W2                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> UMaiFunctions::Tests_Combine2(const TArray<float>& W1, const TArray<float>& W2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "tests_Combine2");

	Params::MaiFunctions_Tests_Combine2 Parms{};

	Parms.W1 = std::move(W1);
	Parms.W2 = std::move(W2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.tests_HighestWeightIntex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<float>                           Weights                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMaiFunctions::Tests_HighestWeightIntex(const TArray<float>& Weights)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "tests_HighestWeightIntex");

	Params::MaiFunctions_Tests_HighestWeightIntex Parms{};

	Parms.Weights = std::move(Weights);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.tests_Weights
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<float>                           Raw                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<float>                           Weights                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    Inverse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Mul                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinClamp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxClamp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::Tests_Weights(const TArray<float>& Raw, TArray<float>* Weights, bool Inverse, float Mul, float MinClamp, float MaxClamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "tests_Weights");

	Params::MaiFunctions_Tests_Weights Parms{};

	Parms.Raw = std::move(Raw);
	Parms.Inverse = Inverse;
	Parms.Mul = Mul;
	Parms.MinClamp = MinClamp;
	Parms.MaxClamp = MaxClamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Weights != nullptr)
		*Weights = std::move(Parms.Weights);
}


// Function Mai.MaiFunctions.unregisterPerceptionStimuliSource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAISense>             Sense                                                  (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiFunctions::UnregisterPerceptionStimuliSource(class UObject* WorldContextObject, TSubclassOf<class UAISense> Sense, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "unregisterPerceptionStimuliSource");

	Params::MaiFunctions_UnregisterPerceptionStimuliSource Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sense = Sense;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiFunctions.updateCrowdAgentParams
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiFunctions::UpdateCrowdAgentParams(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiFunctions", "updateCrowdAgentParams");

	Params::MaiFunctions_UpdateCrowdAgentParams Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHealth.Heal
// (Final, Native, Public, BlueprintCallable)

void UMaiHealth::Heal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHealth", "Heal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHealth.Kill
// (Final, Native, Public, BlueprintCallable)

void UMaiHealth::Kill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHealth", "Kill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHealth.ReceiveCure
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Cure                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiHealth::ReceiveCure(float Cure, class AActor* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHealth", "ReceiveCure");

	Params::MaiHealth_ReceiveCure Parms{};

	Parms.Cure = Cure;
	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHealth.ReceiveDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiHealth::ReceiveDamage(float Damage, class AActor* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHealth", "ReceiveDamage");

	Params::MaiHealth_ReceiveDamage Parms{};

	Parms.Damage = Damage;
	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHealth.Revive
// (Final, Native, Public, BlueprintCallable)

void UMaiHealth::Revive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHealth", "Revive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHealth.SetHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiHealth::SetHealth(int32 NewHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHealth", "SetHealth");

	Params::MaiHealth_SetHealth Parms{};

	Parms.NewHealth = NewHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHealth.SetImmortal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Immortal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiHealth::SetImmortal(bool Immortal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHealth", "SetImmortal");

	Params::MaiHealth_SetImmortal Parms{};

	Parms.Immortal = Immortal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiHealth.GetHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMaiHealth::GetHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHealth", "GetHealth");

	Params::MaiHealth_GetHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiHealth.GetHealthPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMaiHealth::GetHealthPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHealth", "GetHealthPercent");

	Params::MaiHealth_GetHealthPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiHealth.GetMaxHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMaiHealth::GetMaxHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHealth", "GetMaxHealth");

	Params::MaiHealth_GetMaxHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiHealth.IsDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiHealth::IsDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHealth", "IsDead");

	Params::MaiHealth_IsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiHealth.IsImmortal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiHealth::IsImmortal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiHealth", "IsImmortal");

	Params::MaiHealth_IsImmortal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiReincarnationComponent.ClearOverrideData
// (Final, Native, Public, BlueprintCallable)

void UMaiReincarnationComponent::ClearOverrideData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiReincarnationComponent", "ClearOverrideData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiReincarnationComponent.DecreaseEnterCounter
// (Final, Native, Public, BlueprintCallable)

void UMaiReincarnationComponent::DecreaseEnterCounter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiReincarnationComponent", "DecreaseEnterCounter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiReincarnationComponent.EnableCalcEntrance
// (Final, Native, Public, BlueprintCallable)

void UMaiReincarnationComponent::EnableCalcEntrance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiReincarnationComponent", "EnableCalcEntrance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiReincarnationComponent.FillParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaiReincarnationComponent*       Other                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiReincarnationComponent::FillParams(class UMaiReincarnationComponent* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiReincarnationComponent", "FillParams");

	Params::MaiReincarnationComponent_FillParams Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiReincarnationComponent.OnEnterReincarnateArea
// (Final, Native, Public, BlueprintCallable)

void UMaiReincarnationComponent::OnEnterReincarnateArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiReincarnationComponent", "OnEnterReincarnateArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiReincarnationComponent.OnLeaveReincarnateArea
// (Final, Native, Public, BlueprintCallable)

void UMaiReincarnationComponent::OnLeaveReincarnateArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiReincarnationComponent", "OnLeaveReincarnateArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiReincarnationComponent.Reincarnate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   HealthPercent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiReincarnationComponent::Reincarnate(float HealthPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiReincarnationComponent", "Reincarnate");

	Params::MaiReincarnationComponent_Reincarnate Parms{};

	Parms.HealthPercent = HealthPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiReincarnationComponent.SetOverrideData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   MaxReincarnationNumber                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMaiReincarnationInfo>    Data                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMaiReincarnationComponent::SetOverrideData(uint8 MaxReincarnationNumber, const TArray<struct FMaiReincarnationInfo>& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiReincarnationComponent", "SetOverrideData");

	Params::MaiReincarnationComponent_SetOverrideData Parms{};

	Parms.MaxReincarnationNumber = MaxReincarnationNumber;
	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiReincarnationComponent.AllowReincarnation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiReincarnationComponent::AllowReincarnation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiReincarnationComponent", "AllowReincarnation");

	Params::MaiReincarnationComponent_AllowReincarnation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiReincarnationComponent.GetSeizuresNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UMaiReincarnationComponent::GetSeizuresNumber() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiReincarnationComponent", "GetSeizuresNumber");

	Params::MaiReincarnationComponent_GetSeizuresNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiLightEmitter.IsInLight
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Hheight                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiLightEmitter::IsInLight(const struct FVector& Location, float Radius, float Hheight, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLightEmitter", "IsInLight");

	Params::MaiLightEmitter_IsInLight Parms{};

	Parms.Location = std::move(Location);
	Parms.Radius = Radius;
	Parms.Hheight = Hheight;
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiLightEmitter.LightLight
// (Final, Native, Public, BlueprintCallable)

void UMaiLightEmitter::LightLight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLightEmitter", "LightLight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiLightEmitter.SetAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiLightEmitter::SetAngle(float Angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLightEmitter", "SetAngle");

	Params::MaiLightEmitter_SetAngle Parms{};

	Parms.Angle = Angle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiLightEmitter.SetRange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiLightEmitter::SetRange(float Range)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLightEmitter", "SetRange");

	Params::MaiLightEmitter_SetRange Parms{};

	Parms.Range = Range;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiLightEmitter.TestLight
// (Final, Native, Public)

void UMaiLightEmitter::TestLight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLightEmitter", "TestLight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiLightEmitter.TurnOffLight
// (Final, Native, Public, BlueprintCallable)

void UMaiLightEmitter::TurnOffLight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLightEmitter", "TurnOffLight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiLightsManager.getLightsManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiLightsManager*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiLightsManager* UMaiLightsManager::GetLightsManager(const class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiLightsManager", "getLightsManager");

	Params::MaiLightsManager_GetLightsManager Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiLightsManager.OnLightEmitterChange
// (Final, Native, Protected)
// Parameters:
// class UMaiLightEmitter*                 Light                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiLightsManager::OnLightEmitterChange(class UMaiLightEmitter* Light)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLightsManager", "OnLightEmitterChange");

	Params::MaiLightsManager_OnLightEmitterChange Parms{};

	Parms.Light = Light;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiLightsManager.OnLightObserverChange
// (Final, Native, Protected)
// Parameters:
// class UMaiLightObserver*                Observer                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiLightsManager::OnLightObserverChange(class UMaiLightObserver* Observer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLightsManager", "OnLightObserverChange");

	Params::MaiLightsManager_OnLightObserverChange Parms{};

	Parms.Observer = Observer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiLightsManager.RefreshLighting
// (Final, Native, Public, BlueprintCallable)

void UMaiLightsManager::RefreshLighting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLightsManager", "RefreshLighting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiLightsManager.GetIsLit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Observer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiLightsManager::GetIsLit(class AActor* Observer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLightsManager", "GetIsLit");

	Params::MaiLightsManager_GetIsLit Parms{};

	Parms.Observer = Observer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiLightsManager.GetLitLight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaiLightObserver*                Observer                                               (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiLightEmitter*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiLightEmitter* UMaiLightsManager::GetLitLight(const class UMaiLightObserver* Observer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLightsManager", "GetLitLight");

	Params::MaiLightsManager_GetLitLight Parms{};

	Parms.Observer = Observer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiLightsManager.TestIsLit
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Observer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Hheight                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiLightsManager::TestIsLit(class AActor* Observer, float Radius, float Hheight, const struct FVector& Offset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLightsManager", "TestIsLit");

	Params::MaiLightsManager_TestIsLit Parms{};

	Parms.Observer = Observer;
	Parms.Radius = Radius;
	Parms.Hheight = Hheight;
	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiLookAtComponent.ClearLookAt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiLookAtComponent::ClearLookAt(int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLookAtComponent", "ClearLookAt");

	Params::MaiLookAtComponent_ClearLookAt Parms{};

	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiLookAtComponent.DisableLookAt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiLookAtComponent::DisableLookAt(int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLookAtComponent", "DisableLookAt");

	Params::MaiLookAtComponent_DisableLookAt Parms{};

	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiLookAtComponent.EnableLookAt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiLookAtComponent::EnableLookAt(int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLookAtComponent", "EnableLookAt");

	Params::MaiLookAtComponent_EnableLookAt Parms{};

	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiLookAtComponent.LookAtActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiLookAtComponent::LookAtActor(class AActor* Actor, float MaxRange, uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLookAtComponent", "LookAtActor");

	Params::MaiLookAtComponent_LookAtActor Parms{};

	Parms.Actor = Actor;
	Parms.MaxRange = MaxRange;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiLookAtComponent.LookAtComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Comp                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiLookAtComponent::LookAtComponent(class USceneComponent* Comp, float MaxRange, uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLookAtComponent", "LookAtComponent");

	Params::MaiLookAtComponent_LookAtComponent Parms{};

	Parms.Comp = Comp;
	Parms.MaxRange = MaxRange;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiLookAtComponent.LookAtLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiLookAtComponent::LookAtLocation(const struct FVector& Location, float MaxRange, uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLookAtComponent", "LookAtLocation");

	Params::MaiLookAtComponent_LookAtLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.MaxRange = MaxRange;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiLookAtComponent.SetLookAtRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiLookAtComponent::SetLookAtRotation(const struct FRotator& Rotation, float MaxRange, uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLookAtComponent", "SetLookAtRotation");

	Params::MaiLookAtComponent_SetLookAtRotation Parms{};

	Parms.Rotation = std::move(Rotation);
	Parms.MaxRange = MaxRange;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiLookAtComponent.GetHeadLocalRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FRotator                   ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

const struct FRotator UMaiLookAtComponent::GetHeadLocalRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLookAtComponent", "GetHeadLocalRotation");

	Params::MaiLookAtComponent_GetHeadLocalRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiLookAtComponent.GetLookAtActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMaiLookAtComponent::GetLookAtActor(uint8 Priority) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLookAtComponent", "GetLookAtActor");

	Params::MaiLookAtComponent_GetLookAtActor Parms{};

	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiLookAtComponent.GetLookAtLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector UMaiLookAtComponent::GetLookAtLocation(uint8 Priority) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLookAtComponent", "GetLookAtLocation");

	Params::MaiLookAtComponent_GetLookAtLocation Parms{};

	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiLookAtComponent.GetLookAtRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator                   ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

const struct FRotator UMaiLookAtComponent::GetLookAtRotation(uint8 Priority) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLookAtComponent", "GetLookAtRotation");

	Params::MaiLookAtComponent_GetLookAtRotation Parms{};

	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiLookAtComponent.IsLookAtEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiLookAtComponent::IsLookAtEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiLookAtComponent", "IsLookAtEnabled");

	Params::MaiLookAtComponent_IsLookAtEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiManager.getDifficultyLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMaiDifficultyLevel                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMaiDifficultyLevel UMaiManager::GetDifficultyLevel(const class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiManager", "getDifficultyLevel");

	Params::MaiManager_GetDifficultyLevel Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiManager.LockNavMeshGeneration
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Lock                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiManager::LockNavMeshGeneration(bool Lock, class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiManager", "LockNavMeshGeneration");

	Params::MaiManager_LockNavMeshGeneration Parms{};

	Parms.Lock = Lock;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiManager.NegateBool
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           VariableName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiManager::NegateBool(const class FString& VariableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiManager", "NegateBool");

	Params::MaiManager_NegateBool Parms{};

	Parms.VariableName = std::move(VariableName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiManager.SetNavigationForStreamingLevel
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Set                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiManager::SetNavigationForStreamingLevel(bool Set)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiManager", "SetNavigationForStreamingLevel");

	Params::MaiManager_SetNavigationForStreamingLevel Parms{};

	Parms.Set = Set;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiManager.SetPartyAttitude
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   PartyID1                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PartyID2                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPartyAttitude                          Attitude                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiManager::SetPartyAttitude(uint8 PartyID1, uint8 PartyID2, EPartyAttitude Attitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiManager", "SetPartyAttitude");

	Params::MaiManager_SetPartyAttitude Parms{};

	Parms.PartyID1 = PartyID1;
	Parms.PartyID2 = PartyID2;
	Parms.Attitude = Attitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiManager.GetPartyAttitude
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   PartyID1                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PartyID2                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPartyAttitude                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPartyAttitude UMaiManager::GetPartyAttitude(uint8 PartyID1, uint8 PartyID2) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiManager", "GetPartyAttitude");

	Params::MaiManager_GetPartyAttitude Parms{};

	Parms.PartyID1 = PartyID1;
	Parms.PartyID2 = PartyID2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiMessage.makeMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UMaiMessage>          MsgClass                                               (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Sender                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiMessage*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiMessage* UMaiMessage::MakeMessage(class UObject* WorldContextObject, TSubclassOf<class UMaiMessage> MsgClass, class AActor* Sender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiMessage", "makeMessage");

	Params::MaiMessage_MakeMessage Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.MsgClass = MsgClass;
	Parms.Sender = Sender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiMessage.Broadcast
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMaiReceiverFilter               Filter                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   SpreadingSpeed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiMessage::Broadcast(const struct FMaiReceiverFilter& Filter, float SpreadingSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiMessage", "Broadcast");

	Params::MaiMessage_Broadcast Parms{};

	Parms.Filter = std::move(Filter);
	Parms.SpreadingSpeed = SpreadingSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiMessage.Deliver
// (Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                            Receiver                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiMessage::Deliver(class APawn* Receiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiMessage", "Deliver");

	Params::MaiMessage_Deliver Parms{};

	Parms.Receiver = Receiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiMessage.MarkCaptured
// (Final, Native, Public, BlueprintCallable)

void UMaiMessage::MarkCaptured()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiMessage", "MarkCaptured");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiMessage.MarkReceived
// (Final, Native, Public, BlueprintCallable)

void UMaiMessage::MarkReceived()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiMessage", "MarkReceived");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiMessage.ScriptDeliver
// (Event, Public, BlueprintEvent)
// Parameters:
// class APawn*                            Receiver                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiMessage::ScriptDeliver(class APawn* Receiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiMessage", "ScriptDeliver");

	Params::MaiMessage_ScriptDeliver Parms{};

	Parms.Receiver = Receiver;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiMessage.Send
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMaiReceiverFilter               Filter                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   SpreadingSpeed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiMessage::Send(const struct FMaiReceiverFilter& Filter, float SpreadingSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiMessage", "Send");

	Params::MaiMessage_Send Parms{};

	Parms.Filter = std::move(Filter);
	Parms.SpreadingSpeed = SpreadingSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiMessage.IsCaptured
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiMessage::IsCaptured() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiMessage", "IsCaptured");

	Params::MaiMessage_IsCaptured Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiMessage.IsReceived
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiMessage::IsReceived() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiMessage", "IsReceived");

	Params::MaiMessage_IsReceived Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MessageReceiverInterface.ReceiveMessage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMaiMessage*                      Message                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMessageReceiverInterface::ReceiveMessage(class UMaiMessage* Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageReceiverInterface", "ReceiveMessage");

	Params::MessageReceiverInterface_ReceiveMessage Parms{};

	Parms.Message = Message;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MsgStartBlowReceiverInterface.ReceiveStartBlowMsg
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMaiMessage*                      Message                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMsgStartBlowReceiverInterface::ReceiveStartBlowMsg(class UMaiMessage* Message, class AActor* Attacker, TSubclassOf<class UDamageType> DamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MsgStartBlowReceiverInterface", "ReceiveStartBlowMsg");

	Params::MsgStartBlowReceiverInterface_ReceiveStartBlowMsg Parms{};

	Parms.Message = Message;
	Parms.Attacker = Attacker;
	Parms.DamageType = DamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNavLink.BreakMoveToLink
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StartSide                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiNavLink::BreakMoveToLink(class APawn* Being, bool StartSide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavLink", "BreakMoveToLink");

	Params::MaiNavLink_BreakMoveToLink Parms{};

	Parms.Being = Being;
	Parms.StartSide = StartSide;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiNavLink.ClearPathsForWaitingCharacters
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    StartSide                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiNavLink::ClearPathsForWaitingCharacters(bool StartSide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavLink", "ClearPathsForWaitingCharacters");

	Params::MaiNavLink_ClearPathsForWaitingCharacters Parms{};

	Parms.StartSide = StartSide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNavLink.FinishUsingBy
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StartSide                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiNavLink::FinishUsingBy(class APawn* Being, bool StartSide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavLink", "FinishUsingBy");

	Params::MaiNavLink_FinishUsingBy Parms{};

	Parms.Being = Being;
	Parms.StartSide = StartSide;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiNavLink.OnOverlapBegin
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMaiNavLink::OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavLink", "OnOverlapBegin");

	Params::MaiNavLink_OnOverlapBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNavLink.OnOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiNavLink::OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavLink", "OnOverlapEnd");

	Params::MaiNavLink_OnOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNavLink.ReturnOwnership
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiNavLink::ReturnOwnership(class APawn* Being)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavLink", "ReturnOwnership");

	Params::MaiNavLink_ReturnOwnership Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNavLink.SetNavigationRelevancy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsRelevant                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiNavLink::SetNavigationRelevancy(bool IsRelevant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavLink", "SetNavigationRelevancy");

	Params::MaiNavLink_SetNavigationRelevancy Parms{};

	Parms.IsRelevant = IsRelevant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNavLink.StartMoveToLink
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StartSide                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiNavLink::StartMoveToLink(class APawn* Being, bool StartSide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavLink", "StartMoveToLink");

	Params::MaiNavLink_StartMoveToLink Parms{};

	Parms.Being = Being;
	Parms.StartSide = StartSide;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiNavLink.StartUsingBy
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StartSide                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiNavLink::StartUsingBy(class APawn* Being, bool StartSide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavLink", "StartUsingBy");

	Params::MaiNavLink_StartUsingBy Parms{};

	Parms.Being = Being;
	Parms.StartSide = StartSide;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiNavLink.TakeOwnership
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiNavLink::TakeOwnership(class APawn* Being)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavLink", "TakeOwnership");

	Params::MaiNavLink_TakeOwnership Parms{};

	Parms.Being = Being;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNavLink.UpdateNavMesh
// (Final, Native, Public)

void AMaiNavLink::UpdateNavMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavLink", "UpdateNavMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNavLink.GetSmartLinkComp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNavLinkCustomComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNavLinkCustomComponent* AMaiNavLink::GetSmartLinkComp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavLink", "GetSmartLinkComp");

	Params::MaiNavLink_GetSmartLinkComp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiNavLink.IsOnBeingPath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            Being                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckFromNext                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiNavLink::IsOnBeingPath(class APawn* Being, bool CheckFromNext) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavLink", "IsOnBeingPath");

	Params::MaiNavLink_IsOnBeingPath Parms{};

	Parms.Being = Being;
	Parms.CheckFromNext = CheckFromNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiNavLinkComponent.SetLinkEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiNavLinkComponent::SetLinkEnabled(bool NewEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavLinkComponent", "SetLinkEnabled");

	Params::MaiNavLinkComponent_SetLinkEnabled Parms{};

	Parms.NewEnabled = NewEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNavCapsule.DisableArea
// (Final, Native, Public, BlueprintCallable)

void UMaiNavCapsule::DisableArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavCapsule", "DisableArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNavCapsule.EnableArea
// (Final, Native, Public, BlueprintCallable)

void UMaiNavCapsule::EnableArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavCapsule", "EnableArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNavCapsule.SetAreaClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UNavArea>             NewAreaClass                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiNavCapsule::SetAreaClass(TSubclassOf<class UNavArea> NewAreaClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavCapsule", "SetAreaClass");

	Params::MaiNavCapsule_SetAreaClass Parms{};

	Parms.NewAreaClass = NewAreaClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNavCapsule.IsInArea
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiNavCapsule::IsInArea(const struct FVector& Location, float Extent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavCapsule", "IsInArea");

	Params::MaiNavCapsule_IsInArea Parms{};

	Parms.Location = std::move(Location);
	Parms.Extent = Extent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiNavSphere.DisableArea
// (Final, Native, Public, BlueprintCallable)

void UMaiNavSphere::DisableArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavSphere", "DisableArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNavSphere.EnableArea
// (Final, Native, Public, BlueprintCallable)

void UMaiNavSphere::EnableArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavSphere", "EnableArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNavSphere.SetAreaClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UNavArea>             NewAreaClass                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiNavSphere::SetAreaClass(TSubclassOf<class UNavArea> NewAreaClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavSphere", "SetAreaClass");

	Params::MaiNavSphere_SetAreaClass Parms{};

	Parms.NewAreaClass = NewAreaClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNavSphere.IsInArea
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiNavSphere::IsInArea(const struct FVector& Location, float Extent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNavSphere", "IsInArea");

	Params::MaiNavSphere_IsInArea Parms{};

	Parms.Location = std::move(Location);
	Parms.Extent = Extent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiNodeFollowing.MoveTo
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          GoalLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiNodeFollowing::MoveTo(const struct FVector& GoalLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNodeFollowing", "MoveTo");

	Params::MaiNodeFollowing_MoveTo Parms{};

	Parms.GoalLocation = std::move(GoalLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiNodeFollowing.PreparePathTo
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          GoalLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiNodeFollowing::PreparePathTo(const struct FVector& GoalLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNodeFollowing", "PreparePathTo");

	Params::MaiNodeFollowing_PreparePathTo Parms{};

	Parms.GoalLocation = std::move(GoalLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiNodeFollowing.IsGoalReached
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          GoalLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiNodeFollowing::IsGoalReached(const struct FVector& GoalLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNodeFollowing", "IsGoalReached");

	Params::MaiNodeFollowing_IsGoalReached Parms{};

	Parms.GoalLocation = std::move(GoalLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiNodeGraphComponent.RegenerateGraph
// (Final, Native, Public, BlueprintCallable)

void UMaiNodeGraphComponent::RegenerateGraph()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNodeGraphComponent", "RegenerateGraph");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNodeGraphComponent.FindNearestNode
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiPathNodeComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiPathNodeComponent* UMaiNodeGraphComponent::FindNearestNode(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNodeGraphComponent", "FindNearestNode");

	Params::MaiNodeGraphComponent_FindNearestNode Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiNodeGraphComponent.GetAllNodes
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FMaiNodeRef>              NodesList                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMaiNodeGraphComponent::GetAllNodes(TArray<struct FMaiNodeRef>* NodesList) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNodeGraphComponent", "GetAllNodes");

	Params::MaiNodeGraphComponent_GetAllNodes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NodesList != nullptr)
		*NodesList = std::move(Parms.NodesList);
}


// Function Mai.MaiNodeGraphComponent.GetNodesInRange
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FMaiNodeRef>              NodesList                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Pos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiNodeGraphComponent::GetNodesInRange(TArray<struct FMaiNodeRef>* NodesList, const struct FVector& Pos, float Radius) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNodeGraphComponent", "GetNodesInRange");

	Params::MaiNodeGraphComponent_GetNodesInRange Parms{};

	Parms.Pos = std::move(Pos);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NodesList != nullptr)
		*NodesList = std::move(Parms.NodesList);
}


// Function Mai.MaiNodeGraphVolume.RegenerateGraph
// (Final, Native, Public, BlueprintCallable)

void AMaiNodeGraphVolume::RegenerateGraph()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNodeGraphVolume", "RegenerateGraph");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNodeSystem.UpdateInActorBounds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiNodeSystem::UpdateInActorBounds(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNodeSystem", "UpdateInActorBounds");

	Params::MaiNodeSystem_UpdateInActorBounds Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNodeSystem.UpdateInBounds
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FBox                             Box                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMaiNodeSystem::UpdateInBounds(const struct FBox& Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNodeSystem", "UpdateInBounds");

	Params::MaiNodeSystem_UpdateInBounds Parms{};

	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNodeSystem.UpdateInComponentBounds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Scene                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiNodeSystem::UpdateInComponentBounds(class USceneComponent* Scene)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNodeSystem", "UpdateInComponentBounds");

	Params::MaiNodeSystem_UpdateInComponentBounds Parms{};

	Parms.Scene = Scene;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNoiseEmitter.EndNoise
// (Final, Native, Public, BlueprintCallable)

void UMaiNoiseEmitter::EndNoise()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNoiseEmitter", "EndNoise");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNoiseEmitter.MakeLongNoise
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiNoiseEmitter::MakeLongNoise(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNoiseEmitter", "MakeLongNoise");

	Params::MaiNoiseEmitter_MakeLongNoise Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNoiseEmitter.MakeNoise
// (Final, Native, Public, BlueprintCallable)

void UMaiNoiseEmitter::MakeNoise()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNoiseEmitter", "MakeNoise");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiNoiseEmitter.StartNoise
// (Final, Native, Public, BlueprintCallable)

void UMaiNoiseEmitter::StartNoise()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiNoiseEmitter", "StartNoise");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSense_Hearing.ReportNoiseEvent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NoiseLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Aggro                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NoiseRange                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Loudness                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           IgnoreActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSense_Hearing::ReportNoiseEvent(class UObject* WorldContext, const struct FVector& NoiseLocation, class AActor* Instigator, class FName Tag, float Aggro, float NoiseRange, float MaxRange, float Loudness, class AActor* IgnoreActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiSense_Hearing", "ReportNoiseEvent");

	Params::MaiSense_Hearing_ReportNoiseEvent Parms{};

	Parms.WorldContext = WorldContext;
	Parms.NoiseLocation = std::move(NoiseLocation);
	Parms.Instigator = Instigator;
	Parms.Tag = Tag;
	Parms.Aggro = Aggro;
	Parms.NoiseRange = NoiseRange;
	Parms.MaxRange = MaxRange;
	Parms.Loudness = Loudness;
	Parms.IgnoreActor = IgnoreActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSense_The6thSense.Report6thSenseConstEvent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Power                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSense_The6thSense::Report6thSenseConstEvent(class UObject* WorldContext, class FName Tag, bool Enable, class AActor* Instigator, const struct FVector& Location, float Power)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiSense_The6thSense", "Report6thSenseConstEvent");

	Params::MaiSense_The6thSense_Report6thSenseConstEvent Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Tag = Tag;
	Parms.Enable = Enable;
	Parms.Instigator = Instigator;
	Parms.Location = std::move(Location);
	Parms.Power = Power;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSense_The6thSense.Report6thSenseEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Power                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSense_The6thSense::Report6thSenseEvent(class UObject* WorldContext, class FName Tag, bool Enable, class AActor* Instigator, float Power)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiSense_The6thSense", "Report6thSenseEvent");

	Params::MaiSense_The6thSense_Report6thSenseEvent Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Tag = Tag;
	Parms.Enable = Enable;
	Parms.Instigator = Instigator;
	Parms.Power = Power;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawner.BlockSpawn
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiSpawner::BlockSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawner", "BlockSpawn");

	Params::MaiSpawner_BlockSpawn Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawner.ChangeAutoSpawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiSpawner::ChangeAutoSpawn(bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawner", "ChangeAutoSpawn");

	Params::MaiSpawner_ChangeAutoSpawn Parms{};

	Parms.Active = Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawner.Despawn
// (Native, Public, BlueprintCallable)

void AMaiSpawner::Despawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawner", "Despawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawner.OnDespawn
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiSpawner::OnDespawn(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawner", "OnDespawn");

	Params::MaiSpawner_OnDespawn Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiSpawner.OnSpawn
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiSpawner::OnSpawn(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawner", "OnSpawn");

	Params::MaiSpawner_OnSpawn Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiSpawner.OnSpawnController
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiSpawner::OnSpawnController(class AAIController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawner", "OnSpawnController");

	Params::MaiSpawner_OnSpawnController Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawner.PIEDespawn
// (Final, Native, Public)

void AMaiSpawner::PIEDespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawner", "PIEDespawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawner.PIESpawn
// (Final, Native, Public)

void AMaiSpawner::PIESpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawner", "PIESpawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawner.SetActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiSpawner::SetActive(bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawner", "SetActive");

	Params::MaiSpawner_SetActive Parms{};

	Parms.Active = Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawner.Spawn
// (Native, Public, BlueprintCallable)

void AMaiSpawner::Spawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawner", "Spawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawner.SpawnSingle
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AMaiSpawner::SpawnSingle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawner", "SpawnSingle");

	Params::MaiSpawner_SpawnSingle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawner.UpdateAutoSpawn
// (Native, Public, BlueprintCallable)

void AMaiSpawner::UpdateAutoSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawner", "UpdateAutoSpawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawner.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiSpawner::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawner", "IsActive");

	Params::MaiSpawner_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawner.isInChaseArea
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiSpawner::IsInChaseArea(const struct FVector& Location, float Extent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawner", "isInChaseArea");

	Params::MaiSpawner_IsInChaseArea Parms{};

	Parms.Location = std::move(Location);
	Parms.Extent = Extent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawner.IsInSpawnArea
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiSpawner::IsInSpawnArea(const struct FVector& Location, float Extent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawner", "IsInSpawnArea");

	Params::MaiSpawner_IsInSpawnArea Parms{};

	Parms.Location = std::move(Location);
	Parms.Extent = Extent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawner.ShouldAutoSpawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMaiSpawner::ShouldAutoSpawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawner", "ShouldAutoSpawn");

	Params::MaiSpawner_ShouldAutoSpawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSingleSpawner.OnInitBehaviors
// (Event, Public, BlueprintEvent)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiSingleSpawner::OnInitBehaviors(class AAIController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSingleSpawner", "OnInitBehaviors");

	Params::MaiSingleSpawner_OnInitBehaviors Parms{};

	Parms.Controller = Controller;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiSingleSpawner.ReleaseSpawnedActor
// (Final, Native, Public, BlueprintCallable)

void AMaiSingleSpawner::ReleaseSpawnedActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSingleSpawner", "ReleaseSpawnedActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSingleSpawner.SetActorClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiSingleSpawner::SetActorClass(TSubclassOf<class AActor> ActorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSingleSpawner", "SetActorClass");

	Params::MaiSingleSpawner_SetActorClass Parms{};

	Parms.ActorClass = ActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSingleSpawner.SetAIControllerClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AAIController>        AiClass                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiSingleSpawner::SetAIControllerClass(TSubclassOf<class AAIController> AiClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSingleSpawner", "SetAIControllerClass");

	Params::MaiSingleSpawner_SetAIControllerClass Parms{};

	Parms.AiClass = AiClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSingleSpawner.SpawnUnique
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AMaiSingleSpawner::SpawnUnique()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSingleSpawner", "SpawnUnique");

	Params::MaiSingleSpawner_SpawnUnique Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSingleSpawner.GetSpawnedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AMaiSingleSpawner::GetSpawnedActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSingleSpawner", "GetSpawnedActor");

	Params::MaiSingleSpawner_GetSpawnedActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiMultiSpawner.ChangeInfoWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiMultiSpawner::ChangeInfoWeight(int32 Index_0, uint8 Weight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiMultiSpawner", "ChangeInfoWeight");

	Params::MaiMultiSpawner_ChangeInfoWeight Parms{};

	Parms.Index_0 = Index_0;
	Parms.Weight = Weight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiMultiSpawner.StartWaveSpawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinDelay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDelay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMaiMultiSpawner::StartWaveSpawn(int32 Count, float MinDelay, float MaxDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiMultiSpawner", "StartWaveSpawn");

	Params::MaiMultiSpawner_StartWaveSpawn Parms{};

	Parms.Count = Count;
	Parms.MinDelay = MinDelay;
	Parms.MaxDelay = MaxDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiMultiSpawner.StopWaveSpawn
// (Final, Native, Public, BlueprintCallable)

void AMaiMultiSpawner::StopWaveSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiMultiSpawner", "StopWaveSpawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiMultiSpawner.GetSpawnedActors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> AMaiMultiSpawner::GetSpawnedActors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiMultiSpawner", "GetSpawnedActors");

	Params::MaiMultiSpawner_GetSpawnedActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawnerManager.getSpawnerIDByRef
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiSpawner*                      Spawner                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMaiSpawnerID                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FMaiSpawnerID UMaiSpawnerManager::GetSpawnerIDByRef(class UObject* WorldContext, class AMaiSpawner* Spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiSpawnerManager", "getSpawnerIDByRef");

	Params::MaiSpawnerManager_GetSpawnerIDByRef Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Spawner = Spawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawnerManager.getSpawnerIDBySoftRef
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class AMaiSpawner>       SoftRef                                                (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMaiSpawnerID                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FMaiSpawnerID UMaiSpawnerManager::GetSpawnerIDBySoftRef(class UObject* WorldContext, TSoftObjectPtr<class AMaiSpawner> SoftRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiSpawnerManager", "getSpawnerIDBySoftRef");

	Params::MaiSpawnerManager_GetSpawnerIDBySoftRef Parms{};

	Parms.WorldContext = WorldContext;
	Parms.SoftRef = SoftRef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawnerManager.getSpawnerIDByTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMaiSpawnerID                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FMaiSpawnerID UMaiSpawnerManager::GetSpawnerIDByTag(class UObject* WorldContext, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiSpawnerManager", "getSpawnerIDByTag");

	Params::MaiSpawnerManager_GetSpawnerIDByTag Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawnerManager.getSpawnerIDFromSpawned
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Spawned                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMaiSpawnerID                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FMaiSpawnerID UMaiSpawnerManager::GetSpawnerIDFromSpawned(class UObject* WorldContext, class AActor* Spawned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiSpawnerManager", "getSpawnerIDFromSpawned");

	Params::MaiSpawnerManager_GetSpawnerIDFromSpawned Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Spawned = Spawned;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawnerManager.getSpawnerManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiSpawnerManager*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiSpawnerManager* UMaiSpawnerManager::GetSpawnerManager(const class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiSpawnerManager", "getSpawnerManager");

	Params::MaiSpawnerManager_GetSpawnerManager Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawnerManager.AIPrintAllSpawnedActors
// (Final, Exec, Native, Public, BlueprintCallable)

void UMaiSpawnerManager::AIPrintAllSpawnedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "AIPrintAllSpawnedActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.AIPrintAllSpawners
// (Final, Exec, Native, Public, BlueprintCallable)

void UMaiSpawnerManager::AIPrintAllSpawners()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "AIPrintAllSpawners");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.AIPrintSpawnedActors
// (Final, Exec, Native, Public, BlueprintCallable)

void UMaiSpawnerManager::AIPrintSpawnedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "AIPrintSpawnedActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.AIPrintSpawnersWithActors
// (Final, Exec, Native, Public, BlueprintCallable)

void UMaiSpawnerManager::AIPrintSpawnersWithActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "AIPrintSpawnersWithActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.AISpawnSingle
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SpawnerTag                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMaiSpawnerManager::AISpawnSingle(class FName SpawnerTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "AISpawnSingle");

	Params::MaiSpawnerManager_AISpawnSingle Parms{};

	Parms.SpawnerTag = SpawnerTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawnerManager.ClearWorldState
// (Exec, Native, Public, BlueprintCallable)

void UMaiSpawnerManager::ClearWorldState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "ClearWorldState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.DesiredDespawnActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSpawnerManager::DesiredDespawnActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "DesiredDespawnActor");

	Params::MaiSpawnerManager_DesiredDespawnActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.DespawnActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DisableSpawner                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForgetIt                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSpawnerManager::DespawnActor(class AActor* Actor, bool DisableSpawner, bool ForceDestroy, bool ForgetIt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "DespawnActor");

	Params::MaiSpawnerManager_DespawnActor Parms{};

	Parms.Actor = Actor;
	Parms.DisableSpawner = DisableSpawner;
	Parms.ForceDestroy = ForceDestroy;
	Parms.ForgetIt = ForgetIt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.DespawnByTag
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SpawnerTag                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSpawnerManager::DespawnByTag(class FName SpawnerTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "DespawnByTag");

	Params::MaiSpawnerManager_DespawnByTag Parms{};

	Parms.SpawnerTag = SpawnerTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.DespwnAnyoneWhoWants
// (Final, Native, Public, BlueprintCallable)

void UMaiSpawnerManager::DespwnAnyoneWhoWants()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "DespwnAnyoneWhoWants");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.DestroyController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                            Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DisableSpawner                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSpawnerManager::DestroyController(class APawn* Actor, bool DisableSpawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "DestroyController");

	Params::MaiSpawnerManager_DestroyController Parms{};

	Parms.Actor = Actor;
	Parms.DisableSpawner = DisableSpawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.GC
// (Final, Native, Public)

void UMaiSpawnerManager::GC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "GC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.SetWaveSpawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SpawnerTag                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinDelay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDelay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSpawnerManager::SetWaveSpawn(class FName SpawnerTag, int32 Count, float MinDelay, float MaxDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "SetWaveSpawn");

	Params::MaiSpawnerManager_SetWaveSpawn Parms{};

	Parms.SpawnerTag = SpawnerTag;
	Parms.Count = Count;
	Parms.MinDelay = MinDelay;
	Parms.MaxDelay = MaxDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.SP_AutoSpawnMode
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMaiSpawnerID                    SpawnerID                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSpawnerManager::SP_AutoSpawnMode(const struct FMaiSpawnerID& SpawnerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "SP_AutoSpawnMode");

	Params::MaiSpawnerManager_SP_AutoSpawnMode Parms{};

	Parms.SpawnerID = std::move(SpawnerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.SP_Despawn
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMaiSpawnerID                    SpawnerID                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ClearActorEntry                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSpawnerManager::SP_Despawn(const struct FMaiSpawnerID& SpawnerID, bool ClearActorEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "SP_Despawn");

	Params::MaiSpawnerManager_SP_Despawn Parms{};

	Parms.SpawnerID = std::move(SpawnerID);
	Parms.ClearActorEntry = ClearActorEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.SP_DespawnUnique
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ActorTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSpawnerManager::SP_DespawnUnique(const struct FGameplayTag& ActorTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "SP_DespawnUnique");

	Params::MaiSpawnerManager_SP_DespawnUnique Parms{};

	Parms.ActorTag = std::move(ActorTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.SP_Disable
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMaiSpawnerID                    SpawnerID                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSpawnerManager::SP_Disable(const struct FMaiSpawnerID& SpawnerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "SP_Disable");

	Params::MaiSpawnerManager_SP_Disable Parms{};

	Parms.SpawnerID = std::move(SpawnerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.SP_Enable
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMaiSpawnerID                    SpawnerID                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSpawnerManager::SP_Enable(const struct FMaiSpawnerID& SpawnerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "SP_Enable");

	Params::MaiSpawnerManager_SP_Enable Parms{};

	Parms.SpawnerID = std::move(SpawnerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.SP_ManualSpawnMode
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMaiSpawnerID                    SpawnerID                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSpawnerManager::SP_ManualSpawnMode(const struct FMaiSpawnerID& SpawnerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "SP_ManualSpawnMode");

	Params::MaiSpawnerManager_SP_ManualSpawnMode Parms{};

	Parms.SpawnerID = std::move(SpawnerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.SP_Reincarnate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMaiSpawnerID                    SpawnerID                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   HealthPercent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSpawnerManager::SP_Reincarnate(const struct FMaiSpawnerID& SpawnerID, uint8 HealthPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "SP_Reincarnate");

	Params::MaiSpawnerManager_SP_Reincarnate Parms{};

	Parms.SpawnerID = std::move(SpawnerID);
	Parms.HealthPercent = HealthPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.SP_Spawn
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMaiSpawnerID                    SpawnerID                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSpawnerManager::SP_Spawn(const struct FMaiSpawnerID& SpawnerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "SP_Spawn");

	Params::MaiSpawnerManager_SP_Spawn Parms{};

	Parms.SpawnerID = std::move(SpawnerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.SP_SpawnUnique
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ActorTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMaiSpawnerID                    SpawnerID                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMaiSpawnerManager::SP_SpawnUnique(const struct FGameplayTag& ActorTag, const struct FMaiSpawnerID& SpawnerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "SP_SpawnUnique");

	Params::MaiSpawnerManager_SP_SpawnUnique Parms{};

	Parms.ActorTag = std::move(ActorTag);
	Parms.SpawnerID = std::move(SpawnerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawnerManager.SpawnAllByTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             SpawnerTag                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   Actors                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMaiSpawnerManager::SpawnAllByTag(class FName SpawnerTag, TArray<class AActor*>* Actors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "SpawnAllByTag");

	Params::MaiSpawnerManager_SpawnAllByTag Parms{};

	Parms.SpawnerTag = SpawnerTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Actors != nullptr)
		*Actors = std::move(Parms.Actors);
}


// Function Mai.MaiSpawnerManager.SpawnByTag
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SpawnerTag                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSpawnerManager::SpawnByTag(class FName SpawnerTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "SpawnByTag");

	Params::MaiSpawnerManager_SpawnByTag Parms{};

	Parms.SpawnerTag = SpawnerTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.SpawnNearestByTag
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             SpawnerTag                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMaiSpawnerManager::SpawnNearestByTag(class FName SpawnerTag, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "SpawnNearestByTag");

	Params::MaiSpawnerManager_SpawnNearestByTag Parms{};

	Parms.SpawnerTag = SpawnerTag;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawnerManager.StartWaveSpawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SpawnerTag                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinDelay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDelay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSpawnerManager::StartWaveSpawn(class FName SpawnerTag, int32 Count, float MinDelay, float MaxDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "StartWaveSpawn");

	Params::MaiSpawnerManager_StartWaveSpawn Parms{};

	Parms.SpawnerTag = SpawnerTag;
	Parms.Count = Count;
	Parms.MinDelay = MinDelay;
	Parms.MaxDelay = MaxDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.StopWaveSpawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SpawnerTag                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSpawnerManager::StopWaveSpawn(class FName SpawnerTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "StopWaveSpawn");

	Params::MaiSpawnerManager_StopWaveSpawn Parms{};

	Parms.SpawnerTag = SpawnerTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSpawnerManager.FindOrigin
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMaiSpawnerManager::FindOrigin(const class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "FindOrigin");

	Params::MaiSpawnerManager_FindOrigin Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawnerManager.FindSpawner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiSpawner*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiSpawner* UMaiSpawnerManager::FindSpawner(const class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "FindSpawner");

	Params::MaiSpawnerManager_FindSpawner Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawnerManager.IsLevelLoaded
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiSpawnerManager::IsLevelLoaded(class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "IsLevelLoaded");

	Params::MaiSpawnerManager_IsLevelLoaded Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawnerManager.SP_GetSpawnedActor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMaiSpawnerID                    SpawnerID                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMaiSpawnerManager::SP_GetSpawnedActor(const struct FMaiSpawnerID& SpawnerID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "SP_GetSpawnedActor");

	Params::MaiSpawnerManager_SP_GetSpawnedActor Parms{};

	Parms.SpawnerID = std::move(SpawnerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawnerManager.SP_GetSpawner
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMaiSpawnerID                    SpawnerID                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiSpawner*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiSpawner* UMaiSpawnerManager::SP_GetSpawner(const struct FMaiSpawnerID& SpawnerID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "SP_GetSpawner");

	Params::MaiSpawnerManager_SP_GetSpawner Parms{};

	Parms.SpawnerID = std::move(SpawnerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawnerManager.SP_HasSpawnedActor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMaiSpawnerID                    SpawnerID                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiSpawnerManager::SP_HasSpawnedActor(const struct FMaiSpawnerID& SpawnerID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "SP_HasSpawnedActor");

	Params::MaiSpawnerManager_SP_HasSpawnedActor Parms{};

	Parms.SpawnerID = std::move(SpawnerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawnerManager.SP_IsActive
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMaiSpawnerID                    SpawnerID                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiSpawnerManager::SP_IsActive(const struct FMaiSpawnerID& SpawnerID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "SP_IsActive");

	Params::MaiSpawnerManager_SP_IsActive Parms{};

	Parms.SpawnerID = std::move(SpawnerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSpawnerManager.SP_IsInAutoSpawnMode
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMaiSpawnerID                    SpawnerID                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiSpawnerManager::SP_IsInAutoSpawnMode(const struct FMaiSpawnerID& SpawnerID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSpawnerManager", "SP_IsInAutoSpawnMode");

	Params::MaiSpawnerManager_SP_IsInAutoSpawnMode Parms{};

	Parms.SpawnerID = std::move(SpawnerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSplineActor.ProjectOnSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMaiSplineActor::ProjectOnSpline(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSplineActor", "ProjectOnSpline");

	Params::MaiSplineActor_ProjectOnSpline Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSplineFollower.spawnSplineToAP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiActionPoint*                  Point                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMaiSplineActor*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMaiSplineActor* UMaiSplineFollower::SpawnSplineToAP(class APawn* Pawn, class AMaiActionPoint* Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiSplineFollower", "spawnSplineToAP");

	Params::MaiSplineFollower_SpawnSplineToAP Parms{};

	Parms.Pawn = Pawn;
	Parms.Point = Point;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSplineFollower.MoveOnSpline
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSplineFollower::MoveOnSpline(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSplineFollower", "MoveOnSpline");

	Params::MaiSplineFollower_MoveOnSpline Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSplineFollower.RequestSplineMove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMaiSplineActor*                  Spline                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSplineFollower::RequestSplineMove(class AMaiSplineActor* Spline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSplineFollower", "RequestSplineMove");

	Params::MaiSplineFollower_RequestSplineMove Parms{};

	Parms.Spline = Spline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSplineFollower.SetSpline
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMaiSplineActor*                  Spline                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSplineFollower::SetSpline(class AMaiSplineActor* Spline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSplineFollower", "SetSpline");

	Params::MaiSplineFollower_SetSpline Parms{};

	Parms.Spline = Spline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSplineFollower.StopSplineMove
// (Final, Native, Public, BlueprintCallable)

void UMaiSplineFollower::StopSplineMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSplineFollower", "StopSplineMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSplineFollower.IsMoving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiSplineFollower::IsMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSplineFollower", "IsMoving");

	Params::MaiSplineFollower_IsMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiState.GetOwnerAI
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AAIController*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAIController* UMaiState::GetOwnerAI() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiState", "GetOwnerAI");

	Params::MaiState_GetOwnerAI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiState.GetOwnerCH
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UMaiState::GetOwnerCH() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiState", "GetOwnerCH");

	Params::MaiState_GetOwnerCH Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiSnapState.Config
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           FaceTo                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEasingFunc                             EasingFunc                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSnapState::Config(const struct FVector& Location, class AActor* FaceTo, float Timeout, EEasingFunc EasingFunc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSnapState", "Config");

	Params::MaiSnapState_Config Parms{};

	Parms.Location = std::move(Location);
	Parms.FaceTo = FaceTo;
	Parms.Timeout = Timeout;
	Parms.EasingFunc = EasingFunc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiSnapState.Config2
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          FaceTo                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEasingFunc                             EasingFunc                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiSnapState::Config2(const struct FVector& Location, const struct FVector& FaceTo, float Timeout, EEasingFunc EasingFunc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiSnapState", "Config2");

	Params::MaiSnapState_Config2 Parms{};

	Parms.Location = std::move(Location);
	Parms.FaceTo = std::move(FaceTo);
	Parms.Timeout = Timeout;
	Parms.EasingFunc = EasingFunc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiBlowReactionState.IncreaseHits
// (Final, Native, Public, BlueprintCallable)

void UMaiBlowReactionState::IncreaseHits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiBlowReactionState", "IncreaseHits");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiBlowReactionState.OnBlowStartMSG
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaiMessage*                      Msg                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiBlowReactionState::OnBlowStartMSG(class UMaiMessage* Msg, class AActor* Attacker, TSubclassOf<class UDamageType> DamageClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiBlowReactionState", "OnBlowStartMSG");

	Params::MaiBlowReactionState_OnBlowStartMSG Parms{};

	Parms.Msg = Msg;
	Parms.Attacker = Attacker;
	Parms.DamageClass = DamageClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiBlowReactionState.OnEnemyBlow
// (Event, Public, BlueprintEvent)
// Parameters:
// class APawn*                            Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiBlowReactionState::OnEnemyBlow(class APawn* Enemy, TSubclassOf<class UDamageType> DamageClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiBlowReactionState", "OnEnemyBlow");

	Params::MaiBlowReactionState_OnEnemyBlow Parms{};

	Parms.Enemy = Enemy;
	Parms.DamageClass = DamageClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiBlowReactionState.OnGotHit
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiBlowReactionState::OnGotHit(class APawn* Enemy, TSubclassOf<class UDamageType> DamageClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiBlowReactionState", "OnGotHit");

	Params::MaiBlowReactionState_OnGotHit Parms{};

	Parms.Enemy = Enemy;
	Parms.DamageClass = DamageClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mai.MaiBlowReactionState.OverrideChanceArray
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<uint8>                           _Chances                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMaiBlowReactionState::OverrideChanceArray(const TArray<uint8>& _Chances)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiBlowReactionState", "OverrideChanceArray");

	Params::MaiBlowReactionState_OverrideChanceArray Parms{};

	Parms._Chances = std::move(_Chances);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiBlowReactionState.ResetHitCounter
// (Final, Native, Public)

void UMaiBlowReactionState::ResetHitCounter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiBlowReactionState", "ResetHitCounter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiBlowReactionState.GetChance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UMaiBlowReactionState::GetChance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiBlowReactionState", "GetChance");

	Params::MaiBlowReactionState_GetChance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiWasPushedState.IsBlockedByOther
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiWasPushedState::IsBlockedByOther() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWasPushedState", "IsBlockedByOther");

	Params::MaiWasPushedState_IsBlockedByOther Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiTickLODComponent.SetComponentMaxInterval
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Interval                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiTickLODComponent::SetComponentMaxInterval(class UActorComponent* Component, float Interval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiTickLODComponent", "SetComponentMaxInterval");

	Params::MaiTickLODComponent_SetComponentMaxInterval Parms{};

	Parms.Component = Component;
	Parms.Interval = Interval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiMasterLODComponent.ForceLOD0
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiMasterLODComponent::ForceLOD0(bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiMasterLODComponent", "ForceLOD0");

	Params::MaiMasterLODComponent_ForceLOD0 Parms{};

	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiMasterLODComponent.OnControllerChanged
// (Final, Native, Protected)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      OldController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      NewController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiMasterLODComponent::OnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiMasterLODComponent", "OnControllerChanged");

	Params::MaiMasterLODComponent_OnControllerChanged Parms{};

	Parms.Pawn = Pawn;
	Parms.OldController = OldController;
	Parms.NewController = NewController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiWallFollowing.FinishUsingSurfaceLink
// (Final, Native, Public, BlueprintCallable)

void UMaiWallFollowing::FinishUsingSurfaceLink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallFollowing", "FinishUsingSurfaceLink");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiWallFollowing.MoveTo
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          GoalLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiWallFollowing::MoveTo(const struct FVector& GoalLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallFollowing", "MoveTo");

	Params::MaiWallFollowing_MoveTo Parms{};

	Parms.GoalLocation = std::move(GoalLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiWallFollowing.RebuildPath
// (Final, Native, Public, BlueprintCallable)

void UMaiWallFollowing::RebuildPath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallFollowing", "RebuildPath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiWallFollowing.SnapToFloorMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaiWallFollowing::SnapToFloorMesh(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallFollowing", "SnapToFloorMesh");

	Params::MaiWallFollowing_SnapToFloorMesh Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiWallNavGenerator.BuildNavMesh
// (Final, Native, Public, BlueprintCallable)

void UMaiWallNavGenerator::BuildNavMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallNavGenerator", "BuildNavMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiWallNavGenerator.RebuildCell
// (Final, Native, Public, BlueprintCallable)

void UMaiWallNavGenerator::RebuildCell()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallNavGenerator", "RebuildCell");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiWallNavGenerator.RebuildNavMesh
// (Final, Native, Public, BlueprintCallable)

void UMaiWallNavGenerator::RebuildNavMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallNavGenerator", "RebuildNavMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiWallNavGenerator.Test_SlicedFindPath
// (Final, Native, Public, BlueprintCallable)

void UMaiWallNavGenerator::Test_SlicedFindPath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallNavGenerator", "Test_SlicedFindPath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiWallNavGenerator.Test_CanGoto
// (Final, Native, Public, BlueprintCallable, Const)

void UMaiWallNavGenerator::Test_CanGoto() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallNavGenerator", "Test_CanGoto");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiWallNavGenerator.Test_FindNearest
// (Final, Native, Public, BlueprintCallable, Const)

void UMaiWallNavGenerator::Test_FindNearest() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallNavGenerator", "Test_FindNearest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiWallNavGenerator.Test_FindPath
// (Final, Native, Public, BlueprintCallable, Const)

void UMaiWallNavGenerator::Test_FindPath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallNavGenerator", "Test_FindPath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiWallNavGenerator.Test_FindRandomReachable
// (Final, Native, Public, BlueprintCallable, Const)

void UMaiWallNavGenerator::Test_FindRandomReachable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallNavGenerator", "Test_FindRandomReachable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiWallNavGenerator.Test_GenerateGrid
// (Final, Native, Public, BlueprintCallable, Const)

void UMaiWallNavGenerator::Test_GenerateGrid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallNavGenerator", "Test_GenerateGrid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiWallNavGenerator.Test_IsOnNavMesh
// (Final, Native, Public, BlueprintCallable, Const)

void UMaiWallNavGenerator::Test_IsOnNavMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallNavGenerator", "Test_IsOnNavMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiWallSystem.getWallSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaiWallSystem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaiWallSystem* UMaiWallSystem::GetWallSystem(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaiWallSystem", "getWallSystem");

	Params::MaiWallSystem_GetWallSystem Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiWallSystem.AIWallMesh_RebuildCell
// (Final, Exec, Native, Public)

void UMaiWallSystem::AIWallMesh_RebuildCell()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallSystem", "AIWallMesh_RebuildCell");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mai.MaiWallSystem.FindRandomPointOnWallMesh
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Outpoint                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Pos                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Up                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiWallSystem::FindRandomPointOnWallMesh(struct FVector* Outpoint, float Radius, const struct FVector& Pos, const struct FVector& Up, const struct FVector& Extent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallSystem", "FindRandomPointOnWallMesh");

	Params::MaiWallSystem_FindRandomPointOnWallMesh Parms{};

	Parms.Radius = Radius;
	Parms.Pos = std::move(Pos);
	Parms.Up = std::move(Up);
	Parms.Extent = std::move(Extent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Outpoint != nullptr)
		*Outpoint = std::move(Parms.Outpoint);

	return Parms.ReturnValue;
}


// Function Mai.MaiWallSystem.FindReachablePointOnWallMesh
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Outpoint                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Pos                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Up                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiWallSystem::FindReachablePointOnWallMesh(struct FVector* Outpoint, float Radius, const struct FVector& Pos, const struct FVector& Up) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallSystem", "FindReachablePointOnWallMesh");

	Params::MaiWallSystem_FindReachablePointOnWallMesh Parms{};

	Parms.Radius = Radius;
	Parms.Pos = std::move(Pos);
	Parms.Up = std::move(Up);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Outpoint != nullptr)
		*Outpoint = std::move(Parms.Outpoint);

	return Parms.ReturnValue;
}


// Function Mai.MaiWallSystem.IsOnWallMesh
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Pos                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Up                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiWallSystem::IsOnWallMesh(const struct FVector& Pos, const struct FVector& Up, const struct FVector& Extent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallSystem", "IsOnWallMesh");

	Params::MaiWallSystem_IsOnWallMesh Parms{};

	Parms.Pos = std::move(Pos);
	Parms.Up = std::move(Up);
	Parms.Extent = std::move(Extent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mai.MaiWallSystem.ProjectPointOnWallMesh
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Outpoint                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Pos                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Up                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiWallSystem::ProjectPointOnWallMesh(struct FVector* Outpoint, const struct FVector& Pos, const struct FVector& Up, const struct FVector& Extent, const struct FVector& Offset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallSystem", "ProjectPointOnWallMesh");

	Params::MaiWallSystem_ProjectPointOnWallMesh Parms{};

	Parms.Pos = std::move(Pos);
	Parms.Up = std::move(Up);
	Parms.Extent = std::move(Extent);
	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Outpoint != nullptr)
		*Outpoint = std::move(Parms.Outpoint);

	return Parms.ReturnValue;
}


// Function Mai.MaiWallSystem.RaycastOnWallMesh
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          HitPoint                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Destination                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartUp                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DestUp                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaiWallSystem::RaycastOnWallMesh(struct FVector* HitPoint, const struct FVector& Start, const struct FVector& Destination, const struct FVector& StartUp, const struct FVector& DestUp) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallSystem", "RaycastOnWallMesh");

	Params::MaiWallSystem_RaycastOnWallMesh Parms{};

	Parms.Start = std::move(Start);
	Parms.Destination = std::move(Destination);
	Parms.StartUp = std::move(StartUp);
	Parms.DestUp = std::move(DestUp);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HitPoint != nullptr)
		*HitPoint = std::move(Parms.HitPoint);

	return Parms.ReturnValue;
}


// Function Mai.MaiWallVolume.RegenerateGraph
// (Final, Native, Public, BlueprintCallable)

void AMaiWallVolume::RegenerateGraph()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaiWallVolume", "RegenerateGraph");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

