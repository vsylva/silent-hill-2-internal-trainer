#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Dialog

#include "Basic.hpp"

#include "Dai_structs.hpp"
#include "Dai_classes.hpp"
#include "MovieScene_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AkAudio_structs.hpp"
#include "AkAudio_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "Dialog_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK
{

// Class Dialog.FlowAction
// 0x0060 (0x00C8 - 0x0068)
class UFlowAction : public UGraphObject
{
public:
	class UFlowItem*                              _Owner;                                            // 0x0068(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FNameSelector                          _Phase;                                            // 0x0070(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         _Delay;                                            // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _DoOnSkip : 1;                                     // 0x0094(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _StopOnExit : 1;                                   // 0x0094(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _StopOnContextFinish : 1;                          // 0x0094(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _OverrideDoOnSkip : 1;                             // 0x0094(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _CreateInstance : 1;                               // 0x0094(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _NotifyTick : 1;                                   // 0x0094(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _NotifyStop : 1;                                   // 0x0094(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDialogEntity                          _Entity;                                           // 0x0098(0x0028)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           _ActorTag;                                         // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ActionFinish();

	class UFlowItem* GetItemOwner() const;
	void GrabTargets(class UObject* Context, TSubclassOf<class AActor> Aclass, TArray<class AActor*>* Actors) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowAction">();
	}
	static class UFlowAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowAction>();
	}
};
static_assert(alignof(UFlowAction) == 0x000008, "Wrong alignment on UFlowAction");
static_assert(sizeof(UFlowAction) == 0x0000C8, "Wrong size on UFlowAction");
static_assert(offsetof(UFlowAction, _Owner) == 0x000068, "Member 'UFlowAction::_Owner' has a wrong offset!");
static_assert(offsetof(UFlowAction, _Phase) == 0x000070, "Member 'UFlowAction::_Phase' has a wrong offset!");
static_assert(offsetof(UFlowAction, _Delay) == 0x000090, "Member 'UFlowAction::_Delay' has a wrong offset!");
static_assert(offsetof(UFlowAction, _Entity) == 0x000098, "Member 'UFlowAction::_Entity' has a wrong offset!");
static_assert(offsetof(UFlowAction, _ActorTag) == 0x0000C0, "Member 'UFlowAction::_ActorTag' has a wrong offset!");

// Class Dialog.PlayAnimationFA
// 0x0128 (0x01F0 - 0x00C8)
class UPlayAnimationFA final : public UFlowAction
{
public:
	struct FDaiContext                            _Performer;                                        // 0x00C8(0x0080)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          _SelectAnimByTag;                                  // 0x0148(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      _Animation;                                        // 0x0150(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequenceBase>       _SoftAnimation;                                    // 0x0158(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  _AnimTags;                                         // 0x0188(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   _ComponentTag;                                     // 0x01A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _Slot;                                             // 0x01B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _BlendInTime;                                      // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _BlendOutTime;                                     // 0x01BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _LoopCount;                                        // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C4[0x2C];                                     // 0x01C4(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayAnimationFA">();
	}
	static class UPlayAnimationFA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayAnimationFA>();
	}
};
static_assert(alignof(UPlayAnimationFA) == 0x000008, "Wrong alignment on UPlayAnimationFA");
static_assert(sizeof(UPlayAnimationFA) == 0x0001F0, "Wrong size on UPlayAnimationFA");
static_assert(offsetof(UPlayAnimationFA, _Performer) == 0x0000C8, "Member 'UPlayAnimationFA::_Performer' has a wrong offset!");
static_assert(offsetof(UPlayAnimationFA, _SelectAnimByTag) == 0x000148, "Member 'UPlayAnimationFA::_SelectAnimByTag' has a wrong offset!");
static_assert(offsetof(UPlayAnimationFA, _Animation) == 0x000150, "Member 'UPlayAnimationFA::_Animation' has a wrong offset!");
static_assert(offsetof(UPlayAnimationFA, _SoftAnimation) == 0x000158, "Member 'UPlayAnimationFA::_SoftAnimation' has a wrong offset!");
static_assert(offsetof(UPlayAnimationFA, _AnimTags) == 0x000188, "Member 'UPlayAnimationFA::_AnimTags' has a wrong offset!");
static_assert(offsetof(UPlayAnimationFA, _ComponentTag) == 0x0001A8, "Member 'UPlayAnimationFA::_ComponentTag' has a wrong offset!");
static_assert(offsetof(UPlayAnimationFA, _Slot) == 0x0001B0, "Member 'UPlayAnimationFA::_Slot' has a wrong offset!");
static_assert(offsetof(UPlayAnimationFA, _BlendInTime) == 0x0001B8, "Member 'UPlayAnimationFA::_BlendInTime' has a wrong offset!");
static_assert(offsetof(UPlayAnimationFA, _BlendOutTime) == 0x0001BC, "Member 'UPlayAnimationFA::_BlendOutTime' has a wrong offset!");
static_assert(offsetof(UPlayAnimationFA, _LoopCount) == 0x0001C0, "Member 'UPlayAnimationFA::_LoopCount' has a wrong offset!");

// Class Dialog.AkWaveComponent
// 0x0050 (0x0520 - 0x04D0)
class UAkWaveComponent final : public UAkAudioInputComponent
{
public:
	class USoundWave*                             _Wave;                                             // 0x04D0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D8[0x48];                                     // 0x04D8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayWave();
	void StopWave();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkWaveComponent">();
	}
	static class UAkWaveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkWaveComponent>();
	}
};
static_assert(alignof(UAkWaveComponent) == 0x000010, "Wrong alignment on UAkWaveComponent");
static_assert(sizeof(UAkWaveComponent) == 0x000520, "Wrong size on UAkWaveComponent");
static_assert(offsetof(UAkWaveComponent, _Wave) == 0x0004D0, "Member 'UAkWaveComponent::_Wave' has a wrong offset!");

// Class Dialog.DialogChoiceMovieSceneSection
// 0x0038 (0x0128 - 0x00F0)
class UDialogChoiceMovieSceneSection final : public UMovieSceneSection
{
public:
	struct FDialogChoiceMovieSceneParams          _Params;                                           // 0x00F0(0x0038)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogChoiceMovieSceneSection">();
	}
	static class UDialogChoiceMovieSceneSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogChoiceMovieSceneSection>();
	}
};
static_assert(alignof(UDialogChoiceMovieSceneSection) == 0x000008, "Wrong alignment on UDialogChoiceMovieSceneSection");
static_assert(sizeof(UDialogChoiceMovieSceneSection) == 0x000128, "Wrong size on UDialogChoiceMovieSceneSection");
static_assert(offsetof(UDialogChoiceMovieSceneSection, _Params) == 0x0000F0, "Member 'UDialogChoiceMovieSceneSection::_Params' has a wrong offset!");

// Class Dialog.DialogVoices
// 0x0008 (0x0030 - 0x0028)
class UDialogVoices : public UObject
{
public:
	class UDialogData*                            _DialogData;                                       // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogVoices">();
	}
	static class UDialogVoices* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogVoices>();
	}
};
static_assert(alignof(UDialogVoices) == 0x000008, "Wrong alignment on UDialogVoices");
static_assert(sizeof(UDialogVoices) == 0x000030, "Wrong size on UDialogVoices");
static_assert(offsetof(UDialogVoices, _DialogData) == 0x000028, "Member 'UDialogVoices::_DialogData' has a wrong offset!");

// Class Dialog.DialogDefaultVoices
// 0x0138 (0x0168 - 0x0030)
class UDialogDefaultVoices : public UDialogVoices
{
public:
	uint8                                         Pad_30[0xE8];                                      // 0x0030(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _DefaultVoiceOverCulture;                          // 0x0118(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              _VoiceOverTemplate;                                // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _CuePathTemplate;                                  // 0x0130(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _LastGenVoiceOverDir;                              // 0x0140(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDirectoryPath                         _DirRoot;                                          // 0x0150(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _AddDataNameToDir;                                 // 0x0160(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _AddChapterNameToDir;                              // 0x0161(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _AddDialogNameToDir;                               // 0x0162(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _AddSpeakerNameToDir;                              // 0x0163(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogDefaultVoices">();
	}
	static class UDialogDefaultVoices* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogDefaultVoices>();
	}
};
static_assert(alignof(UDialogDefaultVoices) == 0x000008, "Wrong alignment on UDialogDefaultVoices");
static_assert(sizeof(UDialogDefaultVoices) == 0x000168, "Wrong size on UDialogDefaultVoices");
static_assert(offsetof(UDialogDefaultVoices, _DefaultVoiceOverCulture) == 0x000118, "Member 'UDialogDefaultVoices::_DefaultVoiceOverCulture' has a wrong offset!");
static_assert(offsetof(UDialogDefaultVoices, _VoiceOverTemplate) == 0x000128, "Member 'UDialogDefaultVoices::_VoiceOverTemplate' has a wrong offset!");
static_assert(offsetof(UDialogDefaultVoices, _CuePathTemplate) == 0x000130, "Member 'UDialogDefaultVoices::_CuePathTemplate' has a wrong offset!");
static_assert(offsetof(UDialogDefaultVoices, _LastGenVoiceOverDir) == 0x000140, "Member 'UDialogDefaultVoices::_LastGenVoiceOverDir' has a wrong offset!");
static_assert(offsetof(UDialogDefaultVoices, _DirRoot) == 0x000150, "Member 'UDialogDefaultVoices::_DirRoot' has a wrong offset!");
static_assert(offsetof(UDialogDefaultVoices, _AddDataNameToDir) == 0x000160, "Member 'UDialogDefaultVoices::_AddDataNameToDir' has a wrong offset!");
static_assert(offsetof(UDialogDefaultVoices, _AddChapterNameToDir) == 0x000161, "Member 'UDialogDefaultVoices::_AddChapterNameToDir' has a wrong offset!");
static_assert(offsetof(UDialogDefaultVoices, _AddDialogNameToDir) == 0x000162, "Member 'UDialogDefaultVoices::_AddDialogNameToDir' has a wrong offset!");
static_assert(offsetof(UDialogDefaultVoices, _AddSpeakerNameToDir) == 0x000163, "Member 'UDialogDefaultVoices::_AddSpeakerNameToDir' has a wrong offset!");

// Class Dialog.WaveRawUserData
// 0x0018 (0x0040 - 0x0028)
class UWaveRawUserData final : public UAssetUserData
{
public:
	TArray<uint8>                                 _BulkData;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         _Duration;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaveRawUserData">();
	}
	static class UWaveRawUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaveRawUserData>();
	}
};
static_assert(alignof(UWaveRawUserData) == 0x000008, "Wrong alignment on UWaveRawUserData");
static_assert(sizeof(UWaveRawUserData) == 0x000040, "Wrong size on UWaveRawUserData");
static_assert(offsetof(UWaveRawUserData, _BulkData) == 0x000028, "Member 'UWaveRawUserData::_BulkData' has a wrong offset!");
static_assert(offsetof(UWaveRawUserData, _Duration) == 0x000038, "Member 'UWaveRawUserData::_Duration' has a wrong offset!");

// Class Dialog.DialogChoiceObserver
// 0x0000 (0x0028 - 0x0028)
class UDialogChoiceObserver : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogChoiceObserver">();
	}
	static class UDialogChoiceObserver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogChoiceObserver>();
	}
};
static_assert(alignof(UDialogChoiceObserver) == 0x000008, "Wrong alignment on UDialogChoiceObserver");
static_assert(sizeof(UDialogChoiceObserver) == 0x000028, "Wrong size on UDialogChoiceObserver");

// Class Dialog.DialogChoiceSequenceObserver
// 0x0010 (0x0038 - 0x0028)
class UDialogChoiceSequenceObserver final : public UDialogChoiceObserver
{
public:
	TArray<struct FDialogChoiceSequence>          _Choices;                                          // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogChoiceSequenceObserver">();
	}
	static class UDialogChoiceSequenceObserver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogChoiceSequenceObserver>();
	}
};
static_assert(alignof(UDialogChoiceSequenceObserver) == 0x000008, "Wrong alignment on UDialogChoiceSequenceObserver");
static_assert(sizeof(UDialogChoiceSequenceObserver) == 0x000038, "Wrong size on UDialogChoiceSequenceObserver");
static_assert(offsetof(UDialogChoiceSequenceObserver, _Choices) == 0x000028, "Member 'UDialogChoiceSequenceObserver::_Choices' has a wrong offset!");

// Class Dialog.DialogLineSequenceObserver
// 0x0008 (0x0030 - 0x0028)
class UDialogLineSequenceObserver final : public UDialogChoiceObserver
{
public:
	class UMovieSceneSequencePlayer*              _Player;                                           // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogLineSequenceObserver">();
	}
	static class UDialogLineSequenceObserver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogLineSequenceObserver>();
	}
};
static_assert(alignof(UDialogLineSequenceObserver) == 0x000008, "Wrong alignment on UDialogLineSequenceObserver");
static_assert(sizeof(UDialogLineSequenceObserver) == 0x000030, "Wrong size on UDialogLineSequenceObserver");
static_assert(offsetof(UDialogLineSequenceObserver, _Player) == 0x000028, "Member 'UDialogLineSequenceObserver::_Player' has a wrong offset!");

// Class Dialog.DialogDataTree
// 0x0048 (0x0070 - 0x0028)
class UDialogDataTree final : public UObject
{
public:
	class UDialogData*                            _DialogData;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogDataTree">();
	}
	static class UDialogDataTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogDataTree>();
	}
};
static_assert(alignof(UDialogDataTree) == 0x000008, "Wrong alignment on UDialogDataTree");
static_assert(sizeof(UDialogDataTree) == 0x000070, "Wrong size on UDialogDataTree");
static_assert(offsetof(UDialogDataTree, _DialogData) == 0x000028, "Member 'UDialogDataTree::_DialogData' has a wrong offset!");

// Class Dialog.DialogData
// 0x01F0 (0x0218 - 0x0028)
class UDialogData final : public UObject
{
public:
	class FString                                 _SourcePath;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _LocalizationTarget;                               // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ShowLocalizedText;                                // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDialogVoices*                          _Voices;                                           // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             _TagsTable;                                        // 0x0058(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDialogLine>                    _LinesToSkip;                                      // 0x0060(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	class FString                                 _Language;                                         // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilePath                              _JSonTemplate;                                     // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _FixSource;                                        // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _OnlyChanged;                                      // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _ValidIDS;                                         // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FFilePath                              _EntityCSV;                                        // 0x00A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScriptStruct*                          _EntityRow;                                        // 0x00B8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilePath                              _LineCSV;                                          // 0x00C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScriptStruct*                          _LineRow;                                          // 0x00D0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _TagFilter;                                        // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x28];                                      // 0x00E0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UFlowAsset*>                _SubAssets;                                        // 0x0108(0x0050)(Edit, Transient, EditConst, AdvancedDisplay, NativeAccessSpecifierPrivate)
	TMap<int32, class UFlowItem*>                 _PrototypesItems;                                  // 0x0158(0x0050)(Edit, Transient, EditConst, AdvancedDisplay, NativeAccessSpecifierPrivate)
	TMap<int32, class UFlowItem*>                 _InstancesItems;                                   // 0x01A8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UFlowAsset*                             _RootAsset;                                        // 0x01F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDialogDataTree*                        _DialogDataTree;                                   // 0x0200(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFlowItem*                              _CurrentItem;                                      // 0x0208(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFlowDebugger*                          _Debugger;                                         // 0x0210(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CsvToJson();
	void JsonToCsv();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogData">();
	}
	static class UDialogData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogData>();
	}
};
static_assert(alignof(UDialogData) == 0x000008, "Wrong alignment on UDialogData");
static_assert(sizeof(UDialogData) == 0x000218, "Wrong size on UDialogData");
static_assert(offsetof(UDialogData, _SourcePath) == 0x000028, "Member 'UDialogData::_SourcePath' has a wrong offset!");
static_assert(offsetof(UDialogData, _LocalizationTarget) == 0x000038, "Member 'UDialogData::_LocalizationTarget' has a wrong offset!");
static_assert(offsetof(UDialogData, _ShowLocalizedText) == 0x000048, "Member 'UDialogData::_ShowLocalizedText' has a wrong offset!");
static_assert(offsetof(UDialogData, _Voices) == 0x000050, "Member 'UDialogData::_Voices' has a wrong offset!");
static_assert(offsetof(UDialogData, _TagsTable) == 0x000058, "Member 'UDialogData::_TagsTable' has a wrong offset!");
static_assert(offsetof(UDialogData, _LinesToSkip) == 0x000060, "Member 'UDialogData::_LinesToSkip' has a wrong offset!");
static_assert(offsetof(UDialogData, _Language) == 0x000070, "Member 'UDialogData::_Language' has a wrong offset!");
static_assert(offsetof(UDialogData, _JSonTemplate) == 0x000080, "Member 'UDialogData::_JSonTemplate' has a wrong offset!");
static_assert(offsetof(UDialogData, _FixSource) == 0x000090, "Member 'UDialogData::_FixSource' has a wrong offset!");
static_assert(offsetof(UDialogData, _OnlyChanged) == 0x000091, "Member 'UDialogData::_OnlyChanged' has a wrong offset!");
static_assert(offsetof(UDialogData, _ValidIDS) == 0x000098, "Member 'UDialogData::_ValidIDS' has a wrong offset!");
static_assert(offsetof(UDialogData, _EntityCSV) == 0x0000A8, "Member 'UDialogData::_EntityCSV' has a wrong offset!");
static_assert(offsetof(UDialogData, _EntityRow) == 0x0000B8, "Member 'UDialogData::_EntityRow' has a wrong offset!");
static_assert(offsetof(UDialogData, _LineCSV) == 0x0000C0, "Member 'UDialogData::_LineCSV' has a wrong offset!");
static_assert(offsetof(UDialogData, _LineRow) == 0x0000D0, "Member 'UDialogData::_LineRow' has a wrong offset!");
static_assert(offsetof(UDialogData, _TagFilter) == 0x0000D8, "Member 'UDialogData::_TagFilter' has a wrong offset!");
static_assert(offsetof(UDialogData, _SubAssets) == 0x000108, "Member 'UDialogData::_SubAssets' has a wrong offset!");
static_assert(offsetof(UDialogData, _PrototypesItems) == 0x000158, "Member 'UDialogData::_PrototypesItems' has a wrong offset!");
static_assert(offsetof(UDialogData, _InstancesItems) == 0x0001A8, "Member 'UDialogData::_InstancesItems' has a wrong offset!");
static_assert(offsetof(UDialogData, _RootAsset) == 0x0001F8, "Member 'UDialogData::_RootAsset' has a wrong offset!");
static_assert(offsetof(UDialogData, _DialogDataTree) == 0x000200, "Member 'UDialogData::_DialogDataTree' has a wrong offset!");
static_assert(offsetof(UDialogData, _CurrentItem) == 0x000208, "Member 'UDialogData::_CurrentItem' has a wrong offset!");
static_assert(offsetof(UDialogData, _Debugger) == 0x000210, "Member 'UDialogData::_Debugger' has a wrong offset!");

// Class Dialog.DialogFunctions
// 0x0000 (0x0028 - 0x0028)
class UDialogFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UQuest* beginQuest(class UObject* WorldContextObject, const struct FQuestID& QuestID);
	static bool CanPlayTalk(const TArray<class AActor*>& Speakers, const struct FDialogTalkID& TalkID, const struct FDialogInfo& Info, class UObject* Context);
	static void ClearVOCache(const struct FDialogTalkID& TalkID);
	static void ClearVOsCache(const TArray<struct FDialogTalkID>& TalkIDs);
	static void DestroySpeaker(class UDialogSpeaker* Speaker);
	static bool EqualFlowObjectID(const struct FDialogObjectID& A, const struct FDialogObjectID& B);
	static TArray<class UDialogSpeaker*> FilterSpeakersByDistance(const TArray<class UDialogSpeaker*>& Speakers, float MaxDistToPlayer);
	static TArray<class UDialogSpeaker*> FilterSpeakersByEntity(const TArray<class UDialogSpeaker*>& Speakers, const struct FDialogEntity& Entity, bool CheckVoices);
	static TArray<class UDialogSpeaker*> FilterSpeakersByGameplayTags(const TArray<class UDialogSpeaker*>& Speakers, const struct FGameplayTagContainer& Tags);
	static TArray<class UDialogSpeaker*> FilterSpeakersByVoice(const TArray<class UDialogSpeaker*>& Speakers, const struct FDialogEntity& Entity);
	static void FinishObjective(class UObject* WorldContextObject, const struct FQuestObjectiveID& ObjectiveID, EQuestResult Result);
	static TArray<class UDialogSpeaker*> GetAllSpeakers(class UObject* Context, const TArray<class AActor*>& OnlyFromActors);
	static class UDialogManager* GetDialogManager(class UObject* WorldContextObject);
	static struct FColor GetDisplayColor(const struct FDialogObjectID& ObjectID);
	static class FString GetDisplayName(const struct FDialogObjectID& ObjectID);
	static bool GetFlowBoolean(const struct FFlowBoolean& GlobalID);
	static int32 GetFlowInteger(const struct FFlowInteger& GlobalID);
	static struct FGuid GetGUID(const struct FDialogObjectID& ObjectID);
	static class UDialogTalk* GetInteractiveTalk(class UObject* WorldContextObject);
	static class UFlowItem* GetItemObject(const struct FDialogObjectID& ObjectID);
	static class FText GetLocalizedText(class UObject* WorldContextObject, const struct FFlowText& Text);
	static class FText GetLocalizedTextByKey(class UObject* WorldContextObject, const struct FDialogObjectID& ObjectID, const class FString& Key);
	static struct FDialogEntity GetSpeakerEntity(const struct FDialogLine& LineID);
	static class FString GetTechnicalName(const struct FDialogObjectID& ObjectID);
	static class UFlowTemplate* GetTemplateObject(const struct FDialogObjectID& ObjectID);
	static class FText GetTranslationText(class UObject* WorldContextObject, const struct FFlowText& Text);
	static bool IsValidFlowGlobal(const struct FFlowGlobal& GlobalID);
	static bool IsValidFlowObjectID(const struct FDialogObjectID& A);
	static void PauseDialogTalk(class UDialogTalk* Dialog);
	static class UDialogTalk* PlayActorDialog(class AActor* Caller, class AActor* Speaker, class UObject* Context);
	static class UDialogTalk* PlayDialogFromLine(class AActor* Caller, class AActor* Speaker, const struct FDialogLine& DialogLineID, const struct FDialogInfo& Info, class UObject* Context);
	static class UDialogTalk* PlayDialogTalk(class AActor* Caller, class AActor* Speaker, const struct FDialogDialog& DialogID, const struct FDialogInfo& Info, class UObject* Context);
	static class UDialogTalk* PlayMonolog(class AActor* Speaker, const struct FDialogLine& LineID, const struct FDialogInfo& Info, class UObject* Context);
	static class UDialogTalk* PlayMonologFromLine(class UObject* WorldContextObject, const struct FDialogLine& DialogLineID, class AActor* Speaker, ERange SubtitleRange, float OverridenSubtitleRange);
	static class UDialogTalk* PlayMonologSingleLine(class UObject* WorldContextObject, const struct FDialogLine& DialogLineID, class AActor* Speaker, ERange SubtitleRange, float OverridenSubtitleRange);
	static class UDialogTalk* PlaySpeakerDialog(class AActor* Caller, class UDialogSpeaker* Speaker, class UObject* Context);
	static class UDialogTalk* PlayTalk(const TArray<class AActor*>& Speakers, const struct FDialogTalkID& TalkID, const struct FDialogInfo& Info, class UObject* Context);
	static void PreloadVO(const struct FDialogTalkID& TalkID);
	static void PreloadVOs(const TArray<struct FDialogTalkID>& TalkIDs);
	static void ResumeDialogTalk(class UDialogTalk* Dialog);
	static struct FDialogEntity SelectDialogEntityID(class UDialogData* Data, const struct FDialogEntity& DialogEntityID);
	static struct FDialogEntryID SelectDialogEntryID(class UDialogData* Data, const struct FDialogEntryID& DialogEntryID);
	static struct FDialogHub SelectDialogHubID(class UDialogData* Data, const struct FDialogHub& DialogHubID);
	static struct FDialogDialog SelectDialogID(class UDialogData* Data, const struct FDialogDialog& DialogID);
	static struct FDialogLine SelectDialogLineID(class UDialogData* Data, const struct FDialogLine& DialogLineID);
	static struct FFlowBoolean SelectFlowBoolean(class UDialogData* Data, const struct FFlowBoolean& GlobalID);
	static struct FFlowInteger SelectFlowInteger(class UDialogData* Data, const struct FFlowInteger& GlobalID);
	static class UDialogSpeaker* SelectNearestSpeaker(const TArray<class UDialogSpeaker*>& Speakers, const struct FVector& Origin);
	static struct FQuestID SelectQuestID(class UDialogData* Data, const struct FQuestID& QuestID);
	static struct FQuestObjectiveID SelectQuestObjectiveID(class UDialogData* Data, const struct FQuestObjectiveID& ObjectiveID);
	static class UDialogSpeaker* SelectRandomSpeaker(const TArray<class UDialogSpeaker*>& Speakers);
	static void SetFlowBoolean(const struct FFlowBoolean& GlobalID, bool Value);
	static void SetFlowInteger(const struct FFlowInteger& GlobalID, int32 Value);
	static void StopDialogTalk(class UDialogTalk* Dialog);
	static class UDialogTalk* TryPlayAnyTalk(class UObject* Context, class AActor* Caller, class AActor* Speaker, TArray<struct FDialogFullInfo>& Infos);
	static class UDialogTalk* TryPlayTalk(class UObject* Context, class AActor* Caller, class AActor* Speaker, struct FDialogFullInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogFunctions">();
	}
	static class UDialogFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogFunctions>();
	}
};
static_assert(alignof(UDialogFunctions) == 0x000008, "Wrong alignment on UDialogFunctions");
static_assert(sizeof(UDialogFunctions) == 0x000028, "Wrong size on UDialogFunctions");

// Class Dialog.FlowItem
// 0x0118 (0x0180 - 0x0068)
class UFlowItem : public UGraphObject
{
public:
	struct FColor                                 _Color;                                            // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _TechnicalName;                                    // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _SaveGame;                                         // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ResetState;                                       // 0x0081(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x2];                                       // 0x0082(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _CallCounter;                                      // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _ShortID;                                          // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _StringID;                                         // 0x0090(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVarObjectData*                         _ExtraData;                                        // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class FString>              _ExtraFields;                                      // 0x00A8(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<class UFlowAction*>                    _Actions;                                          // 0x00F8(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<class UDaiCondition*>                  _Conditions;                                       // 0x0108(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<struct FDialogObjectID>                _Connections;                                      // 0x0118(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<struct FFlowPin>                       _Pins;                                             // 0x0128(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	class UFlowTemplate*                          _Template;                                         // 0x0138(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x40];                                     // 0x0140(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetDisplayString() const;
	struct FDialogObjectID GetFlowRef() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowItem">();
	}
	static class UFlowItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowItem>();
	}
};
static_assert(alignof(UFlowItem) == 0x000008, "Wrong alignment on UFlowItem");
static_assert(sizeof(UFlowItem) == 0x000180, "Wrong size on UFlowItem");
static_assert(offsetof(UFlowItem, _Color) == 0x000068, "Member 'UFlowItem::_Color' has a wrong offset!");
static_assert(offsetof(UFlowItem, _TechnicalName) == 0x000070, "Member 'UFlowItem::_TechnicalName' has a wrong offset!");
static_assert(offsetof(UFlowItem, _SaveGame) == 0x000080, "Member 'UFlowItem::_SaveGame' has a wrong offset!");
static_assert(offsetof(UFlowItem, _ResetState) == 0x000081, "Member 'UFlowItem::_ResetState' has a wrong offset!");
static_assert(offsetof(UFlowItem, _CallCounter) == 0x000084, "Member 'UFlowItem::_CallCounter' has a wrong offset!");
static_assert(offsetof(UFlowItem, _ShortID) == 0x000088, "Member 'UFlowItem::_ShortID' has a wrong offset!");
static_assert(offsetof(UFlowItem, _StringID) == 0x000090, "Member 'UFlowItem::_StringID' has a wrong offset!");
static_assert(offsetof(UFlowItem, _ExtraData) == 0x0000A0, "Member 'UFlowItem::_ExtraData' has a wrong offset!");
static_assert(offsetof(UFlowItem, _ExtraFields) == 0x0000A8, "Member 'UFlowItem::_ExtraFields' has a wrong offset!");
static_assert(offsetof(UFlowItem, _Actions) == 0x0000F8, "Member 'UFlowItem::_Actions' has a wrong offset!");
static_assert(offsetof(UFlowItem, _Conditions) == 0x000108, "Member 'UFlowItem::_Conditions' has a wrong offset!");
static_assert(offsetof(UFlowItem, _Connections) == 0x000118, "Member 'UFlowItem::_Connections' has a wrong offset!");
static_assert(offsetof(UFlowItem, _Pins) == 0x000128, "Member 'UFlowItem::_Pins' has a wrong offset!");
static_assert(offsetof(UFlowItem, _Template) == 0x000138, "Member 'UFlowItem::_Template' has a wrong offset!");

// Class Dialog.FlowExtItem
// 0x0090 (0x0210 - 0x0180)
class UFlowExtItem : public UFlowItem
{
public:
	class FString                                 _Name;                                             // 0x0180(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _Description;                                      // 0x0190(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFlowText                              _LocName;                                          // 0x01A0(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFlowText                              _LocDescription;                                   // 0x01D8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowExtItem">();
	}
	static class UFlowExtItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowExtItem>();
	}
};
static_assert(alignof(UFlowExtItem) == 0x000008, "Wrong alignment on UFlowExtItem");
static_assert(sizeof(UFlowExtItem) == 0x000210, "Wrong size on UFlowExtItem");
static_assert(offsetof(UFlowExtItem, _Name) == 0x000180, "Member 'UFlowExtItem::_Name' has a wrong offset!");
static_assert(offsetof(UFlowExtItem, _Description) == 0x000190, "Member 'UFlowExtItem::_Description' has a wrong offset!");
static_assert(offsetof(UFlowExtItem, _LocName) == 0x0001A0, "Member 'UFlowExtItem::_LocName' has a wrong offset!");
static_assert(offsetof(UFlowExtItem, _LocDescription) == 0x0001D8, "Member 'UFlowExtItem::_LocDescription' has a wrong offset!");

// Class Dialog.FlowFragment
// 0x0010 (0x0220 - 0x0210)
class UFlowFragment : public UFlowExtItem
{
public:
	bool                                          _IsAChapter;                                       // 0x0210(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Placeholder;                                      // 0x0211(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_212[0x6];                                      // 0x0212(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFlowAsset*                             _Inner;                                            // 0x0218(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowFragment">();
	}
	static class UFlowFragment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowFragment>();
	}
};
static_assert(alignof(UFlowFragment) == 0x000008, "Wrong alignment on UFlowFragment");
static_assert(sizeof(UFlowFragment) == 0x000220, "Wrong size on UFlowFragment");
static_assert(offsetof(UFlowFragment, _IsAChapter) == 0x000210, "Member 'UFlowFragment::_IsAChapter' has a wrong offset!");
static_assert(offsetof(UFlowFragment, _Placeholder) == 0x000211, "Member 'UFlowFragment::_Placeholder' has a wrong offset!");
static_assert(offsetof(UFlowFragment, _Inner) == 0x000218, "Member 'UFlowFragment::_Inner' has a wrong offset!");

// Class Dialog.FlowFolder
// 0x0008 (0x0228 - 0x0220)
class UFlowFolder : public UFlowFragment
{
public:
	bool                                          _EntityFolder;                                     // 0x0220(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowFolder">();
	}
	static class UFlowFolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowFolder>();
	}
};
static_assert(alignof(UFlowFolder) == 0x000008, "Wrong alignment on UFlowFolder");
static_assert(sizeof(UFlowFolder) == 0x000228, "Wrong size on UFlowFolder");
static_assert(offsetof(UFlowFolder, _EntityFolder) == 0x000220, "Member 'UFlowFolder::_EntityFolder' has a wrong offset!");

// Class Dialog.FlowChapter
// 0x0010 (0x0238 - 0x0228)
class UFlowChapter final : public UFlowFolder
{
public:
	struct FFilePath                              _CSV;                                              // 0x0228(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowChapter">();
	}
	static class UFlowChapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowChapter>();
	}
};
static_assert(alignof(UFlowChapter) == 0x000008, "Wrong alignment on UFlowChapter");
static_assert(sizeof(UFlowChapter) == 0x000238, "Wrong size on UFlowChapter");
static_assert(offsetof(UFlowChapter, _CSV) == 0x000228, "Member 'UFlowChapter::_CSV' has a wrong offset!");

// Class Dialog.FlowBranch
// 0x0010 (0x0220 - 0x0210)
class UFlowBranch final : public UFlowExtItem
{
public:
	uint8                                         Pad_210[0x10];                                     // 0x0210(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowBranch">();
	}
	static class UFlowBranch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowBranch>();
	}
};
static_assert(alignof(UFlowBranch) == 0x000008, "Wrong alignment on UFlowBranch");
static_assert(sizeof(UFlowBranch) == 0x000220, "Wrong size on UFlowBranch");

// Class Dialog.FlowDialog
// 0x0068 (0x0288 - 0x0220)
class UFlowDialog final : public UFlowFragment
{
public:
	TSubclassOf<class UFlowDialogTemplate>        _TemplateClass;                                    // 0x0220(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _CanBeSkipped;                                     // 0x0228(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _Tags;                                             // 0x0230(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         _Loudness;                                         // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _Mastering;                                        // 0x0248(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _Note1;                                            // 0x0258(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _Note2;                                            // 0x0268(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _Note3;                                            // 0x0278(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowDialog">();
	}
	static class UFlowDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowDialog>();
	}
};
static_assert(alignof(UFlowDialog) == 0x000008, "Wrong alignment on UFlowDialog");
static_assert(sizeof(UFlowDialog) == 0x000288, "Wrong size on UFlowDialog");
static_assert(offsetof(UFlowDialog, _TemplateClass) == 0x000220, "Member 'UFlowDialog::_TemplateClass' has a wrong offset!");
static_assert(offsetof(UFlowDialog, _CanBeSkipped) == 0x000228, "Member 'UFlowDialog::_CanBeSkipped' has a wrong offset!");
static_assert(offsetof(UFlowDialog, _Tags) == 0x000230, "Member 'UFlowDialog::_Tags' has a wrong offset!");
static_assert(offsetof(UFlowDialog, _Loudness) == 0x000240, "Member 'UFlowDialog::_Loudness' has a wrong offset!");
static_assert(offsetof(UFlowDialog, _Mastering) == 0x000248, "Member 'UFlowDialog::_Mastering' has a wrong offset!");
static_assert(offsetof(UFlowDialog, _Note1) == 0x000258, "Member 'UFlowDialog::_Note1' has a wrong offset!");
static_assert(offsetof(UFlowDialog, _Note2) == 0x000268, "Member 'UFlowDialog::_Note2' has a wrong offset!");
static_assert(offsetof(UFlowDialog, _Note3) == 0x000278, "Member 'UFlowDialog::_Note3' has a wrong offset!");

// Class Dialog.FlowDialogLine
// 0x0108 (0x0288 - 0x0180)
class UFlowDialogLine final : public UFlowItem
{
public:
	TSubclassOf<class UFlowLineTemplate>          _TemplateClass;                                    // 0x0180(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDialogEntity                          _Speaker;                                          // 0x0188(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDialogEntity                          _DisplaySpeaker;                                   // 0x01B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _MenuText;                                         // 0x01D8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _Text;                                             // 0x01E8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _StageDirections;                                  // 0x01F8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _LockUpdate;                                       // 0x0208(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _CustomLength;                                     // 0x0209(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20A[0x6];                                      // 0x020A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        _VoiceOver;                                        // 0x0210(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _LineLength;                                       // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _DelayAfterLine;                                   // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _OverrideDelay;                                    // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _CanBeSkipped;                                     // 0x0239(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Resumeable;                                       // 0x023A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ExclusiveSubtitles;                               // 0x023B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _OverrideShowingSubtitles;                         // 0x023C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D[0x3];                                      // 0x023D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _StartShowingSubtitles;                            // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _Loudness;                                         // 0x0244(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_245[0x3];                                      // 0x0245(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _Mastering;                                        // 0x0248(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _Note1;                                            // 0x0258(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _Note2;                                            // 0x0268(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _Note3;                                            // 0x0278(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowDialogLine">();
	}
	static class UFlowDialogLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowDialogLine>();
	}
};
static_assert(alignof(UFlowDialogLine) == 0x000008, "Wrong alignment on UFlowDialogLine");
static_assert(sizeof(UFlowDialogLine) == 0x000288, "Wrong size on UFlowDialogLine");
static_assert(offsetof(UFlowDialogLine, _TemplateClass) == 0x000180, "Member 'UFlowDialogLine::_TemplateClass' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _Speaker) == 0x000188, "Member 'UFlowDialogLine::_Speaker' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _DisplaySpeaker) == 0x0001B0, "Member 'UFlowDialogLine::_DisplaySpeaker' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _MenuText) == 0x0001D8, "Member 'UFlowDialogLine::_MenuText' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _Text) == 0x0001E8, "Member 'UFlowDialogLine::_Text' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _StageDirections) == 0x0001F8, "Member 'UFlowDialogLine::_StageDirections' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _LockUpdate) == 0x000208, "Member 'UFlowDialogLine::_LockUpdate' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _CustomLength) == 0x000209, "Member 'UFlowDialogLine::_CustomLength' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _VoiceOver) == 0x000210, "Member 'UFlowDialogLine::_VoiceOver' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _LineLength) == 0x000230, "Member 'UFlowDialogLine::_LineLength' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _DelayAfterLine) == 0x000234, "Member 'UFlowDialogLine::_DelayAfterLine' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _OverrideDelay) == 0x000238, "Member 'UFlowDialogLine::_OverrideDelay' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _CanBeSkipped) == 0x000239, "Member 'UFlowDialogLine::_CanBeSkipped' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _Resumeable) == 0x00023A, "Member 'UFlowDialogLine::_Resumeable' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _ExclusiveSubtitles) == 0x00023B, "Member 'UFlowDialogLine::_ExclusiveSubtitles' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _OverrideShowingSubtitles) == 0x00023C, "Member 'UFlowDialogLine::_OverrideShowingSubtitles' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _StartShowingSubtitles) == 0x000240, "Member 'UFlowDialogLine::_StartShowingSubtitles' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _Loudness) == 0x000244, "Member 'UFlowDialogLine::_Loudness' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _Mastering) == 0x000248, "Member 'UFlowDialogLine::_Mastering' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _Note1) == 0x000258, "Member 'UFlowDialogLine::_Note1' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _Note2) == 0x000268, "Member 'UFlowDialogLine::_Note2' has a wrong offset!");
static_assert(offsetof(UFlowDialogLine, _Note3) == 0x000278, "Member 'UFlowDialogLine::_Note3' has a wrong offset!");

// Class Dialog.FlowDialogEntry
// 0x0000 (0x0210 - 0x0210)
class UFlowDialogEntry final : public UFlowExtItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowDialogEntry">();
	}
	static class UFlowDialogEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowDialogEntry>();
	}
};
static_assert(alignof(UFlowDialogEntry) == 0x000008, "Wrong alignment on UFlowDialogEntry");
static_assert(sizeof(UFlowDialogEntry) == 0x000210, "Wrong size on UFlowDialogEntry");

// Class Dialog.FlowEntity
// 0x0028 (0x0238 - 0x0210)
class UFlowEntity final : public UFlowExtItem
{
public:
	TSubclassOf<class UFlowEntityTemplate>        _TemplateClass;                                    // 0x0210(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDialogVoiceAttenuation                _VoiceAttenuation;                                 // 0x0218(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _NameShortcut;                                     // 0x0228(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowEntity">();
	}
	static class UFlowEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowEntity>();
	}
};
static_assert(alignof(UFlowEntity) == 0x000008, "Wrong alignment on UFlowEntity");
static_assert(sizeof(UFlowEntity) == 0x000238, "Wrong size on UFlowEntity");
static_assert(offsetof(UFlowEntity, _TemplateClass) == 0x000210, "Member 'UFlowEntity::_TemplateClass' has a wrong offset!");
static_assert(offsetof(UFlowEntity, _VoiceAttenuation) == 0x000218, "Member 'UFlowEntity::_VoiceAttenuation' has a wrong offset!");
static_assert(offsetof(UFlowEntity, _NameShortcut) == 0x000228, "Member 'UFlowEntity::_NameShortcut' has a wrong offset!");

// Class Dialog.FlowHub
// 0x0040 (0x0250 - 0x0210)
class UFlowHub final : public UFlowExtItem
{
public:
	TSubclassOf<class UFlowHubTemplate>           _TemplateClass;                                    // 0x0210(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHubType                                      _Type;                                             // 0x0218(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDialogObjectID                        _LastSelection;                                    // 0x0220(0x0028)(Edit, DisableEditOnTemplate, Transient, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ShowOneOption;                                    // 0x0248(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowHub">();
	}
	static class UFlowHub* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowHub>();
	}
};
static_assert(alignof(UFlowHub) == 0x000008, "Wrong alignment on UFlowHub");
static_assert(sizeof(UFlowHub) == 0x000250, "Wrong size on UFlowHub");
static_assert(offsetof(UFlowHub, _TemplateClass) == 0x000210, "Member 'UFlowHub::_TemplateClass' has a wrong offset!");
static_assert(offsetof(UFlowHub, _Type) == 0x000218, "Member 'UFlowHub::_Type' has a wrong offset!");
static_assert(offsetof(UFlowHub, _LastSelection) == 0x000220, "Member 'UFlowHub::_LastSelection' has a wrong offset!");
static_assert(offsetof(UFlowHub, _ShowOneOption) == 0x000248, "Member 'UFlowHub::_ShowOneOption' has a wrong offset!");

// Class Dialog.FlowJump
// 0x0028 (0x0238 - 0x0210)
class UFlowJump final : public UFlowExtItem
{
public:
	struct FDialogObjectID                        _Target;                                           // 0x0210(0x0028)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowJump">();
	}
	static class UFlowJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowJump>();
	}
};
static_assert(alignof(UFlowJump) == 0x000008, "Wrong alignment on UFlowJump");
static_assert(sizeof(UFlowJump) == 0x000238, "Wrong size on UFlowJump");
static_assert(offsetof(UFlowJump, _Target) == 0x000210, "Member 'UFlowJump::_Target' has a wrong offset!");

// Class Dialog.FlowQuestFragment
// 0x0008 (0x0228 - 0x0220)
class UFlowQuestFragment : public UFlowFragment
{
public:
	bool                                          _Hidden;                                           // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowQuestFragment">();
	}
	static class UFlowQuestFragment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowQuestFragment>();
	}
};
static_assert(alignof(UFlowQuestFragment) == 0x000008, "Wrong alignment on UFlowQuestFragment");
static_assert(sizeof(UFlowQuestFragment) == 0x000228, "Wrong size on UFlowQuestFragment");
static_assert(offsetof(UFlowQuestFragment, _Hidden) == 0x000220, "Member 'UFlowQuestFragment::_Hidden' has a wrong offset!");

// Class Dialog.FlowQuest
// 0x0008 (0x0230 - 0x0228)
class UFlowQuest final : public UFlowQuestFragment
{
public:
	TSubclassOf<class UFlowQuestTemplate>         _TemplateClass;                                    // 0x0228(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowQuest">();
	}
	static class UFlowQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowQuest>();
	}
};
static_assert(alignof(UFlowQuest) == 0x000008, "Wrong alignment on UFlowQuest");
static_assert(sizeof(UFlowQuest) == 0x000230, "Wrong size on UFlowQuest");
static_assert(offsetof(UFlowQuest, _TemplateClass) == 0x000228, "Member 'UFlowQuest::_TemplateClass' has a wrong offset!");

// Class Dialog.FlowQuestObjective
// 0x00D0 (0x02E0 - 0x0210)
class UFlowQuestObjective final : public UFlowExtItem
{
public:
	TSubclassOf<class UFlowObjectiveTemplate>     _TemplateClass;                                    // 0x0210(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_218[0x30];                                     // 0x0218(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDaiConditions                         _SuccessConditions;                                // 0x0248(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDaiConditions                         _FailureConditions;                                // 0x0278(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDaiConditions                         _ClosingConditions;                                // 0x02A8(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          _Hidden;                                           // 0x02D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Silent;                                           // 0x02D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuestStatus                                  _Status;                                           // 0x02DA(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DB[0x5];                                      // 0x02DB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowQuestObjective">();
	}
	static class UFlowQuestObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowQuestObjective>();
	}
};
static_assert(alignof(UFlowQuestObjective) == 0x000008, "Wrong alignment on UFlowQuestObjective");
static_assert(sizeof(UFlowQuestObjective) == 0x0002E0, "Wrong size on UFlowQuestObjective");
static_assert(offsetof(UFlowQuestObjective, _TemplateClass) == 0x000210, "Member 'UFlowQuestObjective::_TemplateClass' has a wrong offset!");
static_assert(offsetof(UFlowQuestObjective, _SuccessConditions) == 0x000248, "Member 'UFlowQuestObjective::_SuccessConditions' has a wrong offset!");
static_assert(offsetof(UFlowQuestObjective, _FailureConditions) == 0x000278, "Member 'UFlowQuestObjective::_FailureConditions' has a wrong offset!");
static_assert(offsetof(UFlowQuestObjective, _ClosingConditions) == 0x0002A8, "Member 'UFlowQuestObjective::_ClosingConditions' has a wrong offset!");
static_assert(offsetof(UFlowQuestObjective, _Hidden) == 0x0002D8, "Member 'UFlowQuestObjective::_Hidden' has a wrong offset!");
static_assert(offsetof(UFlowQuestObjective, _Silent) == 0x0002D9, "Member 'UFlowQuestObjective::_Silent' has a wrong offset!");
static_assert(offsetof(UFlowQuestObjective, _Status) == 0x0002DA, "Member 'UFlowQuestObjective::_Status' has a wrong offset!");

// Class Dialog.FlowQuestResult
// 0x0000 (0x0210 - 0x0210)
class UFlowQuestResult final : public UFlowExtItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowQuestResult">();
	}
	static class UFlowQuestResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowQuestResult>();
	}
};
static_assert(alignof(UFlowQuestResult) == 0x000008, "Wrong alignment on UFlowQuestResult");
static_assert(sizeof(UFlowQuestResult) == 0x000210, "Wrong size on UFlowQuestResult");

// Class Dialog.FlowQuestStoryRecap
// 0x0000 (0x0210 - 0x0210)
class UFlowQuestStoryRecap final : public UFlowExtItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowQuestStoryRecap">();
	}
	static class UFlowQuestStoryRecap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowQuestStoryRecap>();
	}
};
static_assert(alignof(UFlowQuestStoryRecap) == 0x000008, "Wrong alignment on UFlowQuestStoryRecap");
static_assert(sizeof(UFlowQuestStoryRecap) == 0x000210, "Wrong size on UFlowQuestStoryRecap");

// Class Dialog.FlowReference
// 0x0028 (0x0238 - 0x0210)
class UFlowReference final : public UFlowExtItem
{
public:
	struct FDialogObjectID                        _Target;                                           // 0x0210(0x0028)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowReference">();
	}
	static class UFlowReference* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowReference>();
	}
};
static_assert(alignof(UFlowReference) == 0x000008, "Wrong alignment on UFlowReference");
static_assert(sizeof(UFlowReference) == 0x000238, "Wrong size on UFlowReference");
static_assert(offsetof(UFlowReference, _Target) == 0x000210, "Member 'UFlowReference::_Target' has a wrong offset!");

// Class Dialog.VarObjectData
// 0x0018 (0x0040 - 0x0028)
class UVarObjectData : public UObject
{
public:
	struct FFlowID                                _FlowID;                                           // 0x0028(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFlowAction*>                    _Actions;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VarObjectData">();
	}
	static class UVarObjectData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVarObjectData>();
	}
};
static_assert(alignof(UVarObjectData) == 0x000008, "Wrong alignment on UVarObjectData");
static_assert(sizeof(UVarObjectData) == 0x000040, "Wrong size on UVarObjectData");
static_assert(offsetof(UVarObjectData, _FlowID) == 0x000028, "Member 'UVarObjectData::_FlowID' has a wrong offset!");
static_assert(offsetof(UVarObjectData, _Actions) == 0x000030, "Member 'UVarObjectData::_Actions' has a wrong offset!");

// Class Dialog.VarDialogData
// 0x0000 (0x0040 - 0x0040)
class UVarDialogData final : public UVarObjectData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VarDialogData">();
	}
	static class UVarDialogData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVarDialogData>();
	}
};
static_assert(alignof(UVarDialogData) == 0x000008, "Wrong alignment on UVarDialogData");
static_assert(sizeof(UVarDialogData) == 0x000040, "Wrong size on UVarDialogData");

// Class Dialog.VarEntityData
// 0x0000 (0x0040 - 0x0040)
class UVarEntityData final : public UVarObjectData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VarEntityData">();
	}
	static class UVarEntityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVarEntityData>();
	}
};
static_assert(alignof(UVarEntityData) == 0x000008, "Wrong alignment on UVarEntityData");
static_assert(sizeof(UVarEntityData) == 0x000040, "Wrong size on UVarEntityData");

// Class Dialog.VarHubData
// 0x0000 (0x0040 - 0x0040)
class UVarHubData final : public UVarObjectData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VarHubData">();
	}
	static class UVarHubData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVarHubData>();
	}
};
static_assert(alignof(UVarHubData) == 0x000008, "Wrong alignment on UVarHubData");
static_assert(sizeof(UVarHubData) == 0x000040, "Wrong size on UVarHubData");

// Class Dialog.VarLineData
// 0x0000 (0x0040 - 0x0040)
class UVarLineData final : public UVarObjectData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VarLineData">();
	}
	static class UVarLineData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVarLineData>();
	}
};
static_assert(alignof(UVarLineData) == 0x000008, "Wrong alignment on UVarLineData");
static_assert(sizeof(UVarLineData) == 0x000040, "Wrong size on UVarLineData");

// Class Dialog.VarObjectiveData
// 0x0000 (0x0040 - 0x0040)
class UVarObjectiveData final : public UVarObjectData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VarObjectiveData">();
	}
	static class UVarObjectiveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVarObjectiveData>();
	}
};
static_assert(alignof(UVarObjectiveData) == 0x000008, "Wrong alignment on UVarObjectiveData");
static_assert(sizeof(UVarObjectiveData) == 0x000040, "Wrong size on UVarObjectiveData");

// Class Dialog.VarQuestData
// 0x0000 (0x0040 - 0x0040)
class UVarQuestData final : public UVarObjectData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VarQuestData">();
	}
	static class UVarQuestData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVarQuestData>();
	}
};
static_assert(alignof(UVarQuestData) == 0x000008, "Wrong alignment on UVarQuestData");
static_assert(sizeof(UVarQuestData) == 0x000040, "Wrong size on UVarQuestData");

// Class Dialog.DialogLineMovieSceneSection
// 0x0038 (0x0128 - 0x00F0)
class UDialogLineMovieSceneSection final : public UMovieSceneSection
{
public:
	struct FDialogLineMovieSceneParams            _Params;                                           // 0x00F0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogLineMovieSceneSection">();
	}
	static class UDialogLineMovieSceneSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogLineMovieSceneSection>();
	}
};
static_assert(alignof(UDialogLineMovieSceneSection) == 0x000008, "Wrong alignment on UDialogLineMovieSceneSection");
static_assert(sizeof(UDialogLineMovieSceneSection) == 0x000128, "Wrong size on UDialogLineMovieSceneSection");
static_assert(offsetof(UDialogLineMovieSceneSection, _Params) == 0x0000F0, "Member 'UDialogLineMovieSceneSection::_Params' has a wrong offset!");

// Class Dialog.DialogLineMovieSceneTrack
// 0x0018 (0x00B0 - 0x0098)
class UDialogLineMovieSceneTrack final : public UMovieSceneNameableTrack
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             _Sections;                                         // 0x00A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogLineMovieSceneTrack">();
	}
	static class UDialogLineMovieSceneTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogLineMovieSceneTrack>();
	}
};
static_assert(alignof(UDialogLineMovieSceneTrack) == 0x000008, "Wrong alignment on UDialogLineMovieSceneTrack");
static_assert(sizeof(UDialogLineMovieSceneTrack) == 0x0000B0, "Wrong size on UDialogLineMovieSceneTrack");
static_assert(offsetof(UDialogLineMovieSceneTrack, _Sections) == 0x0000A0, "Member 'UDialogLineMovieSceneTrack::_Sections' has a wrong offset!");

// Class Dialog.DialogManager
// 0x01A8 (0x0248 - 0x00A0)
class UDialogManager final : public UActorComponent
{
public:
	class UDialogData*                            _DialogData;                                       // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UDialogSpeaker*>                 _AllSpeakers;                                      // 0x00A8(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TArray<class UDialogSpeaker*>                 _PlayerSpeakers;                                   // 0x00B8(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	class UFlowActionCaller*                      _ActionCaller;                                     // 0x00C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDialogUI*                              _UI;                                               // 0x00D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDialogSubtitles*                       _Subtitles;                                        // 0x00D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ResetOnEnd;                                       // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDialogTalk*>                    _DialogTalks;                                      // 0x00E8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	class UDialogTalk*                            _InteractiveTalk;                                  // 0x00F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UDialogData*>                    _DialogDataList;                                   // 0x0100(0x0010)(Edit, ZeroConstructor, EditConst, SaveGame, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             _OnDialogBegin;                                    // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _OnDialogFinish;                                   // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAnyDialogBegin;                                  // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAnyDialogEnd;                                    // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAnyLineBegin;                                    // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAnyLineEnd;                                      // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class UDialogData*, struct FDataState>   _DialogDataSaveGame;                               // 0x0170(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x28];                                     // 0x01C0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuestData>                     _QuestsData;                                       // 0x01E8(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class UQuest*>                         _Quests;                                           // 0x01F8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _OnQuestBegin;                                     // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _OnQuestFinish;                                    // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _OnObjectiveBegin;                                 // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _OnObjectiveFinish;                                // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddLineSubtitles(int32 Index_0, const struct FDialogLine& Line);
	class UQuest* beginQuest(const struct FQuestID& QuestID);
	void EndDialogTalk(const class UDialogSpeaker* Speaker, const class UDialogTalk* Ignore);
	class UDialogTalk* FindDialogTalk(const struct FDialogObjectID& DialogID);
	class UDialogTalk* FindSpeakerTalk(const class UDialogSpeaker* Speaker);
	void GetActiveQuests(TArray<class UQuest*>* Quests);
	class UDialogTalk* GetInteractiveTalk();
	void RemoveSubtitles(int32 Index_0);
	void SetDialogUI(class UDialogUI* UI);
	void SetVOSpeed(float Pitch);
	void StopTalksWithLowerPriority(uint8 Priority, const class UDialogTalk* Ignore);

	class UQuest* FindQuest(const struct FQuestID& QuestID) const;
	bool HasAnyActiveTalk() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogManager">();
	}
	static class UDialogManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogManager>();
	}
};
static_assert(alignof(UDialogManager) == 0x000008, "Wrong alignment on UDialogManager");
static_assert(sizeof(UDialogManager) == 0x000248, "Wrong size on UDialogManager");
static_assert(offsetof(UDialogManager, _DialogData) == 0x0000A0, "Member 'UDialogManager::_DialogData' has a wrong offset!");
static_assert(offsetof(UDialogManager, _AllSpeakers) == 0x0000A8, "Member 'UDialogManager::_AllSpeakers' has a wrong offset!");
static_assert(offsetof(UDialogManager, _PlayerSpeakers) == 0x0000B8, "Member 'UDialogManager::_PlayerSpeakers' has a wrong offset!");
static_assert(offsetof(UDialogManager, _ActionCaller) == 0x0000C8, "Member 'UDialogManager::_ActionCaller' has a wrong offset!");
static_assert(offsetof(UDialogManager, _UI) == 0x0000D0, "Member 'UDialogManager::_UI' has a wrong offset!");
static_assert(offsetof(UDialogManager, _Subtitles) == 0x0000D8, "Member 'UDialogManager::_Subtitles' has a wrong offset!");
static_assert(offsetof(UDialogManager, _ResetOnEnd) == 0x0000E0, "Member 'UDialogManager::_ResetOnEnd' has a wrong offset!");
static_assert(offsetof(UDialogManager, _DialogTalks) == 0x0000E8, "Member 'UDialogManager::_DialogTalks' has a wrong offset!");
static_assert(offsetof(UDialogManager, _InteractiveTalk) == 0x0000F8, "Member 'UDialogManager::_InteractiveTalk' has a wrong offset!");
static_assert(offsetof(UDialogManager, _DialogDataList) == 0x000100, "Member 'UDialogManager::_DialogDataList' has a wrong offset!");
static_assert(offsetof(UDialogManager, _OnDialogBegin) == 0x000110, "Member 'UDialogManager::_OnDialogBegin' has a wrong offset!");
static_assert(offsetof(UDialogManager, _OnDialogFinish) == 0x000120, "Member 'UDialogManager::_OnDialogFinish' has a wrong offset!");
static_assert(offsetof(UDialogManager, OnAnyDialogBegin) == 0x000130, "Member 'UDialogManager::OnAnyDialogBegin' has a wrong offset!");
static_assert(offsetof(UDialogManager, OnAnyDialogEnd) == 0x000140, "Member 'UDialogManager::OnAnyDialogEnd' has a wrong offset!");
static_assert(offsetof(UDialogManager, OnAnyLineBegin) == 0x000150, "Member 'UDialogManager::OnAnyLineBegin' has a wrong offset!");
static_assert(offsetof(UDialogManager, OnAnyLineEnd) == 0x000160, "Member 'UDialogManager::OnAnyLineEnd' has a wrong offset!");
static_assert(offsetof(UDialogManager, _DialogDataSaveGame) == 0x000170, "Member 'UDialogManager::_DialogDataSaveGame' has a wrong offset!");
static_assert(offsetof(UDialogManager, _QuestsData) == 0x0001E8, "Member 'UDialogManager::_QuestsData' has a wrong offset!");
static_assert(offsetof(UDialogManager, _Quests) == 0x0001F8, "Member 'UDialogManager::_Quests' has a wrong offset!");
static_assert(offsetof(UDialogManager, _OnQuestBegin) == 0x000208, "Member 'UDialogManager::_OnQuestBegin' has a wrong offset!");
static_assert(offsetof(UDialogManager, _OnQuestFinish) == 0x000218, "Member 'UDialogManager::_OnQuestFinish' has a wrong offset!");
static_assert(offsetof(UDialogManager, _OnObjectiveBegin) == 0x000228, "Member 'UDialogManager::_OnObjectiveBegin' has a wrong offset!");
static_assert(offsetof(UDialogManager, _OnObjectiveFinish) == 0x000238, "Member 'UDialogManager::_OnObjectiveFinish' has a wrong offset!");

// Class Dialog.FlowTask
// 0x0028 (0x00C8 - 0x00A0)
class UFlowTask : public UActorComponent
{
public:
	struct FDialogObjectID                        _FlowRef;                                          // 0x00A0(0x0028)(Edit, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const struct FDialogObjectID GetFlowRef() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowTask">();
	}
	static class UFlowTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowTask>();
	}
};
static_assert(alignof(UFlowTask) == 0x000008, "Wrong alignment on UFlowTask");
static_assert(sizeof(UFlowTask) == 0x0000C8, "Wrong size on UFlowTask");
static_assert(offsetof(UFlowTask, _FlowRef) == 0x0000A0, "Member 'UFlowTask::_FlowRef' has a wrong offset!");

// Class Dialog.DialogVariableData
// 0x0008 (0x0030 - 0x0028)
class UDialogVariableData final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogVariableData">();
	}
	static class UDialogVariableData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogVariableData>();
	}
};
static_assert(alignof(UDialogVariableData) == 0x000008, "Wrong alignment on UDialogVariableData");
static_assert(sizeof(UDialogVariableData) == 0x000030, "Wrong size on UDialogVariableData");

// Class Dialog.DialogScriptInterface
// 0x0000 (0x0028 - 0x0028)
class IDialogScriptInterface final : public IInterface
{
public:
	void DialogScript(class UDialogTalk* DialogTalk, uint8 EventType, int32 UserInteger, const class FString& UserString);
	void DialogScriptByTag(const struct FGameplayTag& EventTag, class UDialogTalk* DialogTalk, int32 UserInteger, const class FString& UserString, class UObject* UserAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogScriptInterface">();
	}
	static class IDialogScriptInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDialogScriptInterface>();
	}
};
static_assert(alignof(IDialogScriptInterface) == 0x000008, "Wrong alignment on IDialogScriptInterface");
static_assert(sizeof(IDialogScriptInterface) == 0x000028, "Wrong size on IDialogScriptInterface");

// Class Dialog.DialogSpeaker
// 0x0290 (0x0530 - 0x02A0)
class UDialogSpeaker final : public USceneComponent
{
public:
	struct FDialogEntity                          _Entity;                                           // 0x02A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDialogFullInfo                        _DialogEntry;                                      // 0x02C8(0x0178)(Edit, BlueprintVisible, SaveGame, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         _IsAPlayerSpeaker : 1;                             // 0x0440(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _VoiceOnPad : 1;                                   // 0x0440(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         _IsDisabledByCS : 1;                               // 0x0440(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_441[0x7];                                      // 0x0441(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _VoiceOffset;                                      // 0x0448(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDialogVoiceAttenuation                _VoiceAttenuation;                                 // 0x0460(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDialogEntity>                  _Voices;                                           // 0x0470(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UDialogUI*                              _UI;                                               // 0x0480(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      _VoiceParameters;                                  // 0x0488(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _OnDialogBegin;                                    // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _OnDialogEnd;                                      // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _OnLineBegin;                                      // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _OnLineEnd;                                        // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _OnStartVoicePlayback;                             // 0x0518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_528[0x8];                                      // 0x0528(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddVoiceParameter(class FName Name_0, float Value, float InterpolationTime);
	void PlayTalk(const struct FLatentActionInfo& Info);
	void PlayTalkInEditor();
	void RemoveVoiceParameter(class FName Name_0, float InterpolationTime);
	void SetIsPlayerSpeaker(bool Is);

	bool CanStartTalk() const;
	class USceneComponent* GetCurrentVoice() const;
	float GetDistanceToPlayer() const;
	struct FDialogTalkID GetTalkID() const;
	bool IsPlayerSpeaker() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogSpeaker">();
	}
	static class UDialogSpeaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogSpeaker>();
	}
};
static_assert(alignof(UDialogSpeaker) == 0x000010, "Wrong alignment on UDialogSpeaker");
static_assert(sizeof(UDialogSpeaker) == 0x000530, "Wrong size on UDialogSpeaker");
static_assert(offsetof(UDialogSpeaker, _Entity) == 0x0002A0, "Member 'UDialogSpeaker::_Entity' has a wrong offset!");
static_assert(offsetof(UDialogSpeaker, _DialogEntry) == 0x0002C8, "Member 'UDialogSpeaker::_DialogEntry' has a wrong offset!");
static_assert(offsetof(UDialogSpeaker, _VoiceOffset) == 0x000448, "Member 'UDialogSpeaker::_VoiceOffset' has a wrong offset!");
static_assert(offsetof(UDialogSpeaker, _VoiceAttenuation) == 0x000460, "Member 'UDialogSpeaker::_VoiceAttenuation' has a wrong offset!");
static_assert(offsetof(UDialogSpeaker, _Voices) == 0x000470, "Member 'UDialogSpeaker::_Voices' has a wrong offset!");
static_assert(offsetof(UDialogSpeaker, _UI) == 0x000480, "Member 'UDialogSpeaker::_UI' has a wrong offset!");
static_assert(offsetof(UDialogSpeaker, _VoiceParameters) == 0x000488, "Member 'UDialogSpeaker::_VoiceParameters' has a wrong offset!");
static_assert(offsetof(UDialogSpeaker, _OnDialogBegin) == 0x0004D8, "Member 'UDialogSpeaker::_OnDialogBegin' has a wrong offset!");
static_assert(offsetof(UDialogSpeaker, _OnDialogEnd) == 0x0004E8, "Member 'UDialogSpeaker::_OnDialogEnd' has a wrong offset!");
static_assert(offsetof(UDialogSpeaker, _OnLineBegin) == 0x0004F8, "Member 'UDialogSpeaker::_OnLineBegin' has a wrong offset!");
static_assert(offsetof(UDialogSpeaker, _OnLineEnd) == 0x000508, "Member 'UDialogSpeaker::_OnLineEnd' has a wrong offset!");
static_assert(offsetof(UDialogSpeaker, _OnStartVoicePlayback) == 0x000518, "Member 'UDialogSpeaker::_OnStartVoicePlayback' has a wrong offset!");

// Class Dialog.DialogPlayer
// 0x01A8 (0x0248 - 0x00A0)
class UDialogPlayer final : public UActorComponent
{
public:
	struct FDialogFullInfo                        _DialogEntry;                                      // 0x00A0(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, SaveGame, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         _Speakers;                                         // 0x0218(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _OnDialogBegin;                                    // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _OnDialogEnd;                                      // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class UDialogTalk* PlayTalk();
	void PlayTalkInEditor();

	bool CanStartTalk() const;
	struct FDialogTalkID GetTalkID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogPlayer">();
	}
	static class UDialogPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogPlayer>();
	}
};
static_assert(alignof(UDialogPlayer) == 0x000008, "Wrong alignment on UDialogPlayer");
static_assert(sizeof(UDialogPlayer) == 0x000248, "Wrong size on UDialogPlayer");
static_assert(offsetof(UDialogPlayer, _DialogEntry) == 0x0000A0, "Member 'UDialogPlayer::_DialogEntry' has a wrong offset!");
static_assert(offsetof(UDialogPlayer, _Speakers) == 0x000218, "Member 'UDialogPlayer::_Speakers' has a wrong offset!");
static_assert(offsetof(UDialogPlayer, _OnDialogBegin) == 0x000228, "Member 'UDialogPlayer::_OnDialogBegin' has a wrong offset!");
static_assert(offsetof(UDialogPlayer, _OnDialogEnd) == 0x000238, "Member 'UDialogPlayer::_OnDialogEnd' has a wrong offset!");

// Class Dialog.DialogSubtitles
// 0x0008 (0x00A8 - 0x00A0)
class UDialogSubtitles : public UActorComponent
{
public:
	bool                                          _MarkMissingSpeakers;                              // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _MaxDistance;                                      // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddSubtitle(int32 Index_0, const struct FDialogLine& Line);
	void ChangeVisibility(bool Show);
	class FText GetLocalizedSpeakerName(const struct FDialogEntity& Entity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogSubtitles">();
	}
	static class UDialogSubtitles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogSubtitles>();
	}
};
static_assert(alignof(UDialogSubtitles) == 0x000008, "Wrong alignment on UDialogSubtitles");
static_assert(sizeof(UDialogSubtitles) == 0x0000A8, "Wrong size on UDialogSubtitles");
static_assert(offsetof(UDialogSubtitles, _MarkMissingSpeakers) == 0x0000A0, "Member 'UDialogSubtitles::_MarkMissingSpeakers' has a wrong offset!");
static_assert(offsetof(UDialogSubtitles, _MaxDistance) == 0x0000A4, "Member 'UDialogSubtitles::_MaxDistance' has a wrong offset!");

// Class Dialog.ScriptDialogSubtitles
// 0x0000 (0x00A8 - 0x00A8)
class UScriptDialogSubtitles final : public UDialogSubtitles
{
public:
	void OnAddSubtitle(int32 Index_0, const class FText& Text, const class FText& SpeakerName, const struct FColor& Color, const struct FDialogEntity& Entity);
	void OnChangeVisibility(bool Show);
	void OnClearSubtitles();
	void OnRemoveSubtitle(int32 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptDialogSubtitles">();
	}
	static class UScriptDialogSubtitles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptDialogSubtitles>();
	}
};
static_assert(alignof(UScriptDialogSubtitles) == 0x000008, "Wrong alignment on UScriptDialogSubtitles");
static_assert(sizeof(UScriptDialogSubtitles) == 0x0000A8, "Wrong size on UScriptDialogSubtitles");

// Class Dialog.DialogTalk
// 0x02C0 (0x0388 - 0x00C8)
class UDialogTalk final : public UFlowTask
{
public:
	TArray<class AActor*>                         _Speakers;                                         // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class UDialogSpeaker*                         _CurrentSpeaker;                                   // 0x00D8(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        _CurrentVoiceOver;                                 // 0x00E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _ActiveDialog;                                     // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _CurrentLine;                                      // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDialogLineLocalization                _CurrentLineLocalization;                          // 0x00F0(0x00A8)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FDialogVoiceAttenuation                _CurrentVoiceAttenuation;                          // 0x0198(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         _PauseAfterLine;                                   // 0x01A4(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _TimeToDistanceCheck;                              // 0x01A8(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETalkState                                    _State;                                            // 0x01AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoiceState                                   _VoiceState;                                       // 0x01AD(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AE[0x2];                                      // 0x01AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _AutoDestroy;                                      // 0x01B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDialogInfo                            _DialogInfo;                                       // 0x01B8(0x00C8)(Edit, BlueprintVisible, DisableEditOnTemplate, ContainsInstancedReference, ExposeOnSpawn, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _OnDialogFinished;                                 // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x18];                                     // 0x0290(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDialogData*                            _DialogData;                                       // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDialogUI*                              _UI;                                               // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _MaxDistance;                                      // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _DistanceCheckPeriod;                              // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FDialogEntity, class UDialogSpeaker*> _Entities;                                         // 0x02C0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UDialogTalk*                            _ParentTalk;                                       // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDialogTalk*                            _SubTalk;                                          // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDialogChoiceObserver*                  _ChoiceObserver;                                   // 0x0320(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObject*                                _LoadedVO;                                         // 0x0328(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x58];                                     // 0x0330(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Choose(int32 Choice, bool EndIfFail);
	void OnAkPostEventCallback(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);
	void OnSubTalkFinished(bool Completed);
	void Pause();
	bool PlayLine(const struct FDialogLine& DialogLineID, class UObject* WorldContext);
	bool PlayTalk(const struct FDialogDialog& DialogID, class UObject* WorldContext);
	bool PlayTalkFromLine(const struct FDialogLine& DialogLineID, class UObject* WorldContext);
	void Resume();
	bool Skip();
	void Stop(class UObject* WorldContext);
	void Suspend();
	void UpdateChoices();

	class UDialogSpeaker* FindNonPlayerSpeaker() const;
	class UDialogSpeaker* FindPlayerSpeaker() const;
	class UDialogSpeaker* FindSpeaker(const struct FDialogEntity& SpeakerID) const;
	void GetAllSpeakers(TArray<class UDialogSpeaker*>* Speakers) const;
	class UDialogSpeaker* GetCurrentSpeaker() const;
	uint8 GetPriority() const;
	struct FDialogLine GetResumeableLine() const;
	bool HasSpeaker(const class UDialogSpeaker* Speaker) const;
	bool IsFinished() const;
	bool IsFinishedOrSuspended() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogTalk">();
	}
	static class UDialogTalk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogTalk>();
	}
};
static_assert(alignof(UDialogTalk) == 0x000008, "Wrong alignment on UDialogTalk");
static_assert(sizeof(UDialogTalk) == 0x000388, "Wrong size on UDialogTalk");
static_assert(offsetof(UDialogTalk, _Speakers) == 0x0000C8, "Member 'UDialogTalk::_Speakers' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _CurrentSpeaker) == 0x0000D8, "Member 'UDialogTalk::_CurrentSpeaker' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _CurrentVoiceOver) == 0x0000E0, "Member 'UDialogTalk::_CurrentVoiceOver' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _ActiveDialog) == 0x0000E8, "Member 'UDialogTalk::_ActiveDialog' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _CurrentLine) == 0x0000EC, "Member 'UDialogTalk::_CurrentLine' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _CurrentLineLocalization) == 0x0000F0, "Member 'UDialogTalk::_CurrentLineLocalization' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _CurrentVoiceAttenuation) == 0x000198, "Member 'UDialogTalk::_CurrentVoiceAttenuation' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _PauseAfterLine) == 0x0001A4, "Member 'UDialogTalk::_PauseAfterLine' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _TimeToDistanceCheck) == 0x0001A8, "Member 'UDialogTalk::_TimeToDistanceCheck' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _State) == 0x0001AC, "Member 'UDialogTalk::_State' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _VoiceState) == 0x0001AD, "Member 'UDialogTalk::_VoiceState' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _AutoDestroy) == 0x0001B0, "Member 'UDialogTalk::_AutoDestroy' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _DialogInfo) == 0x0001B8, "Member 'UDialogTalk::_DialogInfo' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _OnDialogFinished) == 0x000280, "Member 'UDialogTalk::_OnDialogFinished' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _DialogData) == 0x0002A8, "Member 'UDialogTalk::_DialogData' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _UI) == 0x0002B0, "Member 'UDialogTalk::_UI' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _MaxDistance) == 0x0002B8, "Member 'UDialogTalk::_MaxDistance' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _DistanceCheckPeriod) == 0x0002BC, "Member 'UDialogTalk::_DistanceCheckPeriod' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _Entities) == 0x0002C0, "Member 'UDialogTalk::_Entities' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _ParentTalk) == 0x000310, "Member 'UDialogTalk::_ParentTalk' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _SubTalk) == 0x000318, "Member 'UDialogTalk::_SubTalk' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _ChoiceObserver) == 0x000320, "Member 'UDialogTalk::_ChoiceObserver' has a wrong offset!");
static_assert(offsetof(UDialogTalk, _LoadedVO) == 0x000328, "Member 'UDialogTalk::_LoadedVO' has a wrong offset!");

// Class Dialog.DialogUI
// 0x0008 (0x00A8 - 0x00A0)
class UDialogUI : public UActorComponent
{
public:
	class UDialogTalk*                            _DialogTalk;                                       // 0x00A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogUI">();
	}
	static class UDialogUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogUI>();
	}
};
static_assert(alignof(UDialogUI) == 0x000008, "Wrong alignment on UDialogUI");
static_assert(sizeof(UDialogUI) == 0x0000A8, "Wrong size on UDialogUI");
static_assert(offsetof(UDialogUI, _DialogTalk) == 0x0000A0, "Member 'UDialogUI::_DialogTalk' has a wrong offset!");

// Class Dialog.ScriptDialogUI
// 0x0000 (0x00A8 - 0x00A8)
class UScriptDialogUI final : public UDialogUI
{
public:
	void OnAddChoice(const class FText& Text, const class UFlowDialogLine* Line);
	void OnBeginDialog();
	void OnDialogLine(const class FText& Text, const class UFlowDialogLine* Line);
	void OnEndDialog();
	void OnPause();
	void OnReset();
	void OnStartChoiceTimer();
	void OnUnpause();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptDialogUI">();
	}
	static class UScriptDialogUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptDialogUI>();
	}
};
static_assert(alignof(UScriptDialogUI) == 0x000008, "Wrong alignment on UScriptDialogUI");
static_assert(sizeof(UScriptDialogUI) == 0x0000A8, "Wrong size on UScriptDialogUI");

// Class Dialog.BlairwitchDialogVoices
// 0x0000 (0x0168 - 0x0168)
class UBlairwitchDialogVoices final : public UDialogDefaultVoices
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlairwitchDialogVoices">();
	}
	static class UBlairwitchDialogVoices* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlairwitchDialogVoices>();
	}
};
static_assert(alignof(UBlairwitchDialogVoices) == 0x000008, "Wrong alignment on UBlairwitchDialogVoices");
static_assert(sizeof(UBlairwitchDialogVoices) == 0x000168, "Wrong size on UBlairwitchDialogVoices");

// Class Dialog.WwiseDialogVoices
// 0x0178 (0x01A8 - 0x0030)
class UWwiseDialogVoices final : public UDialogVoices
{
public:
	uint8                                         Pad_30[0xE8];                                      // 0x0030(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _LineTextLen;                                      // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _ObjectPath;                                       // 0x0120(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _WEventPath;                                       // 0x0130(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _UEventPath;                                       // 0x0140(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          _WaveEvent;                                        // 0x0150(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UFlowDialogLine*, class UObject*>  _PreloadedVoiceOvers;                              // 0x0158(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WwiseDialogVoices">();
	}
	static class UWwiseDialogVoices* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWwiseDialogVoices>();
	}
};
static_assert(alignof(UWwiseDialogVoices) == 0x000008, "Wrong alignment on UWwiseDialogVoices");
static_assert(sizeof(UWwiseDialogVoices) == 0x0001A8, "Wrong size on UWwiseDialogVoices");
static_assert(offsetof(UWwiseDialogVoices, _LineTextLen) == 0x000118, "Member 'UWwiseDialogVoices::_LineTextLen' has a wrong offset!");
static_assert(offsetof(UWwiseDialogVoices, _ObjectPath) == 0x000120, "Member 'UWwiseDialogVoices::_ObjectPath' has a wrong offset!");
static_assert(offsetof(UWwiseDialogVoices, _WEventPath) == 0x000130, "Member 'UWwiseDialogVoices::_WEventPath' has a wrong offset!");
static_assert(offsetof(UWwiseDialogVoices, _UEventPath) == 0x000140, "Member 'UWwiseDialogVoices::_UEventPath' has a wrong offset!");
static_assert(offsetof(UWwiseDialogVoices, _WaveEvent) == 0x000150, "Member 'UWwiseDialogVoices::_WaveEvent' has a wrong offset!");
static_assert(offsetof(UWwiseDialogVoices, _PreloadedVoiceOvers) == 0x000158, "Member 'UWwiseDialogVoices::_PreloadedVoiceOvers' has a wrong offset!");

// Class Dialog.ScriptFlowAction
// 0x0000 (0x00C8 - 0x00C8)
class UScriptFlowAction final : public UFlowAction
{
public:
	void ScriptPerform(class UObject* Context);
	void ScriptStop(class UObject* Context);
	void ScriptTick(class UObject* Context);

	class FString ScriptToString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptFlowAction">();
	}
	static class UScriptFlowAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptFlowAction>();
	}
};
static_assert(alignof(UScriptFlowAction) == 0x000008, "Wrong alignment on UScriptFlowAction");
static_assert(sizeof(UScriptFlowAction) == 0x0000C8, "Wrong size on UScriptFlowAction");

// Class Dialog.FlowActionCaller
// 0x0020 (0x00C0 - 0x00A0)
class UFlowActionCaller final : public UActorComponent
{
public:
	TArray<struct FDelayedFlowAction>             _DelayedActions;                                   // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FRunningFlowAction>             _RunningActions;                                   // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowActionCaller">();
	}
	static class UFlowActionCaller* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowActionCaller>();
	}
};
static_assert(alignof(UFlowActionCaller) == 0x000008, "Wrong alignment on UFlowActionCaller");
static_assert(sizeof(UFlowActionCaller) == 0x0000C0, "Wrong size on UFlowActionCaller");
static_assert(offsetof(UFlowActionCaller, _DelayedActions) == 0x0000A0, "Member 'UFlowActionCaller::_DelayedActions' has a wrong offset!");
static_assert(offsetof(UFlowActionCaller, _RunningActions) == 0x0000B0, "Member 'UFlowActionCaller::_RunningActions' has a wrong offset!");

// Class Dialog.StopAnimationFA
// 0x0098 (0x0160 - 0x00C8)
class UStopAnimationFA final : public UFlowAction
{
public:
	struct FDaiContext                            _Performer;                                        // 0x00C8(0x0080)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   _ComponentTag;                                     // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _SlotName;                                         // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _BlendOutTime;                                     // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StopAnimationFA">();
	}
	static class UStopAnimationFA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStopAnimationFA>();
	}
};
static_assert(alignof(UStopAnimationFA) == 0x000008, "Wrong alignment on UStopAnimationFA");
static_assert(sizeof(UStopAnimationFA) == 0x000160, "Wrong size on UStopAnimationFA");
static_assert(offsetof(UStopAnimationFA, _Performer) == 0x0000C8, "Member 'UStopAnimationFA::_Performer' has a wrong offset!");
static_assert(offsetof(UStopAnimationFA, _ComponentTag) == 0x000148, "Member 'UStopAnimationFA::_ComponentTag' has a wrong offset!");
static_assert(offsetof(UStopAnimationFA, _SlotName) == 0x000150, "Member 'UStopAnimationFA::_SlotName' has a wrong offset!");
static_assert(offsetof(UStopAnimationFA, _BlendOutTime) == 0x000158, "Member 'UStopAnimationFA::_BlendOutTime' has a wrong offset!");

// Class Dialog.CallDialogEventFA
// 0x00A8 (0x0170 - 0x00C8)
class UCallDialogEventFA final : public UFlowAction
{
public:
	struct FDaiContext                            _Performer;                                        // 0x00C8(0x0080)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTag                           _UserTag;                                          // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _UserString;                                       // 0x0150(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _UserInteger;                                      // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                _UserAsset;                                        // 0x0168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CallDialogEventFA">();
	}
	static class UCallDialogEventFA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCallDialogEventFA>();
	}
};
static_assert(alignof(UCallDialogEventFA) == 0x000008, "Wrong alignment on UCallDialogEventFA");
static_assert(sizeof(UCallDialogEventFA) == 0x000170, "Wrong size on UCallDialogEventFA");
static_assert(offsetof(UCallDialogEventFA, _Performer) == 0x0000C8, "Member 'UCallDialogEventFA::_Performer' has a wrong offset!");
static_assert(offsetof(UCallDialogEventFA, _UserTag) == 0x000148, "Member 'UCallDialogEventFA::_UserTag' has a wrong offset!");
static_assert(offsetof(UCallDialogEventFA, _UserString) == 0x000150, "Member 'UCallDialogEventFA::_UserString' has a wrong offset!");
static_assert(offsetof(UCallDialogEventFA, _UserInteger) == 0x000160, "Member 'UCallDialogEventFA::_UserInteger' has a wrong offset!");
static_assert(offsetof(UCallDialogEventFA, _UserAsset) == 0x000168, "Member 'UCallDialogEventFA::_UserAsset' has a wrong offset!");

// Class Dialog.CallQuestEventFA
// 0x00A0 (0x0168 - 0x00C8)
class UCallQuestEventFA final : public UFlowAction
{
public:
	struct FDaiContext                            _Performer;                                        // 0x00C8(0x0080)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTag                           _UserTag;                                          // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _UserString;                                       // 0x0150(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _UserInteger;                                      // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CallQuestEventFA">();
	}
	static class UCallQuestEventFA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCallQuestEventFA>();
	}
};
static_assert(alignof(UCallQuestEventFA) == 0x000008, "Wrong alignment on UCallQuestEventFA");
static_assert(sizeof(UCallQuestEventFA) == 0x000168, "Wrong size on UCallQuestEventFA");
static_assert(offsetof(UCallQuestEventFA, _Performer) == 0x0000C8, "Member 'UCallQuestEventFA::_Performer' has a wrong offset!");
static_assert(offsetof(UCallQuestEventFA, _UserTag) == 0x000148, "Member 'UCallQuestEventFA::_UserTag' has a wrong offset!");
static_assert(offsetof(UCallQuestEventFA, _UserString) == 0x000150, "Member 'UCallQuestEventFA::_UserString' has a wrong offset!");
static_assert(offsetof(UCallQuestEventFA, _UserInteger) == 0x000160, "Member 'UCallQuestEventFA::_UserInteger' has a wrong offset!");

// Class Dialog.CallNotifyFA
// 0x0008 (0x00D0 - 0x00C8)
class UCallNotifyFA final : public UFlowAction
{
public:
	class UDaiNotify*                             _Notify;                                           // 0x00C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CallNotifyFA">();
	}
	static class UCallNotifyFA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCallNotifyFA>();
	}
};
static_assert(alignof(UCallNotifyFA) == 0x000008, "Wrong alignment on UCallNotifyFA");
static_assert(sizeof(UCallNotifyFA) == 0x0000D0, "Wrong size on UCallNotifyFA");
static_assert(offsetof(UCallNotifyFA, _Notify) == 0x0000C8, "Member 'UCallNotifyFA::_Notify' has a wrong offset!");

// Class Dialog.ChangeFlowBooleanFA
// 0x0020 (0x00E8 - 0x00C8)
class UChangeFlowBooleanFA final : public UFlowAction
{
public:
	struct FFlowBoolean                           _FlowGlobalID;                                     // 0x00C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	EBooleanFlowOperation2                        _Operation;                                        // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Value;                                            // 0x00E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeFlowBooleanFA">();
	}
	static class UChangeFlowBooleanFA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeFlowBooleanFA>();
	}
};
static_assert(alignof(UChangeFlowBooleanFA) == 0x000008, "Wrong alignment on UChangeFlowBooleanFA");
static_assert(sizeof(UChangeFlowBooleanFA) == 0x0000E8, "Wrong size on UChangeFlowBooleanFA");
static_assert(offsetof(UChangeFlowBooleanFA, _FlowGlobalID) == 0x0000C8, "Member 'UChangeFlowBooleanFA::_FlowGlobalID' has a wrong offset!");
static_assert(offsetof(UChangeFlowBooleanFA, _Operation) == 0x0000E0, "Member 'UChangeFlowBooleanFA::_Operation' has a wrong offset!");
static_assert(offsetof(UChangeFlowBooleanFA, _Value) == 0x0000E1, "Member 'UChangeFlowBooleanFA::_Value' has a wrong offset!");

// Class Dialog.ChangeFlowIntegerFA
// 0x0020 (0x00E8 - 0x00C8)
class UChangeFlowIntegerFA final : public UFlowAction
{
public:
	struct FFlowInteger                           _FlowGlobalID;                                     // 0x00C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	EIntegerFlowOperation2                        _Operation;                                        // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _Value;                                            // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeFlowIntegerFA">();
	}
	static class UChangeFlowIntegerFA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeFlowIntegerFA>();
	}
};
static_assert(alignof(UChangeFlowIntegerFA) == 0x000008, "Wrong alignment on UChangeFlowIntegerFA");
static_assert(sizeof(UChangeFlowIntegerFA) == 0x0000E8, "Wrong size on UChangeFlowIntegerFA");
static_assert(offsetof(UChangeFlowIntegerFA, _FlowGlobalID) == 0x0000C8, "Member 'UChangeFlowIntegerFA::_FlowGlobalID' has a wrong offset!");
static_assert(offsetof(UChangeFlowIntegerFA, _Operation) == 0x0000E0, "Member 'UChangeFlowIntegerFA::_Operation' has a wrong offset!");
static_assert(offsetof(UChangeFlowIntegerFA, _Value) == 0x0000E4, "Member 'UChangeFlowIntegerFA::_Value' has a wrong offset!");

// Class Dialog.PlaySoundFA
// 0x0028 (0x00F0 - 0x00C8)
class UPlaySoundFA final : public UFlowAction
{
public:
	struct FSoftObjectPath                        _SoundAsset;                                       // 0x00C8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _ComponentTag;                                     // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaySoundFA">();
	}
	static class UPlaySoundFA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaySoundFA>();
	}
};
static_assert(alignof(UPlaySoundFA) == 0x000008, "Wrong alignment on UPlaySoundFA");
static_assert(sizeof(UPlaySoundFA) == 0x0000F0, "Wrong size on UPlaySoundFA");
static_assert(offsetof(UPlaySoundFA, _SoundAsset) == 0x0000C8, "Member 'UPlaySoundFA::_SoundAsset' has a wrong offset!");
static_assert(offsetof(UPlaySoundFA, _ComponentTag) == 0x0000E8, "Member 'UPlaySoundFA::_ComponentTag' has a wrong offset!");

// Class Dialog.StopSoundFA
// 0x0028 (0x00F0 - 0x00C8)
class UStopSoundFA final : public UFlowAction
{
public:
	struct FSoftObjectPath                        _SoundAsset;                                       // 0x00C8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _ComponentTag;                                     // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StopSoundFA">();
	}
	static class UStopSoundFA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStopSoundFA>();
	}
};
static_assert(alignof(UStopSoundFA) == 0x000008, "Wrong alignment on UStopSoundFA");
static_assert(sizeof(UStopSoundFA) == 0x0000F0, "Wrong size on UStopSoundFA");
static_assert(offsetof(UStopSoundFA, _SoundAsset) == 0x0000C8, "Member 'UStopSoundFA::_SoundAsset' has a wrong offset!");
static_assert(offsetof(UStopSoundFA, _ComponentTag) == 0x0000E8, "Member 'UStopSoundFA::_ComponentTag' has a wrong offset!");

// Class Dialog.ChangeTagFA
// 0x0090 (0x0158 - 0x00C8)
class UChangeTagFA final : public UFlowAction
{
public:
	struct FDaiContext                            _Performer;                                        // 0x00C8(0x0080)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ETagOperation2                                _Operation;                                        // 0x0148(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _Tag;                                              // 0x014C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeTagFA">();
	}
	static class UChangeTagFA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeTagFA>();
	}
};
static_assert(alignof(UChangeTagFA) == 0x000008, "Wrong alignment on UChangeTagFA");
static_assert(sizeof(UChangeTagFA) == 0x000158, "Wrong size on UChangeTagFA");
static_assert(offsetof(UChangeTagFA, _Performer) == 0x0000C8, "Member 'UChangeTagFA::_Performer' has a wrong offset!");
static_assert(offsetof(UChangeTagFA, _Operation) == 0x000148, "Member 'UChangeTagFA::_Operation' has a wrong offset!");
static_assert(offsetof(UChangeTagFA, _Tag) == 0x00014C, "Member 'UChangeTagFA::_Tag' has a wrong offset!");

// Class Dialog.AddTagToActorFA
// 0x0010 (0x00D8 - 0x00C8)
class UAddTagToActorFA final : public UFlowAction
{
public:
	class FName                                   _TagToAdd;                                         // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _Unique;                                           // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddTagToActorFA">();
	}
	static class UAddTagToActorFA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddTagToActorFA>();
	}
};
static_assert(alignof(UAddTagToActorFA) == 0x000008, "Wrong alignment on UAddTagToActorFA");
static_assert(sizeof(UAddTagToActorFA) == 0x0000D8, "Wrong size on UAddTagToActorFA");
static_assert(offsetof(UAddTagToActorFA, _TagToAdd) == 0x0000C8, "Member 'UAddTagToActorFA::_TagToAdd' has a wrong offset!");
static_assert(offsetof(UAddTagToActorFA, _Unique) == 0x0000D0, "Member 'UAddTagToActorFA::_Unique' has a wrong offset!");

// Class Dialog.InterruptTalksFA
// 0x0008 (0x00D0 - 0x00C8)
class UInterruptTalksFA final : public UFlowAction
{
public:
	uint8                                         _Priority;                                         // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ExcludeCaller;                                    // 0x00C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterruptTalksFA">();
	}
	static class UInterruptTalksFA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterruptTalksFA>();
	}
};
static_assert(alignof(UInterruptTalksFA) == 0x000008, "Wrong alignment on UInterruptTalksFA");
static_assert(sizeof(UInterruptTalksFA) == 0x0000D0, "Wrong size on UInterruptTalksFA");
static_assert(offsetof(UInterruptTalksFA, _Priority) == 0x0000C8, "Member 'UInterruptTalksFA::_Priority' has a wrong offset!");
static_assert(offsetof(UInterruptTalksFA, _ExcludeCaller) == 0x0000C9, "Member 'UInterruptTalksFA::_ExcludeCaller' has a wrong offset!");

// Class Dialog.IncCallCounterFA
// 0x0000 (0x00C8 - 0x00C8)
class UIncCallCounterFA final : public UFlowAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IncCallCounterFA">();
	}
	static class UIncCallCounterFA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIncCallCounterFA>();
	}
};
static_assert(alignof(UIncCallCounterFA) == 0x000008, "Wrong alignment on UIncCallCounterFA");
static_assert(sizeof(UIncCallCounterFA) == 0x0000C8, "Wrong size on UIncCallCounterFA");

// Class Dialog.TextDisruptionFA
// 0x0010 (0x00D8 - 0x00C8)
class UTextDisruptionFA final : public UFlowAction
{
public:
	float                                         _EnableDistance;                                   // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _FullDistance;                                     // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Period;                                           // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextDisruptionFA">();
	}
	static class UTextDisruptionFA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextDisruptionFA>();
	}
};
static_assert(alignof(UTextDisruptionFA) == 0x000008, "Wrong alignment on UTextDisruptionFA");
static_assert(sizeof(UTextDisruptionFA) == 0x0000D8, "Wrong size on UTextDisruptionFA");
static_assert(offsetof(UTextDisruptionFA, _EnableDistance) == 0x0000C8, "Member 'UTextDisruptionFA::_EnableDistance' has a wrong offset!");
static_assert(offsetof(UTextDisruptionFA, _FullDistance) == 0x0000CC, "Member 'UTextDisruptionFA::_FullDistance' has a wrong offset!");
static_assert(offsetof(UTextDisruptionFA, _Period) == 0x0000D0, "Member 'UTextDisruptionFA::_Period' has a wrong offset!");

// Class Dialog.FlowBaseGraph
// 0x0000 (0x0060 - 0x0060)
class UFlowBaseGraph final : public UEdGraph
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowBaseGraph">();
	}
	static class UFlowBaseGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowBaseGraph>();
	}
};
static_assert(alignof(UFlowBaseGraph) == 0x000008, "Wrong alignment on UFlowBaseGraph");
static_assert(sizeof(UFlowBaseGraph) == 0x000060, "Wrong size on UFlowBaseGraph");

// Class Dialog.FlowAsset
// 0x01B0 (0x01D8 - 0x0028)
class UFlowAsset final : public UObject
{
public:
	struct FDialogObjectID                        _FlowRef;                                          // 0x0028(0x0028)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDialogObjectID>                _Connections;                                      // 0x0050(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FFlowPin>                       _Pins;                                             // 0x0060(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class FString                                 _CopyPaste;                                        // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _MovedAcionsToItem;                                // 0x0090(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UFlowItem*>                 _FlowItems;                                        // 0x0098(0x0050)(Edit, ExportObject, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<int32, class UVarObjectData*>            _PrototypeData;                                    // 0x00E8(0x0050)(Edit, ExportObject, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<int32, class UVarObjectData*>            _InstanceData;                                     // 0x0138(0x0050)(Edit, ExportObject, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UFlowAsset*>                     _AssetsToRemove;                                   // 0x0188(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x10];                                     // 0x0198(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFlowAsset*>                     _AssetsToRevert;                                   // 0x01A8(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B8[0x10];                                     // 0x01B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                _OuterOfSource;                                    // 0x01C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFlowAsset*                             _ParentOfSource;                                   // 0x01D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowAsset">();
	}
	static class UFlowAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowAsset>();
	}
};
static_assert(alignof(UFlowAsset) == 0x000008, "Wrong alignment on UFlowAsset");
static_assert(sizeof(UFlowAsset) == 0x0001D8, "Wrong size on UFlowAsset");
static_assert(offsetof(UFlowAsset, _FlowRef) == 0x000028, "Member 'UFlowAsset::_FlowRef' has a wrong offset!");
static_assert(offsetof(UFlowAsset, _Connections) == 0x000050, "Member 'UFlowAsset::_Connections' has a wrong offset!");
static_assert(offsetof(UFlowAsset, _Pins) == 0x000060, "Member 'UFlowAsset::_Pins' has a wrong offset!");
static_assert(offsetof(UFlowAsset, _CopyPaste) == 0x000070, "Member 'UFlowAsset::_CopyPaste' has a wrong offset!");
static_assert(offsetof(UFlowAsset, _MovedAcionsToItem) == 0x000090, "Member 'UFlowAsset::_MovedAcionsToItem' has a wrong offset!");
static_assert(offsetof(UFlowAsset, _FlowItems) == 0x000098, "Member 'UFlowAsset::_FlowItems' has a wrong offset!");
static_assert(offsetof(UFlowAsset, _PrototypeData) == 0x0000E8, "Member 'UFlowAsset::_PrototypeData' has a wrong offset!");
static_assert(offsetof(UFlowAsset, _InstanceData) == 0x000138, "Member 'UFlowAsset::_InstanceData' has a wrong offset!");
static_assert(offsetof(UFlowAsset, _AssetsToRemove) == 0x000188, "Member 'UFlowAsset::_AssetsToRemove' has a wrong offset!");
static_assert(offsetof(UFlowAsset, _AssetsToRevert) == 0x0001A8, "Member 'UFlowAsset::_AssetsToRevert' has a wrong offset!");
static_assert(offsetof(UFlowAsset, _OuterOfSource) == 0x0001C8, "Member 'UFlowAsset::_OuterOfSource' has a wrong offset!");
static_assert(offsetof(UFlowAsset, _ParentOfSource) == 0x0001D0, "Member 'UFlowAsset::_ParentOfSource' has a wrong offset!");

// Class Dialog.ScriptFlowCondition
// 0x0000 (0x0088 - 0x0088)
class UScriptFlowCondition final : public UScriptDaiCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptFlowCondition">();
	}
	static class UScriptFlowCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptFlowCondition>();
	}
};
static_assert(alignof(UScriptFlowCondition) == 0x000008, "Wrong alignment on UScriptFlowCondition");
static_assert(sizeof(UScriptFlowCondition) == 0x000088, "Wrong size on UScriptFlowCondition");

// Class Dialog.BooleanFlowCondition
// 0x0020 (0x00A8 - 0x0088)
class UBooleanFlowCondition final : public UDaiCondition
{
public:
	struct FFlowBoolean                           _Key;                                              // 0x0088(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	EBooleanFlowOperation                         _Operation;                                        // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BooleanFlowCondition">();
	}
	static class UBooleanFlowCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBooleanFlowCondition>();
	}
};
static_assert(alignof(UBooleanFlowCondition) == 0x000008, "Wrong alignment on UBooleanFlowCondition");
static_assert(sizeof(UBooleanFlowCondition) == 0x0000A8, "Wrong size on UBooleanFlowCondition");
static_assert(offsetof(UBooleanFlowCondition, _Key) == 0x000088, "Member 'UBooleanFlowCondition::_Key' has a wrong offset!");
static_assert(offsetof(UBooleanFlowCondition, _Operation) == 0x0000A0, "Member 'UBooleanFlowCondition::_Operation' has a wrong offset!");

// Class Dialog.IntegerFlowCondition
// 0x0020 (0x00A8 - 0x0088)
class UIntegerFlowCondition final : public UDaiCondition
{
public:
	struct FFlowInteger                           _Key;                                              // 0x0088(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	EIntegerFlowOperation                         _Operation;                                        // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _Value;                                            // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IntegerFlowCondition">();
	}
	static class UIntegerFlowCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIntegerFlowCondition>();
	}
};
static_assert(alignof(UIntegerFlowCondition) == 0x000008, "Wrong alignment on UIntegerFlowCondition");
static_assert(sizeof(UIntegerFlowCondition) == 0x0000A8, "Wrong size on UIntegerFlowCondition");
static_assert(offsetof(UIntegerFlowCondition, _Key) == 0x000088, "Member 'UIntegerFlowCondition::_Key' has a wrong offset!");
static_assert(offsetof(UIntegerFlowCondition, _Operation) == 0x0000A0, "Member 'UIntegerFlowCondition::_Operation' has a wrong offset!");
static_assert(offsetof(UIntegerFlowCondition, _Value) == 0x0000A4, "Member 'UIntegerFlowCondition::_Value' has a wrong offset!");

// Class Dialog.CheckCallCounter
// 0x0030 (0x00B8 - 0x0088)
class UCheckCallCounter final : public UDaiCondition
{
public:
	struct FDialogObjectID                        _Key;                                              // 0x0088(0x0028)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ENumberCompareOperation                       _Operation;                                        // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _Value;                                            // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheckCallCounter">();
	}
	static class UCheckCallCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheckCallCounter>();
	}
};
static_assert(alignof(UCheckCallCounter) == 0x000008, "Wrong alignment on UCheckCallCounter");
static_assert(sizeof(UCheckCallCounter) == 0x0000B8, "Wrong size on UCheckCallCounter");
static_assert(offsetof(UCheckCallCounter, _Key) == 0x000088, "Member 'UCheckCallCounter::_Key' has a wrong offset!");
static_assert(offsetof(UCheckCallCounter, _Operation) == 0x0000B0, "Member 'UCheckCallCounter::_Operation' has a wrong offset!");
static_assert(offsetof(UCheckCallCounter, _Value) == 0x0000B4, "Member 'UCheckCallCounter::_Value' has a wrong offset!");

// Class Dialog.ProvideSpeaker
// 0x0030 (0x00A0 - 0x0070)
class UProvideSpeaker final : public UDaiContextGetter
{
public:
	bool                                          _DirectSet;                                        // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDialogEntity                          _Entity;                                           // 0x0078(0x0028)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProvideSpeaker">();
	}
	static class UProvideSpeaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProvideSpeaker>();
	}
};
static_assert(alignof(UProvideSpeaker) == 0x000008, "Wrong alignment on UProvideSpeaker");
static_assert(sizeof(UProvideSpeaker) == 0x0000A0, "Wrong size on UProvideSpeaker");
static_assert(offsetof(UProvideSpeaker, _DirectSet) == 0x000070, "Member 'UProvideSpeaker::_DirectSet' has a wrong offset!");
static_assert(offsetof(UProvideSpeaker, _Entity) == 0x000078, "Member 'UProvideSpeaker::_Entity' has a wrong offset!");

// Class Dialog.FlowDebugger
// 0x00B8 (0x00E0 - 0x0028)
class UFlowDebugger final : public UObject
{
public:
	class UDialogData*                            _DialogData;                                       // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFlowTask*>                      _Runtime;                                          // 0x0030(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<struct FDialogObjectID, bool>            _Breakpoints;                                      // 0x0040(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FDialogGlobals                         _DialogGlobals;                                    // 0x0090(0x0010)(Edit, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x40];                                      // 0x00A0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowDebugger">();
	}
	static class UFlowDebugger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowDebugger>();
	}
};
static_assert(alignof(UFlowDebugger) == 0x000008, "Wrong alignment on UFlowDebugger");
static_assert(sizeof(UFlowDebugger) == 0x0000E0, "Wrong size on UFlowDebugger");
static_assert(offsetof(UFlowDebugger, _DialogData) == 0x000028, "Member 'UFlowDebugger::_DialogData' has a wrong offset!");
static_assert(offsetof(UFlowDebugger, _Runtime) == 0x000030, "Member 'UFlowDebugger::_Runtime' has a wrong offset!");
static_assert(offsetof(UFlowDebugger, _Breakpoints) == 0x000040, "Member 'UFlowDebugger::_Breakpoints' has a wrong offset!");
static_assert(offsetof(UFlowDebugger, _DialogGlobals) == 0x000090, "Member 'UFlowDebugger::_DialogGlobals' has a wrong offset!");

// Class Dialog.FlowSettings
// 0x0080 (0x00B8 - 0x0038)
class UFlowSettings final : public UDeveloperSettings
{
public:
	class UDialogData*                            _CachedData;                                       // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        _DefaultData;                                      // 0x0040(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDialogChoiceSequenceObserver> _ChoiceObserver;                                   // 0x0060(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     _PlayerClass;                                      // 0x0068(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _PreloadVoices;                                    // 0x0070(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _DefaultDelayAfterLine;                            // 0x0074(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _DistanceCheckPeriod;                              // 0x0078(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _PlayMaxDistance;                                  // 0x007C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         _DefaultInterruptPriority;                         // 0x0080(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _MarkUntranslatedTexts;                            // 0x0081(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFlowDialogTemplate>        _DialogTemplate;                                   // 0x0088(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFlowEntityTemplate>        _EntityTemplate;                                   // 0x0090(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFlowHubTemplate>           _HubTemplate;                                      // 0x0098(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFlowLineTemplate>          _LineTemplate;                                     // 0x00A0(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFlowObjectiveTemplate>     _ObjectiveTemplate;                                // 0x00A8(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFlowQuestTemplate>         _QuestTemplate;                                    // 0x00B0(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowSettings">();
	}
	static class UFlowSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowSettings>();
	}
};
static_assert(alignof(UFlowSettings) == 0x000008, "Wrong alignment on UFlowSettings");
static_assert(sizeof(UFlowSettings) == 0x0000B8, "Wrong size on UFlowSettings");
static_assert(offsetof(UFlowSettings, _CachedData) == 0x000038, "Member 'UFlowSettings::_CachedData' has a wrong offset!");
static_assert(offsetof(UFlowSettings, _DefaultData) == 0x000040, "Member 'UFlowSettings::_DefaultData' has a wrong offset!");
static_assert(offsetof(UFlowSettings, _ChoiceObserver) == 0x000060, "Member 'UFlowSettings::_ChoiceObserver' has a wrong offset!");
static_assert(offsetof(UFlowSettings, _PlayerClass) == 0x000068, "Member 'UFlowSettings::_PlayerClass' has a wrong offset!");
static_assert(offsetof(UFlowSettings, _PreloadVoices) == 0x000070, "Member 'UFlowSettings::_PreloadVoices' has a wrong offset!");
static_assert(offsetof(UFlowSettings, _DefaultDelayAfterLine) == 0x000074, "Member 'UFlowSettings::_DefaultDelayAfterLine' has a wrong offset!");
static_assert(offsetof(UFlowSettings, _DistanceCheckPeriod) == 0x000078, "Member 'UFlowSettings::_DistanceCheckPeriod' has a wrong offset!");
static_assert(offsetof(UFlowSettings, _PlayMaxDistance) == 0x00007C, "Member 'UFlowSettings::_PlayMaxDistance' has a wrong offset!");
static_assert(offsetof(UFlowSettings, _DefaultInterruptPriority) == 0x000080, "Member 'UFlowSettings::_DefaultInterruptPriority' has a wrong offset!");
static_assert(offsetof(UFlowSettings, _MarkUntranslatedTexts) == 0x000081, "Member 'UFlowSettings::_MarkUntranslatedTexts' has a wrong offset!");
static_assert(offsetof(UFlowSettings, _DialogTemplate) == 0x000088, "Member 'UFlowSettings::_DialogTemplate' has a wrong offset!");
static_assert(offsetof(UFlowSettings, _EntityTemplate) == 0x000090, "Member 'UFlowSettings::_EntityTemplate' has a wrong offset!");
static_assert(offsetof(UFlowSettings, _HubTemplate) == 0x000098, "Member 'UFlowSettings::_HubTemplate' has a wrong offset!");
static_assert(offsetof(UFlowSettings, _LineTemplate) == 0x0000A0, "Member 'UFlowSettings::_LineTemplate' has a wrong offset!");
static_assert(offsetof(UFlowSettings, _ObjectiveTemplate) == 0x0000A8, "Member 'UFlowSettings::_ObjectiveTemplate' has a wrong offset!");
static_assert(offsetof(UFlowSettings, _QuestTemplate) == 0x0000B0, "Member 'UFlowSettings::_QuestTemplate' has a wrong offset!");

// Class Dialog.FlowTemplate
// 0x0020 (0x0088 - 0x0068)
class UFlowTemplate : public UGraphObject
{
public:
	struct FColor                                 _Color;                                            // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x1C];                                      // 0x006C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceiveActivation(class UFlowTask* Task);
	void ReceiveDeactivation(class UFlowTask* Task);

	class UFlowItem* GetOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowTemplate">();
	}
	static class UFlowTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowTemplate>();
	}
};
static_assert(alignof(UFlowTemplate) == 0x000008, "Wrong alignment on UFlowTemplate");
static_assert(sizeof(UFlowTemplate) == 0x000088, "Wrong size on UFlowTemplate");
static_assert(offsetof(UFlowTemplate, _Color) == 0x000068, "Member 'UFlowTemplate::_Color' has a wrong offset!");

// Class Dialog.FlowDialogTemplate
// 0x0000 (0x0088 - 0x0088)
class UFlowDialogTemplate final : public UFlowTemplate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowDialogTemplate">();
	}
	static class UFlowDialogTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowDialogTemplate>();
	}
};
static_assert(alignof(UFlowDialogTemplate) == 0x000008, "Wrong alignment on UFlowDialogTemplate");
static_assert(sizeof(UFlowDialogTemplate) == 0x000088, "Wrong size on UFlowDialogTemplate");

// Class Dialog.FlowEntityTemplate
// 0x0000 (0x0088 - 0x0088)
class UFlowEntityTemplate : public UFlowTemplate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowEntityTemplate">();
	}
	static class UFlowEntityTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowEntityTemplate>();
	}
};
static_assert(alignof(UFlowEntityTemplate) == 0x000008, "Wrong alignment on UFlowEntityTemplate");
static_assert(sizeof(UFlowEntityTemplate) == 0x000088, "Wrong size on UFlowEntityTemplate");

// Class Dialog.FlowHubTemplate
// 0x0000 (0x0088 - 0x0088)
class UFlowHubTemplate final : public UFlowTemplate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowHubTemplate">();
	}
	static class UFlowHubTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowHubTemplate>();
	}
};
static_assert(alignof(UFlowHubTemplate) == 0x000008, "Wrong alignment on UFlowHubTemplate");
static_assert(sizeof(UFlowHubTemplate) == 0x000088, "Wrong size on UFlowHubTemplate");

// Class Dialog.FlowLineTemplate
// 0x0000 (0x0088 - 0x0088)
class UFlowLineTemplate : public UFlowTemplate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowLineTemplate">();
	}
	static class UFlowLineTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowLineTemplate>();
	}
};
static_assert(alignof(UFlowLineTemplate) == 0x000008, "Wrong alignment on UFlowLineTemplate");
static_assert(sizeof(UFlowLineTemplate) == 0x000088, "Wrong size on UFlowLineTemplate");

// Class Dialog.FlowObjectiveTemplate
// 0x0000 (0x0088 - 0x0088)
class UFlowObjectiveTemplate final : public UFlowTemplate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowObjectiveTemplate">();
	}
	static class UFlowObjectiveTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowObjectiveTemplate>();
	}
};
static_assert(alignof(UFlowObjectiveTemplate) == 0x000008, "Wrong alignment on UFlowObjectiveTemplate");
static_assert(sizeof(UFlowObjectiveTemplate) == 0x000088, "Wrong size on UFlowObjectiveTemplate");

// Class Dialog.FlowQuestTemplate
// 0x0000 (0x0088 - 0x0088)
class UFlowQuestTemplate final : public UFlowTemplate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowQuestTemplate">();
	}
	static class UFlowQuestTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowQuestTemplate>();
	}
};
static_assert(alignof(UFlowQuestTemplate) == 0x000008, "Wrong alignment on UFlowQuestTemplate");
static_assert(sizeof(UFlowQuestTemplate) == 0x000088, "Wrong size on UFlowQuestTemplate");

// Class Dialog.FlowCharacterTemplate
// 0x0020 (0x00A8 - 0x0088)
class UFlowCharacterTemplate : public UFlowEntityTemplate
{
public:
	struct FDirectoryPath                         _LipsyncDir;                                       // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _LipsyncSlot;                                      // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _LipsyncBlendInTime;                               // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _LipsyncBlendOutTime;                              // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowCharacterTemplate">();
	}
	static class UFlowCharacterTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowCharacterTemplate>();
	}
};
static_assert(alignof(UFlowCharacterTemplate) == 0x000008, "Wrong alignment on UFlowCharacterTemplate");
static_assert(sizeof(UFlowCharacterTemplate) == 0x0000A8, "Wrong size on UFlowCharacterTemplate");
static_assert(offsetof(UFlowCharacterTemplate, _LipsyncDir) == 0x000088, "Member 'UFlowCharacterTemplate::_LipsyncDir' has a wrong offset!");
static_assert(offsetof(UFlowCharacterTemplate, _LipsyncSlot) == 0x000098, "Member 'UFlowCharacterTemplate::_LipsyncSlot' has a wrong offset!");
static_assert(offsetof(UFlowCharacterTemplate, _LipsyncBlendInTime) == 0x0000A0, "Member 'UFlowCharacterTemplate::_LipsyncBlendInTime' has a wrong offset!");
static_assert(offsetof(UFlowCharacterTemplate, _LipsyncBlendOutTime) == 0x0000A4, "Member 'UFlowCharacterTemplate::_LipsyncBlendOutTime' has a wrong offset!");

// Class Dialog.FlowLineLipsyncTemplate
// 0x0008 (0x0090 - 0x0088)
class UFlowLineLipsyncTemplate : public UFlowLineTemplate
{
public:
	bool                                          _PlayLipsync;                                      // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowLineLipsyncTemplate">();
	}
	static class UFlowLineLipsyncTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowLineLipsyncTemplate>();
	}
};
static_assert(alignof(UFlowLineLipsyncTemplate) == 0x000008, "Wrong alignment on UFlowLineLipsyncTemplate");
static_assert(sizeof(UFlowLineLipsyncTemplate) == 0x000090, "Wrong size on UFlowLineLipsyncTemplate");
static_assert(offsetof(UFlowLineLipsyncTemplate, _PlayLipsync) == 0x000088, "Member 'UFlowLineLipsyncTemplate::_PlayLipsync' has a wrong offset!");

// Class Dialog.Quest
// 0x0030 (0x00F8 - 0x00C8)
class UQuest final : public UFlowTask
{
public:
	EQuestStatus                                  _Status;                                           // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuestObjective>                _Objectives;                                       // 0x00D0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         _StoryRecap;                                       // 0x00E0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0xC];                                       // 0x00E4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UDialogManager*                         _Manager;                                          // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetObjectiveStatus(const struct FQuestObjectiveID& ObjectiveID, EQuestStatus Status);
	void Update();

	class FText GetName() const;
	void GetObjectives(EQuestStatus Status, TArray<struct FQuestObjective>* Objectives) const;
	EQuestStatus GetObjectiveStatus(const struct FQuestObjectiveID& ObjectiveID) const;
	class FText GetStoryRecap() const;
	bool HasActiveStoryRecap() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Quest">();
	}
	static class UQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuest>();
	}
};
static_assert(alignof(UQuest) == 0x000008, "Wrong alignment on UQuest");
static_assert(sizeof(UQuest) == 0x0000F8, "Wrong size on UQuest");
static_assert(offsetof(UQuest, _Status) == 0x0000C8, "Member 'UQuest::_Status' has a wrong offset!");
static_assert(offsetof(UQuest, _Objectives) == 0x0000D0, "Member 'UQuest::_Objectives' has a wrong offset!");
static_assert(offsetof(UQuest, _StoryRecap) == 0x0000E0, "Member 'UQuest::_StoryRecap' has a wrong offset!");
static_assert(offsetof(UQuest, _Manager) == 0x0000F0, "Member 'UQuest::_Manager' has a wrong offset!");

// Class Dialog.QuestScriptInterface
// 0x0000 (0x0028 - 0x0028)
class IQuestScriptInterface final : public IInterface
{
public:
	void QuestScriptByTag(const struct FGameplayTag& EventTag, class UQuest* Quest, int32 UserInteger, const class FString& UserString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestScriptInterface">();
	}
	static class IQuestScriptInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IQuestScriptInterface>();
	}
};
static_assert(alignof(IQuestScriptInterface) == 0x000008, "Wrong alignment on IQuestScriptInterface");
static_assert(sizeof(IQuestScriptInterface) == 0x000028, "Wrong size on IQuestScriptInterface");

// Class Dialog.ReplicaInterface
// 0x0040 (0x0068 - 0x0028)
class UReplicaInterface final : public UObject
{
public:
	class FString                                 _User;                                             // 0x0028(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _Password;                                         // 0x0038(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _BitRate;                                          // 0x0048(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _SampleRate;                                       // 0x004C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplicaInterface">();
	}
	static class UReplicaInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReplicaInterface>();
	}
};
static_assert(alignof(UReplicaInterface) == 0x000008, "Wrong alignment on UReplicaInterface");
static_assert(sizeof(UReplicaInterface) == 0x000068, "Wrong size on UReplicaInterface");
static_assert(offsetof(UReplicaInterface, _User) == 0x000028, "Member 'UReplicaInterface::_User' has a wrong offset!");
static_assert(offsetof(UReplicaInterface, _Password) == 0x000038, "Member 'UReplicaInterface::_Password' has a wrong offset!");
static_assert(offsetof(UReplicaInterface, _BitRate) == 0x000048, "Member 'UReplicaInterface::_BitRate' has a wrong offset!");
static_assert(offsetof(UReplicaInterface, _SampleRate) == 0x00004C, "Member 'UReplicaInterface::_SampleRate' has a wrong offset!");

// Class Dialog.ReplicaEntityTemplate
// 0x0010 (0x00B8 - 0x00A8)
class UReplicaEntityTemplate final : public UFlowCharacterTemplate
{
public:
	struct FDataTableRowHandle                    _ReplicaVoice;                                     // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplicaEntityTemplate">();
	}
	static class UReplicaEntityTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReplicaEntityTemplate>();
	}
};
static_assert(alignof(UReplicaEntityTemplate) == 0x000008, "Wrong alignment on UReplicaEntityTemplate");
static_assert(sizeof(UReplicaEntityTemplate) == 0x0000B8, "Wrong size on UReplicaEntityTemplate");
static_assert(offsetof(UReplicaEntityTemplate, _ReplicaVoice) == 0x0000A8, "Member 'UReplicaEntityTemplate::_ReplicaVoice' has a wrong offset!");

// Class Dialog.ReplicaLineTemplate
// 0x0020 (0x00B0 - 0x0090)
class UReplicaLineTemplate final : public UFlowLineLipsyncTemplate
{
public:
	int32                                         _ReplicaPitch;                                     // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _ReplicaRate;                                      // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _ReplicaVolume;                                    // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _ReplicaSpeechRequest;                             // 0x00A0(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplicaLineTemplate">();
	}
	static class UReplicaLineTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReplicaLineTemplate>();
	}
};
static_assert(alignof(UReplicaLineTemplate) == 0x000008, "Wrong alignment on UReplicaLineTemplate");
static_assert(sizeof(UReplicaLineTemplate) == 0x0000B0, "Wrong size on UReplicaLineTemplate");
static_assert(offsetof(UReplicaLineTemplate, _ReplicaPitch) == 0x000090, "Member 'UReplicaLineTemplate::_ReplicaPitch' has a wrong offset!");
static_assert(offsetof(UReplicaLineTemplate, _ReplicaRate) == 0x000094, "Member 'UReplicaLineTemplate::_ReplicaRate' has a wrong offset!");
static_assert(offsetof(UReplicaLineTemplate, _ReplicaVolume) == 0x000098, "Member 'UReplicaLineTemplate::_ReplicaVolume' has a wrong offset!");
static_assert(offsetof(UReplicaLineTemplate, _ReplicaSpeechRequest) == 0x0000A0, "Member 'UReplicaLineTemplate::_ReplicaSpeechRequest' has a wrong offset!");

}

